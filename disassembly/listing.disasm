Disassembly Listing for pic32-fmu
Generated From:
C:/Users/Jon Watson/Documents/GitHub/pic32-fmu.X/dist/default/debug/pic32-fmu.X.debug.elf
Aug 6, 2015 12:37:41 PM

---  c:/users/jon watson/documents/github/pic32-fmu.x/src/vn100.c  --------------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   vn100.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include "vn100.h"
9:                   #include "coretime.h"
10:                  #include "spi.h"
11:                  #include "stdtypes.h"
12:                  
13:                  
14:                  static VN100_MODEL_NUMBER       modelNumber;
15:                  static VN100_HARDWARE_REVISION  hardwareRevision;
16:                  static VN100_SERIAL_NUMBER      serialNumber;
17:                  static VN100_FIRMWARE_VERSION   firmwareVersion;
18:                  static VN100_IMU_MEASUREMENTS   imuMeasurements;
19:                  
20:                  
21:                  // Local function prototypes. ==================================================
22:                  
23:                  static int VN100Init();
24:                  static unsigned int VN100RegSizeGet(VN100_REG_E reg);
25:                  static VN100_SPI_PKT* VN100ReadReg(VN100_REG_E reg);
26:                  //static VN100_SPI_PKT* VN100WriteReg(VN100_REG_E reg, void* regData);
27:                  
28:                  
29:                  //==============================================================================
30:                  
31:                  void VN100Task()
32:                  {
9D010280  27BDFFE0   ADDIU SP, SP, -32
9D010284  AFBF001C   SW RA, 28(SP)
9D010288  AFBE0018   SW S8, 24(SP)
9D01028C  03A0F021   ADDU S8, SP, ZERO
33:                      static enum
34:                      {
35:                          SM_INIT = 0,
36:                          SM_GET_MODEL_NUMBER,
37:                          SM_GET_HARDWARE_REVISION,
38:                          SM_GET_SERIAL_NUMBER,
39:                          SM_GET_FIRMWARE_VERSION,
40:                          SM_INIT_IMU_TIME,
41:                          SM_GET_IMU_MEASUREMENTS,
42:                          SM_ADD_DELAY,
43:                      } vn100TaskState = SM_INIT;
44:                  
45:                      VN100_SPI_PKT* pkt;
46:                  
47:                      static uint32_t imuTime;
48:                  
49:                      switch (vn100TaskState)
9D010290  8F8280D4   LW V0, -32556(GP)
9D010294  2C430008   SLTIU V1, V0, 8
9D010298  106000BC   BEQ V1, ZERO, 0x9D01058C
9D01029C  00000000   NOP
9D0102A0  00021880   SLL V1, V0, 2
9D0102A4  3C029D01   LUI V0, -25343
9D0102A8  244202BC   ADDIU V0, V0, 700
9D0102AC  00621021   ADDU V0, V1, V0
9D0102B0  8C420000   LW V0, 0(V0)
9D0102B4  00400008   JR V0
9D0102B8  00000000   NOP
50:                      {
51:                          case SM_INIT:
52:                          {
53:                              if (VN100Init() == 0)
9D0102DC  0F404169   JAL 0x9D0105A4
9D0102E0  00000000   NOP
9D0102E4  14400087   BNE V0, ZERO, 0x9D010504
9D0102E8  00000000   NOP
54:                              {
55:                                  vn100TaskState = SM_GET_MODEL_NUMBER;
9D0102EC  24020001   ADDIU V0, ZERO, 1
9D0102F0  AF8280D4   SW V0, -32556(GP)
56:                              }
57:                              break;
9D0102F4  0B404163   J 0x9D01058C
9D0102F8  00000000   NOP
9D010504  00000000   NOP
9D010508  0B404163   J 0x9D01058C
9D01050C  00000000   NOP
58:                          }
59:                          case SM_GET_MODEL_NUMBER:
60:                          {
61:                              pkt = VN100ReadReg(VN100_REG_MODEL);
9D0102FC  24040001   ADDIU A0, ZERO, 1
9D010300  0F404174   JAL 0x9D0105D0
9D010304  00000000   NOP
9D010308  AFC20010   SW V0, 16(S8)
62:                              if ((pkt != 0) && (pkt->header.response.errID == VN100_ERR_NONE))
9D01030C  8FC20010   LW V0, 16(S8)
9D010310  1040007F   BEQ V0, ZERO, 0x9D010510
9D010314  00000000   NOP
9D010318  8FC20010   LW V0, 16(S8)
9D01031C  90420003   LBU V0, 3(V0)
9D010320  1440007E   BNE V0, ZERO, 0x9D01051C
9D010324  00000000   NOP
63:                              {
64:                                  memcpy(&modelNumber, pkt->payload,
9D010328  8FC20010   LW V0, 16(S8)
9D01032C  24420004   ADDIU V0, V0, 4
9D010330  3C03A001   LUI V1, -24575
9D010334  24648674   ADDIU A0, V1, -31116
9D010338  00402821   ADDU A1, V0, ZERO
9D01033C  24060018   ADDIU A2, ZERO, 24
9D010340  0F406788   JAL 0x9D019E20
9D010344  00000000   NOP
65:                                          sizeof(modelNumber));
66:                                  vn100TaskState = SM_GET_HARDWARE_REVISION;
9D010348  24020002   ADDIU V0, ZERO, 2
9D01034C  AF8280D4   SW V0, -32556(GP)
67:                              }
68:                              break;
9D010350  0B404163   J 0x9D01058C
9D010354  00000000   NOP
9D010510  00000000   NOP
9D010514  0B404163   J 0x9D01058C
9D010518  00000000   NOP
9D01051C  00000000   NOP
9D010520  0B404163   J 0x9D01058C
9D010524  00000000   NOP
69:                          }
70:                          case SM_GET_HARDWARE_REVISION:
71:                          {
72:                              pkt = VN100ReadReg(VN100_REG_HWREV);
9D010358  24040002   ADDIU A0, ZERO, 2
9D01035C  0F404174   JAL 0x9D0105D0
9D010360  00000000   NOP
9D010364  AFC20010   SW V0, 16(S8)
73:                              if ((pkt != 0) && (pkt->header.response.errID == VN100_ERR_NONE))
9D010368  8FC20010   LW V0, 16(S8)
9D01036C  1040006E   BEQ V0, ZERO, 0x9D010528
9D010370  00000000   NOP
9D010374  8FC20010   LW V0, 16(S8)
9D010378  90420003   LBU V0, 3(V0)
9D01037C  1440006D   BNE V0, ZERO, 0x9D010534
9D010380  00000000   NOP
74:                              {
75:                                  memcpy(&hardwareRevision, pkt->payload,
9D010384  8FC20010   LW V0, 16(S8)
9D010388  24420004   ADDIU V0, V0, 4
9D01038C  278480C0   ADDIU A0, GP, -32576
9D010390  00402821   ADDU A1, V0, ZERO
9D010394  24060004   ADDIU A2, ZERO, 4
9D010398  0F406788   JAL 0x9D019E20
9D01039C  00000000   NOP
76:                                          sizeof(hardwareRevision));
77:                                  vn100TaskState = SM_GET_SERIAL_NUMBER;
9D0103A0  24020003   ADDIU V0, ZERO, 3
9D0103A4  AF8280D4   SW V0, -32556(GP)
78:                              }
79:                              break;
9D0103A8  0B404163   J 0x9D01058C
9D0103AC  00000000   NOP
9D010528  00000000   NOP
9D01052C  0B404163   J 0x9D01058C
9D010530  00000000   NOP
9D010534  00000000   NOP
9D010538  0B404163   J 0x9D01058C
9D01053C  00000000   NOP
80:                          }
81:                          case SM_GET_SERIAL_NUMBER:
82:                          {
83:                              pkt = VN100ReadReg(VN100_REG_SN);
9D0103B0  24040003   ADDIU A0, ZERO, 3
9D0103B4  0F404174   JAL 0x9D0105D0
9D0103B8  00000000   NOP
9D0103BC  AFC20010   SW V0, 16(S8)
84:                              if ((pkt != 0) && (pkt->header.response.errID == VN100_ERR_NONE))
9D0103C0  8FC20010   LW V0, 16(S8)
9D0103C4  1040005E   BEQ V0, ZERO, 0x9D010540
9D0103C8  00000000   NOP
9D0103CC  8FC20010   LW V0, 16(S8)
9D0103D0  90420003   LBU V0, 3(V0)
9D0103D4  1440005D   BNE V0, ZERO, 0x9D01054C
9D0103D8  00000000   NOP
85:                              {
86:                                  memcpy(&serialNumber, pkt->payload,
9D0103DC  8FC20010   LW V0, 16(S8)
9D0103E0  24420004   ADDIU V0, V0, 4
9D0103E4  278480C4   ADDIU A0, GP, -32572
9D0103E8  00402821   ADDU A1, V0, ZERO
9D0103EC  24060004   ADDIU A2, ZERO, 4
9D0103F0  0F406788   JAL 0x9D019E20
9D0103F4  00000000   NOP
87:                                          sizeof(serialNumber));
88:                                  vn100TaskState = SM_GET_FIRMWARE_VERSION;
9D0103F8  24020004   ADDIU V0, ZERO, 4
9D0103FC  AF8280D4   SW V0, -32556(GP)
89:                              }
90:                              break;
9D010400  0B404163   J 0x9D01058C
9D010404  00000000   NOP
9D010540  00000000   NOP
9D010544  0B404163   J 0x9D01058C
9D010548  00000000   NOP
9D01054C  00000000   NOP
9D010550  0B404163   J 0x9D01058C
9D010554  00000000   NOP
91:                          }
92:                          case SM_GET_FIRMWARE_VERSION:
93:                          {
94:                              pkt = VN100ReadReg(VN100_REG_FWVER);
9D010408  24040004   ADDIU A0, ZERO, 4
9D01040C  0F404174   JAL 0x9D0105D0
9D010410  00000000   NOP
9D010414  AFC20010   SW V0, 16(S8)
95:                              if ((pkt != 0) && (pkt->header.response.errID == VN100_ERR_NONE))
9D010418  8FC20010   LW V0, 16(S8)
9D01041C  1040004E   BEQ V0, ZERO, 0x9D010558
9D010420  00000000   NOP
9D010424  8FC20010   LW V0, 16(S8)
9D010428  90420003   LBU V0, 3(V0)
9D01042C  1440004D   BNE V0, ZERO, 0x9D010564
9D010430  00000000   NOP
96:                              {
97:                                  memcpy(&firmwareVersion, pkt->payload,
9D010434  8FC20010   LW V0, 16(S8)
9D010438  24420004   ADDIU V0, V0, 4
9D01043C  278480C8   ADDIU A0, GP, -32568
9D010440  00402821   ADDU A1, V0, ZERO
9D010444  24060004   ADDIU A2, ZERO, 4
9D010448  0F406788   JAL 0x9D019E20
9D01044C  00000000   NOP
98:                                          sizeof(firmwareVersion));
99:                                  vn100TaskState = SM_INIT_IMU_TIME;
9D010450  24020005   ADDIU V0, ZERO, 5
9D010454  AF8280D4   SW V0, -32556(GP)
100:                             }
101:                             break;
9D010458  0B404163   J 0x9D01058C
9D01045C  00000000   NOP
9D010558  00000000   NOP
9D01055C  0B404163   J 0x9D01058C
9D010560  00000000   NOP
9D010564  00000000   NOP
9D010568  0B404163   J 0x9D01058C
9D01056C  00000000   NOP
102:                         }
103:                         case SM_INIT_IMU_TIME:
104:                         {
105:                             imuTime = CoreTime32usGet();
9D010460  0F405A7C   JAL CoreTime32usGet
9D010464  00000000   NOP
9D010468  AF8280D8   SW V0, -32552(GP)
106:                             // No break;
107:                         }
108:                         case SM_GET_IMU_MEASUREMENTS:
109:                         {
110:                             if (CoreTime32usGet() >= imuTime)
9D01046C  0F405A7C   JAL CoreTime32usGet
9D010470  00000000   NOP
9D010474  00401821   ADDU V1, V0, ZERO
9D010478  8F8280D8   LW V0, -32552(GP)
9D01047C  0062102B   SLTU V0, V1, V0
9D010480  1440003B   BNE V0, ZERO, 0x9D010570
9D010484  00000000   NOP
111:                             {
112:                                 pkt = VN100ReadReg(VN100_REG_IMU);
9D010488  24040036   ADDIU A0, ZERO, 54
9D01048C  0F404174   JAL 0x9D0105D0
9D010490  00000000   NOP
9D010494  AFC20010   SW V0, 16(S8)
113:                                 if ((pkt != 0) && 
9D010498  8FC20010   LW V0, 16(S8)
9D01049C  10400037   BEQ V0, ZERO, 0x9D01057C
9D0104A0  00000000   NOP
9D0104AC  14400036   BNE V0, ZERO, 0x9D010588
9D0104B0  00000000   NOP
114:                                         (pkt->header.response.errID == VN100_ERR_NONE))
9D0104A4  8FC20010   LW V0, 16(S8)
9D0104A8  90420003   LBU V0, 3(V0)
115:                                 {
116:                                     memcpy(&imuMeasurements, pkt->payload,
9D0104B4  8FC20010   LW V0, 16(S8)
9D0104B8  24420004   ADDIU V0, V0, 4
9D0104BC  3C03A001   LUI V1, -24575
9D0104C0  2464868C   ADDIU A0, V1, -31092
9D0104C4  00402821   ADDU A1, V0, ZERO
9D0104C8  2406002C   ADDIU A2, ZERO, 44
9D0104CC  0F406788   JAL 0x9D019E20
9D0104D0  00000000   NOP
117:                                             sizeof(imuMeasurements));
118:                                     vn100TaskState = SM_ADD_DELAY;
9D0104D4  24020007   ADDIU V0, ZERO, 7
9D0104D8  AF8280D4   SW V0, -32556(GP)
119:                                 }
120:                             }
121:                             break;
9D0104DC  0B404163   J 0x9D01058C
9D0104E0  00000000   NOP
9D010570  00000000   NOP
9D010574  0B404163   J 0x9D01058C
9D010578  00000000   NOP
9D01057C  00000000   NOP
9D010580  0B404163   J 0x9D01058C
9D010584  00000000   NOP
9D010588  00000000   NOP
122:                         }
123:                         case SM_ADD_DELAY:
124:                         {
125:                             imuTime += 1250;    // 1250 us period = 800 Hz
9D0104E4  8F8280D8   LW V0, -32552(GP)
9D0104E8  244204E2   ADDIU V0, V0, 1250
9D0104EC  AF8280D8   SW V0, -32552(GP)
126:                             vn100TaskState = SM_GET_IMU_MEASUREMENTS;
9D0104F0  24020006   ADDIU V0, ZERO, 6
9D0104F4  AF8280D4   SW V0, -32556(GP)
127:                             break;
9D0104F8  00000000   NOP
9D0104FC  0B404163   J 0x9D01058C
9D010500  00000000   NOP
128:                         }
129:                     }
130:                 }
9D01058C  03C0E821   ADDU SP, S8, ZERO
9D010590  8FBF001C   LW RA, 28(SP)
9D010594  8FBE0018   LW S8, 24(SP)
9D010598  27BD0020   ADDIU SP, SP, 32
9D01059C  03E00008   JR RA
9D0105A0  00000000   NOP
131:                 
132:                 
133:                 //==============================================================================
134:                 
135:                 static int VN100Init()
136:                 {
9D0105A4  27BDFFF0   ADDIU SP, SP, -16
9D0105A8  AFBE000C   SW S8, 12(SP)
9D0105AC  03A0F021   ADDU S8, SP, ZERO
137:                     int retVal = 1;
9D0105B0  24020001   ADDIU V0, ZERO, 1
9D0105B4  AFC20000   SW V0, 0(S8)
138:                     
139:                 //    const VN100_COMM_PROTO_CTRL cpc = {
140:                 //        .serialCount.val        = 2,    // SYNCIN_TIME
141:                 //        .serialStatus.val       = 1,    // VPE Status
142:                 //        .spiCount.val           = 2,    // SYNCIN_TIME
143:                 //        .spiStatus.val          = 1,    // VPE Status
144:                 //        .serialChecksum.val     = 3,    // 16-Bit CRC
145:                 //        .spiChecksum.val        = 3,    // 16-Bit CRC
146:                 //        .errorMode.val          = 1,    // Send Error
147:                 //    };
148:                     
149:                 //    
150:                 //    TODO: Write configuration to VN100
151:                 //    
152:                     
153:                     return retVal;
9D0105B8  8FC20000   LW V0, 0(S8)
154:                 }
9D0105BC  03C0E821   ADDU SP, S8, ZERO
9D0105C0  8FBE000C   LW S8, 12(SP)
9D0105C4  27BD0010   ADDIU SP, SP, 16
9D0105C8  03E00008   JR RA
9D0105CC  00000000   NOP
155:                 
156:                 
157:                 //==============================================================================
158:                 
159:                 //static VN100_SPI_PKT* VN100WriteReg(VN100_REG_E reg, void* regData)
160:                 //{
161:                 //    VN100_SPI_PKT* retVal = 0;
162:                 //
163:                 //    static VN100_SPI_PKT pkt;
164:                 //    
165:                 //    static SPI_XFER vn100spi = {
166:                 //        .port = SPI_PORT_SPI2,
167:                 //    };
168:                 //
169:                 //    static enum
170:                 //    {
171:                 //        SM_REQUEST_START,
172:                 //        SM_REQUEST_FINISH,
173:                 //        SM_WAIT,
174:                 //        SM_RESPONSE_START,
175:                 //        SM_RESPONSE_FINISH,
176:                 //    } readRegState = SM_REQUEST_START;
177:                 //
178:                 //    static uint32_t requestTime;
179:                 //
180:                 //    switch (readRegState)
181:                 //    {
182:                 //        case SM_REQUEST_START:
183:                 //        {
184:                 //            pkt.header.request.cmdID = VN100_CMD_WRITE_REG;
185:                 //            pkt.header.request.regID = reg;
186:                 //            pkt.header.request.zero_0 = 0;
187:                 //            pkt.header.request.zero_1 = 0;
188:                 //
189:                 //            memcpy(pkt.payload, regData, VN100RegSizeGet(reg));
190:                 //            
191:                 //            vn100spi.rxBuf = 0;
192:                 //            vn100spi.txBuf = (uint8_t*)&pkt;
193:                 //            vn100spi.length =
194:                 //                    sizeof(VN100_SPI_HEADER) + VN100RegSizeGet(reg);
195:                 //
196:                 //            if (SPIXfer(&vn100spi) == 0)
197:                 //            {
198:                 //                readRegState = SM_REQUEST_FINISH;
199:                 //            }
200:                 //            break;
201:                 //        }
202:                 //        case SM_REQUEST_FINISH:
203:                 //        {
204:                 //            if (vn100spi.xferDone != 0)
205:                 //            {
206:                 //                requestTime = CoreTime32usGet();
207:                 //                readRegState = SM_WAIT;
208:                 //            }
209:                 //            break;
210:                 //        }
211:                 //        case SM_WAIT:
212:                 //        {
213:                 //            // Per VN-100 user manual, wait at least 50us before
214:                 //            // issuing the response packet.
215:                 //            if ((CoreTime32usGet() - requestTime) < 100)
216:                 //            {
217:                 //                break;
218:                 //            }
219:                 //            else
220:                 //            {
221:                 //                readRegState = SM_RESPONSE_START;
222:                 //            }
223:                 //            // No break.
224:                 //        }
225:                 //        case SM_RESPONSE_START:
226:                 //        {
227:                 //            vn100spi.rxBuf = (uint8_t*)&pkt;
228:                 //            vn100spi.txBuf = 0;
229:                 //            vn100spi.length = 
230:                 //                    sizeof(VN100_SPI_HEADER) + VN100RegSizeGet(reg);
231:                 //
232:                 //            if (SPIXfer(&vn100spi) == 0)
233:                 //            {
234:                 //                readRegState = SM_RESPONSE_FINISH;
235:                 //            }
236:                 //            break;
237:                 //        }
238:                 //        case SM_RESPONSE_FINISH:
239:                 //        {
240:                 //            if (vn100spi.xferDone != 0)
241:                 //            {
242:                 //                readRegState = SM_REQUEST_START;
243:                 //                retVal = &pkt;
244:                 //            }
245:                 //            break;
246:                 //        }
247:                 //    }
248:                 //    return retVal;
249:                 //}
250:                 
251:                 
252:                 //==============================================================================
253:                 
254:                 static VN100_SPI_PKT* VN100ReadReg(VN100_REG_E reg)
255:                 {
9D0105D0  27BDFFE0   ADDIU SP, SP, -32
9D0105D4  AFBF001C   SW RA, 28(SP)
9D0105D8  AFBE0018   SW S8, 24(SP)
9D0105DC  03A0F021   ADDU S8, SP, ZERO
9D0105E0  00801021   ADDU V0, A0, ZERO
9D0105E4  A3C20020   SB V0, 32(S8)
256:                     VN100_SPI_PKT* retVal = 0;
9D0105E8  AFC00010   SW ZERO, 16(S8)
257:                 
258:                     static VN100_SPI_PKT pkt;
259:                     
260:                     static SPI_XFER vn100spi = {
261:                         .port = SPI_PORT_SPI2,
262:                     };
263:                 
264:                     static enum
265:                     {
266:                         SM_REQUEST_START,
267:                         SM_REQUEST_FINISH,
268:                         SM_WAIT,
269:                         SM_RESPONSE_START,
270:                         SM_RESPONSE_FINISH,
271:                     } readRegState = SM_REQUEST_START;
272:                 
273:                     static uint32_t requestTime;
274:                 
275:                     switch (readRegState)
9D0105EC  8F8280CC   LW V0, -32564(GP)
9D0105F0  2C430005   SLTIU V1, V0, 5
9D0105F4  10600075   BEQ V1, ZERO, 0x9D0107CC
9D0105F8  00000000   NOP
9D0105FC  00021880   SLL V1, V0, 2
9D010600  3C029D01   LUI V0, -25343
9D010604  24420618   ADDIU V0, V0, 1560
9D010608  00621021   ADDU V0, V1, V0
9D01060C  8C420000   LW V0, 0(V0)
9D010610  00400008   JR V0
9D010614  00000000   NOP
276:                     {
277:                         case SM_REQUEST_START:
278:                         {
279:                             pkt.header.request.cmdID = VN100_CMD_READ_REG;
9D01062C  3C02A001   LUI V0, -24575
9D010630  24030001   ADDIU V1, ZERO, 1
9D010634  A04386B8   SB V1, -31048(V0)
280:                             pkt.header.request.regID = reg;
9D010638  3C02A001   LUI V0, -24575
9D01063C  244286B8   ADDIU V0, V0, -31048
9D010640  93C30020   LBU V1, 32(S8)
9D010644  A0430001   SB V1, 1(V0)
281:                             pkt.header.request.zero_0 = 0;
9D010648  3C02A001   LUI V0, -24575
9D01064C  244286B8   ADDIU V0, V0, -31048
9D010650  A0400002   SB ZERO, 2(V0)
282:                             pkt.header.request.zero_1 = 0;
9D010654  3C02A001   LUI V0, -24575
9D010658  244286B8   ADDIU V0, V0, -31048
9D01065C  A0400003   SB ZERO, 3(V0)
283:                 
284:                             vn100spi.rxBuf = 0;
9D010660  3C02A001   LUI V0, -24575
9D010664  2442892C   ADDIU V0, V0, -30420
9D010668  AC400004   SW ZERO, 4(V0)
285:                             vn100spi.txBuf = (uint8_t*)&pkt;
9D01066C  3C02A001   LUI V0, -24575
9D010670  2442892C   ADDIU V0, V0, -30420
9D010674  3C03A001   LUI V1, -24575
9D010678  246386B8   ADDIU V1, V1, -31048
9D01067C  AC430008   SW V1, 8(V0)
286:                             vn100spi.length = sizeof(pkt.header.request);
9D010680  3C02A001   LUI V0, -24575
9D010684  2442892C   ADDIU V0, V0, -30420
9D010688  24030004   ADDIU V1, ZERO, 4
9D01068C  AC43000C   SW V1, 12(V0)
287:                 
288:                             if (SPIXfer(&vn100spi) == 0)
9D010690  3C02A001   LUI V0, -24575
9D010694  2444892C   ADDIU A0, V0, -30420
9D010698  0F405B61   JAL SPIXfer
9D01069C  00000000   NOP
9D0106A0  14400040   BNE V0, ZERO, 0x9D0107A4
9D0106A4  00000000   NOP
289:                             {
290:                                 readRegState = SM_REQUEST_FINISH;
9D0106A8  24020001   ADDIU V0, ZERO, 1
9D0106AC  AF8280CC   SW V0, -32564(GP)
291:                             }
292:                             break;
9D0106B0  0B4041F3   J 0x9D0107CC
9D0106B4  00000000   NOP
9D0107A4  00000000   NOP
9D0107A8  0B4041F3   J 0x9D0107CC
9D0107AC  00000000   NOP
293:                         }
294:                         case SM_REQUEST_FINISH:
295:                         {
296:                             if (vn100spi.xferDone != 0)
9D0106B8  3C02A001   LUI V0, -24575
9D0106BC  2442892C   ADDIU V0, V0, -30420
9D0106C0  8C420010   LW V0, 16(V0)
9D0106C4  1040003A   BEQ V0, ZERO, 0x9D0107B0
9D0106C8  00000000   NOP
297:                             {
298:                                 requestTime = CoreTime32usGet();
9D0106CC  0F405A7C   JAL CoreTime32usGet
9D0106D0  00000000   NOP
9D0106D4  AF8280D0   SW V0, -32560(GP)
299:                                 readRegState = SM_WAIT;
9D0106D8  24020002   ADDIU V0, ZERO, 2
9D0106DC  AF8280CC   SW V0, -32564(GP)
300:                             }
301:                             break;
9D0106E0  0B4041F3   J 0x9D0107CC
9D0106E4  00000000   NOP
9D0107B0  00000000   NOP
9D0107B4  0B4041F3   J 0x9D0107CC
9D0107B8  00000000   NOP
302:                         }
303:                         case SM_WAIT:
304:                         {
305:                             // Per VN-100 user manual, wait at least 50us before
306:                             // issuing the response packet.
307:                             if ((CoreTime32usGet() - requestTime) < 100)
9D0106E8  0F405A7C   JAL CoreTime32usGet
9D0106EC  00000000   NOP
9D0106F0  00401821   ADDU V1, V0, ZERO
9D0106F4  8F8280D0   LW V0, -32560(GP)
9D0106F8  00621023   SUBU V0, V1, V0
9D0106FC  2C420064   SLTIU V0, V0, 100
9D010700  1440002E   BNE V0, ZERO, 0x9D0107BC
9D010704  00000000   NOP
308:                             {
309:                                 break;
9D0107BC  00000000   NOP
9D0107C0  0B4041F3   J 0x9D0107CC
9D0107C4  00000000   NOP
310:                             }
311:                             else
312:                             {
313:                                 readRegState = SM_RESPONSE_START;
9D010708  24020003   ADDIU V0, ZERO, 3
9D01070C  AF8280CC   SW V0, -32564(GP)
314:                             }
315:                             // No break.
316:                         }
317:                         case SM_RESPONSE_START:
318:                         {
319:                             vn100spi.rxBuf = (uint8_t*)&pkt;
9D010710  3C02A001   LUI V0, -24575
9D010714  2442892C   ADDIU V0, V0, -30420
9D010718  3C03A001   LUI V1, -24575
9D01071C  246386B8   ADDIU V1, V1, -31048
9D010720  AC430004   SW V1, 4(V0)
320:                             vn100spi.txBuf = 0;
9D010724  3C02A001   LUI V0, -24575
9D010728  2442892C   ADDIU V0, V0, -30420
9D01072C  AC400008   SW ZERO, 8(V0)
321:                             vn100spi.length = 
9D010744  3C02A001   LUI V0, -24575
9D010748  2442892C   ADDIU V0, V0, -30420
9D01074C  AC43000C   SW V1, 12(V0)
322:                                     VN100RegSizeGet(reg) + 4;   // Add 4-byte response header.
9D010730  93C20020   LBU V0, 32(S8)
9D010734  00402021   ADDU A0, V0, ZERO
9D010738  0F4041FA   JAL 0x9D0107E8
9D01073C  00000000   NOP
9D010740  24430004   ADDIU V1, V0, 4
323:                 
324:                             if (SPIXfer(&vn100spi) == 0)
9D010750  3C02A001   LUI V0, -24575
9D010754  2444892C   ADDIU A0, V0, -30420
9D010758  0F405B61   JAL SPIXfer
9D01075C  00000000   NOP
9D010760  14400019   BNE V0, ZERO, 0x9D0107C8
9D010764  00000000   NOP
325:                             {
326:                                 readRegState = SM_RESPONSE_FINISH;
9D010768  24020004   ADDIU V0, ZERO, 4
9D01076C  AF8280CC   SW V0, -32564(GP)
327:                             }
328:                             break;
9D010770  0B4041F3   J 0x9D0107CC
9D010774  00000000   NOP
9D0107C8  00000000   NOP
329:                         }
330:                         case SM_RESPONSE_FINISH:
331:                         {
332:                             if (vn100spi.xferDone != 0)
9D010778  3C02A001   LUI V0, -24575
9D01077C  2442892C   ADDIU V0, V0, -30420
9D010780  8C420010   LW V0, 16(V0)
9D010784  10400005   BEQ V0, ZERO, 0x9D01079C
9D010788  00000000   NOP
333:                             {
334:                                 readRegState = SM_REQUEST_START;
9D01078C  AF8080CC   SW ZERO, -32564(GP)
335:                                 retVal = &pkt;
9D010790  3C02A001   LUI V0, -24575
9D010794  244286B8   ADDIU V0, V0, -31048
9D010798  AFC20010   SW V0, 16(S8)
336:                             }
337:                             break;
9D01079C  0B4041F3   J 0x9D0107CC
9D0107A0  00000000   NOP
338:                         }
339:                     }
340:                     return retVal;
9D0107CC  8FC20010   LW V0, 16(S8)
341:                 }
9D0107D0  03C0E821   ADDU SP, S8, ZERO
9D0107D4  8FBF001C   LW RA, 28(SP)
9D0107D8  8FBE0018   LW S8, 24(SP)
9D0107DC  27BD0020   ADDIU SP, SP, 32
9D0107E0  03E00008   JR RA
9D0107E4  00000000   NOP
342:                 
343:                 
344:                 //==============================================================================
345:                 
346:                 static unsigned int VN100RegSizeGet(VN100_REG_E reg)
347:                 {
9D0107E8  27BDFFF0   ADDIU SP, SP, -16
9D0107EC  AFBE000C   SW S8, 12(SP)
9D0107F0  03A0F021   ADDU S8, SP, ZERO
9D0107F4  00801021   ADDU V0, A0, ZERO
9D0107F8  A3C20010   SB V0, 16(S8)
348:                     int size = 0;
9D0107FC  AFC00000   SW ZERO, 0(S8)
349:                 
350:                     switch (reg)
9D010800  93C20010   LBU V0, 16(S8)
9D010804  2C430100   SLTIU V1, V0, 256
9D010808  106001B0   BEQ V1, ZERO, 0x9D010ECC
9D01080C  00000000   NOP
9D010810  00021880   SLL V1, V0, 2
9D010814  3C029D01   LUI V0, -25343
9D010818  2442082C   ADDIU V0, V0, 2092
9D01081C  00621021   ADDU V0, V1, V0
9D010820  8C420000   LW V0, 0(V0)
9D010824  00400008   JR V0
9D010828  00000000   NOP
351:                     {
352:                         case VN100_REG_TAG:         // ID: 0
353:                             size = 20;
9D010C2C  24020014   ADDIU V0, ZERO, 20
9D010C30  AFC20000   SW V0, 0(S8)
354:                             break;
9D010C34  0B4043B7   J 0x9D010EDC
9D010C38  00000000   NOP
355:                         case VN100_REG_MODEL:       // ID: 1
356:                             size = 24;
9D010C3C  24020018   ADDIU V0, ZERO, 24
9D010C40  AFC20000   SW V0, 0(S8)
357:                             break;
9D010C44  0B4043B7   J 0x9D010EDC
9D010C48  00000000   NOP
358:                         case VN100_REG_HWREV:       // ID: 2
359:                             size = 4;
9D010C4C  24020004   ADDIU V0, ZERO, 4
9D010C50  AFC20000   SW V0, 0(S8)
360:                             break;
9D010C54  0B4043B7   J 0x9D010EDC
9D010C58  00000000   NOP
361:                         case VN100_REG_SN:          // ID: 3
362:                             size = 4;
9D010C5C  24020004   ADDIU V0, ZERO, 4
9D010C60  AFC20000   SW V0, 0(S8)
363:                             break;
9D010C64  0B4043B7   J 0x9D010EDC
9D010C68  00000000   NOP
364:                         case VN100_REG_FWVER:       // ID: 4
365:                             size = 4;
9D010C6C  24020004   ADDIU V0, ZERO, 4
9D010C70  AFC20000   SW V0, 0(S8)
366:                             break;
9D010C74  0B4043B7   J 0x9D010EDC
9D010C78  00000000   NOP
367:                         case VN100_REG_SBAUD:       // ID: 5
368:                             size = 4;
9D010C7C  24020004   ADDIU V0, ZERO, 4
9D010C80  AFC20000   SW V0, 0(S8)
369:                             break;
9D010C84  0B4043B7   J 0x9D010EDC
9D010C88  00000000   NOP
370:                         case VN100_REG_ADOR:        // ID: 6
371:                             size = 4;
9D010C8C  24020004   ADDIU V0, ZERO, 4
9D010C90  AFC20000   SW V0, 0(S8)
372:                             break;
9D010C94  0B4043B7   J 0x9D010EDC
9D010C98  00000000   NOP
373:                         case VN100_REG_ADOF:        // ID: 7
374:                             size = 4;
9D010C9C  24020004   ADDIU V0, ZERO, 4
9D010CA0  AFC20000   SW V0, 0(S8)
375:                             break;
9D010CA4  0B4043B7   J 0x9D010EDC
9D010CA8  00000000   NOP
376:                         case VN100_REG_YPR:         // ID: 8
377:                             size = 12;
9D010CAC  2402000C   ADDIU V0, ZERO, 12
9D010CB0  AFC20000   SW V0, 0(S8)
378:                             break;
9D010CB4  0B4043B7   J 0x9D010EDC
9D010CB8  00000000   NOP
379:                         case VN100_REG_QTN:         // ID: 9
380:                             size = 16;
9D010CBC  24020010   ADDIU V0, ZERO, 16
9D010CC0  AFC20000   SW V0, 0(S8)
381:                             break;
9D010CC4  0B4043B7   J 0x9D010EDC
9D010CC8  00000000   NOP
382:                         case VN100_REG_QTM:         // ID: 10
383:                             break;
384:                         case VN100_REG_QTA:         // ID: 11
385:                             break;
386:                         case VN100_REG_QTR:         // ID: 12
387:                             break;
388:                         case VN100_REG_QMA:         // ID: 13
389:                             break;
390:                         case VN100_REG_QAR:         // ID: 14
391:                             break;
392:                         case VN100_REG_QMR:         // ID: 15
393:                             size = 52;
9D010CCC  24020034   ADDIU V0, ZERO, 52
9D010CD0  AFC20000   SW V0, 0(S8)
394:                             break;
9D010CD4  0B4043B7   J 0x9D010EDC
9D010CD8  00000000   NOP
395:                         case VN100_REG_DCM:         // ID: 16
396:                             break;
397:                         case VN100_REG_MAG:         // ID: 17
398:                             size = 12;
9D010CDC  2402000C   ADDIU V0, ZERO, 12
9D010CE0  AFC20000   SW V0, 0(S8)
399:                             break;
9D010CE4  0B4043B7   J 0x9D010EDC
9D010CE8  00000000   NOP
400:                         case VN100_REG_ACC:         // ID: 18
401:                             size = 12;
9D010CEC  2402000C   ADDIU V0, ZERO, 12
9D010CF0  AFC20000   SW V0, 0(S8)
402:                             break;
9D010CF4  0B4043B7   J 0x9D010EDC
9D010CF8  00000000   NOP
403:                         case VN100_REG_GYR:         // ID: 19
404:                             size = 12;
9D010CFC  2402000C   ADDIU V0, ZERO, 12
9D010D00  AFC20000   SW V0, 0(S8)
405:                             break;
9D010D04  0B4043B7   J 0x9D010EDC
9D010D08  00000000   NOP
406:                         case VN100_REG_MAR:         // ID: 20
407:                             size = 36;
9D010D0C  24020024   ADDIU V0, ZERO, 36
9D010D10  AFC20000   SW V0, 0(S8)
408:                             break;
9D010D14  0B4043B7   J 0x9D010EDC
9D010D18  00000000   NOP
409:                         case VN100_REG_REF:         // ID: 21
410:                             size = 24;
9D010D1C  24020018   ADDIU V0, ZERO, 24
9D010D20  AFC20000   SW V0, 0(S8)
411:                             break;
9D010D24  0B4043B7   J 0x9D010EDC
9D010D28  00000000   NOP
412:                         case VN100_REG_SIG:         // ID: 22
413:                             break;
414:                         case VN100_REG_HSI:         // ID: 23
415:                             size = 48;
9D010D2C  24020030   ADDIU V0, ZERO, 48
9D010D30  AFC20000   SW V0, 0(S8)
416:                             break;
9D010D34  0B4043B7   J 0x9D010EDC
9D010D38  00000000   NOP
417:                         case VN100_REG_ATP:         // ID: 24
418:                             break;
419:                         case VN100_REG_ACT:         // ID: 25
420:                             size = 48;
9D010D3C  24020030   ADDIU V0, ZERO, 48
9D010D40  AFC20000   SW V0, 0(S8)
421:                             break;
9D010D44  0B4043B7   J 0x9D010EDC
9D010D48  00000000   NOP
422:                         case VN100_REG_RFR:         // ID: 26
423:                             size = 36;
9D010D4C  24020024   ADDIU V0, ZERO, 36
9D010D50  AFC20000   SW V0, 0(S8)
424:                             break;
9D010D54  0B4043B7   J 0x9D010EDC
9D010D58  00000000   NOP
425:                         case VN100_REG_YMR:         // ID: 27
426:                             size = 48;
9D010D5C  24020030   ADDIU V0, ZERO, 48
9D010D60  AFC20000   SW V0, 0(S8)
427:                             break;
9D010D64  0B4043B7   J 0x9D010EDC
9D010D68  00000000   NOP
428:                         case VN100_REG_ACG:         // ID: 28
429:                             break;
430:                         case VN100_REG_PROT:        // ID: 30
431:                             size = 7;
9D010D6C  24020007   ADDIU V0, ZERO, 7
9D010D70  AFC20000   SW V0, 0(S8)
432:                             break;
9D010D74  0B4043B7   J 0x9D010EDC
9D010D78  00000000   NOP
433:                         case VN100_REG_SYNC:        // ID: 32
434:                             size = 20;
9D010D7C  24020014   ADDIU V0, ZERO, 20
9D010D80  AFC20000   SW V0, 0(S8)
435:                             break;
9D010D84  0B4043B7   J 0x9D010EDC
9D010D88  00000000   NOP
436:                         case VN100_REG_STAT:        // ID: 33
437:                             size = 12;
9D010D8C  2402000C   ADDIU V0, ZERO, 12
9D010D90  AFC20000   SW V0, 0(S8)
438:                             break;
9D010D94  0B4043B7   J 0x9D010EDC
9D010D98  00000000   NOP
439:                         case VN100_REG_VPE:         // ID: 35
440:                             size = 4;
9D010D9C  24020004   ADDIU V0, ZERO, 4
9D010DA0  AFC20000   SW V0, 0(S8)
441:                             break;
9D010DA4  0B4043B7   J 0x9D010EDC
9D010DA8  00000000   NOP
442:                         case VN100_REG_VPEMBT:      // ID: 36
443:                             size = 36;
9D010DAC  24020024   ADDIU V0, ZERO, 36
9D010DB0  AFC20000   SW V0, 0(S8)
444:                             break;
9D010DB4  0B4043B7   J 0x9D010EDC
9D010DB8  00000000   NOP
445:                         case VN100_REG_VPEABT:      // ID: 38
446:                             size = 36;
9D010DBC  24020024   ADDIU V0, ZERO, 36
9D010DC0  AFC20000   SW V0, 0(S8)
447:                             break;
9D010DC4  0B4043B7   J 0x9D010EDC
9D010DC8  00000000   NOP
448:                         case VN100_REG_MCC:         // ID: 44
449:                             size = 4;
9D010DCC  24020004   ADDIU V0, ZERO, 4
9D010DD0  AFC20000   SW V0, 0(S8)
450:                             break;
9D010DD4  0B4043B7   J 0x9D010EDC
9D010DD8  00000000   NOP
451:                         case VN100_REG_CMC:         // ID: 47
452:                             size = 48;
9D010DDC  24020030   ADDIU V0, ZERO, 48
9D010DE0  AFC20000   SW V0, 0(S8)
453:                             break;
9D010DE4  0B4043B7   J 0x9D010EDC
9D010DE8  00000000   NOP
454:                         case VN100_REG_VCM:         // ID: 50
455:                             size = 12;
9D010DEC  2402000C   ADDIU V0, ZERO, 12
9D010DF0  AFC20000   SW V0, 0(S8)
456:                             break;
9D010DF4  0B4043B7   J 0x9D010EDC
9D010DF8  00000000   NOP
457:                         case VN100_REG_VCC:         // ID: 51
458:                             size = 8;
9D010DFC  24020008   ADDIU V0, ZERO, 8
9D010E00  AFC20000   SW V0, 0(S8)
459:                             break;
9D010E04  0B4043B7   J 0x9D010EDC
9D010E08  00000000   NOP
460:                         case VN100_REG_VCS:         // ID: 52
461:                             size = 8;
9D010E0C  24020008   ADDIU V0, ZERO, 8
9D010E10  AFC20000   SW V0, 0(S8)
462:                             break;
9D010E14  0B4043B7   J 0x9D010EDC
9D010E18  00000000   NOP
463:                         case VN100_REG_IMU:         // ID: 54
464:                             size = 44;
9D010E1C  2402002C   ADDIU V0, ZERO, 44
9D010E20  AFC20000   SW V0, 0(S8)
465:                             break;
9D010E24  0B4043B7   J 0x9D010EDC
9D010E28  00000000   NOP
466:                         case VN100_REG_BOR1:        // ID: 75
467:                             size = 22;
9D010E2C  24020016   ADDIU V0, ZERO, 22
9D010E30  AFC20000   SW V0, 0(S8)
468:                             break;
9D010E34  0B4043B7   J 0x9D010EDC
9D010E38  00000000   NOP
469:                         case VN100_REG_BOR2:        // ID: 76
470:                             size = 22;
9D010E3C  24020016   ADDIU V0, ZERO, 22
9D010E40  AFC20000   SW V0, 0(S8)
471:                             break;
9D010E44  0B4043B7   J 0x9D010EDC
9D010E48  00000000   NOP
472:                         case VN100_REG_BOR3:        // ID: 77
473:                             size = 22;
9D010E4C  24020016   ADDIU V0, ZERO, 22
9D010E50  AFC20000   SW V0, 0(S8)
474:                             break;
9D010E54  0B4043B7   J 0x9D010EDC
9D010E58  00000000   NOP
475:                         case VN100_REG_DTDV:        // ID: 80
476:                             size = 28;
9D010E5C  2402001C   ADDIU V0, ZERO, 28
9D010E60  AFC20000   SW V0, 0(S8)
477:                             break;
9D010E64  0B4043B7   J 0x9D010EDC
9D010E68  00000000   NOP
478:                         case VN100_REG_DTDVC:       // ID: 82
479:                             size = 6;
9D010E6C  24020006   ADDIU V0, ZERO, 6
9D010E70  AFC20000   SW V0, 0(S8)
480:                             break;
9D010E74  0B4043B7   J 0x9D010EDC
9D010E78  00000000   NOP
481:                         case VN100_REG_RVC:         // ID: 83
482:                             size = 32;
9D010E7C  24020020   ADDIU V0, ZERO, 32
9D010E80  AFC20000   SW V0, 0(S8)
483:                             break;
9D010E84  0B4043B7   J 0x9D010EDC
9D010E88  00000000   NOP
484:                         case VN100_REG_GCMP:        // ID: 84
485:                             size = 48;
9D010E8C  24020030   ADDIU V0, ZERO, 48
9D010E90  AFC20000   SW V0, 0(S8)
486:                             break;
9D010E94  0B4043B7   J 0x9D010EDC
9D010E98  00000000   NOP
487:                         case VN100_REG_IMUF:        // ID: 85
488:                             size = 15;
9D010E9C  2402000F   ADDIU V0, ZERO, 15
9D010EA0  AFC20000   SW V0, 0(S8)
489:                             break;
9D010EA4  0B4043B7   J 0x9D010EDC
9D010EA8  00000000   NOP
490:                         case VN100_REG_YPRTBAAR:    // ID: 239
491:                             size = 36;
9D010EAC  24020024   ADDIU V0, ZERO, 36
9D010EB0  AFC20000   SW V0, 0(S8)
492:                             break;
9D010EB4  0B4043B7   J 0x9D010EDC
9D010EB8  00000000   NOP
493:                         case VN100_REG_YPRTIAAR:    // ID: 240
494:                             size = 36;
9D010EBC  24020024   ADDIU V0, ZERO, 36
9D010EC0  AFC20000   SW V0, 0(S8)
495:                             break;
9D010EC4  0B4043B7   J 0x9D010EDC
9D010EC8  00000000   NOP
496:                         case VN100_REG_RAW:         // ID: 251
497:                             break;
498:                         case VN100_REG_CMV:         // ID: 252
499:                             break;
500:                         case VN100_REG_STV:         // ID: 253
501:                             break;
502:                         case VN100_REG_COV:         // ID: 254
503:                             break;
504:                         case VN100_REG_CAL:         // ID: 255
505:                             break;
506:                         default:
507:                             break;
9D010ECC  00000000   NOP
9D010ED0  0B4043B7   J 0x9D010EDC
9D010ED4  00000000   NOP
9D010ED8  00000000   NOP
508:                     }
509:                 
510:                     return size;
9D010EDC  8FC20000   LW V0, 0(S8)
511:                 }
9D010EE0  03C0E821   ADDU SP, S8, ZERO
9D010EE4  8FBE000C   LW S8, 12(SP)
9D010EE8  27BD0010   ADDIU SP, SP, 16
9D010EEC  03E00008   JR RA
9D010EF0  00000000   NOP
512:                 
513:                 
514:                 //==============================================================================
515:                 
516:                 // Calculates the 8-bit checksum for the given byte sequence. 
517:                 
518:                 unsigned char calculateChecksum(unsigned char data[], unsigned int length)
519:                 { 
9D010EF4  27BDFFF0   ADDIU SP, SP, -16
9D010EF8  AFBE000C   SW S8, 12(SP)
9D010EFC  03A0F021   ADDU S8, SP, ZERO
9D010F00  AFC40010   SW A0, 16(S8)
9D010F04  AFC50014   SW A1, 20(S8)
520:                     unsigned int i; 
521:                     unsigned char cksum = 0;
9D010F08  A3C00004   SB ZERO, 4(S8)
522:                     
523:                     for (i = 0; i < length; i++)
9D010F0C  AFC00000   SW ZERO, 0(S8)
9D010F10  0B4043D0   J 0x9D010F40
9D010F14  00000000   NOP
9D010F34  8FC20000   LW V0, 0(S8)
9D010F38  24420001   ADDIU V0, V0, 1
9D010F3C  AFC20000   SW V0, 0(S8)
9D010F40  8FC30000   LW V1, 0(S8)
9D010F44  8FC20014   LW V0, 20(S8)
9D010F48  0062102B   SLTU V0, V1, V0
9D010F4C  1440FFF2   BNE V0, ZERO, 0x9D010F18
9D010F50  00000000   NOP
524:                     {
525:                         cksum ^= data[i];
9D010F18  8FC30010   LW V1, 16(S8)
9D010F1C  8FC20000   LW V0, 0(S8)
9D010F20  00621021   ADDU V0, V1, V0
9D010F24  90430000   LBU V1, 0(V0)
9D010F28  93C20004   LBU V0, 4(S8)
9D010F2C  00621026   XOR V0, V1, V0
9D010F30  A3C20004   SB V0, 4(S8)
526:                     }
527:                     
528:                     return cksum;
9D010F54  93C20004   LBU V0, 4(S8)
529:                 }
9D010F58  03C0E821   ADDU SP, S8, ZERO
9D010F5C  8FBE000C   LW S8, 12(SP)
9D010F60  27BD0010   ADDIU SP, SP, 16
9D010F64  03E00008   JR RA
9D010F68  00000000   NOP
530:                 
531:                 
532:                 //==============================================================================
533:                 
534:                 // Calculates the 16-bit CRC for the given ASCII or binary message.
535:                 
536:                 unsigned short calculateCRC(unsigned char data[], unsigned int length)
537:                 {
9D010F6C  27BDFFF0   ADDIU SP, SP, -16
9D010F70  AFBE000C   SW S8, 12(SP)
9D010F74  03A0F021   ADDU S8, SP, ZERO
9D010F78  AFC40010   SW A0, 16(S8)
9D010F7C  AFC50014   SW A1, 20(S8)
538:                     unsigned int i;
539:                     unsigned short crc = 0;
9D010F80  A7C00004   SH ZERO, 4(S8)
540:                     
541:                     for (i = 0; i < length; i++)
9D010F84  AFC00000   SW ZERO, 0(S8)
9D010F88  0B404411   J 0x9D011044
9D010F8C  00000000   NOP
9D011038  8FC20000   LW V0, 0(S8)
9D01103C  24420001   ADDIU V0, V0, 1
9D011040  AFC20000   SW V0, 0(S8)
9D011044  8FC30000   LW V1, 0(S8)
9D011048  8FC20014   LW V0, 20(S8)
9D01104C  0062102B   SLTU V0, V1, V0
9D011050  1440FFCF   BNE V0, ZERO, 0x9D010F90
9D011054  00000000   NOP
542:                     {
543:                         crc = (unsigned char)(crc >> 8) | (crc << 8);
9D010F90  97C20004   LHU V0, 4(S8)
9D010F94  00021202   SRL V0, V0, 8
9D010F98  3042FFFF   ANDI V0, V0, -1
9D010F9C  304200FF   ANDI V0, V0, 255
9D010FA0  7C021E20   SEH V1, V0
9D010FA4  97C20004   LHU V0, 4(S8)
9D010FA8  00021200   SLL V0, V0, 8
9D010FAC  7C021620   SEH V0, V0
9D010FB0  00621025   OR V0, V1, V0
9D010FB4  7C021620   SEH V0, V0
9D010FB8  A7C20004   SH V0, 4(S8)
544:                         crc ^= data[i]; crc ^= (unsigned char)(crc & 0xff) >> 4;
9D010FBC  8FC30010   LW V1, 16(S8)
9D010FC0  8FC20000   LW V0, 0(S8)
9D010FC4  00621021   ADDU V0, V1, V0
9D010FC8  90420000   LBU V0, 0(V0)
9D010FCC  00401821   ADDU V1, V0, ZERO
9D010FD0  97C20004   LHU V0, 4(S8)
9D010FD4  00621026   XOR V0, V1, V0
9D010FD8  A7C20004   SH V0, 4(S8)
9D010FDC  97C20004   LHU V0, 4(S8)
9D010FE0  304200FF   ANDI V0, V0, 255
9D010FE4  00021102   SRL V0, V0, 4
9D010FE8  304200FF   ANDI V0, V0, 255
9D010FEC  00401821   ADDU V1, V0, ZERO
9D010FF0  97C20004   LHU V0, 4(S8)
9D010FF4  00621026   XOR V0, V1, V0
9D010FF8  A7C20004   SH V0, 4(S8)
545:                         crc ^= crc << 12; crc ^= (crc & 0x00ff) << 5;
9D010FFC  97C20004   LHU V0, 4(S8)
9D011000  00021300   SLL V0, V0, 12
9D011004  7C021E20   SEH V1, V0
9D011008  87C20004   LH V0, 4(S8)
9D01100C  00621026   XOR V0, V1, V0
9D011010  7C021620   SEH V0, V0
9D011014  A7C20004   SH V0, 4(S8)
9D011018  97C20004   LHU V0, 4(S8)
9D01101C  304200FF   ANDI V0, V0, 255
9D011020  00021140   SLL V0, V0, 5
9D011024  7C021E20   SEH V1, V0
9D011028  87C20004   LH V0, 4(S8)
9D01102C  00621026   XOR V0, V1, V0
9D011030  7C021620   SEH V0, V0
9D011034  A7C20004   SH V0, 4(S8)
546:                     } 
547:                     
548:                     return crc;
9D011058  97C20004   LHU V0, 4(S8)
549:                 }
9D01105C  03C0E821   ADDU SP, S8, ZERO
9D011060  8FBE000C   LW S8, 12(SP)
9D011064  27BD0010   ADDIU SP, SP, 16
9D011068  03E00008   JR RA
9D01106C  00000000   NOP
550:                 
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/util.c  ---------------------------------------
1:                   
2:                   
3:                   #include "stdint.h"
4:                   
5:                   // Calculates the 16-bit CRC for the given data.
6:                   uint16_t utilCRC16( void* data_p, uint16_t data_len, uint16_t crc_start )
7:                   {
9D01A974  27BDFFF0   ADDIU SP, SP, -16
9D01A978  AFBE000C   SW S8, 12(SP)
9D01A97C  03A0F021   ADDU S8, SP, ZERO
9D01A980  AFC40010   SW A0, 16(S8)
9D01A984  00A01821   ADDU V1, A1, ZERO
9D01A988  00C01021   ADDU V0, A2, ZERO
9D01A98C  A7C30014   SH V1, 20(S8)
9D01A990  A7C20018   SH V0, 24(S8)
8:                       uint8_t* data_u8_p;
9:                       uint16_t data_idx;
10:                      uint16_t crc;
11:                      
12:                      // Typecast input for processing.  Note: typecase to 8-bit type does not
13:                      // yield data alignment issues.
14:                      data_u8_p = (uint8_t*) data_p;
9D01A994  8FC20010   LW V0, 16(S8)
9D01A998  AFC20004   SW V0, 4(S8)
15:                      
16:                      // Start CRC calculation value as that supplied.
17:                      crc = crc_start;
9D01A99C  97C20018   LHU V0, 24(S8)
9D01A9A0  A7C20002   SH V0, 2(S8)
18:                      
19:                      for( data_idx = 0; data_idx < data_len; data_idx++ )
9D01A9A4  A7C00000   SH ZERO, 0(S8)
9D01A9A8  0B406A99   J 0x9D01AA64
9D01A9AC  00000000   NOP
9D01AA58  97C20000   LHU V0, 0(S8)
9D01AA5C  24420001   ADDIU V0, V0, 1
9D01AA60  A7C20000   SH V0, 0(S8)
9D01AA64  97C30000   LHU V1, 0(S8)
9D01AA68  97C20014   LHU V0, 20(S8)
9D01AA6C  0062102B   SLTU V0, V1, V0
9D01AA70  1440FFCF   BNE V0, ZERO, 0x9D01A9B0
9D01AA74  00000000   NOP
20:                      {
21:                          crc = (uint8_t)(crc >> 8) | (crc << 8);
9D01A9B0  97C20002   LHU V0, 2(S8)
9D01A9B4  00021202   SRL V0, V0, 8
9D01A9B8  3042FFFF   ANDI V0, V0, -1
9D01A9BC  304200FF   ANDI V0, V0, 255
9D01A9C0  7C021E20   SEH V1, V0
9D01A9C4  97C20002   LHU V0, 2(S8)
9D01A9C8  00021200   SLL V0, V0, 8
9D01A9CC  7C021620   SEH V0, V0
9D01A9D0  00621025   OR V0, V1, V0
9D01A9D4  7C021620   SEH V0, V0
9D01A9D8  A7C20002   SH V0, 2(S8)
22:                          crc ^= data_u8_p[ data_idx ];
9D01A9DC  97C20000   LHU V0, 0(S8)
9D01A9E0  8FC30004   LW V1, 4(S8)
9D01A9E4  00621021   ADDU V0, V1, V0
9D01A9E8  90420000   LBU V0, 0(V0)
9D01A9EC  00401821   ADDU V1, V0, ZERO
9D01A9F0  97C20002   LHU V0, 2(S8)
9D01A9F4  00621026   XOR V0, V1, V0
9D01A9F8  A7C20002   SH V0, 2(S8)
23:                          crc ^= (uint8_t)(crc & 0xff) >> 4;
9D01A9FC  97C20002   LHU V0, 2(S8)
9D01AA00  304200FF   ANDI V0, V0, 255
9D01AA04  00021102   SRL V0, V0, 4
9D01AA08  304200FF   ANDI V0, V0, 255
9D01AA0C  00401821   ADDU V1, V0, ZERO
9D01AA10  97C20002   LHU V0, 2(S8)
9D01AA14  00621026   XOR V0, V1, V0
9D01AA18  A7C20002   SH V0, 2(S8)
24:                          crc ^= crc << 12;
9D01AA1C  97C20002   LHU V0, 2(S8)
9D01AA20  00021300   SLL V0, V0, 12
9D01AA24  7C021E20   SEH V1, V0
9D01AA28  87C20002   LH V0, 2(S8)
9D01AA2C  00621026   XOR V0, V1, V0
9D01AA30  7C021620   SEH V0, V0
9D01AA34  A7C20002   SH V0, 2(S8)
25:                          crc ^= (crc & 0x00ff) << 5;
9D01AA38  97C20002   LHU V0, 2(S8)
9D01AA3C  304200FF   ANDI V0, V0, 255
9D01AA40  00021140   SLL V0, V0, 5
9D01AA44  7C021E20   SEH V1, V0
9D01AA48  87C20002   LH V0, 2(S8)
9D01AA4C  00621026   XOR V0, V1, V0
9D01AA50  7C021620   SEH V0, V0
9D01AA54  A7C20002   SH V0, 2(S8)
26:                      } 
27:                      
28:                      return crc;
9D01AA78  97C20002   LHU V0, 2(S8)
29:                  }
9D01AA7C  03C0E821   ADDU SP, S8, ZERO
9D01AA80  8FBE000C   LW S8, 12(SP)
9D01AA84  27BD0010   ADDIU SP, SP, 16
9D01AA88  03E00008   JR RA
9D01AA8C  00000000   NOP
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/uart.c  ---------------------------------------
1:                   ////////////////////////////////////////////////////////////////////////////////
2:                   /// @file
3:                   /// @brief Universal Asynchronous Receiver Transmitter (UART) driver.
4:                   ////////////////////////////////////////////////////////////////////////////////
5:                   
6:                   // *****************************************************************************
7:                   // ************************** System Include Files *****************************
8:                   // *****************************************************************************
9:                   
10:                  // *****************************************************************************
11:                  // ************************** User Include Files *******************************
12:                  // *****************************************************************************
13:                  
14:                  #include "uart.h"
15:                  #include <sys/attribs.h>
16:                  
17:                  // *****************************************************************************
18:                  // ************************** Defines ******************************************
19:                  // *****************************************************************************
20:                  
21:                  // Constant(s) and Function-like Marco(s) for managing the transmitter FIFO.
22:                  // - LEN_MASK: Bit-mask for the size of the FIFO.
23:                  // - LEN:      Length of FIFO - must be power of '2'.
24:                  // - NEXT_IDX: Next index value in buffer, loop back to start at end of FIFO.
25:                  //
26:                  #define  UART_TX_FIFO_LEN_MASK     0x03
27:                  #define  UART_TX_FIFO_LEN          ( UART_TX_FIFO_LEN_MASK + 1 )
28:                  #define mUART_TX_FIFO_NEXT_IDX(x)  ( ( (x) + 1 ) & UART_TX_FIFO_LEN_MASK )
29:                  
30:                  // Constant(s) and Function-like Marco(s) for managing the receiver circular
31:                  // buffer.
32:                  // - LEN_MASK: Bit-mask for the size of the circular buffer.
33:                  // - LEN:      Length of circular buffer - must be power of '2'.
34:                  // - NEXT_IDX: Next index value in buffer, loop back to start at end of circular
35:                  //             buffer.
36:                  // - PREV_IDX: Previous index value in buffer, loop back to end at start of
37:                  //             circular buffer.
38:                  //
39:                  #define  UART_RX_CB_LEN_MASK       0x03
40:                  #define  UART_RX_CB_LEN            ( UART_RX_CB_LEN_MASK + 1 )
41:                  #define mUART_RX_CB_NEXT_IDX(x)    ( ( (x) + 1 ) & UART_RX_CB_LEN_MASK )
42:                  #define mUART_RX_CB_PREV_IDX(x)    ( ( (x) + ( UART_RX_CB_LEN - 1 ) ) & UART_RX_CB_LEN_MASK )
43:                  
44:                  // Structure of FIFO for transmitting data.
45:                  typedef struct
46:                  {
47:                      UART_TX_BUF_S* buf_arr[ UART_TX_FIFO_LEN ]; // Array of transmission buffer pointers.
48:                      uint8_t        head_idx;                    // Index of data to output.
49:                      uint8_t        tail_idx;                    // Index of data to input - i.e. 1st empty slot.
50:                      
51:                  } UART_TX_FIFO_S;
52:                  
53:                  // Structure of circular buffer for receiving data.
54:                  typedef struct
55:                  {
56:                      UART_RX_BUF_S  buf_arr[ 4 ];   // Array of reception buffers.
57:                      uint8_t        buf_idx;                     // Current array index for receiving data.
58:                      
59:                  } UART_RX_CB_S;
60:                  
61:                  // *****************************************************************************
62:                  // ************************** Definitions **************************************
63:                  // *****************************************************************************
64:                  
65:                  // UART hardware receiver overflow latch.
66:                  static bool uart_oerr_latch = false;
67:                  
68:                  // Number of UART receiver hardware errors (parity or framing) since reset.
69:                  static uint16_t uart_err_cnt = 0;
70:                  
71:                  // Circular buffer for receiving UART data.
72:                  static UART_RX_CB_S uart_rx_cb; // =
73:                  //{
74:                  ////    {
75:                  ////        { { 0 }, 0 },   // Start buffer as empty.
76:                  ////        { { 0 }, 0 },   // Start buffer as empty.
77:                  ////        { { 0 }, 0 },   // Start buffer as empty.
78:                  ////        { { 0 }, 0 },   // Start buffer as empty.
79:                  ////    },
80:                  ////    
81:                  ////    0,                  // Buffer index to start of circular buffer.
82:                  //};
83:                  
84:                  // FIFO for transmitting UART data.
85:                  //
86:                  // NOTE: FIFO is maintained using a "keep one slot empty" method.  This method
87:                  // is used for being able to identify an empty buffer (i.e. head equals tail)
88:                  // and a full buffer (i.e. tail + 1 equals head).
89:                  //
90:                  // Note: A FIFO is maintained to accommodate the slower transmission rate of
91:                  // the UART interface.  Multiple transmission buffers can be queue for
92:                  // transmission by the application software, allowing for maximum utilization
93:                  // of the UART interface and non-blocking of the application software.
94:                  //
95:                  static UART_TX_FIFO_S uart_tx_fifo =
96:                  {
97:                      { NULL, NULL, NULL, NULL }, // To transmitter buffer pointers to start.
98:                      0,                          // Head index to start of FIFO.
99:                      0,                          // Tail index to start of FIFO.
100:                 };
101:                 
102:                 // *****************************************************************************
103:                 // ************************** Function Prototypes ******************************
104:                 // *****************************************************************************
105:                 
106:                 void UARTBufRx( void );
107:                 void UARTBufTX( void );
108:                 
109:                 uint8_t UARTRead( uint8_t* data_p, uint16_t data_len );
110:                 uint8_t UARTWrite( const uint8_t* data_p, uint16_t data_len );
111:                 
112:                 // *****************************************************************************
113:                 // ************************** Global Functions *********************************
114:                 // *****************************************************************************
115:                 
116:                 void UARTInit( void )
117:                 {
9D0128F8  27BDFFF8   ADDIU SP, SP, -8
9D0128FC  AFBE0004   SW S8, 4(SP)
9D012900  03A0F021   ADDU S8, SP, ZERO
118:                     U1MODEbits.ON = 0;          // Turn module off.
9D012904  3C03BF80   LUI V1, -16512
9D012908  8C626000   LW V0, 24576(V1)
9D01290C  7C027BC4   INS V0, ZERO, 15, 1
9D012910  AC626000   SW V0, 24576(V1)
119:                     
120:                     U1MODEbits.UEN   = 0b00;    // Don't use U1CTS and U1RTS pins.
9D012914  3C03BF80   LUI V1, -16512
9D012918  8C626000   LW V0, 24576(V1)
9D01291C  7C024A04   INS V0, ZERO, 8, 2
9D012920  AC626000   SW V0, 24576(V1)
121:                     U1MODEbits.PDSEL = 0b00;    // 8-bit data, no parity.
9D012924  3C03BF80   LUI V1, -16512
9D012928  8C626000   LW V0, 24576(V1)
9D01292C  7C021044   INS V0, ZERO, 1, 2
9D012930  AC626000   SW V0, 24576(V1)
122:                     U1MODEbits.STSEL = 0;       // 1 stop bit.
9D012934  3C03BF80   LUI V1, -16512
9D012938  8C626000   LW V0, 24576(V1)
9D01293C  7C020004   INS V0, ZERO, 0, 1
9D012940  AC626000   SW V0, 24576(V1)
123:                     
124:                     U1STAbits.UTXISEL = 0b10;   // Interrupt generated while transmit buffer empty.
9D012944  3C03BF80   LUI V1, -16512
9D012948  8C626010   LW V0, 24592(V1)
9D01294C  24040002   ADDIU A0, ZERO, 2
9D012950  7C827B84   INS V0, A0, 14, 2
9D012954  AC626010   SW V0, 24592(V1)
125:                     U1STAbits.URXEN   = 1;      // Received enabled.
9D012958  3C03BF80   LUI V1, -16512
9D01295C  8C626010   LW V0, 24592(V1)
9D012960  24040001   ADDIU A0, ZERO, 1
9D012964  7C826304   INS V0, A0, 12, 1
9D012968  AC626010   SW V0, 24592(V1)
126:                     U1STAbits.UTXEN   = 1;      // Transmitter enabled.
9D01296C  3C03BF80   LUI V1, -16512
9D012970  8C626010   LW V0, 24592(V1)
9D012974  24040001   ADDIU A0, ZERO, 1
9D012978  7C825284   INS V0, A0, 10, 1
9D01297C  AC626010   SW V0, 24592(V1)
127:                     U1STAbits.URXISEL = 0b10;   // Interrupt generated while receiver 3/4 full.
9D012980  3C03BF80   LUI V1, -16512
9D012984  8C626010   LW V0, 24592(V1)
9D012988  24040002   ADDIU A0, ZERO, 2
9D01298C  7C823984   INS V0, A0, 6, 2
9D012990  AC626010   SW V0, 24592(V1)
128:                     
129:                     // Baud Rate = Fpb   / ( 16 * ( U1BRG + 1 ) )
130:                     //           = 80MHZ / ( 16 * ( 42    + 1 ) )
131:                     //           = 116,279
132:                     //
133:                     // Error %   = ( 116279 - 115200 ) / 115200
134:                     //           = 0.94 %
135:                     //
136:                     U1BRG = 42;
9D012994  3C02BF80   LUI V0, -16512
9D012998  2403002A   ADDIU V1, ZERO, 42
9D01299C  AC436040   SW V1, 24640(V0)
137:                     
138:                     // Set U1Tx and U1Rx interrupts to priority '1' and sub-priority to '0'.
139:                     IPC6bits.U1IP = 1;
9D0129A0  3C03BF88   LUI V1, -16504
9D0129A4  8C6210F0   LW V0, 4336(V1)
9D0129A8  24040001   ADDIU A0, ZERO, 1
9D0129AC  7C822084   INS V0, A0, 2, 3
9D0129B0  AC6210F0   SW V0, 4336(V1)
140:                     IPC6bits.U1IS = 0;
9D0129B4  3C03BF88   LUI V1, -16504
9D0129B8  8C6210F0   LW V0, 4336(V1)
9D0129BC  7C020804   INS V0, ZERO, 0, 2
9D0129C0  AC6210F0   SW V0, 4336(V1)
141:                     
142:                     // Clear the U1Tx and U1Rx interrupt flags.
143:                     IFS0bits.U1RXIF = 0;
9D0129C4  3C03BF88   LUI V1, -16504
9D0129C8  8C621030   LW V0, 4144(V1)
9D0129CC  7C02DEC4   INS V0, ZERO, 27, 1
9D0129D0  AC621030   SW V0, 4144(V1)
144:                     IFS0bits.U1TXIF = 0;
9D0129D4  3C03BF88   LUI V1, -16504
9D0129D8  8C621030   LW V0, 4144(V1)
9D0129DC  7C02E704   INS V0, ZERO, 28, 1
9D0129E0  AC621030   SW V0, 4144(V1)
145:                     
146:                     // Enable the receive interrupt
147:                     IEC0bits.U1RXIE = 1;
9D0129E4  3C03BF88   LUI V1, -16504
9D0129E8  8C621060   LW V0, 4192(V1)
9D0129EC  24040001   ADDIU A0, ZERO, 1
9D0129F0  7C82DEC4   INS V0, A0, 27, 1
9D0129F4  AC621060   SW V0, 4192(V1)
148:                 }
9D0129F8  03C0E821   ADDU SP, S8, ZERO
9D0129FC  8FBE0004   LW S8, 4(SP)
9D012A00  27BD0008   ADDIU SP, SP, 8
9D012A04  03E00008   JR RA
9D012A08  00000000   NOP
149:                 
150:                 // Note: Alternate control flow supplied for turning on the
151:                 // UART communication to manage software receiver buffer overflow. If a large
152:                 // amount of time exists between enabling the module and the first execution
153:                 // of 'Task', then the receiver hardware buffer could overflow and
154:                 // received data be lost.
155:                 void UARTStartup( void )
156:                 {
9D012A0C  27BDFFF8   ADDIU SP, SP, -8
9D012A10  AFBE0004   SW S8, 4(SP)
9D012A14  03A0F021   ADDU S8, SP, ZERO
157:                     // Turn module on.
158:                     U1MODEbits.ON = 1;
9D012A18  3C03BF80   LUI V1, -16512
9D012A1C  8C626000   LW V0, 24576(V1)
9D012A20  24040001   ADDIU A0, ZERO, 1
9D012A24  7C827BC4   INS V0, A0, 15, 1
9D012A28  AC626000   SW V0, 24576(V1)
159:                 }
9D012A2C  03C0E821   ADDU SP, S8, ZERO
9D012A30  8FBE0004   LW S8, 4(SP)
9D012A34  27BD0008   ADDIU SP, SP, 8
9D012A38  03E00008   JR RA
9D012A3C  00000000   NOP
160:                 
161:                 // Manage receiver buffer for receiving of new data.
162:                 //
163:                 // Note: This function must occur at a lower priority that the receiver ISR.
164:                 //
165:                 // Note: Data over UART is assumed to be a continuous stream; therefore,
166:                 // the hardware buffer is never flush as it's assumed the 3/4 full interrupt
167:                 // will occur.  That is, it's assumed that unread data will not sit in
168:                 // the receiver hardware buffer (e.g. 1/2 full of data) for an extended
169:                 // period of time.
170:                 //
171:                 void UARTTask( void )
172:                 {
9D012A40  27BDFFF0   ADDIU SP, SP, -16
9D012A44  AFBE000C   SW S8, 12(SP)
9D012A48  03A0F021   ADDU S8, SP, ZERO
173:                     uint8_t cb_next_idx;
174:                     
175:                     cb_next_idx = mUART_RX_CB_NEXT_IDX( uart_rx_cb.buf_idx );
9D012A4C  3C02A001   LUI V0, -24575
9D012A50  24428878   ADDIU V0, V0, -30600
9D012A54  90420028   LBU V0, 40(V0)
9D012A58  24420001   ADDIU V0, V0, 1
9D012A5C  304200FF   ANDI V0, V0, 255
9D012A60  30420003   ANDI V0, V0, 3
9D012A64  A3C20000   SB V0, 0(S8)
176:                     
177:                     // Setup next circular buffer index for receiving data.
178:                     //
179:                     // Note: data length of next element reset before updating buffer index
180:                     // to prevent race condition of ISR updating buffer data between two
181:                     // buffer management operations (i.e. variable serves as semaphore for
182:                     // multi-threaded data).
183:                     //
184:                     // Note: 'uart_rx_cb.buf_idx' only modified by this function and update
185:                     // is atomic.
186:                     //
187:                     uart_rx_cb.buf_arr[ cb_next_idx ].data_len = 0;
9D012A68  93C20000   LBU V0, 0(S8)
9D012A6C  3C03A001   LUI V1, -24575
9D012A70  00021040   SLL V0, V0, 1
9D012A74  00022080   SLL A0, V0, 2
9D012A78  00441021   ADDU V0, V0, A0
9D012A7C  24638878   ADDIU V1, V1, -30600
9D012A80  00431021   ADDU V0, V0, V1
9D012A84  A4400008   SH ZERO, 8(V0)
188:                     uart_rx_cb.buf_idx = cb_next_idx;
9D012A88  3C02A001   LUI V0, -24575
9D012A8C  24428878   ADDIU V0, V0, -30600
9D012A90  93C30000   LBU V1, 0(S8)
9D012A94  A0430028   SB V1, 40(V0)
189:                 }
9D012A98  03C0E821   ADDU SP, S8, ZERO
9D012A9C  8FBE000C   LW S8, 12(SP)
9D012AA0  27BD0010   ADDIU SP, SP, 16
9D012AA4  03E00008   JR RA
9D012AA8  00000000   NOP
190:                 
191:                 void __ISR ( _UART_1_VECTOR, IPL1SOFT) UART1ISR( void ) 
192:                 {
9D012AAC  415DE800   RDPGPR SP, SP
9D012AB0  401A7000   MFC0 K0, EPC
9D012AB4  401B6000   MFC0 K1, Status
9D012AB8  27BDFF88   ADDIU SP, SP, -120
9D012ABC  AFBA0074   SW K0, 116(SP)
9D012AC0  401A6002   MFC0 K0, SRSCtl
9D012AC4  AFBB0070   SW K1, 112(SP)
9D012AC8  AFBA006C   SW K0, 108(SP)
9D012ACC  7C1B7844   INS K1, ZERO, 1, 15
9D012AD0  377B0400   ORI K1, K1, 1024
9D012AD4  409B6000   MTC0 K1, Status
9D012AD8  AFBF005C   SW RA, 92(SP)
9D012ADC  AFBE0058   SW S8, 88(SP)
9D012AE0  AFB90054   SW T9, 84(SP)
9D012AE4  AFB80050   SW T8, 80(SP)
9D012AE8  AFAF004C   SW T7, 76(SP)
9D012AEC  AFAE0048   SW T6, 72(SP)
9D012AF0  AFAD0044   SW T5, 68(SP)
9D012AF4  AFAC0040   SW T4, 64(SP)
9D012AF8  AFAB003C   SW T3, 60(SP)
9D012AFC  AFAA0038   SW T2, 56(SP)
9D012B00  AFA90034   SW T1, 52(SP)
9D012B04  AFA80030   SW T0, 48(SP)
9D012B08  AFA7002C   SW A3, 44(SP)
9D012B0C  AFA60028   SW A2, 40(SP)
9D012B10  AFA50024   SW A1, 36(SP)
9D012B14  AFA40020   SW A0, 32(SP)
9D012B18  AFA3001C   SW V1, 28(SP)
9D012B1C  AFA20018   SW V0, 24(SP)
9D012B20  AFA10014   SW AT, 20(SP)
9D012B24  00001012   MFLO V0, 0
9D012B28  AFA20064   SW V0, 100(SP)
9D012B2C  00001810   MFHI V1, 0
9D012B30  AFA30060   SW V1, 96(SP)
9D012B34  03A0F021   ADDU S8, SP, ZERO
193:                     // Receiver caused interrupt ?
194:                     if( IFS0bits.U1RXIF == 1 )
9D012B38  3C02BF88   LUI V0, -16504
9D012B3C  8C431030   LW V1, 4144(V0)
9D012B40  3C020800   LUI V0, 2048
9D012B44  00621024   AND V0, V1, V0
9D012B48  10400003   BEQ V0, ZERO, 0x9D012B58
9D012B4C  00000000   NOP
195:                     {
196:                         // Service the receiver.
197:                         UARTBufRx();
9D012B50  0F404B54   JAL UARTBufRx
9D012B54  00000000   NOP
198:                     }
199:                     
200:                     // Transmitter caused interrupt ?
201:                     if( IFS0bits.U1TXIF == 1 )
9D012B58  3C02BF88   LUI V0, -16504
9D012B5C  8C431030   LW V1, 4144(V0)
9D012B60  3C021000   LUI V0, 4096
9D012B64  00621024   AND V0, V1, V0
9D012B68  10400003   BEQ V0, ZERO, 0x9D012B78
9D012B6C  00000000   NOP
202:                     {
203:                         // Service the transmitter.
204:                         UARTBufTX();
9D012B70  0F404C0C   JAL UARTBufTX
9D012B74  00000000   NOP
205:                     }
206:                 }
9D012B78  03C0E821   ADDU SP, S8, ZERO
9D012B7C  8FA20064   LW V0, 100(SP)
9D012B80  00400013   MTLO V0, 0
9D012B84  8FA30060   LW V1, 96(SP)
9D012B88  00600011   MTHI V1, 0
9D012B8C  8FBF005C   LW RA, 92(SP)
9D012B90  8FBE0058   LW S8, 88(SP)
9D012B94  8FB90054   LW T9, 84(SP)
9D012B98  8FB80050   LW T8, 80(SP)
9D012B9C  8FAF004C   LW T7, 76(SP)
9D012BA0  8FAE0048   LW T6, 72(SP)
9D012BA4  8FAD0044   LW T5, 68(SP)
9D012BA8  8FAC0040   LW T4, 64(SP)
9D012BAC  8FAB003C   LW T3, 60(SP)
9D012BB0  8FAA0038   LW T2, 56(SP)
9D012BB4  8FA90034   LW T1, 52(SP)
9D012BB8  8FA80030   LW T0, 48(SP)
9D012BBC  8FA7002C   LW A3, 44(SP)
9D012BC0  8FA60028   LW A2, 40(SP)
9D012BC4  8FA50024   LW A1, 36(SP)
9D012BC8  8FA40020   LW A0, 32(SP)
9D012BCC  8FA3001C   LW V1, 28(SP)
9D012BD0  8FA20018   LW V0, 24(SP)
9D012BD4  8FA10014   LW AT, 20(SP)
9D012BD8  41606000   DI ZERO
9D012BDC  000000C0   EHB
9D012BE0  8FBA0074   LW K0, 116(SP)
9D012BE4  8FBB0070   LW K1, 112(SP)
9D012BE8  409A7000   MTC0 K0, EPC
9D012BEC  8FBA006C   LW K0, 108(SP)
9D012BF0  27BD0078   ADDIU SP, SP, 120
9D012BF4  409A6002   MTC0 K0, SRSCtl
9D012BF8  41DDE800   WRPGPR SP, SP
9D012BFC  409B6000   MTC0 K1, Status
9D012C00  42000018   ERET
207:                 
208:                 // Return pointer to freshest received data available for processing.
209:                 const UART_RX_BUF_S* UARTGet( void )
210:                 {
9D012C04  27BDFFF0   ADDIU SP, SP, -16
9D012C08  AFBE000C   SW S8, 12(SP)
9D012C0C  03A0F021   ADDU S8, SP, ZERO
211:                     uint8_t prev_idx;
212:                     
213:                     // Get the previous index from the receiver circular buffer.  The current
214:                     // index is used for receiving data while the previous index is the 
215:                     // freshest data available for processing.
216:                     prev_idx = mUART_RX_CB_PREV_IDX( uart_rx_cb.buf_idx );
9D012C10  3C02A001   LUI V0, -24575
9D012C14  24428878   ADDIU V0, V0, -30600
9D012C18  90420028   LBU V0, 40(V0)
9D012C1C  24420003   ADDIU V0, V0, 3
9D012C20  304200FF   ANDI V0, V0, 255
9D012C24  30420003   ANDI V0, V0, 3
9D012C28  A3C20000   SB V0, 0(S8)
217:                     
218:                     return ( &uart_rx_cb.buf_arr[ prev_idx ] );
9D012C2C  93C20000   LBU V0, 0(S8)
9D012C30  00021040   SLL V0, V0, 1
9D012C34  00021880   SLL V1, V0, 2
9D012C38  00431821   ADDU V1, V0, V1
9D012C3C  3C02A001   LUI V0, -24575
9D012C40  24428878   ADDIU V0, V0, -30600
9D012C44  00621021   ADDU V0, V1, V0
219:                 }
9D012C48  03C0E821   ADDU SP, S8, ZERO
9D012C4C  8FBE000C   LW S8, 12(SP)
9D012C50  27BD0010   ADDIU SP, SP, 16
9D012C54  03E00008   JR RA
9D012C58  00000000   NOP
220:                 
221:                 // Setup a buffer for transmission if space available.
222:                 bool UARTSet( UART_TX_BUF_S* tx_buf_p )
223:                 {
9D012C5C  27BDFFF0   ADDIU SP, SP, -16
9D012C60  AFBE000C   SW S8, 12(SP)
9D012C64  03A0F021   ADDU S8, SP, ZERO
9D012C68  AFC40010   SW A0, 16(S8)
224:                     bool success = false;
9D012C6C  A3C00000   SB ZERO, 0(S8)
225:                     
226:                     // Supplied buffer is valid ?
227:                     if( tx_buf_p != NULL )
9D012C70  8FC20010   LW V0, 16(S8)
9D012C74  10400030   BEQ V0, ZERO, 0x9D012D38
9D012C78  00000000   NOP
228:                     {
229:                         // FIFO is not already full ?
230:                         if( mUART_TX_FIFO_NEXT_IDX( uart_tx_fifo.tail_idx ) != uart_tx_fifo.head_idx )
9D012C7C  3C02A001   LUI V0, -24575
9D012C80  244288A4   ADDIU V0, V0, -30556
9D012C84  90420011   LBU V0, 17(V0)
9D012C88  24420001   ADDIU V0, V0, 1
9D012C8C  30430003   ANDI V1, V0, 3
9D012C90  3C02A001   LUI V0, -24575
9D012C94  244288A4   ADDIU V0, V0, -30556
9D012C98  90420010   LBU V0, 16(V0)
9D012C9C  10620026   BEQ V1, V0, 0x9D012D38
9D012CA0  00000000   NOP
231:                         {
232:                             success = true;
9D012CA4  24020001   ADDIU V0, ZERO, 1
9D012CA8  A3C20000   SB V0, 0(S8)
233:                             
234:                             // Queue the buffer for transmission.
235:                             uart_tx_fifo.buf_arr[ uart_tx_fifo.tail_idx ] = tx_buf_p;
9D012CAC  3C02A001   LUI V0, -24575
9D012CB0  244288A4   ADDIU V0, V0, -30556
9D012CB4  90420011   LBU V0, 17(V0)
9D012CB8  00401821   ADDU V1, V0, ZERO
9D012CBC  3C02A001   LUI V0, -24575
9D012CC0  00031880   SLL V1, V1, 2
9D012CC4  244288A4   ADDIU V0, V0, -30556
9D012CC8  00621021   ADDU V0, V1, V0
9D012CCC  8FC30010   LW V1, 16(S8)
9D012CD0  AC430000   SW V1, 0(V0)
236:                             
237:                             // Identify buffer transmission as incomplete.
238:                             uart_tx_fifo.buf_arr[ uart_tx_fifo.tail_idx ]->tx_done = false;
9D012CD4  3C02A001   LUI V0, -24575
9D012CD8  244288A4   ADDIU V0, V0, -30556
9D012CDC  90420011   LBU V0, 17(V0)
9D012CE0  00401821   ADDU V1, V0, ZERO
9D012CE4  3C02A001   LUI V0, -24575
9D012CE8  00031880   SLL V1, V1, 2
9D012CEC  244288A4   ADDIU V0, V0, -30556
9D012CF0  00621021   ADDU V0, V1, V0
9D012CF4  8C420000   LW V0, 0(V0)
9D012CF8  A0400006   SB ZERO, 6(V0)
239:                             
240:                             // Update FIFO control variable.
241:                             //
242:                             // Note: Tail index update is performed last in buffer management
243:                             // operation to eliminate race conditions. (i.e. variable serves
244:                             // as semaphore for multi-threaded buffer).
245:                             //
246:                             // Note: Tail index only modified by this function and update
247:                             // is atomic.
248:                             //
249:                             uart_tx_fifo.tail_idx = mUART_TX_FIFO_NEXT_IDX( uart_tx_fifo.tail_idx );
9D012CFC  3C02A001   LUI V0, -24575
9D012D00  244288A4   ADDIU V0, V0, -30556
9D012D04  90420011   LBU V0, 17(V0)
9D012D08  24420001   ADDIU V0, V0, 1
9D012D0C  304200FF   ANDI V0, V0, 255
9D012D10  30420003   ANDI V0, V0, 3
9D012D14  304300FF   ANDI V1, V0, 255
9D012D18  3C02A001   LUI V0, -24575
9D012D1C  244288A4   ADDIU V0, V0, -30556
9D012D20  A0430011   SB V1, 17(V0)
250:                             
251:                             // Enable the transmit interrupt to send the buffered data.
252:                             IEC0bits.U1TXIE = 1;
9D012D24  3C03BF88   LUI V1, -16504
9D012D28  8C621060   LW V0, 4192(V1)
9D012D2C  24040001   ADDIU A0, ZERO, 1
9D012D30  7C82E704   INS V0, A0, 28, 1
9D012D34  AC621060   SW V0, 4192(V1)
253:                         }
254:                     }
255:                         
256:                     return success;
9D012D38  93C20000   LBU V0, 0(S8)
257:                 }
9D012D3C  03C0E821   ADDU SP, S8, ZERO
9D012D40  8FBE000C   LW S8, 12(SP)
9D012D44  27BD0010   ADDIU SP, SP, 16
9D012D48  03E00008   JR RA
9D012D4C  00000000   NOP
258:                 
259:                 // *****************************************************************************
260:                 // ************************** Static Functions *********************************
261:                 // *****************************************************************************
262:                 
263:                 void UARTBufRx( void )
264:                 {
9D012D50  27BDFFE0   ADDIU SP, SP, -32
9D012D54  AFBF001C   SW RA, 28(SP)
9D012D58  AFBE0018   SW S8, 24(SP)
9D012D5C  03A0F021   ADDU S8, SP, ZERO
265:                     UART_RX_BUF_S* rx_buf_elem;
266:                     uint8_t        read_cnt;
267:                 
268:                     static uint16_t tmp1;
269:                     static uint16_t tmp2;
270:                     
271:                 //        // Perform intermediate access of current receiver buffer element used 
272:                 //    // for storing data to increase processing speed and reduce line length.
273:                 //    rx_buf_elem = &uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ];
274:                 //    
275:                 //    // Receive available data.
276:                 //    read_cnt = UARTRead( &rx_buf_elem->data[ rx_buf_elem->data_len ],
277:                 //                         ( UART_RX_BUF_DATA_LEN - rx_buf_elem->data_len ) );
278:                 //    
279:                 //        // Manage buffer control variables.
280:                 //    rx_buf_elem->data_len += read_cnt;
281:                     
282:                 
283:                     
284:                     // Receive available data.
285:                     read_cnt = UARTRead( &uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ].data[ uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ].data_len ],
9D012D60  3C02A001   LUI V0, -24575
9D012D64  24428878   ADDIU V0, V0, -30600
9D012D68  90420028   LBU V0, 40(V0)
9D012D6C  00021040   SLL V0, V0, 1
9D012D70  00021880   SLL V1, V0, 2
9D012D74  00431021   ADDU V0, V0, V1
9D012D78  3C03A001   LUI V1, -24575
9D012D7C  24638878   ADDIU V1, V1, -30600
9D012D80  00431821   ADDU V1, V0, V1
9D012D84  3C02A001   LUI V0, -24575
9D012D88  24428878   ADDIU V0, V0, -30600
9D012D8C  90420028   LBU V0, 40(V0)
9D012D90  3C04A001   LUI A0, -24575
9D012D94  00021040   SLL V0, V0, 1
9D012D98  00022880   SLL A1, V0, 2
9D012D9C  00451021   ADDU V0, V0, A1
9D012DA0  24848878   ADDIU A0, A0, -30600
9D012DA4  00441021   ADDU V0, V0, A0
9D012DA8  94420008   LHU V0, 8(V0)
9D012DAC  00621821   ADDU V1, V1, V0
9D012DD8  24040008   ADDIU A0, ZERO, 8
9D012DDC  00821023   SUBU V0, A0, V0
9D012DE0  3042FFFF   ANDI V0, V0, -1
9D012DE4  00602021   ADDU A0, V1, ZERO
9D012DE8  0F404BC8   JAL UARTRead
9D012DEC  00402821   ADDU A1, V0, ZERO
9D012DF0  A3C20010   SB V0, 16(S8)
286:                                          ( UART_RX_BUF_DATA_LEN - uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ].data_len ) );
9D012DB0  3C02A001   LUI V0, -24575
9D012DB4  24428878   ADDIU V0, V0, -30600
9D012DB8  90420028   LBU V0, 40(V0)
9D012DBC  3C04A001   LUI A0, -24575
9D012DC0  00021040   SLL V0, V0, 1
9D012DC4  00022880   SLL A1, V0, 2
9D012DC8  00451021   ADDU V0, V0, A1
9D012DCC  24848878   ADDIU A0, A0, -30600
9D012DD0  00441021   ADDU V0, V0, A0
9D012DD4  94420008   LHU V0, 8(V0)
287:                 
288:                     tmp1 = uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ].data_len;
9D012DF4  3C02A001   LUI V0, -24575
9D012DF8  24428878   ADDIU V0, V0, -30600
9D012DFC  90420028   LBU V0, 40(V0)
9D012E00  3C03A001   LUI V1, -24575
9D012E04  00021040   SLL V0, V0, 1
9D012E08  00022080   SLL A0, V0, 2
9D012E0C  00441021   ADDU V0, V0, A0
9D012E10  24638878   ADDIU V1, V1, -30600
9D012E14  00431021   ADDU V0, V0, V1
9D012E18  94420008   LHU V0, 8(V0)
9D012E1C  A7828110   SH V0, -32496(GP)
289:                     
290:                     // Manage buffer control variables.
291:                     uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ].data_len += read_cnt;
9D012E20  3C02A001   LUI V0, -24575
9D012E24  24428878   ADDIU V0, V0, -30600
9D012E28  90420028   LBU V0, 40(V0)
9D012E2C  00402821   ADDU A1, V0, ZERO
9D012E30  3C02A001   LUI V0, -24575
9D012E34  24428878   ADDIU V0, V0, -30600
9D012E38  90420028   LBU V0, 40(V0)
9D012E3C  3C03A001   LUI V1, -24575
9D012E40  00021040   SLL V0, V0, 1
9D012E44  00022080   SLL A0, V0, 2
9D012E48  00441021   ADDU V0, V0, A0
9D012E4C  24638878   ADDIU V1, V1, -30600
9D012E50  00431021   ADDU V0, V0, V1
9D012E54  94430008   LHU V1, 8(V0)
9D012E58  93C20010   LBU V0, 16(S8)
9D012E5C  3042FFFF   ANDI V0, V0, -1
9D012E60  00621021   ADDU V0, V1, V0
9D012E64  3043FFFF   ANDI V1, V0, -1
9D012E68  3C04A001   LUI A0, -24575
9D012E6C  00A01021   ADDU V0, A1, ZERO
9D012E70  00021040   SLL V0, V0, 1
9D012E74  00022880   SLL A1, V0, 2
9D012E78  00451021   ADDU V0, V0, A1
9D012E7C  24848878   ADDIU A0, A0, -30600
9D012E80  00441021   ADDU V0, V0, A0
9D012E84  A4430008   SH V1, 8(V0)
292:                     
293:                     tmp2 = uart_rx_cb.buf_arr[ uart_rx_cb.buf_idx ].data_len;
9D012E88  3C02A001   LUI V0, -24575
9D012E8C  24428878   ADDIU V0, V0, -30600
9D012E90  90420028   LBU V0, 40(V0)
9D012E94  3C03A001   LUI V1, -24575
9D012E98  00021040   SLL V0, V0, 1
9D012E9C  00022080   SLL A0, V0, 2
9D012EA0  00441021   ADDU V0, V0, A0
9D012EA4  24638878   ADDIU V1, V1, -30600
9D012EA8  00431021   ADDU V0, V0, V1
9D012EAC  94420008   LHU V0, 8(V0)
9D012EB0  A7828112   SH V0, -32494(GP)
294:                     
295:                     Nop();
9D012EB4  00000040   SSNOP
296:                     
297:                     uart_rx_cb.buf_arr[ 0 ].data_len = 0xAA;
9D012EB8  3C02A001   LUI V0, -24575
9D012EBC  24428878   ADDIU V0, V0, -30600
9D012EC0  240300AA   ADDIU V1, ZERO, 170
9D012EC4  A4430008   SH V1, 8(V0)
298:                     uart_rx_cb.buf_arr[ 1 ].data_len = 0xBB;
9D012EC8  3C02A001   LUI V0, -24575
9D012ECC  24428878   ADDIU V0, V0, -30600
9D012ED0  240300BB   ADDIU V1, ZERO, 187
9D012ED4  A4430012   SH V1, 18(V0)
299:                     uart_rx_cb.buf_arr[ 2 ].data_len = 0xCC;
9D012ED8  3C02A001   LUI V0, -24575
9D012EDC  24428878   ADDIU V0, V0, -30600
9D012EE0  240300CC   ADDIU V1, ZERO, 204
9D012EE4  A443001C   SH V1, 28(V0)
300:                     uart_rx_cb.buf_arr[ 3 ].data_len = 0xDD;
9D012EE8  3C02A001   LUI V0, -24575
9D012EEC  24428878   ADDIU V0, V0, -30600
9D012EF0  240300DD   ADDIU V1, ZERO, 221
9D012EF4  A4430026   SH V1, 38(V0)
301:                     
302:                     Nop();
9D012EF8  00000040   SSNOP
303:                     
304:                     // Clear the interrupt flag.
305:                     //
306:                     // Note: this must be performed after the condition which caused the 
307:                     // interrupt (i.e. received data) is addressed.
308:                     //
309:                     IFS0bits.U1RXIF = 0;
9D012EFC  3C03BF88   LUI V1, -16504
9D012F00  8C621030   LW V0, 4144(V1)
9D012F04  7C02DEC4   INS V0, ZERO, 27, 1
9D012F08  AC621030   SW V0, 4144(V1)
310:                 }
9D012F0C  03C0E821   ADDU SP, S8, ZERO
9D012F10  8FBF001C   LW RA, 28(SP)
9D012F14  8FBE0018   LW S8, 24(SP)
9D012F18  03E00008   JR RA
9D012F1C  27BD0020   ADDIU SP, SP, 32
311:                 
312:                 // Read data from hardware buffer into supplied buffer. 
313:                 //
314:                 // Note: It's assumed that higher-level integrity checks are included within
315:                 // the serial data (e.g. checksum, CRC, etc.) for verifying content.  Low-level
316:                 // communication failures (e.g. parity-bit failure) are internally recorded
317:                 // to provide visibility during development.
318:                 //
319:                 // uint8_t* data_p - pointer to buffer for storing received data.
320:                 //
321:                 // uint8_t data_len - number of bytes available in data_p for storing received
322:                 // data
323:                 //
324:                 // Note: the function will stored data within data_p until data_p is full.
325:                 // When data_p is full, receiver hardware must still be read to service hardware
326:                 // operation.  Read hardware data when data_p is full is lost.
327:                 //
328:                 uint8_t UARTRead( uint8_t* data_p, uint16_t data_len )
329:                 {
9D012F20  27BDFFF0   ADDIU SP, SP, -16
9D012F24  AFBE000C   SW S8, 12(SP)
9D012F28  03A0F021   ADDU S8, SP, ZERO
9D012F2C  AFC40010   SW A0, 16(S8)
9D012F30  00A01021   ADDU V0, A1, ZERO
9D012F34  A7C20014   SH V0, 20(S8)
330:                     uint8_t data_cnt = 0;
9D012F38  A3C00000   SB ZERO, 0(S8)
331:                     uint8_t rx_byte;
332:                     
333:                     // Hardware buffer overflow has occurred ?
334:                     if( U1STAbits.OERR == 1 )
9D012F3C  3C02BF80   LUI V0, -16512
9D012F40  8C426010   LW V0, 24592(V0)
9D012F44  30420002   ANDI V0, V0, 2
9D012F48  1040002D   BEQ V0, ZERO, 0x9D013000
9D012F4C  00000000   NOP
335:                     {
336:                         // Latch identification of overflow error.
337:                         uart_oerr_latch = true;
9D012F50  24020001   ADDIU V0, ZERO, 1
9D012F54  A382810C   SB V0, -32500(GP)
338:                         
339:                         // Clear the hardware overflow hardware flag.
340:                         //
341:                         // Note: The overflow flag needs to be cleared because all UART
342:                         // reception is inhibited while this hardware flag is set.
343:                         //
344:                         U1STAbits.OERR = 0;
9D012F58  3C03BF80   LUI V1, -16512
9D012F5C  8C626010   LW V0, 24592(V1)
9D012F60  7C020844   INS V0, ZERO, 1, 1
9D012F64  AC626010   SW V0, 24592(V1)
345:                     }
346:                     
347:                     // Read data from the hardware buffer until it is empty.
348:                     while( U1STAbits.URXDA == 1 )
9D012F68  0B404C01   J 0x9D013004
9D012F6C  00000000   NOP
9D013000  00000000   NOP
9D013004  3C02BF80   LUI V0, -16512
9D013008  8C426010   LW V0, 24592(V0)
9D01300C  30420001   ANDI V0, V0, 1
9D013010  1440FFD7   BNE V0, ZERO, 0x9D012F70
9D013014  00000000   NOP
349:                     {
350:                         // Parity or framing error with received byte ?
351:                         if( ( U1STAbits.PERR == 1 ) ||
9D012F70  3C02BF80   LUI V0, -16512
9D012F74  8C426010   LW V0, 24592(V0)
9D012F78  30420008   ANDI V0, V0, 8
9D012F7C  14400006   BNE V0, ZERO, 0x9D012F98
9D012F80  00000000   NOP
9D012F90  10400005   BEQ V0, ZERO, 0x9D012FA8
9D012F94  00000000   NOP
352:                             ( U1STAbits.FERR == 1 ) )
9D012F84  3C02BF80   LUI V0, -16512
9D012F88  8C426010   LW V0, 24592(V0)
9D012F8C  30420004   ANDI V0, V0, 4
353:                         {
354:                             uart_err_cnt++;
9D012F98  9782810E   LHU V0, -32498(GP)
9D012F9C  24420001   ADDIU V0, V0, 1
9D012FA0  3042FFFF   ANDI V0, V0, -1
9D012FA4  A782810E   SH V0, -32498(GP)
355:                         }
356:                         
357:                         // Read byte from hardware buffer.
358:                         rx_byte = (uint8_t) U1RXREG;
9D012FA8  3C02BF80   LUI V0, -16512
9D012FAC  8C426030   LW V0, 24624(V0)
9D012FB0  A3C20001   SB V0, 1(S8)
359:                         
360:                         // Supplied buffer is valid and not full ?
361:                         //
362:                         // Note: byte is still read from hardware but not saved if supplied
363:                         // buffer is invalid so that hardware buffer is still emptied and newer
364:                         // data can be received (i.e hardware buffer will not overflow).
365:                         //
366:                         if( ( data_p   != NULL ) &&
9D012FB4  8FC20010   LW V0, 16(S8)
9D012FB8  10400012   BEQ V0, ZERO, 0x9D013004
9D012FBC  00000000   NOP
9D012FC0  97C20014   LHU V0, 20(S8)
9D012FC4  1040000F   BEQ V0, ZERO, 0x9D013004
9D012FC8  00000000   NOP
367:                             ( data_len != 0    ) )
368:                         {
369:                             // Store data into supplied buffer.
370:                             data_p[ data_cnt ] = rx_byte;
9D012FCC  93C20000   LBU V0, 0(S8)
9D012FD0  8FC30010   LW V1, 16(S8)
9D012FD4  00621021   ADDU V0, V1, V0
9D012FD8  93C30001   LBU V1, 1(S8)
9D012FDC  A0430000   SB V1, 0(V0)
371:                             data_cnt++;
9D012FE0  93C20000   LBU V0, 0(S8)
9D012FE4  24420001   ADDIU V0, V0, 1
9D012FE8  A3C20000   SB V0, 0(S8)
372:                             data_len--;
9D012FEC  97C20014   LHU V0, 20(S8)
9D012FF0  2442FFFF   ADDIU V0, V0, -1
9D012FF4  A7C20014   SH V0, 20(S8)
9D012FF8  0B404C01   J 0x9D013004
9D012FFC  00000000   NOP
373:                         }
374:                     }
375:                     
376:                     return data_cnt;
9D013018  93C20000   LBU V0, 0(S8)
377:                 }
9D01301C  03C0E821   ADDU SP, S8, ZERO
9D013020  8FBE000C   LW S8, 12(SP)
9D013024  27BD0010   ADDIU SP, SP, 16
9D013028  03E00008   JR RA
9D01302C  00000000   NOP
378:                 
379:                 // Write next chunk of data to be transmitted.
380:                 void UARTBufTX( void )
381:                 {
9D013030  27BDFFE0   ADDIU SP, SP, -32
9D013034  AFBF001C   SW RA, 28(SP)
9D013038  AFBE0018   SW S8, 24(SP)
9D01303C  03A0F021   ADDU S8, SP, ZERO
382:                     UART_TX_BUF_S* tx_buf_elem;
383:                     uint8_t        write_cnt;
384:                     
385:                     // FIFO contains data ?
386:                     if( uart_tx_fifo.head_idx != uart_tx_fifo.tail_idx )
9D013040  3C02A001   LUI V0, -24575
9D013044  244288A4   ADDIU V0, V0, -30556
9D013048  90430010   LBU V1, 16(V0)
9D01304C  3C02A001   LUI V0, -24575
9D013050  244288A4   ADDIU V0, V0, -30556
9D013054  90420011   LBU V0, 17(V0)
9D013058  10620033   BEQ V1, V0, 0x9D013128
9D01305C  00000000   NOP
387:                     {
388:                         // Perform intermediate access of current transmitter buffer element 
389:                         // used  for writing data to increase processing speed and reduce line
390:                         // length.
391:                         tx_buf_elem = uart_tx_fifo.buf_arr[ uart_tx_fifo.head_idx ];
9D013060  3C02A001   LUI V0, -24575
9D013064  244288A4   ADDIU V0, V0, -30556
9D013068  90420010   LBU V0, 16(V0)
9D01306C  00401821   ADDU V1, V0, ZERO
9D013070  3C02A001   LUI V0, -24575
9D013074  00031880   SLL V1, V1, 2
9D013078  244288A4   ADDIU V0, V0, -30556
9D01307C  00621021   ADDU V0, V1, V0
9D013080  8C420000   LW V0, 0(V0)
9D013084  AFC20010   SW V0, 16(S8)
392:                         
393:                         // Transmit available data.
394:                         write_cnt = UARTWrite( tx_buf_elem->data_p,
9D013088  8FC20010   LW V0, 16(S8)
9D01308C  8C430000   LW V1, 0(V0)
9D013098  00602021   ADDU A0, V1, ZERO
9D01309C  00402821   ADDU A1, V0, ZERO
9D0130A0  0F404C60   JAL UARTWrite
9D0130A4  00000000   NOP
9D0130A8  A3C20014   SB V0, 20(S8)
395:                                                tx_buf_elem->data_len );
9D013090  8FC20010   LW V0, 16(S8)
9D013094  94420004   LHU V0, 4(V0)
396:                         
397:                         // Manage buffer control variables.
398:                         tx_buf_elem->data_p   += write_cnt;
9D0130AC  8FC20010   LW V0, 16(S8)
9D0130B0  8C430000   LW V1, 0(V0)
9D0130B4  93C20014   LBU V0, 20(S8)
9D0130B8  00621821   ADDU V1, V1, V0
9D0130BC  8FC20010   LW V0, 16(S8)
9D0130C0  AC430000   SW V1, 0(V0)
399:                         tx_buf_elem->data_len -= write_cnt;
9D0130C4  8FC20010   LW V0, 16(S8)
9D0130C8  94430004   LHU V1, 4(V0)
9D0130CC  93C20014   LBU V0, 20(S8)
9D0130D0  3042FFFF   ANDI V0, V0, -1
9D0130D4  00621023   SUBU V0, V1, V0
9D0130D8  3043FFFF   ANDI V1, V0, -1
9D0130DC  8FC20010   LW V0, 16(S8)
9D0130E0  A4430004   SH V1, 4(V0)
400:                         
401:                         // All buffer data has been transmitted ?
402:                         if( tx_buf_elem->data_len == 0 )
9D0130E4  8FC20010   LW V0, 16(S8)
9D0130E8  94420004   LHU V0, 4(V0)
9D0130EC  1440000E   BNE V0, ZERO, 0x9D013128
9D0130F0  00000000   NOP
403:                         {
404:                             // Identify buffer transmission as complete.
405:                             tx_buf_elem->tx_done = true;
9D0130F4  8FC20010   LW V0, 16(S8)
9D0130F8  24030001   ADDIU V1, ZERO, 1
9D0130FC  A0430006   SB V1, 6(V0)
406:                             
407:                             // Move FIFO head to next index.
408:                             //
409:                             // Note: Head index update is performed last in buffer management
410:                             // operation to eliminate race conditions. (i.e. variable serves
411:                             // as semaphore for multi-threaded buffer).
412:                             //
413:                             // Note: Head index only modified by this function and update
414:                             // is atomic.
415:                             //
416:                             uart_tx_fifo.head_idx = mUART_TX_FIFO_NEXT_IDX( uart_tx_fifo.head_idx );
9D013100  3C02A001   LUI V0, -24575
9D013104  244288A4   ADDIU V0, V0, -30556
9D013108  90420010   LBU V0, 16(V0)
9D01310C  24420001   ADDIU V0, V0, 1
9D013110  304200FF   ANDI V0, V0, 255
9D013114  30420003   ANDI V0, V0, 3
9D013118  304300FF   ANDI V1, V0, 255
9D01311C  3C02A001   LUI V0, -24575
9D013120  244288A4   ADDIU V0, V0, -30556
9D013124  A0430010   SB V1, 16(V0)
417:                         }
418:                     }
419:                     
420:                     // FIFO is empty ?
421:                     if( uart_tx_fifo.head_idx == uart_tx_fifo.tail_idx )
9D013128  3C02A001   LUI V0, -24575
9D01312C  244288A4   ADDIU V0, V0, -30556
9D013130  90430010   LBU V1, 16(V0)
9D013134  3C02A001   LUI V0, -24575
9D013138  244288A4   ADDIU V0, V0, -30556
9D01313C  90420011   LBU V0, 17(V0)
9D013140  14620005   BNE V1, V0, 0x9D013158
9D013144  00000000   NOP
422:                     {
423:                         // Disable transmitter interrupt since no additional data to send.
424:                         IEC0bits.U1TXIE = 0;
9D013148  3C03BF88   LUI V1, -16504
9D01314C  8C621060   LW V0, 4192(V1)
9D013150  7C02E704   INS V0, ZERO, 28, 1
9D013154  AC621060   SW V0, 4192(V1)
425:                     }
426:                     
427:                     // Clear the interrupt flag.
428:                     //
429:                     // Note: this must be performed after the condition which caused the 
430:                     // interrupt (i.e. transmitter empty) is addressed.
431:                     //
432:                     IFS0bits.U1TXIF = 0;
9D013158  3C03BF88   LUI V1, -16504
9D01315C  8C621030   LW V0, 4144(V1)
9D013160  7C02E704   INS V0, ZERO, 28, 1
9D013164  AC621030   SW V0, 4144(V1)
433:                 }
9D013168  03C0E821   ADDU SP, S8, ZERO
9D01316C  8FBF001C   LW RA, 28(SP)
9D013170  8FBE0018   LW S8, 24(SP)
9D013174  27BD0020   ADDIU SP, SP, 32
9D013178  03E00008   JR RA
9D01317C  00000000   NOP
434:                 
435:                 // Write supplied data to the hardware transmit buffer.
436:                 uint8_t UARTWrite( const uint8_t* data_p, uint16_t data_len )
437:                 {
9D013180  27BDFFF0   ADDIU SP, SP, -16
9D013184  AFBE000C   SW S8, 12(SP)
9D013188  03A0F021   ADDU S8, SP, ZERO
9D01318C  AFC40010   SW A0, 16(S8)
9D013190  00A01021   ADDU V0, A1, ZERO
9D013194  A7C20014   SH V0, 20(S8)
438:                     uint8_t data_cnt = 0;
9D013198  A3C00000   SB ZERO, 0(S8)
439:                     
440:                     // Load the hardware buffer while it is not full and there is additional
441:                     // data to send
442:                     while( ( U1STAbits.UTXBF == 0 ) &&
9D01319C  0B404C76   J 0x9D0131D8
9D0131A0  00000000   NOP
9D0131D8  3C02BF80   LUI V0, -16512
9D0131DC  8C426010   LW V0, 24592(V0)
9D0131E0  30420200   ANDI V0, V0, 512
9D0131E4  14400004   BNE V0, ZERO, 0x9D0131F8
9D0131E8  00000000   NOP
9D0131EC  97C20014   LHU V0, 20(S8)
9D0131F0  1440FFEC   BNE V0, ZERO, 0x9D0131A4
9D0131F4  00000000   NOP
443:                            ( data_len        != 0 ) )
444:                     {
445:                         // Store a byte to the hardware buffer.
446:                         U1TXREG = data_p[ data_cnt ];
9D0131A4  93C20000   LBU V0, 0(S8)
9D0131A8  8FC30010   LW V1, 16(S8)
9D0131AC  00621021   ADDU V0, V1, V0
9D0131B0  90420000   LBU V0, 0(V0)
9D0131B4  00401821   ADDU V1, V0, ZERO
9D0131B8  3C02BF80   LUI V0, -16512
9D0131BC  AC436020   SW V1, 24608(V0)
447:                         
448:                         // Update control values.
449:                         data_cnt++;
9D0131C0  93C20000   LBU V0, 0(S8)
9D0131C4  24420001   ADDIU V0, V0, 1
9D0131C8  A3C20000   SB V0, 0(S8)
450:                         data_len--;
9D0131CC  97C20014   LHU V0, 20(S8)
9D0131D0  2442FFFF   ADDIU V0, V0, -1
9D0131D4  A7C20014   SH V0, 20(S8)
451:                     }
452:                     
453:                     return data_cnt;
9D0131F8  93C20000   LBU V0, 0(S8)
454:                 }
9D0131FC  03C0E821   ADDU SP, S8, ZERO
9D013200  8FBE000C   LW S8, 12(SP)
9D013204  27BD0010   ADDIU SP, SP, 16
9D013208  03E00008   JR RA
9D01320C  00000000   NOP
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/udp.c  ----------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       udp.c
7:                   
8:                     Summary:
9:                       Module for Microchip TCP/IP Stack
10:                      -Provides unreliable, minimum latency transport of application
11:                       datagram (packet) oriented data
12:                      -Reference: RFC 768
13:                  
14:                    Description:
15:                      User Datagram Protocol (UDP) Communications Layer
16:                  
17:                   *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #define __UDP_C_
45:                  
46:                  #include "tcpip/tcpip.h"
47:                  
48:                  #if defined(STACK_USE_UDP)
49:                  
50:                  /****************************************************************************
51:                    Section:
52:                      Configuration Parameters
53:                    ***************************************************************************/
54:                  
55:                  // First port number for randomized local port number selection
56:                  #define LOCAL_UDP_PORT_START_NUMBER (4096u)
57:                  
58:                  // Last port number for randomized local port number selection
59:                  #define LOCAL_UDP_PORT_END_NUMBER   (8192u)
60:                  
61:                  /****************************************************************************
62:                    Section:
63:                      UDP Global Variables
64:                    ***************************************************************************/
65:                  
66:                  // Stores an array of information pertaining to each UDP socket
67:                  UDP_SOCKET_INFO     UDPSocketInfo[MAX_UDP_SOCKETS];
68:                  
69:                  // Indicates which UDP socket is currently active
70:                  UDP_SOCKET          activeUDPSocket;
71:                  
72:                  uint16_t UDPTxCount;    // Number of bytes written to this UDP segment
73:                  uint16_t UDPRxCount;    // Number of bytes read from this UDP segment
74:                  static UDP_SOCKET   LastPutSocket = INVALID_UDP_SOCKET; // Indicates the last socket to which data was written
75:                  static uint16_t wPutOffset;     // Offset from beginning of payload where data is to be written.
76:                  static uint16_t wGetOffset;     // Offset from beginning of payload from where data is to be read.
77:                  
78:                  // Stores various flags for the UDP module
79:                  static struct
80:                  {
81:                      unsigned char bFirstRead : 1;       // No data has been read from this segment yet
82:                      unsigned char bWasDiscarded : 1;    // The data in this segment has been discarded
83:                  } Flags;
84:                  
85:                  // Indicates which socket has currently received data for this loop
86:                  static UDP_SOCKET SocketWithRxData = INVALID_UDP_SOCKET;
87:                  
88:                  /****************************************************************************
89:                    Section:
90:                      Function Prototypes
91:                    ***************************************************************************/
92:                  
93:                  static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, NODE_INFO *remoteNode,
94:                                                      IP_ADDR *localIP);
95:                  
96:                  /****************************************************************************
97:                    Section:
98:                      Connection Management Functions
99:                    ***************************************************************************/
100:                 
101:                 /*****************************************************************************
102:                   Function:
103:                     void UDPInit(void)
104:                 
105:                   Summary:
106:                     Initializes the UDP module.
107:                 
108:                   Description:
109:                     Initializes the UDP module. This function initializes all the UDP
110:                     sockets to the closed state.
111:                 
112:                   Precondition:
113:                     None
114:                 
115:                   Parameters:
116:                     None
117:                 
118:                   Returns:
119:                     None
120:                 
121:                   Remarks:
122:                     This function is called only once during lifetime of the application.
123:                   ***************************************************************************/
124:                 void UDPInit(void)
125:                 {
9D00E150  27BDFFE0   ADDIU SP, SP, -32
9D00E154  AFBF001C   SW RA, 28(SP)
9D00E158  AFBE0018   SW S8, 24(SP)
9D00E15C  03A0F021   ADDU S8, SP, ZERO
126:                     UDP_SOCKET s;
127:                 
128:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9D00E160  A3C00010   SB ZERO, 16(S8)
9D00E164  0B403862   J 0x9D00E188
9D00E168  00000000   NOP
9D00E17C  93C20010   LBU V0, 16(S8)
9D00E180  24420001   ADDIU V0, V0, 1
9D00E184  A3C20010   SB V0, 16(S8)
9D00E188  93C20010   LBU V0, 16(S8)
9D00E18C  2C42000A   SLTIU V0, V0, 10
9D00E190  1440FFF6   BNE V0, ZERO, 0x9D00E16C
9D00E194  00000000   NOP
129:                     {
130:                         UDPClose(s);
9D00E16C  93C20010   LBU V0, 16(S8)
9D00E170  00402021   ADDU A0, V0, ZERO
9D00E174  0F4039D9   JAL UDPClose
9D00E178  00000000   NOP
131:                     }
132:                     Flags.bWasDiscarded = 1;
9D00E198  93828054   LBU V0, -32684(GP)
9D00E19C  24030001   ADDIU V1, ZERO, 1
9D00E1A0  7C620844   INS V0, V1, 1, 1
9D00E1A4  A3828054   SB V0, -32684(GP)
133:                 }
9D00E1A8  03C0E821   ADDU SP, S8, ZERO
9D00E1AC  8FBF001C   LW RA, 28(SP)
9D00E1B0  8FBE0018   LW S8, 24(SP)
9D00E1B4  27BD0020   ADDIU SP, SP, 32
9D00E1B8  03E00008   JR RA
9D00E1BC  00000000   NOP
134:                 
135:                 /*****************************************************************************
136:                 Function:
137:                     UDP_SOCKET UDPOpenEx(uint32_t remoteHost, uint8_t remoteHostType, UDP_PORT localPort,
138:                     UDP_PORT remotePort)
139:                 
140:                  Summary:
141:                     Opens a UDP socket for a client.
142:                 
143:                  Description:
144:                     Provides a unified method for opening UDP sockets. This function can open both client and
145:                     server   sockets. For client sockets, it can accept a host name string to query in DNS, an IP
146:                     address as a string, an IP address in binary form, or a previously resolved NODE_INFO
147:                     structure containing the remote IP address and associated MAC address. When a host name
148:                     or IP address only is provided, UDP module will internally perform the necessary DNSResolve
149:                     and/or ARP resolution steps before reporting that the UDP socket is connected (via a call to
150:                     UDPISOpen returning true). Server sockets ignore this destination parameter and listen
151:                     only on the indicated port. Sockets are statically allocated on boot, but can be claimed with
152:                     this function and freed using UDPClose.
153:                 
154:                 Conditions:
155:                 UDPInit should be called.
156:                 
157:                 Input:
158:                     remoteHost - Pointer to remote node info (MAC and IP address) for this connection.
159:                     If this is a server socket (receives the first packet) or the destination is the broadcast
160:                     address, then this parameter should be NULL. For client sockets only. Provide a pointer to
161:                     a null-terminated string of the remote host name (ex\:"www.microchip.com" or
162:                     "192.168.1.123"), a literal destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR data type),
163:                     or a pointer to a NODE_INFO structure with the remote IP address and remote node or gateway
164:                     MAC address specified, If a string is provided.
165:                 
166:                     remoteHostType - Any one of the following flags to identify the meaning of the remoteHost parameter:
167:                         - UDP_OPEN_SERVER   = Open a server socket and ignore the remoteHost parameter.
168:                             (e.g. - DHCP server, Announce)
169:                         - UDP_OPEN_IP_ADDRESS = Open a client socket and connect it to a remote IP address.
170:                             Ex: 0x7B01A8C0 for 192.168.1.123 (uint32_t type). Note that the byte ordering is big endian.
171:                         - UDP_OPEN_NODE_INFO = Open a client socket and connect it to a remote IP and MAC
172:                             addresses pair stored in a NODE_INFO structure.
173:                         - UDP_OPEN_RAM_HOST = Open a client socket and connect it to a remote host who's
174:                             name is stored as a null terminated string in a RAM array. Ex:"www.microchip.com" or
175:                             "192.168.0.123"
176:                         - UDP_OPEN_ROM_HOST = Open a client socket and connect it to a remote host who's
177:                             name is stored as a null terminated string in a literal string or ROM array. Ex:
178:                             "www.microchip.com" or "192.168.0.123"
179:                 
180:                     localPort - UDP port number to listen on.  If 0, stack will dynamically assign a unique port
181:                     number to use.
182:                 
183:                     remotePort - For client sockets, the remote port number.
184:                 
185:                 Return Values:
186:                     Success -
187:                         A UDP socket handle that can be used for subsequent UDP API calls.
188:                     Failure -
189:                         INVALID_UDP_SOCKET.  This function fails when no more UDP socket
190:                         handles are available.  Increase MAX_UDP_SOCKETS to make more sockets   available.
191:                 Remarks:
192:                     When finished using the UDP socket handle, call the UDPClose() function to free the
193:                     socket and delete the handle.
194:                 
195:                 *****************************************************************************/
196:                 UDP_SOCKET UDPOpenEx(uint32_t remoteHost, uint8_t remoteHostType, UDP_PORT localPort,
197:                         UDP_PORT remotePort)
198:                 {
9D00E1C0  27BDFFE0   ADDIU SP, SP, -32
9D00E1C4  AFBF001C   SW RA, 28(SP)
9D00E1C8  AFBE0018   SW S8, 24(SP)
9D00E1CC  03A0F021   ADDU S8, SP, ZERO
9D00E1D0  AFC40020   SW A0, 32(S8)
9D00E1D4  00A02021   ADDU A0, A1, ZERO
9D00E1D8  00C01821   ADDU V1, A2, ZERO
9D00E1DC  00E01021   ADDU V0, A3, ZERO
9D00E1E0  A3C40024   SB A0, 36(S8)
9D00E1E4  A7C30028   SH V1, 40(S8)
9D00E1E8  A7C2002C   SH V0, 44(S8)
199:                     UDP_SOCKET s;
200:                     UDP_SOCKET_INFO *p;
201:                 
202:                     // Local temp port numbers.
203:                     static uint16_t NextPort __attribute__((persistent));
204:                 
205:                 
206:                     p = UDPSocketInfo;
9D00E1EC  3C02A000   LUI V0, -24576
9D00E1F0  24420388   ADDIU V0, V0, 904
9D00E1F4  AFC20014   SW V0, 20(S8)
207:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
9D00E1F8  A3C00010   SB ZERO, 16(S8)
9D00E1FC  0B4038E0   J 0x9D00E380
9D00E200  00000000   NOP
9D00E374  93C20010   LBU V0, 16(S8)
9D00E378  24420001   ADDIU V0, V0, 1
9D00E37C  A3C20010   SB V0, 16(S8)
9D00E380  93C20010   LBU V0, 16(S8)
9D00E384  2C42000A   SLTIU V0, V0, 10
9D00E388  1440FF9E   BNE V0, ZERO, 0x9D00E204
9D00E38C  00000000   NOP
208:                     {
209:                         if(p->localPort == INVALID_UDP_PORT)
9D00E204  8FC20014   LW V0, 20(S8)
9D00E208  9442000E   LHU V0, 14(V0)
9D00E20C  14400056   BNE V0, ZERO, 0x9D00E368
9D00E210  00000000   NOP
210:                         {
211:                             p->localPort = localPort;
9D00E214  8FC20014   LW V0, 20(S8)
9D00E218  97C30028   LHU V1, 40(S8)
9D00E21C  A443000E   SH V1, 14(V0)
212:                             if(localPort == 0x0000u)
9D00E220  97C20028   LHU V0, 40(S8)
9D00E224  14400016   BNE V0, ZERO, 0x9D00E280
9D00E228  00000000   NOP
213:                             {
214:                                if (NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
9D00E22C  3C02A001   LUI V0, -24575
9D00E230  94428952   LHU V0, -30382(V0)
9D00E234  2C422001   SLTIU V0, V0, 8193
9D00E238  10400006   BEQ V0, ZERO, 0x9D00E254
9D00E23C  00000000   NOP
9D00E240  3C02A001   LUI V0, -24575
9D00E244  94428952   LHU V0, -30382(V0)
9D00E248  2C421000   SLTIU V0, V0, 4096
9D00E24C  10400004   BEQ V0, ZERO, 0x9D00E260
9D00E250  00000000   NOP
215:                                    NextPort = LOCAL_UDP_PORT_START_NUMBER;
9D00E254  3C02A001   LUI V0, -24575
9D00E258  24031000   ADDIU V1, ZERO, 4096
9D00E25C  A4438952   SH V1, -30382(V0)
216:                 
217:                                p->localPort    = NextPort++;
9D00E260  3C02A001   LUI V0, -24575
9D00E264  94428952   LHU V0, -30382(V0)
9D00E268  8FC30014   LW V1, 20(S8)
9D00E26C  A462000E   SH V0, 14(V1)
9D00E270  24420001   ADDIU V0, V0, 1
9D00E274  3043FFFF   ANDI V1, V0, -1
9D00E278  3C02A001   LUI V0, -24575
9D00E27C  A4438952   SH V1, -30382(V0)
218:                             }
219:                             if((remoteHostType == UDP_OPEN_SERVER) || (remoteHost == 0))
9D00E280  93C20024   LBU V0, 36(S8)
9D00E284  10400004   BEQ V0, ZERO, 0x9D00E298
9D00E288  00000000   NOP
9D00E28C  8FC20020   LW V0, 32(S8)
9D00E290  1440000C   BNE V0, ZERO, 0x9D00E2C4
9D00E294  00000000   NOP
220:                             {
221:                                   //Set remote node as 0xFF ( broadcast address)
222:                                   // else Set broadcast address
223:                                   memset((void*)&p->remote.remoteNode, 0xFF, sizeof(p->remote));
9D00E298  8FC20014   LW V0, 20(S8)
9D00E29C  00402021   ADDU A0, V0, ZERO
9D00E2A0  240500FF   ADDIU A1, ZERO, 255
9D00E2A4  2406000C   ADDIU A2, ZERO, 12
9D00E2A8  0F406D3B   JAL 0x9D01B4EC
9D00E2AC  00000000   NOP
224:                                   p->smState = UDP_OPENED;
9D00E2B0  8FC20014   LW V0, 20(S8)
9D00E2B4  24030005   ADDIU V1, ZERO, 5
9D00E2B8  AC430010   SW V1, 16(V0)
9D00E2BC  0B4038D2   J 0x9D00E348
9D00E2C0  00000000   NOP
225:                             }
226:                             else
227:                             {
228:                                 switch(remoteHostType)
9D00E2C4  93C20024   LBU V0, 36(S8)
9D00E2C8  24030003   ADDIU V1, ZERO, 3
9D00E2CC  10430006   BEQ V0, V1, 0x9D00E2E8
9D00E2D0  00000000   NOP
9D00E2D4  24030004   ADDIU V1, ZERO, 4
9D00E2D8  10430010   BEQ V0, V1, 0x9D00E31C
9D00E2DC  00000000   NOP
229:                                 {
230:                 #if defined (STACK_CLIENT_MODE)
231:                 #if defined (STACK_USE_DNS)
232:                                     case UDP_OPEN_RAM_HOST:
233:                                     case UDP_OPEN_ROM_HOST:
234:                                         //set the UDP state to UDP_GET_DNS_MODULE
235:                                         p->remote.remoteHost = remoteHost;
236:                                         p->flags.bRemoteHostIsROM = (remoteHostType == UDP_OPEN_ROM_HOST);
237:                                         p->smState = UDP_DNS_RESOLVE;
238:                                     break;
239:                 #endif
240:                                     case UDP_OPEN_IP_ADDRESS:
241:                                     // remoteHost is a literal IP address.  This doesn't need DNS and can skip directly to the Gateway ARPing step.
242:                                     //Next UDP state UDP_GATEWAY_SEND_ARP;
243:                                     p->remote.remoteNode.IPAddr.Val = remoteHost;
9D00E2E8  8FC20014   LW V0, 20(S8)
9D00E2EC  8FC30020   LW V1, 32(S8)
9D00E2F0  AC430000   SW V1, 0(V0)
244:                                     p->retryCount = 0;
9D00E2F4  8FC20014   LW V0, 20(S8)
9D00E2F8  A0400018   SB ZERO, 24(V0)
245:                                     p->retryInterval = (TICK_SECOND/4)/256;
9D00E2FC  8FC20014   LW V0, 20(S8)
9D00E300  24030131   ADDIU V1, ZERO, 305
9D00E304  AC430014   SW V1, 20(V0)
246:                                     p->smState = UDP_GATEWAY_SEND_ARP;
9D00E308  8FC20014   LW V0, 20(S8)
9D00E30C  24030002   ADDIU V1, ZERO, 2
9D00E310  AC430010   SW V1, 16(V0)
247:                                     break;
9D00E314  0B4038D2   J 0x9D00E348
9D00E318  00000000   NOP
248:                 #endif
249:                                     case UDP_OPEN_NODE_INFO:
250:                                     //skip DNS and ARP resolution steps if connecting to a remote node which we've already
251:                                         memcpy((void*)(uint8_t*)&p->remote,(void*)(uint8_t*)(PTR_BASE)remoteHost,sizeof(p->remote));
9D00E31C  8FC30014   LW V1, 20(S8)
9D00E320  8FC20020   LW V0, 32(S8)
9D00E324  00602021   ADDU A0, V1, ZERO
9D00E328  00402821   ADDU A1, V0, ZERO
9D00E32C  2406000C   ADDIU A2, ZERO, 12
9D00E330  0F406788   JAL 0x9D019E20
9D00E334  00000000   NOP
252:                                         p->smState = UDP_OPENED;
9D00E338  8FC20014   LW V0, 20(S8)
9D00E33C  24030005   ADDIU V1, ZERO, 5
9D00E340  AC430010   SW V1, 16(V0)
253:                                     // CALL UDPFlushto transmit incluind peding data.
254:                                     break;
9D00E344  00000000   NOP
255:                                     default:
256:                                         break;
9D00E2E0  0B4038D2   J 0x9D00E348
9D00E2E4  00000000   NOP
257:                                 }
258:                             }
259:                             p->remotePort   = remotePort;
9D00E348  8FC20014   LW V0, 20(S8)
9D00E34C  97C3002C   LHU V1, 44(S8)
9D00E350  A443000C   SH V1, 12(V0)
260:                 
261:                             // Mark this socket as active.
262:                             // Once an active socket is set, subsequent operation can be
263:                             // done without explicitely supply socket identifier.
264:                             activeUDPSocket = s;
9D00E354  93C20010   LBU V0, 16(S8)
9D00E358  A3828158   SB V0, -32424(GP)
265:                             return s;
9D00E35C  93C20010   LBU V0, 16(S8)
9D00E360  0B4038E5   J 0x9D00E394
9D00E364  00000000   NOP
266:                         }
267:                         p++;
9D00E368  8FC20014   LW V0, 20(S8)
9D00E36C  2442001C   ADDIU V0, V0, 28
9D00E370  AFC20014   SW V0, 20(S8)
268:                     }
269:                 
270:                     return (UDP_SOCKET)INVALID_UDP_SOCKET;
9D00E390  240200FF   ADDIU V0, ZERO, 255
271:                 }
9D00E394  03C0E821   ADDU SP, S8, ZERO
9D00E398  8FBF001C   LW RA, 28(SP)
9D00E39C  8FBE0018   LW S8, 24(SP)
9D00E3A0  27BD0020   ADDIU SP, SP, 32
9D00E3A4  03E00008   JR RA
9D00E3A8  00000000   NOP
272:                 
273:                 
274:                 /******************************************************************************
275:                 Function:
276:                     void UDPTask(void)
277:                 
278:                   Summary:
279:                     Performs periodic UDP tasks.
280:                 
281:                   Description:
282:                     This function performs any required periodic UDP tasks.  Each socket's state machine is
283:                     checked, and any elapsed timeout periods are handled.
284:                 
285:                   Precondition:
286:                     UDP is initialized.
287:                 
288:                   Parameters:
289:                     None
290:                 
291:                   Returns:
292:                     None
293:                 
294:                 ******************************************************************************/
295:                 void UDPTask(void)
296:                 {
9D00E3AC  27BDFFD8   ADDIU SP, SP, -40
9D00E3B0  AFBF0024   SW RA, 36(SP)
9D00E3B4  AFBE0020   SW S8, 32(SP)
9D00E3B8  AFB0001C   SW S0, 28(SP)
9D00E3BC  03A0F021   ADDU S8, SP, ZERO
297:                     UDP_SOCKET ss;
298:                 
299:                     for ( ss = 0; ss < MAX_UDP_SOCKETS; ss++ )
9D00E3C0  A3C00010   SB ZERO, 16(S8)
9D00E3C4  0B4039B9   J 0x9D00E6E4
9D00E3C8  00000000   NOP
9D00E6D8  93C20010   LBU V0, 16(S8)
9D00E6DC  24420001   ADDIU V0, V0, 1
9D00E6E0  A3C20010   SB V0, 16(S8)
9D00E6E4  93C20010   LBU V0, 16(S8)
9D00E6E8  2C42000A   SLTIU V0, V0, 10
9D00E6EC  1440FF37   BNE V0, ZERO, 0x9D00E3CC
9D00E6F0  00000000   NOP
300:                     {
301:                 
302:                         // need to put Extra check if UDP has opened or NOT
303:                 
304:                         if ((UDPSocketInfo[ss].smState == UDP_OPENED) ||
9D00E3CC  93C20010   LBU V0, 16(S8)
9D00E3D0  3C04A000   LUI A0, -24576
9D00E3D4  00021080   SLL V0, V0, 2
9D00E3D8  000218C0   SLL V1, V0, 3
9D00E3DC  00621823   SUBU V1, V1, V0
9D00E3E0  24820388   ADDIU V0, A0, 904
9D00E3E4  00621021   ADDU V0, V1, V0
9D00E3E8  8C430010   LW V1, 16(V0)
9D00E3EC  24020005   ADDIU V0, ZERO, 5
9D00E3F0  106200B2   BEQ V1, V0, 0x9D00E6BC
9D00E3F4  00000000   NOP
9D00E418  24020004   ADDIU V0, ZERO, 4
9D00E41C  106200AA   BEQ V1, V0, 0x9D00E6C8
9D00E420  00000000   NOP
305:                             (UDPSocketInfo[ss].smState == UDP_CLOSED))
9D00E3F8  93C20010   LBU V0, 16(S8)
9D00E3FC  3C04A000   LUI A0, -24576
9D00E400  00021080   SLL V0, V0, 2
9D00E404  000218C0   SLL V1, V0, 3
9D00E408  00621823   SUBU V1, V1, V0
9D00E40C  24820388   ADDIU V0, A0, 904
9D00E410  00621021   ADDU V0, V1, V0
9D00E414  8C430010   LW V1, 16(V0)
306:                             continue;
9D00E6BC  00000000   NOP
9D00E6C0  0B4039B6   J 0x9D00E6D8
9D00E6C4  00000000   NOP
9D00E6C8  00000000   NOP
9D00E6CC  0B4039B6   J 0x9D00E6D8
9D00E6D0  00000000   NOP
307:                         // A timeout has occured.  Respond to this timeout condition
308:                         // depending on what state this socket is in.
309:                         switch(UDPSocketInfo[ss].smState)
9D00E424  93C20010   LBU V0, 16(S8)
9D00E428  3C04A000   LUI A0, -24576
9D00E42C  00021080   SLL V0, V0, 2
9D00E430  000218C0   SLL V1, V0, 3
9D00E434  00621823   SUBU V1, V1, V0
9D00E438  24820388   ADDIU V0, A0, 904
9D00E43C  00621021   ADDU V0, V1, V0
9D00E440  8C420010   LW V0, 16(V0)
9D00E444  24030002   ADDIU V1, ZERO, 2
9D00E448  10430006   BEQ V0, V1, 0x9D00E464
9D00E44C  00000000   NOP
9D00E450  24030003   ADDIU V1, ZERO, 3
9D00E454  10430024   BEQ V0, V1, 0x9D00E4E8
9D00E458  00000000   NOP
310:                         {
311:                             #if defined(STACK_CLIENT_MODE)
312:                             #if defined(STACK_USE_DNS)
313:                             case UDP_DNS_RESOLVE:
314:                             if(DNSBeginUsage())
315:                             {
316:                                 // call DNS Resolve function and move to UDP next State machine
317:                                 UDPSocketInfo[ss].smState = UDP_DNS_IS_RESOLVED;
318:                                 if(UDPSocketInfo[ss].flags.bRemoteHostIsROM)
319:                                     DNSResolveROM((ROM uint8_t*)(ROM_PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A);
320:                                 else
321:                                     DNSResolve((uint8_t*)(PTR_BASE)UDPSocketInfo[ss].remote.remoteHost, DNS_TYPE_A);
322:                             }
323:                             break;
324:                             case UDP_DNS_IS_RESOLVED:
325:                             {
326:                                 IP_ADDR ipResolvedDNSIP;
327:                                 // See if DNS resolution has finished.  Note that if the DNS
328:                                 // fails, the &ipResolvedDNSIP will be written with 0x00000000.
329:                                 // MyTCB.remote.dwRemoteHost is unioned with
330:                                 // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write
331:                                 // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We
332:                                 // must copy it over only if the DNS is resolution step was
333:                                 // successful.
334:                 
335:                                 if(DNSIsResolved(&ipResolvedDNSIP))
336:                                 {
337:                                     if(DNSEndUsage())
338:                                     {
339:                                         UDPSocketInfo[ss].remote.remoteNode.IPAddr.Val = ipResolvedDNSIP.Val;
340:                                         UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP;
341:                                         UDPSocketInfo[ss].retryCount = 0;
342:                                         UDPSocketInfo[ss].retryInterval = (TICK_SECOND/4)/256;
343:                                     }
344:                                     else
345:                                     {
346:                                         UDPSocketInfo[ss].smState = UDP_DNS_RESOLVE;
347:                                     }
348:                                 }
349:                             }
350:                             break;
351:                             #endif // #if defined(STACK_USE_DNS)
352:                 
353:                             case UDP_GATEWAY_SEND_ARP:
354:                                 // Obtain the MAC address associated with the server's IP address
355:                                 //(either direct MAC address on same subnet, or the MAC address of the Gateway machine)
356:                                 UDPSocketInfo[ss].eventTime = (uint16_t)TickGetDiv256();
9D00E464  93D00010   LBU S0, 16(S8)
9D00E468  0F405C62   JAL TickGetDiv256
9D00E46C  00000000   NOP
9D00E470  3044FFFF   ANDI A0, V0, -1
9D00E474  3C05A000   LUI A1, -24576
9D00E478  02001021   ADDU V0, S0, ZERO
9D00E47C  00021080   SLL V0, V0, 2
9D00E480  000218C0   SLL V1, V0, 3
9D00E484  00621823   SUBU V1, V1, V0
9D00E488  24A20388   ADDIU V0, A1, 904
9D00E48C  00621021   ADDU V0, V1, V0
9D00E490  A444001A   SH A0, 26(V0)
357:                                 ARPResolve(&UDPSocketInfo[ss].remote.remoteNode.IPAddr);
9D00E494  93C20010   LBU V0, 16(S8)
9D00E498  00021080   SLL V0, V0, 2
9D00E49C  000218C0   SLL V1, V0, 3
9D00E4A0  00621823   SUBU V1, V1, V0
9D00E4A4  3C02A000   LUI V0, -24576
9D00E4A8  24420388   ADDIU V0, V0, 904
9D00E4AC  00621021   ADDU V0, V1, V0
9D00E4B0  00402021   ADDU A0, V0, ZERO
9D00E4B4  0F40536D   JAL ARPResolve
9D00E4B8  00000000   NOP
358:                                 UDPSocketInfo[ss].smState = UDP_GATEWAY_GET_ARP;
9D00E4BC  93C20010   LBU V0, 16(S8)
9D00E4C0  3C04A000   LUI A0, -24576
9D00E4C4  00021080   SLL V0, V0, 2
9D00E4C8  000218C0   SLL V1, V0, 3
9D00E4CC  00621823   SUBU V1, V1, V0
9D00E4D0  24820388   ADDIU V0, A0, 904
9D00E4D4  00621021   ADDU V0, V1, V0
9D00E4D8  24030003   ADDIU V1, ZERO, 3
9D00E4DC  AC430010   SW V1, 16(V0)
359:                                 break;
9D00E4E0  0B4039B6   J 0x9D00E6D8
9D00E4E4  00000000   NOP
360:                 
361:                             case UDP_GATEWAY_GET_ARP:
362:                             if(!ARPIsResolved(&UDPSocketInfo[ss].remote.remoteNode.IPAddr,
9D00E4E8  93C20010   LBU V0, 16(S8)
9D00E4EC  00021080   SLL V0, V0, 2
9D00E4F0  000218C0   SLL V1, V0, 3
9D00E4F4  00621823   SUBU V1, V1, V0
9D00E4F8  3C02A000   LUI V0, -24576
9D00E4FC  24420388   ADDIU V0, V0, 904
9D00E500  00622021   ADDU A0, V1, V0
9D00E508  00021080   SLL V0, V0, 2
9D00E50C  000218C0   SLL V1, V0, 3
9D00E510  00621823   SUBU V1, V1, V0
9D00E514  3C02A000   LUI V0, -24576
9D00E518  24420388   ADDIU V0, V0, 904
9D00E51C  00621021   ADDU V0, V1, V0
9D00E520  24420004   ADDIU V0, V0, 4
9D00E524  00402821   ADDU A1, V0, ZERO
9D00E528  0F4053A6   JAL ARPIsResolved
9D00E52C  00000000   NOP
9D00E530  38420001   XORI V0, V0, 1
9D00E534  304200FF   ANDI V0, V0, 255
9D00E538  10400055   BEQ V0, ZERO, 0x9D00E690
9D00E53C  00000000   NOP
363:                                                 &UDPSocketInfo[ss].remote.remoteNode.MACAddr))
9D00E504  93C20010   LBU V0, 16(S8)
364:                             {
365:                                 // Time out if too much time is spent in this state
366:                                 // Note that this will continuously send out ARP
367:                                 // requests for an infinite time if the Gateway
368:                                 // never responds
369:                                 if((uint16_t)TickGetDiv256() - UDPSocketInfo[ss].eventTime> (uint16_t)UDPSocketInfo[ss].retryInterval)
9D00E540  0F405C62   JAL TickGetDiv256
9D00E544  00000000   NOP
9D00E548  3042FFFF   ANDI V0, V0, -1
9D00E54C  00402021   ADDU A0, V0, ZERO
9D00E550  93C20010   LBU V0, 16(S8)
9D00E554  3C05A000   LUI A1, -24576
9D00E558  00021080   SLL V0, V0, 2
9D00E55C  000218C0   SLL V1, V0, 3
9D00E560  00621823   SUBU V1, V1, V0
9D00E564  24A20388   ADDIU V0, A1, 904
9D00E568  00621021   ADDU V0, V1, V0
9D00E56C  9442001A   LHU V0, 26(V0)
9D00E570  00821823   SUBU V1, A0, V0
9D00E574  93C20010   LBU V0, 16(S8)
9D00E578  3C04A000   LUI A0, -24576
9D00E57C  24840388   ADDIU A0, A0, 904
9D00E580  00021080   SLL V0, V0, 2
9D00E584  000228C0   SLL A1, V0, 3
9D00E588  00A21023   SUBU V0, A1, V0
9D00E58C  00821021   ADDU V0, A0, V0
9D00E590  8C420014   LW V0, 20(V0)
9D00E594  3042FFFF   ANDI V0, V0, -1
9D00E598  0043102A   SLT V0, V0, V1
9D00E59C  1040004D   BEQ V0, ZERO, 0x9D00E6D4
9D00E5A0  00000000   NOP
370:                                 {
371:                                     // Exponentially increase timeout until we reach 6 attempts then stay constant
372:                                     if(UDPSocketInfo[ss].retryCount < 6u)
9D00E5A4  93C20010   LBU V0, 16(S8)
9D00E5A8  3C04A000   LUI A0, -24576
9D00E5AC  00021080   SLL V0, V0, 2
9D00E5B0  000218C0   SLL V1, V0, 3
9D00E5B4  00621823   SUBU V1, V1, V0
9D00E5B8  24820388   ADDIU V0, A0, 904
9D00E5BC  00621021   ADDU V0, V1, V0
9D00E5C0  90420018   LBU V0, 24(V0)
9D00E5C4  2C420006   SLTIU V0, V0, 6
9D00E5C8  10400026   BEQ V0, ZERO, 0x9D00E664
9D00E5CC  00000000   NOP
373:                                     {
374:                                         UDPSocketInfo[ss].retryCount++;
9D00E5D0  93C40010   LBU A0, 16(S8)
9D00E5D4  3C05A000   LUI A1, -24576
9D00E5D8  00801021   ADDU V0, A0, ZERO
9D00E5DC  00021080   SLL V0, V0, 2
9D00E5E0  000218C0   SLL V1, V0, 3
9D00E5E4  00621823   SUBU V1, V1, V0
9D00E5E8  24A20388   ADDIU V0, A1, 904
9D00E5EC  00621021   ADDU V0, V1, V0
9D00E5F0  90420018   LBU V0, 24(V0)
9D00E5F4  24420001   ADDIU V0, V0, 1
9D00E5F8  304500FF   ANDI A1, V0, 255
9D00E5FC  3C06A000   LUI A2, -24576
9D00E600  00801021   ADDU V0, A0, ZERO
9D00E604  00021080   SLL V0, V0, 2
9D00E608  000218C0   SLL V1, V0, 3
9D00E60C  00621823   SUBU V1, V1, V0
9D00E610  24C20388   ADDIU V0, A2, 904
9D00E614  00621021   ADDU V0, V1, V0
9D00E618  A0450018   SB A1, 24(V0)
375:                                         UDPSocketInfo[ss].retryInterval <<= 1;
9D00E61C  93C50010   LBU A1, 16(S8)
9D00E620  93C20010   LBU V0, 16(S8)
9D00E624  3C03A000   LUI V1, -24576
9D00E628  24630388   ADDIU V1, V1, 904
9D00E62C  00021080   SLL V0, V0, 2
9D00E630  000220C0   SLL A0, V0, 3
9D00E634  00821023   SUBU V0, A0, V0
9D00E638  00621021   ADDU V0, V1, V0
9D00E63C  8C420014   LW V0, 20(V0)
9D00E640  00021840   SLL V1, V0, 1
9D00E644  3C02A000   LUI V0, -24576
9D00E648  24440388   ADDIU A0, V0, 904
9D00E64C  00A01021   ADDU V0, A1, ZERO
9D00E650  00021080   SLL V0, V0, 2
9D00E654  000228C0   SLL A1, V0, 3
9D00E658  00A21023   SUBU V0, A1, V0
9D00E65C  00821021   ADDU V0, A0, V0
9D00E660  AC430014   SW V1, 20(V0)
376:                                     }
377:                                     // Retransmit ARP request
378:                                     UDPSocketInfo[ss].smState = UDP_GATEWAY_SEND_ARP;
9D00E664  93C20010   LBU V0, 16(S8)
9D00E668  3C04A000   LUI A0, -24576
9D00E66C  00021080   SLL V0, V0, 2
9D00E670  000218C0   SLL V1, V0, 3
9D00E674  00621823   SUBU V1, V1, V0
9D00E678  24820388   ADDIU V0, A0, 904
9D00E67C  00621021   ADDU V0, V1, V0
9D00E680  24030002   ADDIU V1, ZERO, 2
9D00E684  AC430010   SW V1, 16(V0)
379:                                 }
380:                             }
381:                             else
382:                             {
383:                                 UDPSocketInfo[ss].smState = UDP_OPENED;
9D00E690  93C20010   LBU V0, 16(S8)
9D00E694  3C04A000   LUI A0, -24576
9D00E698  00021080   SLL V0, V0, 2
9D00E69C  000218C0   SLL V1, V0, 3
9D00E6A0  00621823   SUBU V1, V1, V0
9D00E6A4  24820388   ADDIU V0, A0, 904
9D00E6A8  00621021   ADDU V0, V1, V0
9D00E6AC  24030005   ADDIU V1, ZERO, 5
9D00E6B0  AC430010   SW V1, 16(V0)
384:                             }
385:                             break;
9D00E688  0B4039B6   J 0x9D00E6D8
9D00E68C  00000000   NOP
9D00E6B4  0B4039B6   J 0x9D00E6D8
9D00E6B8  00000000   NOP
9D00E6D4  00000000   NOP
386:                             default:
387:                             case UDP_OPENED:
388:                             case UDP_CLOSED:
389:                             // not used
390:                             break;
9D00E45C  0B4039B6   J 0x9D00E6D8
9D00E460  00000000   NOP
391:                 #endif // #if defined(STACK_CLIENT_MODE)
392:                         }
393:                     }
394:                 }
9D00E6F4  03C0E821   ADDU SP, S8, ZERO
9D00E6F8  8FBF0024   LW RA, 36(SP)
9D00E6FC  8FBE0020   LW S8, 32(SP)
9D00E700  8FB0001C   LW S0, 28(SP)
9D00E704  27BD0028   ADDIU SP, SP, 40
9D00E708  03E00008   JR RA
9D00E70C  00000000   NOP
395:                 
396:                 /******************************************************************************
397:                 
398:                   Function:
399:                       bool UDPISOpened(UDP_SOCKET socket)
400:                 
401:                  Summary:
402:                       Determines if a socket has an established connection.
403:                 
404:                  Description:
405:                     This function determines if a socket has an established connection to a remote node .
406:                     Call this function after calling UDPOpen to determine when the connection is set up
407:                     and ready for use.
408:                 
409:                  Precondition:
410:                     UDP is initialized.
411:                 
412:                  Parameters:
413:                     socket - The socket to check.
414:                 
415:                  Return Values:
416:                     true - The socket has been opened and ARP has been resolved.
417:                     false - The socket is not currently connected.
418:                 
419:                  Remarks:
420:                     None
421:                 
422:                  *****************************************************************************/
423:                 bool UDPIsOpened(UDP_SOCKET socket)
424:                 {
9D00E710  27BDFFF8   ADDIU SP, SP, -8
9D00E714  AFBE0004   SW S8, 4(SP)
9D00E718  03A0F021   ADDU S8, SP, ZERO
9D00E71C  00801021   ADDU V0, A0, ZERO
9D00E720  A3C20008   SB V0, 8(S8)
425:                     return (UDPSocketInfo[socket].smState == UDP_OPENED);
9D00E724  93C20008   LBU V0, 8(S8)
9D00E728  3C04A000   LUI A0, -24576
9D00E72C  00021080   SLL V0, V0, 2
9D00E730  000218C0   SLL V1, V0, 3
9D00E734  00621823   SUBU V1, V1, V0
9D00E738  24820388   ADDIU V0, A0, 904
9D00E73C  00621021   ADDU V0, V1, V0
9D00E740  8C420010   LW V0, 16(V0)
9D00E744  38420005   XORI V0, V0, 5
9D00E748  2C420001   SLTIU V0, V0, 1
9D00E74C  304200FF   ANDI V0, V0, 255
426:                 }
9D00E750  03C0E821   ADDU SP, S8, ZERO
9D00E754  8FBE0004   LW S8, 4(SP)
9D00E758  27BD0008   ADDIU SP, SP, 8
9D00E75C  03E00008   JR RA
9D00E760  00000000   NOP
427:                 
428:                 
429:                 #if 0
430:                 /*****************************************************************************
431:                   Function:
432:                     void UDPTask(void)
433:                 
434:                   Summary:
435:                     Performs state management and housekeeping for UDP.
436:                 
437:                   Description:
438:                     Performs state management and housekeeping for UDP.  This is an internal
439:                     function meant to be called by StackTask() (not a user API).
440:                 
441:                   Precondition:
442:                     None
443:                 
444:                   Parameters:
445:                     None
446:                 
447:                   Return Values:
448:                     None
449:                 
450:                   Remarks:
451:                     UDPTask() is called once per StackTask() iteration to ensure that calls
452:                     to UDPIsPutReady() always update the Ethernet Write pointer location
453:                     between StackTask() iterations.
454:                   ***************************************************************************/
455:                 void UDPTask(void)
456:                 {
457:                     LastPutSocket = INVALID_UDP_SOCKET;
458:                 }
459:                 
460:                 
461:                 /*****************************************************************************
462:                   Function:
463:                     UDP_SOCKET UDPOpen(UDP_PORT localPort, NODE_INFO* remoteNode,
464:                                         UDP_PORT remotePort)
465:                 
466:                   Summary:
467:                     Creates a UDP socket handle for transmiting or receiving UDP packets.
468:                 
469:                   Description:
470:                     Creates a UDP socket handle for transmiting or receiving UDP packets.
471:                     Call this function to obtain a handle required by other UDP function.
472:                 
473:                   Precondition:
474:                     UDPInit() must have been previously called.
475:                 
476:                   Parameters:
477:                     localPort - UDP port number to listen on.  If 0, stack will dynamically
478:                         assign a unique port number to use.
479:                     remoteNode - Pointer to remote node info (MAC and IP address) for this
480:                         connection.  If this is a server socket (receives the first packet)
481:                         or the destination is the broadcast address, then this parameter
482:                         should be NULL.
483:                     remotePort - For client sockets, the remote port number.
484:                 
485:                   Return Values:
486:                     Success -
487:                         A UDP socket handle that can be used for subsequent UDP API calls.
488:                     Failure -
489:                         INVALID_UDP_SOCKET.  This function fails when no more UDP socket
490:                         handles are available.  Increase MAX_UDP_SOCKETS to make more sockets
491:                         available.
492:                 
493:                   Remarks:
494:                     When finished using the UDP socket handle, call the UDPClose() function
495:                     to free the socket and delete the handle.
496:                   ***************************************************************************/
497:                 UDP_SOCKET UDPOpen(UDP_PORT localPort,
498:                                    NODE_INFO *remoteNode,
499:                                    UDP_PORT remotePort)
500:                 {
501:                     UDP_SOCKET s;
502:                     UDP_SOCKET_INFO *p;
503:                 
504:                     // Local temp port numbers.
505:                     static uint16_t NextPort __attribute__((persistent));
506:                 
507:                 
508:                     p = UDPSocketInfo;
509:                     for ( s = 0; s < MAX_UDP_SOCKETS; s++ )
510:                     {
511:                         if(p->localPort == INVALID_UDP_PORT)
512:                         {
513:                             p->localPort = localPort;
514:                 
515:                             if(localPort == 0x0000u)
516:                             {
517:                                 if(NextPort > LOCAL_UDP_PORT_END_NUMBER || NextPort < LOCAL_UDP_PORT_START_NUMBER)
518:                                     NextPort = LOCAL_UDP_PORT_START_NUMBER;
519:                 
520:                                 p->localPort    = NextPort++;
521:                             }
522:                 
523:                             // If remoteNode is supplied, remember it.
524:                             if(remoteNode)
525:                             {
526:                                 memcpy((void*)&p->remoteNode,
527:                                         (const void*)remoteNode,
528:                                         sizeof(p->remoteNode));
529:                             }
530:                             else
531:                             {
532:                                 // else Set broadcast address
533:                                 memset((void*)&p->remoteNode, 0xFF, sizeof(p->remoteNode));
534:                             }
535:                 
536:                             p->remotePort   = remotePort;
537:                 
538:                             // Mark this socket as active.
539:                             // Once an active socket is set, subsequent operation can be
540:                             // done without explicitely supply socket identifier.
541:                             activeUDPSocket = s;
542:                             return s;
543:                         }
544:                         p++;
545:                     }
546:                 
547:                     return (UDP_SOCKET)INVALID_UDP_SOCKET;
548:                 }
549:                 
550:                 #endif
551:                 
552:                 
553:                 /*****************************************************************************
554:                   Function:
555:                     void UDPClose(UDP_SOCKET s)
556:                 
557:                   Summary:
558:                     Closes a UDP socket and frees the handle.
559:                 
560:                   Description:
561:                     Closes a UDP socket and frees the handle.  Call this function to release
562:                     a socket and return it to the pool for use by future communications.
563:                 
564:                   Precondition:
565:                     UDPInit() must have been previously called.
566:                 
567:                   Parameters:
568:                     s - The socket handle to be released.  If an illegal handle value is
569:                         provided, the function safely does nothing.
570:                 
571:                   Returns:
572:                     None
573:                 
574:                   Remarks:
575:                     This function does not affect the previously designated active socket.
576:                   ***************************************************************************/
577:                 void UDPClose(UDP_SOCKET s)
578:                 {
9D00E764  27BDFFF8   ADDIU SP, SP, -8
9D00E768  AFBE0004   SW S8, 4(SP)
9D00E76C  03A0F021   ADDU S8, SP, ZERO
9D00E770  00801021   ADDU V0, A0, ZERO
9D00E774  A3C20008   SB V0, 8(S8)
579:                     if(s >= MAX_UDP_SOCKETS)
9D00E778  93C20008   LBU V0, 8(S8)
9D00E77C  2C42000A   SLTIU V0, V0, 10
9D00E780  1040001C   BEQ V0, ZERO, 0x9D00E7F4
9D00E784  00000000   NOP
580:                         return;
9D00E7F4  00000000   NOP
581:                 
582:                     UDPSocketInfo[s].localPort = INVALID_UDP_PORT;
9D00E788  93C20008   LBU V0, 8(S8)
9D00E78C  3C04A000   LUI A0, -24576
9D00E790  00021080   SLL V0, V0, 2
9D00E794  000218C0   SLL V1, V0, 3
9D00E798  00621823   SUBU V1, V1, V0
9D00E79C  24820388   ADDIU V0, A0, 904
9D00E7A0  00621021   ADDU V0, V1, V0
9D00E7A4  A440000E   SH ZERO, 14(V0)
583:                     UDPSocketInfo[s].remote.remoteNode.IPAddr.Val = 0x00000000;
9D00E7A8  93C20008   LBU V0, 8(S8)
9D00E7AC  3C04A000   LUI A0, -24576
9D00E7B0  00021080   SLL V0, V0, 2
9D00E7B4  000218C0   SLL V1, V0, 3
9D00E7B8  00621823   SUBU V1, V1, V0
9D00E7BC  24820388   ADDIU V0, A0, 904
9D00E7C0  00621021   ADDU V0, V1, V0
9D00E7C4  AC400000   SW ZERO, 0(V0)
584:                     UDPSocketInfo[s].smState = UDP_CLOSED;
9D00E7C8  93C20008   LBU V0, 8(S8)
9D00E7CC  3C04A000   LUI A0, -24576
9D00E7D0  00021080   SLL V0, V0, 2
9D00E7D4  000218C0   SLL V1, V0, 3
9D00E7D8  00621823   SUBU V1, V1, V0
9D00E7DC  24820388   ADDIU V0, A0, 904
9D00E7E0  00621021   ADDU V0, V1, V0
9D00E7E4  24030004   ADDIU V1, ZERO, 4
9D00E7E8  AC430010   SW V1, 16(V0)
9D00E7EC  0B4039FE   J 0x9D00E7F8
9D00E7F0  00000000   NOP
585:                 }
9D00E7F8  03C0E821   ADDU SP, S8, ZERO
9D00E7FC  8FBE0004   LW S8, 4(SP)
9D00E800  27BD0008   ADDIU SP, SP, 8
9D00E804  03E00008   JR RA
9D00E808  00000000   NOP
586:                 
587:                 
588:                 /*****************************************************************************
589:                   Function:
590:                     void UDPSetTxBuffer(uint16_t wOffset)
591:                 
592:                   Summary:
593:                     Moves the pointer within the TX buffer.
594:                 
595:                   Description:
596:                     This function allows the write location within the TX buffer to be
597:                     specified.  Future calls to UDPPut, UDPPutArray, UDPPutString, etc will
598:                     write data from the indicated location.
599:                 
600:                   Precondition:
601:                     UDPInit() must have been previously called and a socket is currently
602:                     active.
603:                 
604:                   Parameters:
605:                     wOffset - Offset from beginning of UDP packet data payload to place the
606:                         write pointer.
607:                 
608:                   Returns:
609:                     None
610:                   ***************************************************************************/
611:                 void UDPSetTxBuffer(uint16_t wOffset)
612:                 {
9D00E80C  27BDFFE0   ADDIU SP, SP, -32
9D00E810  AFBF001C   SW RA, 28(SP)
9D00E814  AFBE0018   SW S8, 24(SP)
9D00E818  AFB00014   SW S0, 20(SP)
9D00E81C  03A0F021   ADDU S8, SP, ZERO
9D00E820  00801021   ADDU V0, A0, ZERO
9D00E824  A7C20020   SH V0, 32(S8)
613:                     IPSetTxBuffer(wOffset+sizeof(UDP_HEADER));
9D00E828  97D00020   LHU S0, 32(S8)
9D00E82C  0F404508   JAL MACGetTxBaseAddr
9D00E830  00000000   NOP
9D00E834  02021021   ADDU V0, S0, V0
9D00E838  2442002A   ADDIU V0, V0, 42
9D00E83C  00402021   ADDU A0, V0, ZERO
9D00E840  0F40452C   JAL MACSetWritePtr
9D00E844  00000000   NOP
614:                     wPutOffset = wOffset;
9D00E848  97C20020   LHU V0, 32(S8)
9D00E84C  A7828050   SH V0, -32688(GP)
615:                 }
9D00E850  03C0E821   ADDU SP, S8, ZERO
9D00E854  8FBF001C   LW RA, 28(SP)
9D00E858  8FBE0018   LW S8, 24(SP)
9D00E85C  8FB00014   LW S0, 20(SP)
9D00E860  27BD0020   ADDIU SP, SP, 32
9D00E864  03E00008   JR RA
9D00E868  00000000   NOP
616:                 
617:                 
618:                 /*****************************************************************************
619:                   Function:
620:                     void UDPSetRxBuffer(uint16_t wOffset)
621:                 
622:                   Summary:
623:                     Moves the pointer within the RX buffer.
624:                 
625:                   Description:
626:                     This function allows the read location within the RX buffer to be
627:                     specified.  Future calls to UDPGet and UDPGetArray will read data from
628:                     the indicated location forward.
629:                 
630:                   Precondition:
631:                     UDPInit() must have been previously called and a socket is currently
632:                     active.
633:                 
634:                   Parameters:
635:                     wOffset - Offset from beginning of UDP packet data payload to place the
636:                         read pointer.
637:                 
638:                   Returns:
639:                     None
640:                   ***************************************************************************/
641:                 void UDPSetRxBuffer(uint16_t wOffset)
642:                 {
9D00E86C  27BDFFE8   ADDIU SP, SP, -24
9D00E870  AFBF0014   SW RA, 20(SP)
9D00E874  AFBE0010   SW S8, 16(SP)
9D00E878  03A0F021   ADDU S8, SP, ZERO
9D00E87C  00801021   ADDU V0, A0, ZERO
9D00E880  A7C20018   SH V0, 24(S8)
643:                     IPSetRxBuffer(wOffset+sizeof(UDP_HEADER));
9D00E884  97C20018   LHU V0, 24(S8)
9D00E888  24420008   ADDIU V0, V0, 8
9D00E88C  3042FFFF   ANDI V0, V0, -1
9D00E890  00402021   ADDU A0, V0, ZERO
9D00E894  0F406020   JAL IPSetRxBuffer
9D00E898  00000000   NOP
644:                     wGetOffset = wOffset;
9D00E89C  97C20018   LHU V0, 24(S8)
9D00E8A0  A7828052   SH V0, -32686(GP)
645:                 }
9D00E8A4  03C0E821   ADDU SP, S8, ZERO
9D00E8A8  8FBF0014   LW RA, 20(SP)
9D00E8AC  8FBE0010   LW S8, 16(SP)
9D00E8B0  27BD0018   ADDIU SP, SP, 24
9D00E8B4  03E00008   JR RA
9D00E8B8  00000000   NOP
646:                 
647:                 
648:                 
649:                 /****************************************************************************
650:                   Section:
651:                     Transmit Functions
652:                   ***************************************************************************/
653:                 
654:                 /*****************************************************************************
655:                   Function:
656:                     uint16_t UDPIsPutReady(UDP_SOCKET s)
657:                 
658:                   Summary:
659:                     Determines how many bytes can be written to the UDP socket.
660:                 
661:                   Description:
662:                     This function determines if bytes can be written to the specified UDP
663:                     socket.  It also prepares the UDP module for writing by setting the
664:                     indicated socket as the currently active connection.
665:                 
666:                   Precondition:
667:                     UDPInit() must have been previously called.
668:                 
669:                   Parameters:
670:                     s - The socket to be made active
671:                 
672:                   Returns:
673:                     The number of bytes that can be written to this socket.
674:                   ***************************************************************************/
675:                 uint16_t UDPIsPutReady(UDP_SOCKET s)
676:                 {
9D00E8BC  27BDFFE8   ADDIU SP, SP, -24
9D00E8C0  AFBF0014   SW RA, 20(SP)
9D00E8C4  AFBE0010   SW S8, 16(SP)
9D00E8C8  03A0F021   ADDU S8, SP, ZERO
9D00E8CC  00801021   ADDU V0, A0, ZERO
9D00E8D0  A3C20018   SB V0, 24(S8)
677:                     if(!MACIsTxReady())
9D00E8D4  0F40453A   JAL MACIsTxReady
9D00E8D8  00000000   NOP
9D00E8DC  38420001   XORI V0, V0, 1
9D00E8E0  304200FF   ANDI V0, V0, 255
9D00E8E4  10400004   BEQ V0, ZERO, 0x9D00E8F8
9D00E8E8  00000000   NOP
678:                         return 0;
9D00E8EC  00001021   ADDU V0, ZERO, ZERO
9D00E8F0  0B403A4E   J 0x9D00E938
9D00E8F4  00000000   NOP
679:                 
680:                     if(LastPutSocket != s)
9D00E8F8  93828016   LBU V0, -32746(GP)
9D00E8FC  93C30018   LBU V1, 24(S8)
9D00E900  10620007   BEQ V1, V0, 0x9D00E920
9D00E904  00000000   NOP
681:                     {
682:                         LastPutSocket = s;
9D00E908  93C20018   LBU V0, 24(S8)
9D00E90C  A3828016   SB V0, -32746(GP)
683:                         UDPTxCount = 0;
9D00E910  A7808156   SH ZERO, -32426(GP)
684:                         UDPSetTxBuffer(0);
9D00E914  00002021   ADDU A0, ZERO, ZERO
9D00E918  0F403A03   JAL UDPSetTxBuffer
9D00E91C  00000000   NOP
685:                     }
686:                 
687:                     activeUDPSocket = s;
9D00E920  93C20018   LBU V0, 24(S8)
9D00E924  A3828158   SB V0, -32424(GP)
688:                 
689:                     return MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER) - UDPTxCount;
9D00E928  97828156   LHU V0, -32426(GP)
9D00E92C  240305C0   ADDIU V1, ZERO, 1472
9D00E930  00621023   SUBU V0, V1, V0
9D00E934  3042FFFF   ANDI V0, V0, -1
690:                 }
9D00E938  03C0E821   ADDU SP, S8, ZERO
9D00E93C  8FBF0014   LW RA, 20(SP)
9D00E940  8FBE0010   LW S8, 16(SP)
9D00E944  27BD0018   ADDIU SP, SP, 24
9D00E948  03E00008   JR RA
9D00E94C  00000000   NOP
691:                 
692:                 /*****************************************************************************
693:                   Function:
694:                     bool UDPPut(uint8_t v)
695:                 
696:                   Summary:
697:                     Writes a byte to the currently active socket.
698:                 
699:                   Description:
700:                     This function writes a single byte to the currently active UDP socket,
701:                     while incrementing the buffer length.  UDPIsPutReady should be used
702:                     before calling this function to specify the currently active socket.
703:                 
704:                   Precondition:
705:                     UDPIsPutReady() was previously called to specify the current socket.
706:                 
707:                   Parameters:
708:                     v - The byte to be loaded into the transmit buffer.
709:                 
710:                   Return Values:
711:                     true - The byte was successfully written to the socket.
712:                     false - The transmit buffer is already full and so the write failed.
713:                   ***************************************************************************/
714:                 bool UDPPut(uint8_t v)
715:                 {
9D00E950  27BDFFE8   ADDIU SP, SP, -24
9D00E954  AFBF0014   SW RA, 20(SP)
9D00E958  AFBE0010   SW S8, 16(SP)
9D00E95C  03A0F021   ADDU S8, SP, ZERO
9D00E960  00801021   ADDU V0, A0, ZERO
9D00E964  A3C20018   SB V0, 24(S8)
716:                     // See if we are out of transmit space.
717:                     if(wPutOffset >= (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)))
9D00E968  97828050   LHU V0, -32688(GP)
9D00E96C  2C4205C0   SLTIU V0, V0, 1472
9D00E970  14400004   BNE V0, ZERO, 0x9D00E984
9D00E974  00000000   NOP
718:                     {
719:                         return false;
9D00E978  00001021   ADDU V0, ZERO, ZERO
9D00E97C  0B403A71   J 0x9D00E9C4
9D00E980  00000000   NOP
720:                     }
721:                 
722:                     // Load application data byte
723:                     MACPut(v);
9D00E984  93C20018   LBU V0, 24(S8)
9D00E988  00402021   ADDU A0, V0, ZERO
9D00E98C  0F4045AE   JAL MACPut
9D00E990  00000000   NOP
724:                     wPutOffset++;
9D00E994  97828050   LHU V0, -32688(GP)
9D00E998  24420001   ADDIU V0, V0, 1
9D00E99C  3042FFFF   ANDI V0, V0, -1
9D00E9A0  A7828050   SH V0, -32688(GP)
725:                     if(wPutOffset > UDPTxCount)
9D00E9A4  97838050   LHU V1, -32688(GP)
9D00E9A8  97828156   LHU V0, -32426(GP)
9D00E9AC  0043102B   SLTU V0, V0, V1
9D00E9B0  10400003   BEQ V0, ZERO, 0x9D00E9C0
9D00E9B4  00000000   NOP
726:                         UDPTxCount = wPutOffset;
9D00E9B8  97828050   LHU V0, -32688(GP)
9D00E9BC  A7828156   SH V0, -32426(GP)
727:                 
728:                     return true;
9D00E9C0  24020001   ADDIU V0, ZERO, 1
729:                 }
9D00E9C4  03C0E821   ADDU SP, S8, ZERO
9D00E9C8  8FBF0014   LW RA, 20(SP)
9D00E9CC  8FBE0010   LW S8, 16(SP)
9D00E9D0  27BD0018   ADDIU SP, SP, 24
9D00E9D4  03E00008   JR RA
9D00E9D8  00000000   NOP
730:                 
731:                 /*****************************************************************************
732:                   Function:
733:                     uint16_t UDPPutArray(uint8_t *cData, uint16_t wDataLen)
734:                 
735:                   Summary:
736:                     Writes an array of bytes to the currently active socket.
737:                 
738:                   Description:
739:                     This function writes an array of bytes to the currently active UDP socket,
740:                     while incrementing the buffer length.  UDPIsPutReady should be used
741:                     before calling this function to specify the currently active socket.
742:                 
743:                   Precondition:
744:                     UDPIsPutReady() was previously called to specify the current socket.
745:                 
746:                   Parameters:
747:                     cData - The array to write to the socket.
748:                     wDateLen - Number of bytes from cData to be written.
749:                 
750:                   Returns:
751:                     The number of bytes successfully placed in the UDP transmit buffer.  If
752:                     this value is less than wDataLen, then the buffer became full and the
753:                     input was truncated.
754:                   ***************************************************************************/
755:                 uint16_t UDPPutArray(uint8_t *cData, uint16_t wDataLen)
756:                 {
9D00E9DC  27BDFFE0   ADDIU SP, SP, -32
9D00E9E0  AFBF001C   SW RA, 28(SP)
9D00E9E4  AFBE0018   SW S8, 24(SP)
9D00E9E8  03A0F021   ADDU S8, SP, ZERO
9D00E9EC  AFC40020   SW A0, 32(S8)
9D00E9F0  00A01021   ADDU V0, A1, ZERO
9D00E9F4  A7C20024   SH V0, 36(S8)
757:                     uint16_t wTemp;
758:                 
759:                     wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
9D00E9F8  97828050   LHU V0, -32688(GP)
9D00E9FC  240305C0   ADDIU V1, ZERO, 1472
9D00EA00  00621023   SUBU V0, V1, V0
9D00EA04  A7C20010   SH V0, 16(S8)
760:                     if(wTemp < wDataLen)
9D00EA08  97C30010   LHU V1, 16(S8)
9D00EA0C  97C20024   LHU V0, 36(S8)
9D00EA10  0062102B   SLTU V0, V1, V0
9D00EA14  10400003   BEQ V0, ZERO, 0x9D00EA24
9D00EA18  00000000   NOP
761:                         wDataLen = wTemp;
9D00EA1C  97C20010   LHU V0, 16(S8)
9D00EA20  A7C20024   SH V0, 36(S8)
762:                 
763:                     wPutOffset += wDataLen;
9D00EA24  97838050   LHU V1, -32688(GP)
9D00EA28  97C20024   LHU V0, 36(S8)
9D00EA2C  00621021   ADDU V0, V1, V0
9D00EA30  3042FFFF   ANDI V0, V0, -1
9D00EA34  A7828050   SH V0, -32688(GP)
764:                     if(wPutOffset > UDPTxCount)
9D00EA38  97838050   LHU V1, -32688(GP)
9D00EA3C  97828156   LHU V0, -32426(GP)
9D00EA40  0043102B   SLTU V0, V0, V1
9D00EA44  10400003   BEQ V0, ZERO, 0x9D00EA54
9D00EA48  00000000   NOP
765:                         UDPTxCount = wPutOffset;
9D00EA4C  97828050   LHU V0, -32688(GP)
9D00EA50  A7828156   SH V0, -32426(GP)
766:                 
767:                     // Load application data bytes
768:                     MACPutArray(cData, wDataLen);
9D00EA54  97C20024   LHU V0, 36(S8)
9D00EA58  8FC40020   LW A0, 32(S8)
9D00EA5C  00402821   ADDU A1, V0, ZERO
9D00EA60  0F4045BD   JAL MACPutArray
9D00EA64  00000000   NOP
769:                 
770:                     return wDataLen;
9D00EA68  97C20024   LHU V0, 36(S8)
771:                 }
9D00EA6C  03C0E821   ADDU SP, S8, ZERO
9D00EA70  8FBF001C   LW RA, 28(SP)
9D00EA74  8FBE0018   LW S8, 24(SP)
9D00EA78  27BD0020   ADDIU SP, SP, 32
9D00EA7C  03E00008   JR RA
9D00EA80  00000000   NOP
772:                 
773:                 /*****************************************************************************
774:                   Function:
775:                     uint16_t UDPPutROMArray(ROM uint8_t *cData, uint16_t wDataLen)
776:                 
777:                   Summary:
778:                     Writes an array of bytes from ROM to the currently active socket.
779:                 
780:                   Description:
781:                     This function writes an array of bytes from ROM to the currently active
782:                     UDP socket, while incrementing the buffer length.  UDPIsPutReady should
783:                     be used before calling this function to specify the currently active
784:                     socket.
785:                 
786:                   Precondition:
787:                     UDPIsPutReady() was previously called to specify the current socket.
788:                 
789:                   Parameters:
790:                     cData - The array to write to the socket.
791:                     wDateLen - Number of bytes from cData to be written.
792:                 
793:                   Returns:
794:                     The number of bytes successfully placed in the UDP transmit buffer.  If
795:                     this value is less than wDataLen, then the buffer became full and the
796:                     input was truncated.
797:                 
798:                   Remarks:
799:                     This function is aliased to UDPPutArray on non-PIC18 platforms.
800:                   ***************************************************************************/
801:                 #if defined(__XC8)
802:                 uint16_t UDPPutROMArray(ROM uint8_t *cData, uint16_t wDataLen)
803:                 {
804:                     uint16_t wTemp;
805:                 
806:                     wTemp = (MAC_TX_BUFFER_SIZE - sizeof(IP_HEADER) - sizeof(UDP_HEADER)) - wPutOffset;
807:                     if(wTemp < wDataLen)
808:                         wDataLen = wTemp;
809:                 
810:                     wPutOffset += wDataLen;
811:                     if(wPutOffset > UDPTxCount)
812:                         UDPTxCount = wPutOffset;
813:                 
814:                     // Load application data bytes
815:                     MACPutROMArray(cData, wDataLen);
816:                 
817:                     return wDataLen;
818:                 }
819:                 #endif
820:                 
821:                 /*****************************************************************************
822:                   Function:
823:                     uint8_t* UDPPutString(uint8_t *strData)
824:                 
825:                   Summary:
826:                     Writes null-terminated string to the currently active socket.
827:                 
828:                   Description:
829:                     This function writes a null-terminated string to the currently active
830:                     UDP socket, while incrementing the buffer length.  UDPIsPutReady should
831:                     be used before calling this function to specify the currently active
832:                     socket.
833:                 
834:                   Precondition:
835:                     UDPIsPutReady() was previously called to specify the current socket.
836:                 
837:                   Parameters:
838:                     cData - Pointer to the string to be written to the socket.
839:                 
840:                   Returns:
841:                     A pointer to the byte following the last byte written.  Note that this
842:                     is different than the UDPPutArray functions.  If this pointer does not
843:                     dereference to a NULL byte, then the buffer became full and the input
844:                     data was truncated.
845:                   ***************************************************************************/
846:                 uint8_t* UDPPutString(uint8_t *strData)
847:                 {
9D00EA84  27BDFFE8   ADDIU SP, SP, -24
9D00EA88  AFBF0014   SW RA, 20(SP)
9D00EA8C  AFBE0010   SW S8, 16(SP)
9D00EA90  03A0F021   ADDU S8, SP, ZERO
9D00EA94  AFC40018   SW A0, 24(S8)
848:                     return strData + UDPPutArray(strData, strlen((char*)strData));
9D00EA98  8FC20018   LW V0, 24(S8)
9D00EA9C  00402021   ADDU A0, V0, ZERO
9D00EAA0  0F4067E2   JAL 0x9D019F88
9D00EAA4  00000000   NOP
9D00EAA8  3042FFFF   ANDI V0, V0, -1
9D00EAAC  8FC40018   LW A0, 24(S8)
9D00EAB0  00402821   ADDU A1, V0, ZERO
9D00EAB4  0F403A77   JAL UDPPutArray
9D00EAB8  00000000   NOP
9D00EABC  8FC30018   LW V1, 24(S8)
9D00EAC0  00621021   ADDU V0, V1, V0
849:                 }
9D00EAC4  03C0E821   ADDU SP, S8, ZERO
9D00EAC8  8FBF0014   LW RA, 20(SP)
9D00EACC  8FBE0010   LW S8, 16(SP)
9D00EAD0  27BD0018   ADDIU SP, SP, 24
9D00EAD4  03E00008   JR RA
9D00EAD8  00000000   NOP
850:                 
851:                 /*****************************************************************************
852:                   Function:
853:                     uint8_t* UDPPutString(uint8_t *strData)
854:                 
855:                   Summary:
856:                     Writes null-terminated string from ROM to the currently active socket.
857:                 
858:                   Description:
859:                     This function writes a null-terminated string from ROM to the currently
860:                     active UDP socket, while incrementing the buffer length.  UDPIsPutReady
861:                     should be used before calling this function to specify the currently
862:                     active socket.
863:                 
864:                   Precondition:
865:                     UDPIsPutReady() was previously called to specify the current socket.
866:                 
867:                   Parameters:
868:                     cData - Pointer to the string to be written to the socket.
869:                 
870:                   Returns:
871:                     A pointer to the byte following the last byte written.  Note that this
872:                     is different than the UDPPutArray functions.  If this pointer does not
873:                     dereference to a NULL byte, then the buffer became full and the input
874:                     data was truncated.
875:                 
876:                   Remarks:
877:                     This function is aliased to UDPPutString on non-PIC18 platforms.
878:                   ***************************************************************************/
879:                 #if defined(__XC8)
880:                 ROM uint8_t* UDPPutROMString(ROM uint8_t *strData)
881:                 {
882:                     return strData + UDPPutROMArray(strData, strlenpgm((ROM char*)strData));
883:                 }
884:                 #endif
885:                 
886:                 /*****************************************************************************
887:                   Function:
888:                     void UDPFlush(void)
889:                 
890:                   Summary:
891:                     Transmits all pending data in a UDP socket.
892:                 
893:                   Description:
894:                     This function builds a UDP packet with the pending TX data and marks it
895:                     for transmission over the network interface.  Since UDP is a frame-based
896:                     protocol, this function must be called before returning to the main
897:                     stack loop whenever any data is written.
898:                 
899:                   Precondition:
900:                     UDPIsPutReady() was previously called to specify the current socket, and
901:                     data has been written to the socket using the UDPPut family of functions.
902:                 
903:                   Parameters:
904:                     None
905:                 
906:                   Returns:
907:                     None
908:                 
909:                   Remarks:
910:                     Note that unlike TCPFlush, UDPFlush must be called before returning to
911:                     the main stack loop.  There is no auto transmit for UDP segments.
912:                   ***************************************************************************/
913:                 void UDPFlush(void)
914:                 {
9D00EADC  27BDFFC0   ADDIU SP, SP, -64
9D00EAE0  AFBF003C   SW RA, 60(SP)
9D00EAE4  AFBE0038   SW S8, 56(SP)
9D00EAE8  03A0F021   ADDU S8, SP, ZERO
915:                     UDP_HEADER      h;
916:                     UDP_SOCKET_INFO *p;
917:                     uint16_t            wUDPLength;
918:                 
919:                     p = &UDPSocketInfo[activeUDPSocket];
9D00EAEC  93828158   LBU V0, -32424(GP)
9D00EAF0  00021080   SLL V0, V0, 2
9D00EAF4  000218C0   SLL V1, V0, 3
9D00EAF8  00621823   SUBU V1, V1, V0
9D00EAFC  3C02A000   LUI V0, -24576
9D00EB00  24420388   ADDIU V0, V0, 904
9D00EB04  00621021   ADDU V0, V1, V0
9D00EB08  AFC20010   SW V0, 16(S8)
920:                 
921:                     wUDPLength = UDPTxCount + sizeof(UDP_HEADER);
9D00EB0C  97828156   LHU V0, -32426(GP)
9D00EB10  24420008   ADDIU V0, V0, 8
9D00EB14  A7C20014   SH V0, 20(S8)
922:                 
923:                     // Generate the correct UDP header
924:                     h.SourcePort        = swaps(p->localPort);
9D00EB18  8FC20010   LW V0, 16(S8)
9D00EB1C  9442000E   LHU V0, 14(V0)
9D00EB20  00402021   ADDU A0, V0, ZERO
9D00EB24  0F403F50   JAL swaps
9D00EB28  00000000   NOP
9D00EB2C  A7C2001C   SH V0, 28(S8)
925:                     h.DestinationPort   = swaps(p->remotePort);
9D00EB30  8FC20010   LW V0, 16(S8)
9D00EB34  9442000C   LHU V0, 12(V0)
9D00EB38  00402021   ADDU A0, V0, ZERO
9D00EB3C  0F403F50   JAL swaps
9D00EB40  00000000   NOP
9D00EB44  A7C2001E   SH V0, 30(S8)
926:                     h.Length            = swaps(wUDPLength);
9D00EB48  97C20014   LHU V0, 20(S8)
9D00EB4C  00402021   ADDU A0, V0, ZERO
9D00EB50  0F403F50   JAL swaps
9D00EB54  00000000   NOP
9D00EB58  A7C20020   SH V0, 32(S8)
927:                     h.Checksum          = 0x0000;
9D00EB5C  A7C00022   SH ZERO, 34(S8)
928:                 
929:                     // Calculate IP pseudoheader checksum if we are going to enable
930:                     // the checksum field
931:                     #if defined(UDP_USE_TX_CHECKSUM)
932:                     {
933:                         PSEUDO_HEADER   pseudoHeader;
934:                 
935:                         pseudoHeader.SourceAddress  = AppConfig.MyIPAddr;
9D00EB60  3C02A000   LUI V0, -24576
9D00EB64  244308D8   ADDIU V1, V0, 2264
9D00EB68  88630003   LWL V1, 3(V1)
9D00EB6C  00602021   ADDU A0, V1, ZERO
9D00EB70  984408D8   LWR A0, 2264(V0)
9D00EB74  00801021   ADDU V0, A0, ZERO
9D00EB78  AFC20024   SW V0, 36(S8)
936:                         pseudoHeader.DestAddress    = p->remote.remoteNode.IPAddr;
9D00EB7C  8FC20010   LW V0, 16(S8)
9D00EB80  8C420000   LW V0, 0(V0)
9D00EB84  AFC20028   SW V0, 40(S8)
937:                         pseudoHeader.Zero           = 0x0;
9D00EB88  A3C0002C   SB ZERO, 44(S8)
938:                         pseudoHeader.Protocol       = IP_PROT_UDP;
9D00EB8C  24020011   ADDIU V0, ZERO, 17
9D00EB90  A3C2002D   SB V0, 45(S8)
939:                         pseudoHeader.Length         = wUDPLength;
9D00EB94  97C20014   LHU V0, 20(S8)
9D00EB98  A7C2002E   SH V0, 46(S8)
940:                         SwapPseudoHeader(pseudoHeader);
9D00EB9C  97C2002E   LHU V0, 46(S8)
9D00EBA0  00402021   ADDU A0, V0, ZERO
9D00EBA4  0F403F50   JAL swaps
9D00EBA8  00000000   NOP
9D00EBAC  A7C2002E   SH V0, 46(S8)
941:                         h.Checksum = ~CalcIPChecksum((uint8_t*)&pseudoHeader, sizeof(pseudoHeader));
9D00EBB0  27C20024   ADDIU V0, S8, 36
9D00EBB4  00402021   ADDU A0, V0, ZERO
9D00EBB8  2405000C   ADDIU A1, ZERO, 12
9D00EBBC  0F403F9D   JAL CalcIPChecksum
9D00EBC0  00000000   NOP
9D00EBC4  00021027   NOR V0, ZERO, V0
9D00EBC8  3042FFFF   ANDI V0, V0, -1
9D00EBCC  A7C20022   SH V0, 34(S8)
942:                     }
943:                     #endif
944:                 
945:                     // Position the hardware write pointer where we will need to
946:                     // begin writing the IP header
947:                     MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D00EBD0  0F404508   JAL MACGetTxBaseAddr
9D00EBD4  00000000   NOP
9D00EBD8  2442000E   ADDIU V0, V0, 14
9D00EBDC  00402021   ADDU A0, V0, ZERO
9D00EBE0  0F40452C   JAL MACSetWritePtr
9D00EBE4  00000000   NOP
948:                 
949:                     // Write IP header to packet
950:                     IPPutHeader(&p->remote.remoteNode, IP_PROT_UDP, wUDPLength);
9D00EBE8  8FC30010   LW V1, 16(S8)
9D00EBEC  97C20014   LHU V0, 20(S8)
9D00EBF0  00602021   ADDU A0, V1, ZERO
9D00EBF4  24050011   ADDIU A1, ZERO, 17
9D00EBF8  00403021   ADDU A2, V0, ZERO
9D00EBFC  0F405FD5   JAL IPPutHeader
9D00EC00  00000000   NOP
951:                 
952:                     // Write UDP header to packet
953:                     MACPutArray((uint8_t*)&h, sizeof(h));
9D00EC04  27C2001C   ADDIU V0, S8, 28
9D00EC08  00402021   ADDU A0, V0, ZERO
9D00EC0C  24050008   ADDIU A1, ZERO, 8
9D00EC10  0F4045BD   JAL MACPutArray
9D00EC14  00000000   NOP
954:                 
955:                     // Calculate the final UDP checksum and write it in, if enabled
956:                     #if defined(UDP_USE_TX_CHECKSUM)
957:                     {
958:                         PTR_BASE    wReadPtrSave;
959:                         uint16_t        wChecksum;
960:                 
961:                         wReadPtrSave = MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9D00EC18  0F404508   JAL MACGetTxBaseAddr
9D00EC1C  00000000   NOP
9D00EC20  24420022   ADDIU V0, V0, 34
9D00EC24  00402021   ADDU A0, V0, ZERO
9D00EC28  0F4046B6   JAL MACSetReadPtr
9D00EC2C  00000000   NOP
9D00EC30  AFC20018   SW V0, 24(S8)
962:                         wChecksum = CalcIPBufferChecksum(wUDPLength);
9D00EC34  97C20014   LHU V0, 20(S8)
9D00EC38  00402021   ADDU A0, V0, ZERO
9D00EC3C  0F404733   JAL CalcIPBufferChecksum
9D00EC40  00000000   NOP
9D00EC44  A7C20030   SH V0, 48(S8)
963:                         if(wChecksum == 0x0000u)
9D00EC48  97C20030   LHU V0, 48(S8)
9D00EC4C  14400003   BNE V0, ZERO, 0x9D00EC5C
9D00EC50  00000000   NOP
964:                             wChecksum = 0xFFFF;
9D00EC54  2402FFFF   ADDIU V0, ZERO, -1
9D00EC58  A7C20030   SH V0, 48(S8)
965:                         MACSetReadPtr(wReadPtrSave);
9D00EC5C  8FC40018   LW A0, 24(S8)
9D00EC60  0F4046B6   JAL MACSetReadPtr
9D00EC64  00000000   NOP
966:                         MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 6);    // 6 is the offset to the Checksum field in UDP_HEADER
9D00EC68  0F404508   JAL MACGetTxBaseAddr
9D00EC6C  00000000   NOP
9D00EC70  24420028   ADDIU V0, V0, 40
9D00EC74  00402021   ADDU A0, V0, ZERO
9D00EC78  0F40452C   JAL MACSetWritePtr
9D00EC7C  00000000   NOP
967:                         MACPutArray((uint8_t*)&wChecksum, sizeof(wChecksum));
9D00EC80  27C20030   ADDIU V0, S8, 48
9D00EC84  00402021   ADDU A0, V0, ZERO
9D00EC88  24050002   ADDIU A1, ZERO, 2
9D00EC8C  0F4045BD   JAL MACPutArray
9D00EC90  00000000   NOP
968:                     }
969:                     #endif
970:                 
971:                     // Transmit the packet
972:                     MACFlush();
9D00EC94  0F40460E   JAL MACFlush
9D00EC98  00000000   NOP
973:                 
974:                     // Reset packet size counter for the next TX operation
975:                     UDPTxCount = 0;
9D00EC9C  A7808156   SH ZERO, -32426(GP)
976:                     LastPutSocket = INVALID_UDP_SOCKET;
9D00ECA0  2402FFFF   ADDIU V0, ZERO, -1
9D00ECA4  A3828016   SB V0, -32746(GP)
977:                 }
9D00ECA8  03C0E821   ADDU SP, S8, ZERO
9D00ECAC  8FBF003C   LW RA, 60(SP)
9D00ECB0  8FBE0038   LW S8, 56(SP)
9D00ECB4  27BD0040   ADDIU SP, SP, 64
9D00ECB8  03E00008   JR RA
9D00ECBC  00000000   NOP
978:                 
979:                 
980:                 
981:                 /****************************************************************************
982:                   Section:
983:                     Receive Functions
984:                   ***************************************************************************/
985:                 
986:                 /*****************************************************************************
987:                   Function:
988:                     uint16_t UDPIsGetReady(UDP_SOCKET s)
989:                 
990:                   Summary:
991:                     Determines how many bytes can be read from the UDP socket.
992:                 
993:                   Description:
994:                     This function determines if bytes can be read from the specified UDP
995:                     socket.  It also prepares the UDP module for reading by setting the
996:                     indicated socket as the currently active connection.
997:                 
998:                   Precondition:
999:                     UDPInit() must have been previously called.
1000:                
1001:                  Parameters:
1002:                    s - The socket to be made active (which has already been opened or is
1003:                        listening)
1004:                
1005:                  Returns:
1006:                    The number of bytes that can be read from this socket.
1007:                  ***************************************************************************/
1008:                uint16_t UDPIsGetReady(UDP_SOCKET s)
1009:                {
9D00ECC0  27BDFFE8   ADDIU SP, SP, -24
9D00ECC4  AFBF0014   SW RA, 20(SP)
9D00ECC8  AFBE0010   SW S8, 16(SP)
9D00ECCC  03A0F021   ADDU S8, SP, ZERO
9D00ECD0  00801021   ADDU V0, A0, ZERO
9D00ECD4  A3C20018   SB V0, 24(S8)
1010:                    activeUDPSocket = s;
9D00ECD8  93C20018   LBU V0, 24(S8)
9D00ECDC  A3828158   SB V0, -32424(GP)
1011:                    if(SocketWithRxData != s)
9D00ECE0  93828017   LBU V0, -32745(GP)
9D00ECE4  93C30018   LBU V1, 24(S8)
9D00ECE8  10620004   BEQ V1, V0, 0x9D00ECFC
9D00ECEC  00000000   NOP
1012:                        return 0;
9D00ECF0  00001021   ADDU V0, ZERO, ZERO
9D00ECF4  0B403B4E   J 0x9D00ED38
9D00ECF8  00000000   NOP
1013:                
1014:                    // If this is the very first time we are accessing this packet,
1015:                    // move the read point to the begining of the packet.
1016:                    if(Flags.bFirstRead)
9D00ECFC  93828054   LBU V0, -32684(GP)
9D00ED00  30420001   ANDI V0, V0, 1
9D00ED04  304200FF   ANDI V0, V0, 255
9D00ED08  10400007   BEQ V0, ZERO, 0x9D00ED28
9D00ED0C  00000000   NOP
1017:                    {
1018:                        Flags.bFirstRead = 0;
9D00ED10  93828054   LBU V0, -32684(GP)
9D00ED14  7C020004   INS V0, ZERO, 0, 1
9D00ED18  A3828054   SB V0, -32684(GP)
1019:                        UDPSetRxBuffer(0);
9D00ED1C  00002021   ADDU A0, ZERO, ZERO
9D00ED20  0F403A1B   JAL UDPSetRxBuffer
9D00ED24  00000000   NOP
1020:                    }
1021:                
1022:                    return UDPRxCount - wGetOffset;
9D00ED28  97838154   LHU V1, -32428(GP)
9D00ED2C  97828052   LHU V0, -32686(GP)
9D00ED30  00621023   SUBU V0, V1, V0
9D00ED34  3042FFFF   ANDI V0, V0, -1
1023:                }
9D00ED38  03C0E821   ADDU SP, S8, ZERO
9D00ED3C  8FBF0014   LW RA, 20(SP)
9D00ED40  8FBE0010   LW S8, 16(SP)
9D00ED44  27BD0018   ADDIU SP, SP, 24
9D00ED48  03E00008   JR RA
9D00ED4C  00000000   NOP
1024:                
1025:                /*****************************************************************************
1026:                  Function:
1027:                    bool UDPGet(uint8_t *v)
1028:                
1029:                  Summary:
1030:                    Reads a byte from the currently active socket.
1031:                
1032:                  Description:
1033:                    This function reads a single byte from the currently active UDP socket,
1034:                    while decrementing the remaining buffer length.  UDPIsGetReady should be
1035:                    used before calling this function to specify the currently active socket.
1036:                
1037:                  Precondition:
1038:                    UDPIsGetReady() was previously called to specify the current socket.
1039:                
1040:                  Parameters:
1041:                    v - The buffer to receive the data being read.
1042:                
1043:                  Return Values:
1044:                    true - A byte was successfully read
1045:                    false - No data remained in the read buffer
1046:                  ***************************************************************************/
1047:                bool UDPGet(uint8_t *v)
1048:                {
9D00ED50  27BDFFE8   ADDIU SP, SP, -24
9D00ED54  AFBF0014   SW RA, 20(SP)
9D00ED58  AFBE0010   SW S8, 16(SP)
9D00ED5C  03A0F021   ADDU S8, SP, ZERO
9D00ED60  AFC40018   SW A0, 24(S8)
1049:                    // Make sure that there is data to return
1050:                    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9D00ED64  97838052   LHU V1, -32686(GP)
9D00ED68  97828154   LHU V0, -32428(GP)
9D00ED6C  0062102B   SLTU V0, V1, V0
9D00ED70  10400005   BEQ V0, ZERO, 0x9D00ED88
9D00ED74  00000000   NOP
9D00ED78  93838017   LBU V1, -32745(GP)
9D00ED7C  93828158   LBU V0, -32424(GP)
9D00ED80  10620004   BEQ V1, V0, 0x9D00ED94
9D00ED84  00000000   NOP
1051:                        return false;
9D00ED88  00001021   ADDU V0, ZERO, ZERO
9D00ED8C  0B403B6F   J 0x9D00EDBC
9D00ED90  00000000   NOP
1052:                
1053:                    *v = MACGet();
9D00ED94  0F4046C4   JAL MACGet
9D00ED98  00000000   NOP
9D00ED9C  00401821   ADDU V1, V0, ZERO
9D00EDA0  8FC20018   LW V0, 24(S8)
9D00EDA4  A0430000   SB V1, 0(V0)
1054:                    wGetOffset++;
9D00EDA8  97828052   LHU V0, -32686(GP)
9D00EDAC  24420001   ADDIU V0, V0, 1
9D00EDB0  3042FFFF   ANDI V0, V0, -1
9D00EDB4  A7828052   SH V0, -32686(GP)
1055:                
1056:                    return true;
9D00EDB8  24020001   ADDIU V0, ZERO, 1
1057:                }
9D00EDBC  03C0E821   ADDU SP, S8, ZERO
9D00EDC0  8FBF0014   LW RA, 20(SP)
9D00EDC4  8FBE0010   LW S8, 16(SP)
9D00EDC8  27BD0018   ADDIU SP, SP, 24
9D00EDCC  03E00008   JR RA
9D00EDD0  00000000   NOP
1058:                
1059:                
1060:                /*****************************************************************************
1061:                  Function:
1062:                    uint16_t UDPGetArray(uint8_t *cData, uint16_t wDataLen)
1063:                
1064:                  Summary:
1065:                    Reads an array of bytes from the currently active socket.
1066:                
1067:                  Description:
1068:                    This function reads an array of bytes from the currently active UDP socket,
1069:                    while decrementing the remaining bytes available. UDPIsGetReady should be
1070:                    used before calling this function to specify the currently active socket.
1071:                
1072:                  Precondition:
1073:                    UDPIsGetReady() was previously called to specify the current socket.
1074:                
1075:                  Parameters:
1076:                    cData - The buffer to receive the bytes being read.  If NULL, the bytes are
1077:                            simply discarded without being written anywhere (effectively skips
1078:                            over the bytes in the RX buffer, although if you need to skip a lot
1079:                            of data, seeking using the UDPSetRxBuffer() will be more efficient).
1080:                    wDateLen - Number of bytes to be read from the socket.
1081:                
1082:                  Returns:
1083:                    The number of bytes successfully read from the UDP buffer.  If this
1084:                    value is less than wDataLen, then the buffer was emptied and no more
1085:                    data is available.
1086:                  ***************************************************************************/
1087:                uint16_t UDPGetArray(uint8_t *cData, uint16_t wDataLen)
1088:                {
9D00EDD4  27BDFFE0   ADDIU SP, SP, -32
9D00EDD8  AFBF001C   SW RA, 28(SP)
9D00EDDC  AFBE0018   SW S8, 24(SP)
9D00EDE0  03A0F021   ADDU S8, SP, ZERO
9D00EDE4  AFC40020   SW A0, 32(S8)
9D00EDE8  00A01021   ADDU V0, A1, ZERO
9D00EDEC  A7C20024   SH V0, 36(S8)
1089:                    uint16_t wBytesAvailable;
1090:                
1091:                    // Make sure that there is data to return
1092:                    if((wGetOffset >= UDPRxCount) || (SocketWithRxData != activeUDPSocket))
9D00EDF0  97838052   LHU V1, -32686(GP)
9D00EDF4  97828154   LHU V0, -32428(GP)
9D00EDF8  0062102B   SLTU V0, V1, V0
9D00EDFC  10400005   BEQ V0, ZERO, 0x9D00EE14
9D00EE00  00000000   NOP
9D00EE04  93838017   LBU V1, -32745(GP)
9D00EE08  93828158   LBU V0, -32424(GP)
9D00EE0C  10620004   BEQ V1, V0, 0x9D00EE20
9D00EE10  00000000   NOP
1093:                        return 0;
9D00EE14  00001021   ADDU V0, ZERO, ZERO
9D00EE18  0B403B9F   J 0x9D00EE7C
9D00EE1C  00000000   NOP
1094:                
1095:                    // Make sure we don't try to read more data than exists
1096:                    wBytesAvailable = UDPRxCount - wGetOffset;
9D00EE20  97838154   LHU V1, -32428(GP)
9D00EE24  97828052   LHU V0, -32686(GP)
9D00EE28  00621023   SUBU V0, V1, V0
9D00EE2C  A7C20010   SH V0, 16(S8)
1097:                    if(wBytesAvailable < wDataLen)
9D00EE30  97C30010   LHU V1, 16(S8)
9D00EE34  97C20024   LHU V0, 36(S8)
9D00EE38  0062102B   SLTU V0, V1, V0
9D00EE3C  10400003   BEQ V0, ZERO, 0x9D00EE4C
9D00EE40  00000000   NOP
1098:                        wDataLen = wBytesAvailable;
9D00EE44  97C20010   LHU V0, 16(S8)
9D00EE48  A7C20024   SH V0, 36(S8)
1099:                
1100:                    wDataLen = MACGetArray(cData, wDataLen);
9D00EE4C  97C20024   LHU V0, 36(S8)
9D00EE50  8FC40020   LW A0, 32(S8)
9D00EE54  00402821   ADDU A1, V0, ZERO
9D00EE58  0F4046D1   JAL MACGetArray
9D00EE5C  00000000   NOP
9D00EE60  A7C20024   SH V0, 36(S8)
1101:                    wGetOffset += wDataLen;
9D00EE64  97838052   LHU V1, -32686(GP)
9D00EE68  97C20024   LHU V0, 36(S8)
9D00EE6C  00621021   ADDU V0, V1, V0
9D00EE70  3042FFFF   ANDI V0, V0, -1
9D00EE74  A7828052   SH V0, -32686(GP)
1102:                
1103:                    return wDataLen;
9D00EE78  97C20024   LHU V0, 36(S8)
1104:                }
9D00EE7C  03C0E821   ADDU SP, S8, ZERO
9D00EE80  8FBF001C   LW RA, 28(SP)
9D00EE84  8FBE0018   LW S8, 24(SP)
9D00EE88  27BD0020   ADDIU SP, SP, 32
9D00EE8C  03E00008   JR RA
9D00EE90  00000000   NOP
1105:                
1106:                /*****************************************************************************
1107:                  Function:
1108:                    void UDPDiscard(void)
1109:                
1110:                  Summary:
1111:                    Discards any remaining RX data from a UDP socket.
1112:                
1113:                  Description:
1114:                    This function discards any remaining received data in the currently
1115:                    active UDP socket.
1116:                
1117:                  Precondition:
1118:                    UDPIsGetReady() was previously called to select the currently active
1119:                    socket.
1120:                
1121:                  Parameters:
1122:                    None
1123:                
1124:                  Returns:
1125:                    None
1126:                
1127:                  Remarks:
1128:                    It is safe to call this function more than is necessary.  If no data is
1129:                    available, this function does nothing.
1130:                  ***************************************************************************/
1131:                void UDPDiscard(void)
1132:                {
9D00EE94  27BDFFE8   ADDIU SP, SP, -24
9D00EE98  AFBF0014   SW RA, 20(SP)
9D00EE9C  AFBE0010   SW S8, 16(SP)
9D00EEA0  03A0F021   ADDU S8, SP, ZERO
1133:                    if(!Flags.bWasDiscarded)
9D00EEA4  93828054   LBU V0, -32684(GP)
9D00EEA8  30420002   ANDI V0, V0, 2
9D00EEAC  304200FF   ANDI V0, V0, 255
9D00EEB0  1440000A   BNE V0, ZERO, 0x9D00EEDC
9D00EEB4  00000000   NOP
1134:                    {
1135:                        MACDiscardRx();
9D00EEB8  0F40462A   JAL MACDiscardRx
9D00EEBC  00000000   NOP
1136:                        UDPRxCount = 0;
9D00EEC0  A7808154   SH ZERO, -32428(GP)
1137:                        SocketWithRxData = INVALID_UDP_SOCKET;
9D00EEC4  2402FFFF   ADDIU V0, ZERO, -1
9D00EEC8  A3828017   SB V0, -32745(GP)
1138:                        Flags.bWasDiscarded = 1;
9D00EECC  93828054   LBU V0, -32684(GP)
9D00EED0  24030001   ADDIU V1, ZERO, 1
9D00EED4  7C620844   INS V0, V1, 1, 1
9D00EED8  A3828054   SB V0, -32684(GP)
1139:                    }
1140:                }
9D00EEDC  03C0E821   ADDU SP, S8, ZERO
9D00EEE0  8FBF0014   LW RA, 20(SP)
9D00EEE4  8FBE0010   LW S8, 16(SP)
9D00EEE8  27BD0018   ADDIU SP, SP, 24
9D00EEEC  03E00008   JR RA
9D00EEF0  00000000   NOP
1141:                
1142:                
1143:                
1144:                /****************************************************************************
1145:                  Section:
1146:                    Data Processing Functions
1147:                  ***************************************************************************/
1148:                
1149:                /*****************************************************************************
1150:                  Function:
1151:                    bool UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, uint16_t len)
1152:                
1153:                  Summary:
1154:                    Handles an incoming UDP segment.
1155:                
1156:                  Description:
1157:                    This function handles an incoming UDP segment to determine if it is
1158:                    acceptable and should be handed to one of the stack applications for
1159:                    processing.
1160:                
1161:                  Precondition:
1162:                    UDPInit() has been called an a UDP segment is ready in the MAC buffer.
1163:                
1164:                  Parameters:
1165:                    remoteNode - The remote node that sent this segment.
1166:                    localIP - The destination IP address for this segment.
1167:                    len - Total length of the UDP segment.
1168:                
1169:                  Return Values:
1170:                    true - A valid packet is waiting and the stack applications should be
1171:                        called to handle it.
1172:                    false - The packet was discarded.
1173:                  ***************************************************************************/
1174:                bool UDPProcess(NODE_INFO *remoteNode, IP_ADDR *localIP, uint16_t len)
1175:                {
9D00EEF4  27BDFFC8   ADDIU SP, SP, -56
9D00EEF8  AFBF0034   SW RA, 52(SP)
9D00EEFC  AFBE0030   SW S8, 48(SP)
9D00EF00  03A0F021   ADDU S8, SP, ZERO
9D00EF04  AFC40038   SW A0, 56(S8)
9D00EF08  AFC5003C   SW A1, 60(S8)
9D00EF0C  00C01021   ADDU V0, A2, ZERO
9D00EF10  A7C20040   SH V0, 64(S8)
1176:                    UDP_HEADER      h;
1177:                    UDP_SOCKET      s;
1178:                    PSEUDO_HEADER   pseudoHeader;
1179:                    TCPIP_UINT32_VAL        checksums;
1180:                
1181:                    UDPRxCount = 0;
9D00EF14  A7808154   SH ZERO, -32428(GP)
1182:                
1183:                    // Retrieve UDP header.
1184:                    MACGetArray((uint8_t*)&h, sizeof(h));
9D00EF18  27C20014   ADDIU V0, S8, 20
9D00EF1C  00402021   ADDU A0, V0, ZERO
9D00EF20  24050008   ADDIU A1, ZERO, 8
9D00EF24  0F4046D1   JAL MACGetArray
9D00EF28  00000000   NOP
1185:                
1186:                    h.SourcePort        = swaps(h.SourcePort);
9D00EF2C  97C20014   LHU V0, 20(S8)
9D00EF30  00402021   ADDU A0, V0, ZERO
9D00EF34  0F403F50   JAL swaps
9D00EF38  00000000   NOP
9D00EF3C  A7C20014   SH V0, 20(S8)
1187:                    h.DestinationPort   = swaps(h.DestinationPort);
9D00EF40  97C20016   LHU V0, 22(S8)
9D00EF44  00402021   ADDU A0, V0, ZERO
9D00EF48  0F403F50   JAL swaps
9D00EF4C  00000000   NOP
9D00EF50  A7C20016   SH V0, 22(S8)
1188:                    h.Length            = swaps(h.Length) - sizeof(UDP_HEADER);
9D00EF54  97C20018   LHU V0, 24(S8)
9D00EF58  00402021   ADDU A0, V0, ZERO
9D00EF5C  0F403F50   JAL swaps
9D00EF60  00000000   NOP
9D00EF64  2442FFF8   ADDIU V0, V0, -8
9D00EF68  3042FFFF   ANDI V0, V0, -1
9D00EF6C  A7C20018   SH V0, 24(S8)
1189:                
1190:                    // See if we need to validate the checksum field (0x0000 is disabled)
1191:                    if(h.Checksum)
9D00EF70  97C2001A   LHU V0, 26(S8)
9D00EF74  1040002D   BEQ V0, ZERO, 0x9D00F02C
9D00EF78  00000000   NOP
1192:                    {
1193:                        // Calculate IP pseudoheader checksum.
1194:                        pseudoHeader.SourceAddress      = remoteNode->IPAddr;
9D00EF7C  8FC20038   LW V0, 56(S8)
9D00EF80  88430003   LWL V1, 3(V0)
9D00EF84  00602021   ADDU A0, V1, ZERO
9D00EF88  98440000   LWR A0, 0(V0)
9D00EF8C  00801021   ADDU V0, A0, ZERO
9D00EF90  AFC2001C   SW V0, 28(S8)
1195:                        pseudoHeader.DestAddress.Val    = localIP->Val;
9D00EF94  8FC2003C   LW V0, 60(S8)
9D00EF98  8C420000   LW V0, 0(V0)
9D00EF9C  AFC20020   SW V0, 32(S8)
1196:                        pseudoHeader.Zero               = 0x0;
9D00EFA0  A3C00024   SB ZERO, 36(S8)
1197:                        pseudoHeader.Protocol           = IP_PROT_UDP;
9D00EFA4  24020011   ADDIU V0, ZERO, 17
9D00EFA8  A3C20025   SB V0, 37(S8)
1198:                        pseudoHeader.Length             = len;
9D00EFAC  97C20040   LHU V0, 64(S8)
9D00EFB0  A7C20026   SH V0, 38(S8)
1199:                
1200:                        SwapPseudoHeader(pseudoHeader);
9D00EFB4  97C20026   LHU V0, 38(S8)
9D00EFB8  00402021   ADDU A0, V0, ZERO
9D00EFBC  0F403F50   JAL swaps
9D00EFC0  00000000   NOP
9D00EFC4  A7C20026   SH V0, 38(S8)
1201:                
1202:                        checksums.w[0] = ~CalcIPChecksum((uint8_t*)&pseudoHeader,
9D00EFC8  27C2001C   ADDIU V0, S8, 28
9D00EFCC  00402021   ADDU A0, V0, ZERO
9D00EFD0  2405000C   ADDIU A1, ZERO, 12
9D00EFD4  0F403F9D   JAL CalcIPChecksum
9D00EFD8  00000000   NOP
9D00EFDC  00021027   NOR V0, ZERO, V0
9D00EFE0  3042FFFF   ANDI V0, V0, -1
9D00EFE4  A7C20028   SH V0, 40(S8)
1203:                                                        sizeof(pseudoHeader));
1204:                
1205:                
1206:                        // Now calculate UDP packet checksum in NIC RAM -- should match pseudoHeader
1207:                        IPSetRxBuffer(0);
9D00EFE8  00002021   ADDU A0, ZERO, ZERO
9D00EFEC  0F406020   JAL IPSetRxBuffer
9D00EFF0  00000000   NOP
1208:                        checksums.w[1] = CalcIPBufferChecksum(len);
9D00EFF4  97C20040   LHU V0, 64(S8)
9D00EFF8  00402021   ADDU A0, V0, ZERO
9D00EFFC  0F404733   JAL CalcIPBufferChecksum
9D00F000  00000000   NOP
9D00F004  A7C2002A   SH V0, 42(S8)
1209:                
1210:                        if(checksums.w[0] != checksums.w[1])
9D00F008  97C30028   LHU V1, 40(S8)
9D00F00C  97C2002A   LHU V0, 42(S8)
9D00F010  10620006   BEQ V1, V0, 0x9D00F02C
9D00F014  00000000   NOP
1211:                        {
1212:                            MACDiscardRx();
9D00F018  0F40462A   JAL MACDiscardRx
9D00F01C  00000000   NOP
1213:                            return false;
9D00F020  00001021   ADDU V0, ZERO, ZERO
9D00F024  0B403C27   J 0x9D00F09C
9D00F028  00000000   NOP
1214:                        }
1215:                    }
1216:                
1217:                    s = FindMatchingSocket(&h, remoteNode, localIP);
9D00F02C  27C20014   ADDIU V0, S8, 20
9D00F030  00402021   ADDU A0, V0, ZERO
9D00F034  8FC50038   LW A1, 56(S8)
9D00F038  8FC6003C   LW A2, 60(S8)
9D00F03C  0F403C2D   JAL 0x9D00F0B4
9D00F040  00000000   NOP
9D00F044  A3C20010   SB V0, 16(S8)
1218:                    if(s == INVALID_UDP_SOCKET)
9D00F048  93C30010   LBU V1, 16(S8)
9D00F04C  240200FF   ADDIU V0, ZERO, 255
9D00F050  14620006   BNE V1, V0, 0x9D00F06C
9D00F054  00000000   NOP
1219:                    {
1220:                        // If there is no matching socket, There is no one to handle
1221:                        // this data.  Discard it.
1222:                        MACDiscardRx();
9D00F058  0F40462A   JAL MACDiscardRx
9D00F05C  00000000   NOP
1223:                        return false;
9D00F060  00001021   ADDU V0, ZERO, ZERO
9D00F064  0B403C27   J 0x9D00F09C
9D00F068  00000000   NOP
1224:                    }
1225:                    else
1226:                    {
1227:                        SocketWithRxData = s;
9D00F06C  93C20010   LBU V0, 16(S8)
9D00F070  A3828017   SB V0, -32745(GP)
1228:                        UDPRxCount = h.Length;
9D00F074  97C20018   LHU V0, 24(S8)
9D00F078  A7828154   SH V0, -32428(GP)
1229:                        Flags.bFirstRead = 1;
9D00F07C  93828054   LBU V0, -32684(GP)
9D00F080  24030001   ADDIU V1, ZERO, 1
9D00F084  7C620004   INS V0, V1, 0, 1
9D00F088  A3828054   SB V0, -32684(GP)
1230:                        Flags.bWasDiscarded = 0;
9D00F08C  93828054   LBU V0, -32684(GP)
9D00F090  7C020844   INS V0, ZERO, 1, 1
9D00F094  A3828054   SB V0, -32684(GP)
1231:                    }
1232:                
1233:                
1234:                    return true;
9D00F098  24020001   ADDIU V0, ZERO, 1
1235:                }
9D00F09C  03C0E821   ADDU SP, S8, ZERO
9D00F0A0  8FBF0034   LW RA, 52(SP)
9D00F0A4  8FBE0030   LW S8, 48(SP)
9D00F0A8  27BD0038   ADDIU SP, SP, 56
9D00F0AC  03E00008   JR RA
9D00F0B0  00000000   NOP
1236:                
1237:                /*****************************************************************************
1238:                  Function:
1239:                    static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h, NODE_INFO *remoteNode,
1240:                                                            IP_ADDR *localIP)
1241:                
1242:                  Summary:
1243:                    Matches an incoming UDP segment to a currently active socket.
1244:                
1245:                  Description:
1246:                    This function attempts to match an incoming UDP segment to a currently
1247:                    active socket for processing.
1248:                
1249:                  Precondition:
1250:                    UDP segment header and IP header have both been retrieved.
1251:                
1252:                  Parameters:
1253:                    h - The UDP header that was received.
1254:                    remoteNode - IP and MAC of the remote node that sent this segment.
1255:                    localIP - IP address that this segment was destined for.
1256:                
1257:                  Returns:
1258:                    A UDP_SOCKET handle of a matching socket, or INVALID_UDP_SOCKET when no
1259:                    match could be made.
1260:                  ***************************************************************************/
1261:                static UDP_SOCKET FindMatchingSocket(UDP_HEADER *h,
1262:                                                     NODE_INFO *remoteNode,
1263:                                                     IP_ADDR *localIP)
1264:                {
9D00F0B4  27BDFFE0   ADDIU SP, SP, -32
9D00F0B8  AFBF001C   SW RA, 28(SP)
9D00F0BC  AFBE0018   SW S8, 24(SP)
9D00F0C0  03A0F021   ADDU S8, SP, ZERO
9D00F0C4  AFC40020   SW A0, 32(S8)
9D00F0C8  AFC50024   SW A1, 36(S8)
9D00F0CC  AFC60028   SW A2, 40(S8)
1265:                    UDP_SOCKET s;
1266:                    UDP_SOCKET partialMatch;
1267:                    UDP_SOCKET_INFO *p;
1268:                
1269:                // This is commented out because most applications don't need this type of filtering.  It comes at a performance cost.
1270:                //  // Filter out unicast packets that aren't for our IP address, but accept
1271:                //  // all multicast and broadcast traffic
1272:                //  if(!((localIP->Val == AppConfig.MyIPAddr.Val) || (localIP->v[0] & 0x80) || (localIP->Val == (AppConfig.MyIPAddr.Val | (~AppConfig.MyMask.Val)))))
1273:                //      return INVALID_UDP_SOCKET;
1274:                
1275:                    // Discard any packets received that were generated by ourself.  In
1276:                    // structured Wi-Fi networks, the Access Point rebroadcasts our broadcast
1277:                    // and multicast packets, causing self-reception to occur unless filtered
1278:                    // out.
1279:                    if(remoteNode->IPAddr.Val == AppConfig.MyIPAddr.Val)
9D00F0D0  8FC20024   LW V0, 36(S8)
9D00F0D4  88430003   LWL V1, 3(V0)
9D00F0D8  98430000   LWR V1, 0(V0)
9D00F0DC  3C02A000   LUI V0, -24576
9D00F0E0  244408D8   ADDIU A0, V0, 2264
9D00F0E4  88840003   LWL A0, 3(A0)
9D00F0E8  00802821   ADDU A1, A0, ZERO
9D00F0EC  984508D8   LWR A1, 2264(V0)
9D00F0F0  00A01021   ADDU V0, A1, ZERO
9D00F0F4  14620004   BNE V1, V0, 0x9D00F108
9D00F0F8  00000000   NOP
1280:                        return INVALID_UDP_SOCKET;
9D00F0FC  240200FF   ADDIU V0, ZERO, 255
9D00F100  0B403C85   J 0x9D00F214
9D00F104  00000000   NOP
1281:                
1282:                    partialMatch = INVALID_UDP_SOCKET;
9D00F108  2402FFFF   ADDIU V0, ZERO, -1
9D00F10C  A3C20011   SB V0, 17(S8)
1283:                
1284:                    p = UDPSocketInfo;
9D00F110  3C02A000   LUI V0, -24576
9D00F114  24420388   ADDIU V0, V0, 904
9D00F118  AFC20014   SW V0, 20(S8)
1285:                    for(s = 0; s < MAX_UDP_SOCKETS; s++)
9D00F11C  A3C00010   SB ZERO, 16(S8)
9D00F120  0B403C6A   J 0x9D00F1A8
9D00F124  00000000   NOP
9D00F19C  93C20010   LBU V0, 16(S8)
9D00F1A0  24420001   ADDIU V0, V0, 1
9D00F1A4  A3C20010   SB V0, 16(S8)
9D00F1A8  93C20010   LBU V0, 16(S8)
9D00F1AC  2C42000A   SLTIU V0, V0, 10
9D00F1B0  1440FFDD   BNE V0, ZERO, 0x9D00F128
9D00F1B4  00000000   NOP
1286:                    {
1287:                        // This packet is said to be matching with current socket:
1288:                        // 1. If its destination port matches with our local port and
1289:                        // 2. Packet source IP address matches with previously saved socket remote IP address and
1290:                        // 3. Packet source port number matches with previously saved socket remote port number
1291:                        if(p->localPort == h->DestinationPort)
9D00F128  8FC20014   LW V0, 20(S8)
9D00F12C  9443000E   LHU V1, 14(V0)
9D00F130  8FC20020   LW V0, 32(S8)
9D00F134  94420002   LHU V0, 2(V0)
9D00F138  14620015   BNE V1, V0, 0x9D00F190
9D00F13C  00000000   NOP
1292:                        {
1293:                            if(p->remotePort == h->SourcePort)
9D00F140  8FC20014   LW V0, 20(S8)
9D00F144  9443000C   LHU V1, 12(V0)
9D00F148  8FC20020   LW V0, 32(S8)
9D00F14C  94420000   LHU V0, 0(V0)
9D00F150  1462000D   BNE V1, V0, 0x9D00F188
9D00F154  00000000   NOP
1294:                            {
1295:                                if(p->remote.remoteNode.IPAddr.Val == remoteNode->IPAddr.Val)
9D00F158  8FC20014   LW V0, 20(S8)
9D00F15C  8C430000   LW V1, 0(V0)
9D00F160  8FC20024   LW V0, 36(S8)
9D00F164  88440003   LWL A0, 3(V0)
9D00F168  00802821   ADDU A1, A0, ZERO
9D00F16C  98450000   LWR A1, 0(V0)
9D00F170  00A01021   ADDU V0, A1, ZERO
9D00F174  14620004   BNE V1, V0, 0x9D00F188
9D00F178  00000000   NOP
1296:                                {
1297:                                    return s;
9D00F17C  93C20010   LBU V0, 16(S8)
9D00F180  0B403C85   J 0x9D00F214
9D00F184  00000000   NOP
1298:                                }
1299:                            }
1300:                
1301:                            partialMatch = s;
9D00F188  93C20010   LBU V0, 16(S8)
9D00F18C  A3C20011   SB V0, 17(S8)
1302:                        }
1303:                        p++;
9D00F190  8FC20014   LW V0, 20(S8)
9D00F194  2442001C   ADDIU V0, V0, 28
9D00F198  AFC20014   SW V0, 20(S8)
1304:                    }
1305:                
1306:                    if(partialMatch != INVALID_UDP_SOCKET)
9D00F1B8  93C30011   LBU V1, 17(S8)
9D00F1BC  240200FF   ADDIU V0, ZERO, 255
9D00F1C0  10620013   BEQ V1, V0, 0x9D00F210
9D00F1C4  00000000   NOP
1307:                    {
1308:                        p = &UDPSocketInfo[partialMatch];
9D00F1C8  93C20011   LBU V0, 17(S8)
9D00F1CC  00021080   SLL V0, V0, 2
9D00F1D0  000218C0   SLL V1, V0, 3
9D00F1D4  00621823   SUBU V1, V1, V0
9D00F1D8  3C02A000   LUI V0, -24576
9D00F1DC  24420388   ADDIU V0, V0, 904
9D00F1E0  00621021   ADDU V0, V1, V0
9D00F1E4  AFC20014   SW V0, 20(S8)
1309:                
1310:                        memcpy((void*)&p->remote.remoteNode,
9D00F1E8  8FC20014   LW V0, 20(S8)
9D00F1EC  00402021   ADDU A0, V0, ZERO
9D00F1F0  8FC50024   LW A1, 36(S8)
9D00F1F4  2406000A   ADDIU A2, ZERO, 10
9D00F1F8  0F406788   JAL 0x9D019E20
9D00F1FC  00000000   NOP
1311:                                (const void*)remoteNode, sizeof(p->remote.remoteNode) );
1312:                
1313:                        p->remotePort = h->SourcePort;
9D00F200  8FC20020   LW V0, 32(S8)
9D00F204  94430000   LHU V1, 0(V0)
9D00F208  8FC20014   LW V0, 20(S8)
9D00F20C  A443000C   SH V1, 12(V0)
1314:                    }
1315:                
1316:                    return partialMatch;
9D00F210  93C20011   LBU V0, 17(S8)
1317:                }
9D00F214  03C0E821   ADDU SP, S8, ZERO
9D00F218  8FBF001C   LW RA, 28(SP)
9D00F21C  8FBE0018   LW S8, 24(SP)
9D00F220  27BD0020   ADDIU SP, SP, 32
9D00F224  03E00008   JR RA
9D00F228  00000000   NOP
1318:                
1319:                #endif //#if defined(STACK_USE_UDP)
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/tick.c  ---------------------------------
1:                   /**
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       tick.c
7:                   
8:                     Summary:
9:                   
10:                  
11:                    Description:
12:                      Tick Manager for Timekeeping
13:                  
14:                   */
15:                  
16:                  //DOM-IGNORE-BEGIN
17:                  /*******************************************************************************
18:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
19:                  
20:                  Microchip licenses to you the right to use, modify, copy and distribute
21:                  Software only when embedded on a Microchip microcontroller or digital signal
22:                  controller that is integrated into your product or third party product
23:                  (pursuant to the sublicense terms in the accompanying license agreement).
24:                  
25:                  You should refer to the license agreement accompanying this Software for
26:                  additional information regarding your rights and obligations.
27:                  
28:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
29:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
30:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
31:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
32:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
33:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
34:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
35:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
36:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
37:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
38:                   *******************************************************************************/
39:                  //DOM-IGNORE-END
40:                  
41:                  #define __TICK_C_
42:                  
43:                  #include "tcpip/tcpip.h"
44:                  
45:                  // Internal counter to store Ticks.  This variable is incremented in an ISR and
46:                  // therefore must be marked volatile to prevent the compiler optimizer from
47:                  // reordering code to use this value in the main context while interrupts are
48:                  // disabled.
49:                  static volatile uint32_t dwInternalTicks = 0;
50:                  
51:                  // 6-byte value to store Ticks.  Allows for use over longer periods of time.
52:                  static volatile uint8_t vTickReading[6] __attribute__ ((aligned));
53:                  
54:                  static void GetTickCopy(void);
55:                  
56:                  
57:                  /*****************************************************************************
58:                    Function:
59:                      void TickInit(void)
60:                  
61:                    Summary:
62:                      Initializes the Tick manager module.
63:                  
64:                    Description:
65:                      Configures the Tick module and any necessary hardware resources.
66:                  
67:                    Precondition:
68:                      None
69:                  
70:                    Parameters:
71:                      None
72:                  
73:                    Returns:
74:                      None
75:                  
76:                    Remarks:
77:                      This function is called only one during lifetime of the application.
78:                    ***************************************************************************/
79:                  void TickInit(void)
80:                  {
9D016FC4  27BDFFF8   ADDIU SP, SP, -8
9D016FC8  AFBE0004   SW S8, 4(SP)
9D016FCC  03A0F021   ADDU S8, SP, ZERO
81:                  #if defined(__XC8)
82:                      // Use Timer0 for 8 bit processors
83:                      // Initialize the time
84:                      TMR0H = 0;
85:                      TMR0L = 0;
86:                  
87:                      // Set up the timer interrupt
88:                      INTCON2bits.TMR0IP = 0;     // Low priority
89:                      INTCONbits.TMR0IF = 0;
90:                      INTCONbits.TMR0IE = 1;      // Enable interrupt
91:                  
92:                      // Timer0 on, 16-bit, internal timer, 1:256 prescalar
93:                      T0CON = 0x87;
94:                  
95:                  #else
96:                      // Use Timer 1 for 16-bit and 32-bit processors
97:                      // 1:256 prescale
98:                      T1CONbits.TCKPS = 3;
9D016FD0  3C03BF80   LUI V1, -16512
9D016FD4  8C620600   LW V0, 1536(V1)
9D016FD8  24040003   ADDIU A0, ZERO, 3
9D016FDC  7C822904   INS V0, A0, 4, 2
9D016FE0  AC620600   SW V0, 1536(V1)
99:                      // Base
100:                     PR1 = 0xFFFF;
9D016FE4  3C02BF80   LUI V0, -16512
9D016FE8  3403FFFF   ORI V1, ZERO, -1
9D016FEC  AC430620   SW V1, 1568(V0)
101:                     // Clear counter
102:                     TMR1 = 0;
9D016FF0  3C02BF80   LUI V0, -16512
9D016FF4  AC400610   SW ZERO, 1552(V0)
103:                 
104:                     // Enable timer interrupt
105:                     #if defined(__XC16)
106:                         IPC0bits.T1IP = 2;  // Interrupt priority 2 (low)
107:                         IFS0bits.T1IF = 0;
108:                         IEC0bits.T1IE = 1;
109:                     #else
110:                         IPC1bits.T1IP = 2;  // Interrupt priority 2 (low)
9D016FF8  3C03BF88   LUI V1, -16504
9D016FFC  8C6210A0   LW V0, 4256(V1)
9D017000  24040002   ADDIU A0, ZERO, 2
9D017004  7C822084   INS V0, A0, 2, 3
9D017008  AC6210A0   SW V0, 4256(V1)
111:                         IFS0CLR = _IFS0_T1IF_MASK;
9D01700C  3C02BF88   LUI V0, -16504
9D017010  24030010   ADDIU V1, ZERO, 16
9D017014  AC431034   SW V1, 4148(V0)
112:                         IEC0SET = _IEC0_T1IE_MASK;
9D017018  3C02BF88   LUI V0, -16504
9D01701C  24030010   ADDIU V1, ZERO, 16
9D017020  AC431068   SW V1, 4200(V0)
113:                     #endif
114:                 
115:                     // Start timer
116:                     T1CONbits.TON = 1;
9D017024  3C03BF80   LUI V1, -16512
9D017028  8C620600   LW V0, 1536(V1)
9D01702C  24040001   ADDIU A0, ZERO, 1
9D017030  7C827BC4   INS V0, A0, 15, 1
9D017034  AC620600   SW V0, 1536(V1)
117:                 #endif
118:                 }
9D017038  03C0E821   ADDU SP, S8, ZERO
9D01703C  8FBE0004   LW S8, 4(SP)
9D017040  27BD0008   ADDIU SP, SP, 8
9D017044  03E00008   JR RA
9D017048  00000000   NOP
119:                 
120:                 /*****************************************************************************
121:                   Function:
122:                     static void GetTickCopy(void)
123:                 
124:                   Summary:
125:                     Reads the tick value.
126:                 
127:                   Description:
128:                     This function performs an interrupt-safe and synchronized read of the
129:                     48-bit Tick value.
130:                 
131:                   Precondition:
132:                     None
133:                 
134:                   Parameters:
135:                     None
136:                 
137:                   Returns:
138:                     None
139:                   ***************************************************************************/
140:                 static void GetTickCopy(void)
141:                 {
9D01704C  27BDFFF0   ADDIU SP, SP, -16
9D017050  AFBE000C   SW S8, 12(SP)
9D017054  03A0F021   ADDU S8, SP, ZERO
142:                     // Perform an Interrupt safe and synchronized read of the 48-bit
143:                     // tick value
144:                 #if defined(__XC8)
145:                     do
146:                     {
147:                         INTCONbits.TMR0IE = 1;      // Enable interrupt
148:                         Nop();
149:                         INTCONbits.TMR0IE = 0;      // Disable interrupt
150:                         vTickReading[0] = TMR0L;
151:                         vTickReading[1] = TMR0H;
152:                         *((uint32_t*)&vTickReading[2]) = dwInternalTicks;
153:                     } while(INTCONbits.TMR0IF);
154:                     INTCONbits.TMR0IE = 1;          // Enable interrupt
155:                 #elif defined(__XC16)
156:                     do
157:                     {
158:                         uint32_t dwTempTicks;
159:                         TCPIP_UINT16_VAL wTemp;
160:                 
161:                         IEC0bits.T1IE = 1;          // Enable interrupt
162:                         Nop();
163:                         IEC0bits.T1IE = 0;          // Disable interrupt
164:                 
165:                         // Get low 2 bytes
166:                         wTemp.Val = TMR1;
167:                         vTickReading[0] = wTemp.v[0];
168:                         vTickReading[1] = wTemp.v[1];
169:                         //((uint16_t*)vTickReading)[0] = TMR1;
170:                 
171:                         // Correct corner case where interrupt increments byte[4+] but
172:                         // TMR1 hasn't rolled over to 0x0000 yet
173:                         dwTempTicks = dwInternalTicks;
174:                         //if(((uint16_t*)vTickReading)[0] == 0xFFFFu)
175:                         if(wTemp.Val == 0xFFFFu)
176:                             dwTempTicks--;
177:                 
178:                         // Get high 4 bytes
179:                         vTickReading[2] = ((uint8_t*)&dwTempTicks)[0];
180:                         vTickReading[3] = ((uint8_t*)&dwTempTicks)[1];
181:                         vTickReading[4] = ((uint8_t*)&dwTempTicks)[2];
182:                         vTickReading[5] = ((uint8_t*)&dwTempTicks)[3];
183:                     } while(IFS0bits.T1IF);
184:                     IEC0bits.T1IE = 1;              // Enable interrupt
185:                 #else   // PIC32
186:                     do
187:                     {
188:                         uint32_t dwTempTicks;
189:                         TCPIP_UINT16_VAL wTemp;
190:                 
191:                         IEC0SET = _IEC0_T1IE_MASK;  // Enable interrupt
9D017058  3C02BF88   LUI V0, -16504
9D01705C  24030010   ADDIU V1, ZERO, 16
9D017060  AC431068   SW V1, 4200(V0)
192:                         Nop();
9D017064  00000040   SSNOP
193:                         IEC0CLR = _IEC0_T1IE_MASK;  // Disable interrupt
9D017068  3C02BF88   LUI V0, -16504
9D01706C  24030010   ADDIU V1, ZERO, 16
9D017070  AC431064   SW V1, 4196(V0)
194:                 
195:                         // Get low 2 bytes
196:                         wTemp.Val = TMR1;
9D017074  3C02BF80   LUI V0, -16512
9D017078  8C420610   LW V0, 1552(V0)
9D01707C  3042FFFF   ANDI V0, V0, -1
9D017080  A7C20004   SH V0, 4(S8)
197:                         vTickReading[0] = wTemp.v[0];
9D017084  93C20004   LBU V0, 4(S8)
9D017088  A3828048   SB V0, -32696(GP)
198:                         vTickReading[1] = wTemp.v[1];
9D01708C  93C20005   LBU V0, 5(S8)
9D017090  A3828049   SB V0, -32695(GP)
199:                         //((volatile uint16_t*)vTickReading)[0] = TMR1;
200:                 
201:                         // Correct corner case where interrupt increments byte[4+] but
202:                         // TMR1 hasn't rolled over to 0x0000 yet
203:                         dwTempTicks = dwInternalTicks;
9D017094  8F828040   LW V0, -32704(GP)
9D017098  AFC20000   SW V0, 0(S8)
204:                 
205:                         // PIC32MX3XX/4XX devices trigger the timer interrupt when TMR1 == PR1
206:                         // (TMR1 prescalar is 0x00), requiring us to undo the ISR's increment
207:                         // of the upper 32 bits of our 48 bit timer in the special case when
208:                         // TMR1 == PR1 == 0xFFFF.  For other PIC32 families, the ISR is
209:                         // triggered when TMR1 increments from PR1 to 0x0000, making no special
210:                         // corner case.
211:                         #if __PIC32_FEATURE_SET__ <= 460
212:                             //if(((uint16_t*)vTickReading)[0] == 0xFFFFu)
213:                             if(wTemp.Val == 0xFFFFu)
214:                                 dwTempTicks--;
215:                         #elif !defined(__PIC32_FEATURE_SET__)
216:                             #error __PIC32_FEATURE_SET__ macro must be defined.  You need to download a newer C32 compiler version.
217:                         #endif
218:                 
219:                         // Get high 4 bytes
220:                         vTickReading[2] = ((uint8_t*)&dwTempTicks)[0];
9D01709C  03C01021   ADDU V0, S8, ZERO
9D0170A0  90420000   LBU V0, 0(V0)
9D0170A4  A382804A   SB V0, -32694(GP)
221:                         vTickReading[3] = ((uint8_t*)&dwTempTicks)[1];
9D0170A8  03C01021   ADDU V0, S8, ZERO
9D0170AC  24420001   ADDIU V0, V0, 1
9D0170B0  90420000   LBU V0, 0(V0)
9D0170B4  A382804B   SB V0, -32693(GP)
222:                         vTickReading[4] = ((uint8_t*)&dwTempTicks)[2];
9D0170B8  03C01021   ADDU V0, S8, ZERO
9D0170BC  24420002   ADDIU V0, V0, 2
9D0170C0  90420000   LBU V0, 0(V0)
9D0170C4  A382804C   SB V0, -32692(GP)
223:                         vTickReading[5] = ((uint8_t*)&dwTempTicks)[3];
9D0170C8  03C01021   ADDU V0, S8, ZERO
9D0170CC  24420003   ADDIU V0, V0, 3
9D0170D0  90420000   LBU V0, 0(V0)
9D0170D4  A382804D   SB V0, -32691(GP)
224:                     } while(IFS0bits.T1IF);
9D0170D8  3C02BF88   LUI V0, -16504
9D0170DC  8C421030   LW V0, 4144(V0)
9D0170E0  30420010   ANDI V0, V0, 16
9D0170E4  1440FFDC   BNE V0, ZERO, 0x9D017058
9D0170E8  00000000   NOP
225:                     IEC0SET = _IEC0_T1IE_MASK;      // Enable interrupt
9D0170EC  3C02BF88   LUI V0, -16504
9D0170F0  24030010   ADDIU V1, ZERO, 16
9D0170F4  AC431068   SW V1, 4200(V0)
226:                 #endif
227:                 }
9D0170F8  03C0E821   ADDU SP, S8, ZERO
9D0170FC  8FBE000C   LW S8, 12(SP)
9D017100  03E00008   JR RA
9D017104  27BD0010   ADDIU SP, SP, 16
228:                 
229:                 
230:                 /*****************************************************************************
231:                   Function:
232:                     uint32_t TickGet(void)
233:                 
234:                   Summary:
235:                     Obtains the current Tick value.
236:                 
237:                   Description:
238:                     This function retrieves the current Tick value, allowing timing and
239:                     measurement code to be written in a non-blocking fashion.  This function
240:                     retrieves the least significant 32 bits of the internal tick counter,
241:                     and is useful for measuring time increments ranging from a few
242:                     microseconds to a few hours.  Use TickGetDiv256 or TickGetDiv64K for
243:                     longer periods of time.
244:                 
245:                   Precondition:
246:                     None
247:                 
248:                   Parameters:
249:                     None
250:                 
251:                   Returns:
252:                     Lower 32 bits of the current Tick value.
253:                   ***************************************************************************/
254:                 uint32_t TickGet(void)
255:                 {
9D017108  27BDFFE0   ADDIU SP, SP, -32
9D01710C  AFBF001C   SW RA, 28(SP)
9D017110  AFBE0018   SW S8, 24(SP)
9D017114  03A0F021   ADDU S8, SP, ZERO
256:                     uint32_t dw;
257:                 
258:                     GetTickCopy();
9D017118  0F405C13   JAL 0x9D01704C
9D01711C  00000000   NOP
259:                     ((uint8_t*)&dw)[0] = vTickReading[0];   // Note: This copy must be done one
9D017120  27C20010   ADDIU V0, S8, 16
9D017124  93838048   LBU V1, -32696(GP)
9D017128  306300FF   ANDI V1, V1, 255
9D01712C  A0430000   SB V1, 0(V0)
260:                     ((uint8_t*)&dw)[1] = vTickReading[1];   // byte at a time to prevent misaligned
9D017130  27C20010   ADDIU V0, S8, 16
9D017134  24420001   ADDIU V0, V0, 1
9D017138  93838049   LBU V1, -32695(GP)
9D01713C  306300FF   ANDI V1, V1, 255
9D017140  A0430000   SB V1, 0(V0)
261:                     ((uint8_t*)&dw)[2] = vTickReading[2];   // memory reads, which will reset the PIC.
9D017144  27C20010   ADDIU V0, S8, 16
9D017148  24420002   ADDIU V0, V0, 2
9D01714C  9383804A   LBU V1, -32694(GP)
9D017150  306300FF   ANDI V1, V1, 255
9D017154  A0430000   SB V1, 0(V0)
262:                     ((uint8_t*)&dw)[3] = vTickReading[3];
9D017158  27C20010   ADDIU V0, S8, 16
9D01715C  24420003   ADDIU V0, V0, 3
9D017160  9383804B   LBU V1, -32693(GP)
9D017164  306300FF   ANDI V1, V1, 255
9D017168  A0430000   SB V1, 0(V0)
263:                     return dw;
9D01716C  8FC20010   LW V0, 16(S8)
264:                 }
9D017170  03C0E821   ADDU SP, S8, ZERO
9D017174  8FBF001C   LW RA, 28(SP)
9D017178  8FBE0018   LW S8, 24(SP)
9D01717C  27BD0020   ADDIU SP, SP, 32
9D017180  03E00008   JR RA
9D017184  00000000   NOP
265:                 
266:                 /*****************************************************************************
267:                   Function:
268:                     uint32_t TickGetDiv256(void)
269:                 
270:                   Summary:
271:                     Obtains the current Tick value divided by 256.
272:                 
273:                   Description:
274:                     This function retrieves the current Tick value, allowing timing and
275:                     measurement code to be written in a non-blocking fashion.  This function
276:                     retrieves the middle 32 bits of the internal tick counter,
277:                     and is useful for measuring time increments ranging from a few
278:                     minutes to a few weeks.  Use TickGet for shorter periods or TickGetDiv64K
279:                     for longer ones.
280:                 
281:                   Precondition:
282:                     None
283:                 
284:                   Parameters:
285:                     None
286:                 
287:                   Returns:
288:                     Middle 32 bits of the current Tick value.
289:                   ***************************************************************************/
290:                 uint32_t TickGetDiv256(void)
291:                 {
9D017188  27BDFFE0   ADDIU SP, SP, -32
9D01718C  AFBF001C   SW RA, 28(SP)
9D017190  AFBE0018   SW S8, 24(SP)
9D017194  03A0F021   ADDU S8, SP, ZERO
292:                     uint32_t dw;
293:                 
294:                     GetTickCopy();
9D017198  0F405C13   JAL 0x9D01704C
9D01719C  00000000   NOP
295:                     ((uint8_t*)&dw)[0] = vTickReading[1];   // Note: This copy must be done one
9D0171A0  27C20010   ADDIU V0, S8, 16
9D0171A4  93838049   LBU V1, -32695(GP)
9D0171A8  306300FF   ANDI V1, V1, 255
9D0171AC  A0430000   SB V1, 0(V0)
296:                     ((uint8_t*)&dw)[1] = vTickReading[2];   // byte at a time to prevent misaligned
9D0171B0  27C20010   ADDIU V0, S8, 16
9D0171B4  24420001   ADDIU V0, V0, 1
9D0171B8  9383804A   LBU V1, -32694(GP)
9D0171BC  306300FF   ANDI V1, V1, 255
9D0171C0  A0430000   SB V1, 0(V0)
297:                     ((uint8_t*)&dw)[2] = vTickReading[3];   // memory reads, which will reset the PIC.
9D0171C4  27C20010   ADDIU V0, S8, 16
9D0171C8  24420002   ADDIU V0, V0, 2
9D0171CC  9383804B   LBU V1, -32693(GP)
9D0171D0  306300FF   ANDI V1, V1, 255
9D0171D4  A0430000   SB V1, 0(V0)
298:                     ((uint8_t*)&dw)[3] = vTickReading[4];
9D0171D8  27C20010   ADDIU V0, S8, 16
9D0171DC  24420003   ADDIU V0, V0, 3
9D0171E0  9383804C   LBU V1, -32692(GP)
9D0171E4  306300FF   ANDI V1, V1, 255
9D0171E8  A0430000   SB V1, 0(V0)
299:                 
300:                     return dw;
9D0171EC  8FC20010   LW V0, 16(S8)
301:                 }
9D0171F0  03C0E821   ADDU SP, S8, ZERO
9D0171F4  8FBF001C   LW RA, 28(SP)
9D0171F8  8FBE0018   LW S8, 24(SP)
9D0171FC  27BD0020   ADDIU SP, SP, 32
9D017200  03E00008   JR RA
9D017204  00000000   NOP
302:                 
303:                 /*****************************************************************************
304:                   Function:
305:                     uint32_t TickGetDiv64K(void)
306:                 
307:                   Summary:
308:                     Obtains the current Tick value divided by 64K.
309:                 
310:                   Description:
311:                     This function retrieves the current Tick value, allowing timing and
312:                     measurement code to be written in a non-blocking fashion.  This function
313:                     retrieves the most significant 32 bits of the internal tick counter,
314:                     and is useful for measuring time increments ranging from a few
315:                     days to a few years, or for absolute time measurements.  Use TickGet or
316:                     TickGetDiv256 for shorter periods of time.
317:                 
318:                   Precondition:
319:                     None
320:                 
321:                   Parameters:
322:                     None
323:                 
324:                   Returns:
325:                     Upper 32 bits of the current Tick value.
326:                   ***************************************************************************/
327:                 uint32_t TickGetDiv64K(void)
328:                 {
9D017208  27BDFFE0   ADDIU SP, SP, -32
9D01720C  AFBF001C   SW RA, 28(SP)
9D017210  AFBE0018   SW S8, 24(SP)
9D017214  03A0F021   ADDU S8, SP, ZERO
329:                     uint32_t dw;
330:                 
331:                     GetTickCopy();
9D017218  0F405C13   JAL 0x9D01704C
9D01721C  00000000   NOP
332:                     ((uint8_t*)&dw)[0] = vTickReading[2];   // Note: This copy must be done one
9D017220  27C20010   ADDIU V0, S8, 16
9D017224  9383804A   LBU V1, -32694(GP)
9D017228  306300FF   ANDI V1, V1, 255
9D01722C  A0430000   SB V1, 0(V0)
333:                     ((uint8_t*)&dw)[1] = vTickReading[3];   // byte at a time to prevent misaligned
9D017230  27C20010   ADDIU V0, S8, 16
9D017234  24420001   ADDIU V0, V0, 1
9D017238  9383804B   LBU V1, -32693(GP)
9D01723C  306300FF   ANDI V1, V1, 255
9D017240  A0430000   SB V1, 0(V0)
334:                     ((uint8_t*)&dw)[2] = vTickReading[4];   // memory reads, which will reset the PIC.
9D017244  27C20010   ADDIU V0, S8, 16
9D017248  24420002   ADDIU V0, V0, 2
9D01724C  9383804C   LBU V1, -32692(GP)
9D017250  306300FF   ANDI V1, V1, 255
9D017254  A0430000   SB V1, 0(V0)
335:                     ((uint8_t*)&dw)[3] = vTickReading[5];
9D017258  27C20010   ADDIU V0, S8, 16
9D01725C  24420003   ADDIU V0, V0, 3
9D017260  9383804D   LBU V1, -32691(GP)
9D017264  306300FF   ANDI V1, V1, 255
9D017268  A0430000   SB V1, 0(V0)
336:                 
337:                     return dw;
9D01726C  8FC20010   LW V0, 16(S8)
338:                 }
9D017270  03C0E821   ADDU SP, S8, ZERO
9D017274  8FBF001C   LW RA, 28(SP)
9D017278  8FBE0018   LW S8, 24(SP)
9D01727C  27BD0020   ADDIU SP, SP, 32
9D017280  03E00008   JR RA
9D017284  00000000   NOP
339:                 
340:                 
341:                 /*****************************************************************************
342:                   Function:
343:                     uint32_t TickConvertToMilliseconds(uint32_t dwTickValue)
344:                 
345:                   Summary:
346:                     Converts a Tick value or difference to milliseconds.
347:                 
348:                   Description:
349:                     This function converts a Tick value or difference to milliseconds.  For
350:                     example, TickConvertToMilliseconds(32768) returns 1000 when a 32.768kHz
351:                     clock with no prescaler drives the Tick module interrupt.
352:                 
353:                   Precondition:
354:                     None
355:                 
356:                   Parameters:
357:                     dwTickValue - Value to convert to milliseconds
358:                 
359:                   Returns:
360:                     Input value expressed in milliseconds.
361:                 
362:                   Remarks:
363:                     This function performs division on DWORDs, which is slow.  Avoid using
364:                     it unless you absolutely must (such as displaying data to a user).  For
365:                     timeout comparisons, compare the current value to a multiple or fraction
366:                     of TICK_SECOND, which will be calculated only once at compile time.
367:                   ***************************************************************************/
368:                 uint32_t TickConvertToMilliseconds(uint32_t dwTickValue)
369:                 {
9D017288  27BDFFE8   ADDIU SP, SP, -24
9D01728C  AFBF0014   SW RA, 20(SP)
9D017290  AFBE0010   SW S8, 16(SP)
9D017294  03A0F021   ADDU S8, SP, ZERO
9D017298  AFC40018   SW A0, 24(S8)
370:                     return (dwTickValue+(TICKS_PER_SECOND/2000ul))/((uint32_t)(TICKS_PER_SECOND/1000ul));
9D01729C  8FC60018   LW A2, 24(S8)
9D0172A0  00003821   ADDU A3, ZERO, ZERO
9D0172A4  2404009C   ADDIU A0, ZERO, 156
9D0172A8  00002821   ADDU A1, ZERO, ZERO
9D0172AC  00C41021   ADDU V0, A2, A0
9D0172B0  0046402B   SLTU T0, V0, A2
9D0172B4  00E51821   ADDU V1, A3, A1
9D0172B8  01032021   ADDU A0, T0, V1
9D0172BC  00801821   ADDU V1, A0, ZERO
9D0172C0  00402021   ADDU A0, V0, ZERO
9D0172C4  00602821   ADDU A1, V1, ZERO
9D0172C8  24060138   ADDIU A2, ZERO, 312
9D0172CC  00003821   ADDU A3, ZERO, ZERO
9D0172D0  0F4056D8   JAL __udivdi3
9D0172D4  00000000   NOP
371:                 }
9D0172D8  03C0E821   ADDU SP, S8, ZERO
9D0172DC  8FBF0014   LW RA, 20(SP)
9D0172E0  8FBE0010   LW S8, 16(SP)
9D0172E4  27BD0018   ADDIU SP, SP, 24
9D0172E8  03E00008   JR RA
9D0172EC  00000000   NOP
372:                 
373:                 
374:                 /*****************************************************************************
375:                   Function:
376:                     void TickUpdate(void)
377:                 
378:                   Description:
379:                     Updates the tick value when an interrupt occurs.
380:                 
381:                   Precondition:
382:                     None
383:                 
384:                   Parameters:
385:                     None
386:                 
387:                   Returns:
388:                     None
389:                   ***************************************************************************/
390:                 #if defined(__XC8)
391:                 void TickUpdate(void)
392:                 {
393:                     if(INTCONbits.TMR0IF)
394:                     {
395:                         // Increment internal high tick counter
396:                         dwInternalTicks++;
397:                 
398:                         // Reset interrupt flag
399:                         INTCONbits.TMR0IF = 0;
400:                     }
401:                 }
402:                 
403:                 /*****************************************************************************
404:                   Function:
405:                     void _ISR _T1Interrupt(void)
406:                 
407:                   Description:
408:                     Updates the tick value when an interrupt occurs.
409:                 
410:                   Precondition:
411:                     None
412:                 
413:                   Parameters:
414:                     None
415:                 
416:                   Returns:
417:                     None
418:                   ***************************************************************************/
419:                 #elif defined(__XC32)
420:                 void __attribute((interrupt(IPL2SOFT), vector(_TIMER_1_VECTOR), nomips16)) _T1Interrupt(void)
421:                 {
9D0172F0  415DE800   RDPGPR SP, SP
9D0172F4  401A7000   MFC0 K0, EPC
9D0172F8  401B6000   MFC0 K1, Status
9D0172FC  27BDFFE0   ADDIU SP, SP, -32
9D017300  AFBA001C   SW K0, 28(SP)
9D017304  401A6002   MFC0 K0, SRSCtl
9D017308  AFBB0018   SW K1, 24(SP)
9D01730C  AFBA0014   SW K0, 20(SP)
9D017310  7C1B7844   INS K1, ZERO, 1, 15
9D017314  377B0800   ORI K1, K1, 2048
9D017318  409B6000   MTC0 K1, Status
9D01731C  AFBE000C   SW S8, 12(SP)
9D017320  AFA30008   SW V1, 8(SP)
9D017324  AFA20004   SW V0, 4(SP)
9D017328  03A0F021   ADDU S8, SP, ZERO
422:                     // Increment internal high tick counter
423:                     dwInternalTicks++;
9D01732C  8F828040   LW V0, -32704(GP)
9D017330  24420001   ADDIU V0, V0, 1
9D017334  AF828040   SW V0, -32704(GP)
424:                 
425:                     // Reset interrupt flag
426:                     IFS0CLR = _IFS0_T1IF_MASK;
9D017338  3C02BF88   LUI V0, -16504
9D01733C  24030010   ADDIU V1, ZERO, 16
9D017340  AC431034   SW V1, 4148(V0)
427:                 }
9D017344  03C0E821   ADDU SP, S8, ZERO
9D017348  8FBE000C   LW S8, 12(SP)
9D01734C  8FA30008   LW V1, 8(SP)
9D017350  8FA20004   LW V0, 4(SP)
9D017354  41606000   DI ZERO
9D017358  000000C0   EHB
9D01735C  8FBA001C   LW K0, 28(SP)
9D017360  8FBB0018   LW K1, 24(SP)
9D017364  409A7000   MTC0 K0, EPC
9D017368  8FBA0014   LW K0, 20(SP)
9D01736C  27BD0020   ADDIU SP, SP, 32
9D017370  409A6002   MTC0 K0, SRSCtl
9D017374  41DDE800   WRPGPR SP, SP
9D017378  409B6000   MTC0 K1, Status
9D01737C  42000018   ERET
428:                 #else
429:                 #if __C30_VERSION__ >= 300
430:                 void _ISR __attribute__((__no_auto_psv__)) _T1Interrupt(void)
431:                 #else
432:                 void _ISR _T1Interrupt(void)
433:                 #endif
434:                 {
435:                     // Increment internal high tick counter
436:                     dwInternalTicks++;
437:                 
438:                     // Reset interrupt flag
439:                     IFS0bits.T1IF = 0;
440:                 }
441:                 
442:                 #endif
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/tcp.c  ----------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       tcp.c
7:                   
8:                     Summary:
9:                       Module for Microchip TCP/IP Stack
10:                       -Provides reliable, handshaked transport of application stream
11:                        oriented data with flow control
12:                       -Reference: RFC 793
13:                  
14:                    Description:
15:                      Transmission Control Protocol (TCP) Communications Layer
16:                  
17:                   *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #define __TCP_C_
45:                  
46:                  #include "tcpip/tcpip.h"
47:                  
48:                  #if defined(STACK_USE_TCP)
49:                  
50:                  /****************************************************************************
51:                    Section:
52:                      Configuration Parameters
53:                    ***************************************************************************/
54:                  
55:                  // Starting port for client sockets
56:                  #define LOCAL_PORT_START_NUMBER (1024u)
57:                  // End port for client sockets
58:                  #define LOCAL_PORT_END_NUMBER   (5000u)
59:                  
60:                  // For debugging only.  Normal applications should never enable these
61:                  //#define DEBUG_GENERATE_TX_LOSS        62257
62:                  //#define DEBUG_GENERATE_RX_LOSS        64225
63:                  
64:                  // A lot of pointer dereference code can be removed if you
65:                  // locally copy TCBStubs to an absolute memory location.
66:                  // If you define TCP_OPTIMIZE_FOR_SIZE, local caching will
67:                  // occur and will substantially decrease the entire TCP ROM
68:                  // footprint (up to 35%).  If you leave TCP_OPTIMIZE_FOR_SIZE
69:                  // undefined, the local caching will be disabled.  On PIC18
70:                  // products, this will improve TCP performance/throughput by
71:                  // approximately 15%.
72:                  #define TCP_OPTIMIZE_FOR_SIZE
73:                  
74:                  // For smallest size and best throughput, TCP_OPTIMIZE_FOR_SIZE
75:                  // should always be enabled on PIC24 products.  On PIC32
76:                  // products there is very little difference and depnds on compiler
77:                  // optimization level
78:                  #if defined(__XC16) && !defined(TCP_OPTIMIZE_FOR_SIZE)
79:                      #define TCP_OPTIMIZE_FOR_SIZE
80:                  #elif defined(__XC32) && defined(TCP_OPTIMIZE_FOR_SIZE)
81:                      #undef TCP_OPTIMIZE_FOR_SIZE
82:                  #endif
83:                  
84:                  // TCP Maximum Segment Size for TX.  The TX maximum segment size is actually
85:                  // govered by the remote node's MSS option advirtised during connection
86:                  // establishment.  However, if the remote node specifies an unhandlably large
87:                  // MSS (ex: > Ethernet MTU), this define sets a hard limit so that we don't
88:                  // cause any TX buffer overflows.  If the remote node does not advirtise a MSS
89:                  // option, all TX segments are fixed at 536 bytes maximum.
90:                  #define TCP_MAX_SEG_SIZE_TX         (1460u)
91:                  
92:                  // TCP Maximum Segment Size for RX.  This value is advirtised during connection
93:                  // establishment and the remote node should obey it.  This should be set to 536
94:                  // to avoid IP layer fragmentation from causing packet loss.  However, raising
95:                  // its value can enhance performance at the (small) risk of introducing
96:                  // incompatibility with certain special remote nodes (ex: ones connected via a
97:                  // slow dial up modem).
98:                  #define TCP_MAX_SEG_SIZE_RX         (536u)
99:                  
100:                 // TCP Timeout and retransmit numbers
101:                 #define TCP_START_TIMEOUT_VAL       ((uint32_t)TICK_SECOND*1)   // Timeout to retransmit unacked data
102:                 #define TCP_DELAYED_ACK_TIMEOUT     ((uint32_t)TICK_SECOND/10)  // Timeout for delayed-acknowledgement algorithm
103:                 #define TCP_FIN_WAIT_2_TIMEOUT      ((uint32_t)TICK_SECOND*5)   // Timeout for FIN WAIT 2 state
104:                 #define TCP_KEEP_ALIVE_TIMEOUT      ((uint32_t)TICK_SECOND*10)  // Timeout for keep-alive messages when no traffic is sent
105:                 #define TCP_CLOSE_WAIT_TIMEOUT      ((uint32_t)TICK_SECOND/5)   // Timeout for the CLOSE_WAIT state
106:                 #define TCP_MAX_RETRIES             (5u)                    // Maximum number of retransmission attempts
107:                 #define TCP_MAX_UNACKED_KEEP_ALIVES (6u)                    // Maximum number of keep-alive messages that can be sent without receiving a response before automatically closing the connection
108:                 #define TCP_MAX_SYN_RETRIES         (2u)    // Smaller than all other retries to reduce SYN flood DoS duration
109:                 
110:                 #define TCP_AUTO_TRANSMIT_TIMEOUT_VAL   (TICK_SECOND/25ull) // Timeout before automatically transmitting unflushed data
111:                 #define TCP_WINDOW_UPDATE_TIMEOUT_VAL   (TICK_SECOND/5ull)  // Timeout before automatically transmitting a window update due to a TCPGet() or TCPGetArray() function call
112:                 
113:                 #define TCP_SYN_QUEUE_MAX_ENTRIES   (3u)                    // Number of TCP RX SYN packets to save if they cannot be serviced immediately
114:                 #define TCP_SYN_QUEUE_TIMEOUT       ((uint32_t)TICK_SECOND*3)   // Timeout for when SYN queue entries are deleted if unserviceable
115:                 
116:                 /****************************************************************************
117:                   Section:
118:                     TCP Header Data Types
119:                   ***************************************************************************/
120:                 
121:                 #define FIN     (0x01)      // FIN Flag as defined in RFC
122:                 #define SYN     (0x02)      // SYN Flag as defined in RFC
123:                 #define RST     (0x04)      // Reset Flag as defined in RFC
124:                 #define PSH     (0x08)      // Push Flag as defined in RFC
125:                 #define ACK     (0x10)      // Acknowledge Flag as defined in RFC
126:                 #define URG     (0x20)      // Urgent Flag as defined in RFC
127:                 
128:                 // TCP Header Data Structure
129:                 typedef struct
130:                 {
131:                     uint16_t    SourcePort;     // Local port number
132:                     uint16_t    DestPort;       // Remote port number
133:                     uint32_t   SeqNumber;       // Local sequence number
134:                     uint32_t   AckNumber;       // Acknowledging remote sequence number
135:                 
136:                     struct
137:                     {
138:                         unsigned char Reserved3      : 4;
139:                         unsigned char Val            : 4;
140:                     } DataOffset;           // Data offset flags nibble
141:                 
142:                     union
143:                     {
144:                         struct
145:                         {
146:                             unsigned char flagFIN    : 1;
147:                             unsigned char flagSYN    : 1;
148:                             unsigned char flagRST    : 1;
149:                             unsigned char flagPSH    : 1;
150:                             unsigned char flagACK    : 1;
151:                             unsigned char flagURG    : 1;
152:                             unsigned char Reserved2  : 2;
153:                         } bits;
154:                         uint8_t byte;
155:                     } Flags;                // TCP Flags as defined in RFC
156:                 
157:                     uint16_t    Window;         // Local free RX buffer window
158:                     uint16_t    Checksum;       // Data payload checksum
159:                     uint16_t    UrgentPointer;  // Urgent pointer
160:                 } TCP_HEADER;
161:                 
162:                 #define TCP_OPTIONS_END_OF_LIST     (0x00u)     // End of List TCP Option Flag
163:                 #define TCP_OPTIONS_NO_OP           (0x01u)     // No Op TCP Option
164:                 #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02u)     // Maximum segment size TCP flag
165:                 typedef struct
166:                 {
167:                     uint8_t        Kind;                            // Type of option
168:                     uint8_t        Length;                          // Length
169:                     TCPIP_UINT16_VAL    MaxSegSize;                     // Maximum segment size
170:                 } TCP_OPTIONS;                                  // TCP Options data structure
171:                 
172:                 // Structure containing all the important elements of an incomming
173:                 // SYN packet in order to establish a connection at a future time
174:                 // if all sockets on the listening port are already connected to
175:                 // someone
176:                 typedef struct
177:                 {
178:                     NODE_INFO   niSourceAddress;// Remote IP address and MAC address
179:                     uint16_t        wSourcePort;    // Remote TCP port number that the response SYN needs to be sent to
180:                     uint32_t        dwSourceSEQ;    // Remote TCP SEQuence number that must be ACKnowledged when we send our response SYN
181:                     uint16_t        wDestPort;      // Local TCP port which the original SYN was destined for
182:                     uint16_t        wTimestamp;     // Timer to expire old SYN packets that can't be serviced at all
183:                 } TCP_SYN_QUEUE;
184:                 
185:                 
186:                 #if defined(STACK_CLIENT_MODE)
187:                 static uint16_t NextPort __attribute__((persistent));   // Tracking variable for next local client port number
188:                 #endif
189:                 
190:                 /****************************************************************************
191:                   Section:
192:                     TCB Definitions
193:                   ***************************************************************************/
194:                 
195:                 // Determines the number of defined TCP sockets
196:                 #define TCP_SOCKET_COUNT    (sizeof(TCPSocketInitializer)/sizeof(TCPSocketInitializer[0]))
197:                 
198:                 
199:                 #if defined(__XC8)
200:                     // The initializer forces this large array out of the bss section
201:                     // so we can link correctly.
202:                     #pragma psect bigdata=TCB_uRAM_BIG
203:                     #pragma psect data=TCB_uRAM
204:                     static TCB_STUB TCBStubs[TCP_SOCKET_COUNT] = {'\0'};
205:                     #pragma psect data=ordinary_data_sect
206:                     #pragma psect bigdata=ordinary_data_sect_big
207:                 #else
208:                     static TCB_STUB TCBStubs[TCP_SOCKET_COUNT];
209:                 #endif
210:                 
211:                 static TCB MyTCB;                                   // Currently loaded TCB
212:                 static TCP_SOCKET hCurrentTCP = INVALID_SOCKET;     // Current TCP socket
213:                 #if TCP_SYN_QUEUE_MAX_ENTRIES
214:                     static TCP_SYN_QUEUE SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES];   // Array of saved incoming SYN requests that need to be serviced later
215:                 #endif
216:                 
217:                 /****************************************************************************
218:                   Section:
219:                     Function Prototypes
220:                   ***************************************************************************/
221:                 
222:                 static void TCPRAMCopy(PTR_BASE wDest, uint8_t vDestType, PTR_BASE wSource, uint8_t vSourceType, uint16_t wLength);
223:                 
224:                 #if defined(__XC8)
225:                     static void TCPRAMCopyROM(PTR_BASE wDest, uint8_t wDestType, ROM uint8_t* wSource, uint16_t wLength);
226:                 #else
227:                     #define TCPRAMCopyROM(a,b,c,d)  TCPRAMCopy(a,b,c,TCP_PIC_RAM,d)
228:                 #endif
229:                 
230:                 static void SendTCP(uint8_t vTCPFlags, uint8_t vSendFlags);
231:                 static void HandleTCPSeg(TCP_HEADER* h, uint16_t len);
232:                 static bool FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote);
233:                 static void SwapTCPHeader(TCP_HEADER* header);
234:                 static void CloseSocket(void);
235:                 static void SyncTCB(void);
236:                 
237:                 #if defined(WF_CS_TRIS)
238:                 uint16_t WFGetTCBSize(void);
239:                 #endif
240:                 
241:                 // Indicates if this packet is a retransmission (no reset) or a new packet (reset required)
242:                 #define SENDTCP_RESET_TIMERS    0x01
243:                 // Instead of transmitting normal data, a garbage octet is transmitted according to RFC 1122 section 4.2.3.6
244:                 #define SENDTCP_KEEP_ALIVE      0x02
245:                 
246:                 
247:                 /****************************************************************************
248:                   Section:
249:                     TCB Optimization Configuration
250:                   ***************************************************************************/
251:                 
252:                 #if defined(TCP_OPTIMIZE_FOR_SIZE)
253:                     static TCB_STUB MyTCBStub;
254:                 
255:                     // Flushes MyTCBStub cache and loads up the specified TCB_STUB.
256:                     // Does nothing on cache hit.
257:                     static void SyncTCBStub(TCP_SOCKET hTCP)
258:                     {
259:                         if(hCurrentTCP == hTCP)
260:                             return;
261:                 
262:                         if(hCurrentTCP != INVALID_SOCKET)
263:                         {
264:                             // Save the current TCB stub
265:                             memcpy((void*)&TCBStubs[hCurrentTCP], (void*)&MyTCBStub, sizeof(MyTCBStub));
266:                         }
267:                 
268:                         hCurrentTCP = hTCP;
269:                 
270:                         if(hTCP == INVALID_SOCKET)
271:                             return;
272:                 
273:                         // Load up the new TCB stub
274:                         memcpy((void*)&MyTCBStub, (void*)&TCBStubs[hTCP], sizeof(MyTCBStub));
275:                     }
276:                 #else
277:                     // Flushes MyTCBStub cache and loads up the specified TCB_STUB.
278:                     // Does nothing on cache hit.
279:                     #define SyncTCBStub(a)  hCurrentTCP = (a)
280:                     // Alias to current TCP stub.
281:                     #define MyTCBStub       TCBStubs[hCurrentTCP]
282:                 #endif
283:                 
284:                 
285:                 
286:                 // Flushes MyTCB cache and loads up the specified TCB.
287:                 // Does nothing on cache hit.
288:                 static void SyncTCB(void)
289:                 {
9D000000  27BDFFE0   ADDIU SP, SP, -32
9D000004  AFBF001C   SW RA, 28(SP)
9D000008  AFBE0018   SW S8, 24(SP)
9D00000C  03A0F021   ADDU S8, SP, ZERO
290:                     static TCP_SOCKET hLastTCB = INVALID_SOCKET;
291:                 
292:                     if(hLastTCB == hCurrentTCP)
9D000010  93838015   LBU V1, -32747(GP)
9D000014  93828014   LBU V0, -32748(GP)
9D000018  1062003D   BEQ V1, V0, 0x9D000110
9D00001C  00000000   NOP
293:                         return;
9D000110  00000000   NOP
294:                 
295:                     if(hLastTCB != INVALID_SOCKET)
9D000020  93838015   LBU V1, -32747(GP)
9D000024  240200FE   ADDIU V0, ZERO, 254
9D000028  1062001C   BEQ V1, V0, 0x9D00009C
9D00002C  00000000   NOP
296:                     {
297:                         // Save the current TCB
298:                         TCPRAMCopy(TCBStubs[hLastTCB].bufferTxStart - sizeof(MyTCB), TCBStubs[hLastTCB].vMemoryMedium, (PTR_BASE)&MyTCB, TCP_PIC_RAM, sizeof(MyTCB));
9D000030  93828015   LBU V0, -32747(GP)
9D000034  3C04A000   LUI A0, -24576
9D000038  00021100   SLL V0, V0, 4
9D00003C  00021880   SLL V1, V0, 2
9D000040  00621823   SUBU V1, V1, V0
9D000044  2482753C   ADDIU V0, A0, 30012
9D000048  00621021   ADDU V0, V1, V0
9D00004C  8C420000   LW V0, 0(V0)
9D000050  2444FFD4   ADDIU A0, V0, -44
9D000054  93828015   LBU V0, -32747(GP)
9D000058  3C05A000   LUI A1, -24576
9D00005C  00021100   SLL V0, V0, 4
9D000060  00021880   SLL V1, V0, 2
9D000064  00621823   SUBU V1, V1, V0
9D000068  24A2753C   ADDIU V0, A1, 30012
9D00006C  00621021   ADDU V0, V1, V0
9D000070  9042002C   LBU V0, 44(V0)
9D000074  00401821   ADDU V1, V0, ZERO
9D000078  3C02A000   LUI V0, -24576
9D00007C  2442759C   ADDIU V0, V0, 30108
9D000080  2405002C   ADDIU A1, ZERO, 44
9D000084  AFA50010   SW A1, 16(SP)
9D000088  00602821   ADDU A1, V1, ZERO
9D00008C  00403021   ADDU A2, V0, ZERO
9D000090  24070001   ADDIU A3, ZERO, 1
9D000094  0F4020A8   JAL 0x9D0082A0
9D000098  00000000   NOP
299:                     }
300:                 
301:                     // Load up the new TCB
302:                     hLastTCB = hCurrentTCP;
9D00009C  93828014   LBU V0, -32748(GP)
9D0000A0  A3828015   SB V0, -32747(GP)
303:                     TCPRAMCopy((PTR_BASE)&MyTCB, TCP_PIC_RAM, MyTCBStub.bufferTxStart - sizeof(MyTCB), MyTCBStub.vMemoryMedium, sizeof(MyTCB));
9D0000A4  3C02A000   LUI V0, -24576
9D0000A8  2444759C   ADDIU A0, V0, 30108
9D0000AC  93828014   LBU V0, -32748(GP)
9D0000B0  3C05A000   LUI A1, -24576
9D0000B4  00021100   SLL V0, V0, 4
9D0000B8  00021880   SLL V1, V0, 2
9D0000BC  00621823   SUBU V1, V1, V0
9D0000C0  24A2753C   ADDIU V0, A1, 30012
9D0000C4  00621021   ADDU V0, V1, V0
9D0000C8  8C420000   LW V0, 0(V0)
9D0000CC  2446FFD4   ADDIU A2, V0, -44
9D0000D0  93828014   LBU V0, -32748(GP)
9D0000D4  3C05A000   LUI A1, -24576
9D0000D8  00021100   SLL V0, V0, 4
9D0000DC  00021880   SLL V1, V0, 2
9D0000E0  00621823   SUBU V1, V1, V0
9D0000E4  24A2753C   ADDIU V0, A1, 30012
9D0000E8  00621021   ADDU V0, V1, V0
9D0000EC  9042002C   LBU V0, 44(V0)
9D0000F0  2403002C   ADDIU V1, ZERO, 44
9D0000F4  AFA30010   SW V1, 16(SP)
9D0000F8  24050001   ADDIU A1, ZERO, 1
9D0000FC  00403821   ADDU A3, V0, ZERO
9D000100  0F4020A8   JAL 0x9D0082A0
9D000104  00000000   NOP
9D000108  0B400045   J 0x9D000114
9D00010C  00000000   NOP
304:                 }
9D000114  03C0E821   ADDU SP, S8, ZERO
9D000118  8FBF001C   LW RA, 28(SP)
9D00011C  8FBE0018   LW S8, 24(SP)
9D000120  27BD0020   ADDIU SP, SP, 32
9D000124  03E00008   JR RA
9D000128  00000000   NOP
305:                 
306:                 
307:                 /*****************************************************************************
308:                   Function:
309:                     void TCPInit(void)
310:                 
311:                   Summary:
312:                     Initializes the TCP module.
313:                 
314:                   Description:
315:                     Initializes the TCP module.  This function sets up the TCP buffers
316:                     in memory and initializes each socket to the CLOSED state.  If
317:                     insufficient memory was allocated for the TCP sockets, the function
318:                     will hang here to be captured by the debugger.
319:                 
320:                   Precondition:
321:                     None
322:                 
323:                   Parameters:
324:                     None
325:                 
326:                   Returns:
327:                     None
328:                 
329:                   Remarks:
330:                     This function is called only one during lifetime of the application.
331:                   ***************************************************************************/
332:                 void TCPInit(void)
333:                 {
9D00012C  27BDFFD0   ADDIU SP, SP, -48
9D000130  AFBF002C   SW RA, 44(SP)
9D000134  AFBE0028   SW S8, 40(SP)
9D000138  03A0F021   ADDU S8, SP, ZERO
334:                     uint8_t i;
335:                     uint8_t vSocketsAllocated;
336:                     uint16_t wTXSize, wRXSize;
337:                     PTR_BASE ptrBaseAddress;
338:                     uint8_t vMedium;
339:                     #if TCP_ETH_RAM_SIZE > 0
340:                     uint16_t wCurrentETHAddress = TCP_ETH_RAM_BASE_ADDRESS;
341:                     #endif
342:                     #if TCP_PIC_RAM_SIZE > 0
343:                     PTR_BASE ptrCurrentPICAddress = TCP_PIC_RAM_BASE_ADDRESS;
9D00013C  3C02A000   LUI V0, -24576
9D000140  24424D3C   ADDIU V0, V0, 19772
9D000144  AFC20014   SW V0, 20(S8)
344:                     #endif
345:                     #if TCP_SPI_RAM_SIZE > 0
346:                     uint16_t wCurrentSPIAddress = TCP_SPI_RAM_BASE_ADDRESS;
347:                     #endif
348:                 
349:                     #if defined(STACK_CLIENT_MODE)
350:                         // Initialize NextPort to a random value if it is zero (such as after
351:                         // reset on a PIC32 or PIC18 when the static memory initializer is
352:                         // used).  By starting with a random number, we decrease the risk of
353:                         // reusing a port number that was previously used if the user power
354:                         // cycles the device.
355:                         if(NextPort == 0u)
9D000148  3C02A001   LUI V0, -24575
9D00014C  94428950   LHU V0, -30384(V0)
9D000150  1440000A   BNE V0, ZERO, 0x9D00017C
9D000154  00000000   NOP
356:                             NextPort = (((uint16_t)GenerateRandomDWORD()) & 0x07FFu) + LOCAL_PORT_START_NUMBER;
9D000158  0F403CCA   JAL GenerateRandomDWORD
9D00015C  00000000   NOP
9D000160  3042FFFF   ANDI V0, V0, -1
9D000164  304207FF   ANDI V0, V0, 2047
9D000168  3042FFFF   ANDI V0, V0, -1
9D00016C  24420400   ADDIU V0, V0, 1024
9D000170  3043FFFF   ANDI V1, V0, -1
9D000174  3C02A001   LUI V0, -24575
9D000178  A4438950   SH V1, -30384(V0)
357:                     #endif
358:                 
359:                 
360:                     // Mark all SYN Queue entries as invalid by zeroing the memory
361:                     #if TCP_SYN_QUEUE_MAX_ENTRIES
362:                         memset((void*)SYNQueue, 0x00, sizeof(SYNQueue));
9D00017C  3C02A000   LUI V0, -24576
9D000180  244475C8   ADDIU A0, V0, 30152
9D000184  00002821   ADDU A1, ZERO, ZERO
9D000188  2406003C   ADDIU A2, ZERO, 60
9D00018C  0F406D3B   JAL 0x9D01B4EC
9D000190  00000000   NOP
363:                     #endif
364:                 
365:                     // Allocate all socket FIFO addresses
366:                     vSocketsAllocated = 0;
9D000194  A3C00018   SB ZERO, 24(S8)
367:                     for(i = 0; i < TCP_SOCKET_COUNT; i++)
9D000198  A3C00010   SB ZERO, 16(S8)
9D00019C  0B400102   J 0x9D000408
9D0001A0  00000000   NOP
9D0003EC  93C20010   LBU V0, 16(S8)
9D0003F0  24420001   ADDIU V0, V0, 1
9D0003F4  A3C20010   SB V0, 16(S8)
9D0003F8  0B400102   J 0x9D000408
9D0003FC  00000000   NOP
9D000408  93C20010   LBU V0, 16(S8)
9D00040C  2C420002   SLTIU V0, V0, 2
9D000410  1440FF64   BNE V0, ZERO, 0x9D0001A4
9D000414  00000000   NOP
368:                     {
369:                         // Generate all needed sockets of each type (TCP_PURPOSE_*)
370:                         SyncTCBStub(i);
9D0001A4  93C20010   LBU V0, 16(S8)
9D0001A8  A3828014   SB V0, -32748(GP)
371:                 
372:                         vMedium = TCPSocketInitializer[i].vMemoryMedium;
9D0001AC  93C20010   LBU V0, 16(S8)
9D0001B0  3C049D02   LUI A0, -25342
9D0001B4  00021040   SLL V0, V0, 1
9D0001B8  00021880   SLL V1, V0, 2
9D0001BC  00621823   SUBU V1, V1, V0
9D0001C0  2482C378   ADDIU V0, A0, -15496
9D0001C4  00621021   ADDU V0, V1, V0
9D0001C8  90420001   LBU V0, 1(V0)
9D0001CC  A3C20019   SB V0, 25(S8)
373:                         wTXSize = TCPSocketInitializer[i].wTXBufferSize;
9D0001D0  93C20010   LBU V0, 16(S8)
9D0001D4  3C049D02   LUI A0, -25342
9D0001D8  00021040   SLL V0, V0, 1
9D0001DC  00021880   SLL V1, V0, 2
9D0001E0  00621823   SUBU V1, V1, V0
9D0001E4  2482C378   ADDIU V0, A0, -15496
9D0001E8  00621021   ADDU V0, V1, V0
9D0001EC  94420002   LHU V0, 2(V0)
9D0001F0  A7C2001A   SH V0, 26(S8)
374:                         wRXSize = TCPSocketInitializer[i].wRXBufferSize;
9D0001F4  93C20010   LBU V0, 16(S8)
9D0001F8  3C049D02   LUI A0, -25342
9D0001FC  00021040   SLL V0, V0, 1
9D000200  00021880   SLL V1, V0, 2
9D000204  00621823   SUBU V1, V1, V0
9D000208  2482C378   ADDIU V0, A0, -15496
9D00020C  00621021   ADDU V0, V1, V0
9D000210  94420004   LHU V0, 4(V0)
9D000214  A7C2001C   SH V0, 28(S8)
375:                 
376:                         switch(vMedium)
9D000218  93C30019   LBU V1, 25(S8)
9D00021C  24020001   ADDIU V0, ZERO, 1
9D000220  10620003   BEQ V1, V0, 0x9D000230
9D000224  00000000   NOP
9D000228  0B400100   J 0x9D000400
9D00022C  00000000   NOP
377:                         {
378:                             #if TCP_ETH_RAM_SIZE > 0
379:                             case TCP_ETH_RAM:
380:                                 ptrBaseAddress = wCurrentETHAddress;
381:                                 wCurrentETHAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
382:                                 // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
383:                                 // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in tcpip_config.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
384:                 #if defined(WF_CS_TRIS)
385:                                 while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + WFGetTCBSize()/*TCP_ETH_RAM_SIZE*/);
386:                 #else
387:                                 while(wCurrentETHAddress > TCP_ETH_RAM_BASE_ADDRESS + TCP_ETH_RAM_SIZE);
388:                 #endif
389:                                 break;
390:                             #endif
391:                 
392:                             #if TCP_PIC_RAM_SIZE > 0
393:                             case TCP_PIC_RAM:
394:                                 ptrBaseAddress = ptrCurrentPICAddress;
9D000230  8FC20014   LW V0, 20(S8)
9D000234  AFC20020   SW V0, 32(S8)
395:                                 ptrCurrentPICAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
9D000238  97C3001A   LHU V1, 26(S8)
9D00023C  97C2001C   LHU V0, 28(S8)
9D000240  00621821   ADDU V1, V1, V0
9D000244  8FC20014   LW V0, 20(S8)
9D000248  00621021   ADDU V0, V1, V0
9D00024C  2442002E   ADDIU V0, V0, 46
9D000250  AFC20014   SW V0, 20(S8)
396:                                 // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
397:                                 // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in tcpip_config.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
398:                                 while(ptrCurrentPICAddress > TCP_PIC_RAM_BASE_ADDRESS + TCP_PIC_RAM_SIZE);
9D000254  00000000   NOP
9D000258  3C02A000   LUI V0, -24576
9D00025C  24424D3C   ADDIU V0, V0, 19772
9D000260  24422800   ADDIU V0, V0, 10240
9D000264  8FC30014   LW V1, 20(S8)
9D000268  0043102B   SLTU V0, V0, V1
9D00026C  1440FFFA   BNE V0, ZERO, 0x9D000258
9D000270  00000000   NOP
399:                                 break;
400:                             #endif
401:                 
402:                             #if TCP_SPI_RAM_SIZE > 0
403:                             case TCP_SPI_RAM:
404:                                 ptrBaseAddress = wCurrentSPIAddress;
405:                                 wCurrentSPIAddress += sizeof(TCB) + wTXSize+1 + wRXSize+1;
406:                                 // Do a sanity check to ensure that we aren't going to use memory that hasn't been allocated to us.
407:                                 // If your code locks up right here, it means you've incorrectly allocated your TCP socket buffers in tcpip_config.h.  See the TCP memory allocation section.  More RAM needs to be allocated to the base memory mediums, or the individual sockets TX and RX FIFOS and socket quantiy needs to be shrunken.
408:                                 while(wCurrentSPIAddress > TCP_SPI_RAM_BASE_ADDRESS + TCP_SPI_RAM_SIZE);
409:                                 break;
410:                             #endif
411:                 
412:                             default:
413:                                 while(1); // Undefined allocation medium.  Go fix your tcpip_config.h TCP memory allocations.
9D000400  0B400100   J 0x9D000400
9D000404  00000000   NOP
414:                         }
415:                 
416:                         MyTCBStub.vMemoryMedium = vMedium;
9D000274  93828014   LBU V0, -32748(GP)
9D000278  3C04A000   LUI A0, -24576
9D00027C  00021100   SLL V0, V0, 4
9D000280  00021880   SLL V1, V0, 2
9D000284  00621823   SUBU V1, V1, V0
9D000288  2482753C   ADDIU V0, A0, 30012
9D00028C  00621021   ADDU V0, V1, V0
9D000290  93C30019   LBU V1, 25(S8)
9D000294  A043002C   SB V1, 44(V0)
417:                         MyTCBStub.bufferTxStart = ptrBaseAddress + sizeof(TCB);
9D000298  93828014   LBU V0, -32748(GP)
9D00029C  8FC30020   LW V1, 32(S8)
9D0002A0  2464002C   ADDIU A0, V1, 44
9D0002A4  3C05A000   LUI A1, -24576
9D0002A8  00021100   SLL V0, V0, 4
9D0002AC  00021880   SLL V1, V0, 2
9D0002B0  00621823   SUBU V1, V1, V0
9D0002B4  24A2753C   ADDIU V0, A1, 30012
9D0002B8  00621021   ADDU V0, V1, V0
9D0002BC  AC440000   SW A0, 0(V0)
418:                         MyTCBStub.bufferRxStart = MyTCBStub.bufferTxStart + wTXSize + 1;
9D0002C0  93828014   LBU V0, -32748(GP)
9D0002C4  00402821   ADDU A1, V0, ZERO
9D0002C8  93828014   LBU V0, -32748(GP)
9D0002CC  3C04A000   LUI A0, -24576
9D0002D0  00021100   SLL V0, V0, 4
9D0002D4  00021880   SLL V1, V0, 2
9D0002D8  00621823   SUBU V1, V1, V0
9D0002DC  2482753C   ADDIU V0, A0, 30012
9D0002E0  00621021   ADDU V0, V1, V0
9D0002E4  8C430000   LW V1, 0(V0)
9D0002E8  97C2001A   LHU V0, 26(S8)
9D0002EC  00621021   ADDU V0, V1, V0
9D0002F0  24430001   ADDIU V1, V0, 1
9D0002F4  3C02A000   LUI V0, -24576
9D0002F8  2444753C   ADDIU A0, V0, 30012
9D0002FC  00A01021   ADDU V0, A1, ZERO
9D000300  00021100   SLL V0, V0, 4
9D000304  00022880   SLL A1, V0, 2
9D000308  00A21023   SUBU V0, A1, V0
9D00030C  00821021   ADDU V0, A0, V0
9D000310  AC430004   SW V1, 4(V0)
419:                         MyTCBStub.bufferEnd     = MyTCBStub.bufferRxStart + wRXSize;
9D000314  93828014   LBU V0, -32748(GP)
9D000318  00401821   ADDU V1, V0, ZERO
9D00031C  93828014   LBU V0, -32748(GP)
9D000320  3C04A000   LUI A0, -24576
9D000324  2484753C   ADDIU A0, A0, 30012
9D000328  00021100   SLL V0, V0, 4
9D00032C  00022880   SLL A1, V0, 2
9D000330  00A21023   SUBU V0, A1, V0
9D000334  00821021   ADDU V0, A0, V0
9D000338  8C440004   LW A0, 4(V0)
9D00033C  97C2001C   LHU V0, 28(S8)
9D000340  00822021   ADDU A0, A0, V0
9D000344  3C05A000   LUI A1, -24576
9D000348  00601021   ADDU V0, V1, ZERO
9D00034C  00021100   SLL V0, V0, 4
9D000350  00021880   SLL V1, V0, 2
9D000354  00621823   SUBU V1, V1, V0
9D000358  24A2753C   ADDIU V0, A1, 30012
9D00035C  00621021   ADDU V0, V1, V0
9D000360  AC440008   SW A0, 8(V0)
420:                         MyTCBStub.smState       = TCP_CLOSED;
9D000364  93828014   LBU V0, -32748(GP)
9D000368  3C03A000   LUI V1, -24576
9D00036C  2463753C   ADDIU V1, V1, 30012
9D000370  00021100   SLL V0, V0, 4
9D000374  00022080   SLL A0, V0, 2
9D000378  00821023   SUBU V0, A0, V0
9D00037C  00621021   ADDU V0, V1, V0
9D000380  2403000D   ADDIU V1, ZERO, 13
9D000384  AC430024   SW V1, 36(V0)
421:                         MyTCBStub.Flags.bServer = false;
9D000388  93828014   LBU V0, -32748(GP)
9D00038C  3C04A000   LUI A0, -24576
9D000390  00021100   SLL V0, V0, 4
9D000394  00021880   SLL V1, V0, 2
9D000398  00621823   SUBU V1, V1, V0
9D00039C  2482753C   ADDIU V0, A0, 30012
9D0003A0  00621821   ADDU V1, V1, V0
9D0003A4  8C620028   LW V0, 40(V1)
9D0003A8  7C0218C4   INS V0, ZERO, 3, 1
9D0003AC  AC620028   SW V0, 40(V1)
422:                         #if defined(STACK_USE_SSL)
423:                         MyTCBStub.sslStubID = SSL_INVALID_ID;
424:                         #endif
425:                 
426:                         SyncTCB();
9D0003B0  0F400000   JAL 0x9D000000
9D0003B4  00000000   NOP
427:                         MyTCB.vSocketPurpose = TCPSocketInitializer[i].vSocketPurpose;
9D0003B8  93C20010   LBU V0, 16(S8)
9D0003BC  3C049D02   LUI A0, -25342
9D0003C0  00021040   SLL V0, V0, 1
9D0003C4  00021880   SLL V1, V0, 2
9D0003C8  00621823   SUBU V1, V1, V0
9D0003CC  2482C378   ADDIU V0, A0, -15496
9D0003D0  00621021   ADDU V0, V1, V0
9D0003D4  90430000   LBU V1, 0(V0)
9D0003D8  3C02A000   LUI V0, -24576
9D0003DC  2442759C   ADDIU V0, V0, 30108
9D0003E0  A043002B   SB V1, 43(V0)
428:                         CloseSocket();
9D0003E4  0F401470   JAL 0x9D0051C0
9D0003E8  00000000   NOP
429:                     }
430:                 }
9D000418  03C0E821   ADDU SP, S8, ZERO
9D00041C  8FBF002C   LW RA, 44(SP)
9D000420  8FBE0028   LW S8, 40(SP)
9D000424  27BD0030   ADDIU SP, SP, 48
9D000428  03E00008   JR RA
9D00042C  00000000   NOP
431:                 
432:                 /****************************************************************************
433:                   Section:
434:                     Connection Management Functions
435:                   ***************************************************************************/
436:                 
437:                 
438:                 /*****************************************************************************
439:                   Function:
440:                     TCP_SOCKET TCPOpen(uint32_t dwRemoteHost, uint8_t vRemoteHostType, uint16_t wPort, uint8_t vSocketPurpose)
441:                 
442:                   Summary:
443:                     Opens a TCP socket for listening or as a client.
444:                 
445:                   Description:
446:                     Provides a unified method for opening TCP sockets. This function can
447:                     open both client and server sockets. For client sockets, it can accept
448:                     a host name string to query in DNS, an IP address as a string, an IP
449:                     address in binary form, or a previously resolved NODE_INFO structure
450:                     containing the remote IP address and associated MAC address. When a
451:                     host name or IP address only is provided, the TCP module will
452:                     internally perform the necessary DNS and/or ARP resolution steps before
453:                     reporting that the TCP socket is connected (via a call to
454:                     TCPISConnected returning true). Server sockets ignore this destination
455:                     parameter and listen only on the indicated port.
456:                 
457:                     The vSocketPurpose field allows sockets to be opened with varying
458:                     buffer size parameters and memory storage mediums. This field
459:                     corresponds to pre-defined sockets allocated in the
460:                     TCPSocketInitializer[] array in tcpip_config.h. The tcpip_config.h file
461:                     can be edited using the TCP/IP Configuration Wizard.
462:                 
463:                     Sockets are statically allocated on boot, but can be claimed with this
464:                     \function and freed using TCPDisconnect or TCPClose (for client
465:                     sockets). Server sockets can be freed using TCPClose only (calls to
466:                     TCPDisconnect will return server sockets to the listening state,
467:                     allowing reuse).
468:                 
469:                   Conditions:
470:                     TCP is initialized.
471:                 
472:                   Input:
473:                     dwRemoteHost -     For client sockets only. Provide a pointer to a
474:                                        null\-terminated string of the remote host name (ex\:
475:                                        "www.microchip.com" or "192.168.1.123"), a literal
476:                                        destination IP address (ex\: 0x7B01A8C0 or an IP_ADDR
477:                                        data type), or a pointer to a NODE_INFO structure
478:                                        with the remote IP address and remote node or gateway
479:                                        MAC address specified. If a string is provided, note
480:                                        that it must be statically allocated in memory and
481:                                        cannot be modified or deallocated until
482:                                        TCPIsConnected returns true.<p />This parameter is
483:                                        ignored for server sockets.
484:                     vRemoteHostType -  Any one of the following flags to identify the
485:                                        meaning of the dwRemoteHost parameter\:
486:                                        * TCP_OPEN_SERVER &#45; Open a server socket and
487:                                          ignore the dwRemoteHost parameter.
488:                                        * TCP_OPEN_RAM_HOST &#45; Open a client socket and
489:                                          connect it to a remote host who's name is stored as a
490:                                          null terminated string in a RAM array. Ex\:
491:                                          "www.microchip.com" or "192.168.0.123" (uint8_t&#42;
492:                                          type)
493:                                        * TCP_OPEN_ROM_HOST &#45; Open a client socket and
494:                                          connect it to a remote host who's name is stored as a
495:                                          null terminated string in a literal string or ROM
496:                                          array. Ex\: "www.microchip.com" or "192.168.0.123"
497:                                          (ROM uint8_t&#42; type)
498:                                        * TCP_OPEN_IP_ADDRESS &#45; Open a client socket and
499:                                          connect it to a remote IP address. Ex\: 0x7B01A8C0
500:                                          for 192.168.1.123 (uint32_t type). Note that the byte
501:                                          ordering is big endian.
502:                                        * TCP_OPEN_NODE_INFO &#45; Open a client socket and
503:                                          connect it to a remote IP and MAC addresses pair
504:                                          stored in a NODE_INFO structure. dwRemoteHost must be
505:                                          a pointer to the NODE_INFO structure. This option is
506:                                          provided for backwards compatibility with
507:                                          applications built against prior stack versions that
508:                                          only implemented the TCPConnect() function. It can
509:                                          also be used to skip DNS and ARP resolution steps if
510:                                          connecting to a remote node which you've already
511:                                          connected to and have cached addresses for.
512:                     wPort -            TCP port to listen on or connect to\:
513:                                        * Client sockets &#45; the remote TCP port to which a
514:                                          connection should be made. The local port for client
515:                                          sockets will be automatically picked by the TCP
516:                                          module.
517:                                        * Server sockets &#45; the local TCP port on which to
518:                                          listen for connections.
519:                     vSocketPurpose -   Any of the TCP_PURPOSE_* constants defined in
520:                                        tcpip_config.h or the TCPIPConfig utility (see
521:                                        TCPSocketInitializer[] array).
522:                 
523:                   Return Values:
524:                     INVALID_SOCKET -  No sockets of the specified type were available to be
525:                                       opened.
526:                     Otherwise -       A TCP_SOCKET handle. Save this handle and use it when
527:                                       calling all other TCP APIs.
528:                 
529:                   Remarks:
530:                     This function replaces the old TCPConnect and TCPListen functions.
531:                 
532:                     If TCP_OPEN_RAM_HOST or TCP_OPEN_ROM_HOST are used for the destination
533:                     type, the DNS client module must also be enabled (STACK_USE_DNS must be
534:                     defined in tcpip_config.h).
535:                 
536:                   Example:
537:                     \ \
538:                     <code>
539:                     // Open a server socket
540:                     skt = TCPOpen(NULL, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
541:                 
542:                     // Open a client socket to www.microchip.com
543:                     // The double cast here prevents compiler warnings
544:                     skt = TCPOpen((uint32_t)(PTR_BASE)"www.microchip.com",
545:                                     TCP_OPEN_ROM_HOST, 80, TCP_PURPOSE_DEFAULT);
546:                 
547:                     // Reopen a client socket without repeating DNS or ARP
548:                     SOCKET_INFO cache = TCPGetSocketInfo(skt);  // Call with the old socket
549:                     skt = TCPOpen((uint32_t)(PTR_BASE)&amp;cache.remote, TCP_OPEN_NODE_INFO,
550:                                     cache.remotePort.Val, TCP_PURPOSE_DEFAULT);
551:                     </code>
552:                   *****************************************************************************/
553:                 TCP_SOCKET TCPOpen(uint32_t dwRemoteHost, uint8_t vRemoteHostType, uint16_t wPort, uint8_t vSocketPurpose)
554:                 {
9D000430  27BDFFD8   ADDIU SP, SP, -40
9D000434  AFBF0024   SW RA, 36(SP)
9D000438  AFBE0020   SW S8, 32(SP)
9D00043C  AFB0001C   SW S0, 28(SP)
9D000440  03A0F021   ADDU S8, SP, ZERO
9D000444  AFC40028   SW A0, 40(S8)
9D000448  00A02021   ADDU A0, A1, ZERO
9D00044C  00C01821   ADDU V1, A2, ZERO
9D000450  00E01021   ADDU V0, A3, ZERO
9D000454  A3C4002C   SB A0, 44(S8)
9D000458  A7C30030   SH V1, 48(S8)
9D00045C  A3C20034   SB V0, 52(S8)
555:                     TCP_SOCKET hTCP;
556:                 
557:                     // Find an available socket that matches the specified socket type
558:                     for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D000460  A3C00010   SB ZERO, 16(S8)
9D000464  0B400205   J 0x9D000814
9D000468  00000000   NOP
9D000808  93C20010   LBU V0, 16(S8)
9D00080C  24420001   ADDIU V0, V0, 1
9D000810  A3C20010   SB V0, 16(S8)
9D000814  93C20010   LBU V0, 16(S8)
9D000818  2C420002   SLTIU V0, V0, 2
9D00081C  1440FF13   BNE V0, ZERO, 0x9D00046C
9D000820  00000000   NOP
559:                     {
560:                         SyncTCBStub(hTCP);
9D00046C  93C20010   LBU V0, 16(S8)
9D000470  A3828014   SB V0, -32748(GP)
561:                 
562:                         // Sockets that are in use will be in a non-closed state
563:                         if(MyTCBStub.smState != TCP_CLOSED)
9D000474  93828014   LBU V0, -32748(GP)
9D000478  3C03A000   LUI V1, -24576
9D00047C  2463753C   ADDIU V1, V1, 30012
9D000480  00021100   SLL V0, V0, 4
9D000484  00022080   SLL A0, V0, 2
9D000488  00821023   SUBU V0, A0, V0
9D00048C  00621021   ADDU V0, V1, V0
9D000490  8C430024   LW V1, 36(V0)
9D000494  2402000D   ADDIU V0, ZERO, 13
9D000498  146200D7   BNE V1, V0, 0x9D0007F8
9D00049C  00000000   NOP
564:                             continue;
9D0007F8  00000000   NOP
9D0007FC  0B400202   J 0x9D000808
9D000800  00000000   NOP
565:                 
566:                         SyncTCB();
9D0004A0  0F400000   JAL 0x9D000000
9D0004A4  00000000   NOP
567:                 
568:                         // See if this socket matches the desired type
569:                         if(MyTCB.vSocketPurpose != vSocketPurpose)
9D0004A8  3C02A000   LUI V0, -24576
9D0004AC  2442759C   ADDIU V0, V0, 30108
9D0004B0  9042002B   LBU V0, 43(V0)
9D0004B4  93C30034   LBU V1, 52(S8)
9D0004B8  146200D2   BNE V1, V0, 0x9D000804
9D0004BC  00000000   NOP
570:                             continue;
9D000804  00000000   NOP
571:                 
572:                         // Start out assuming worst case Maximum Segment Size (changes when MSS
573:                         // option is received from remote node)
574:                         MyTCB.wRemoteMSS = 536;
9D0004C0  3C02A000   LUI V0, -24576
9D0004C4  2442759C   ADDIU V0, V0, 30108
9D0004C8  24030218   ADDIU V1, ZERO, 536
9D0004CC  A4430028   SH V1, 40(V0)
575:                 
576:                         // See if this is a server socket
577:                         if(vRemoteHostType == TCP_OPEN_SERVER)
9D0004D0  93C2002C   LBU V0, 44(S8)
9D0004D4  14400024   BNE V0, ZERO, 0x9D000568
9D0004D8  00000000   NOP
578:                         {
579:                             MyTCB.localPort.Val = wPort;
9D0004DC  3C02A000   LUI V0, -24576
9D0004E0  2442759C   ADDIU V0, V0, 30108
9D0004E4  97C30030   LHU V1, 48(S8)
9D0004E8  A4430012   SH V1, 18(V0)
580:                             MyTCBStub.Flags.bServer = true;
9D0004EC  93828014   LBU V0, -32748(GP)
9D0004F0  3C04A000   LUI A0, -24576
9D0004F4  00021100   SLL V0, V0, 4
9D0004F8  00021880   SLL V1, V0, 2
9D0004FC  00621823   SUBU V1, V1, V0
9D000500  2482753C   ADDIU V0, A0, 30012
9D000504  00621821   ADDU V1, V1, V0
9D000508  8C620028   LW V0, 40(V1)
9D00050C  24040001   ADDIU A0, ZERO, 1
9D000510  7C8218C4   INS V0, A0, 3, 1
9D000514  AC620028   SW V0, 40(V1)
581:                             MyTCBStub.smState = TCP_LISTEN;
9D000518  93828014   LBU V0, -32748(GP)
9D00051C  3C03A000   LUI V1, -24576
9D000520  2463753C   ADDIU V1, V1, 30012
9D000524  00021100   SLL V0, V0, 4
9D000528  00022080   SLL A0, V0, 2
9D00052C  00821023   SUBU V0, A0, V0
9D000530  00621021   ADDU V0, V1, V0
9D000534  24030004   ADDIU V1, ZERO, 4
9D000538  AC430024   SW V1, 36(V0)
582:                             MyTCBStub.remoteHash.Val = wPort;
9D00053C  93828014   LBU V0, -32748(GP)
9D000540  3C04A000   LUI A0, -24576
9D000544  00021100   SLL V0, V0, 4
9D000548  00021880   SLL V1, V0, 2
9D00054C  00621823   SUBU V1, V1, V0
9D000550  2482753C   ADDIU V0, A0, 30012
9D000554  00621021   ADDU V0, V1, V0
9D000558  97C30030   LHU V1, 48(S8)
9D00055C  A443002A   SH V1, 42(V0)
9D000560  0B4001FB   J 0x9D0007EC
9D000564  00000000   NOP
583:                             #if defined(STACK_USE_SSL_SERVER)
584:                             MyTCB.localSSLPort.Val = 0;
585:                             #endif
586:                         }
587:                         // Handle all the client mode socket types
588:                         else
589:                         {
590:                             #if defined(STACK_CLIENT_MODE)
591:                             {
592:                                 // Each new socket that is opened by this node, gets the
593:                                 // next sequential local port number.
594:                                 if(NextPort < LOCAL_PORT_START_NUMBER || NextPort > LOCAL_PORT_END_NUMBER)
9D000568  3C02A001   LUI V0, -24575
9D00056C  94428950   LHU V0, -30384(V0)
9D000570  2C420400   SLTIU V0, V0, 1024
9D000574  14400006   BNE V0, ZERO, 0x9D000590
9D000578  00000000   NOP
9D00057C  3C02A001   LUI V0, -24575
9D000580  94428950   LHU V0, -30384(V0)
9D000584  2C421389   SLTIU V0, V0, 5001
9D000588  14400004   BNE V0, ZERO, 0x9D00059C
9D00058C  00000000   NOP
595:                                     NextPort = LOCAL_PORT_START_NUMBER;
9D000590  3C02A001   LUI V0, -24575
9D000594  24030400   ADDIU V1, ZERO, 1024
9D000598  A4438950   SH V1, -30384(V0)
596:                 
597:                                 // Set the non-zero TCB fields
598:                                 MyTCB.localPort.Val = NextPort++;
9D00059C  3C02A001   LUI V0, -24575
9D0005A0  94428950   LHU V0, -30384(V0)
9D0005A4  3C03A000   LUI V1, -24576
9D0005A8  2463759C   ADDIU V1, V1, 30108
9D0005AC  A4620012   SH V0, 18(V1)
9D0005B0  24420001   ADDIU V0, V0, 1
9D0005B4  3043FFFF   ANDI V1, V0, -1
9D0005B8  3C02A001   LUI V0, -24575
9D0005BC  A4438950   SH V1, -30384(V0)
599:                                 MyTCB.remotePort.Val = wPort;
9D0005C0  3C02A000   LUI V0, -24576
9D0005C4  2442759C   ADDIU V0, V0, 30108
9D0005C8  97C30030   LHU V1, 48(S8)
9D0005CC  A4430010   SH V1, 16(V0)
600:                 
601:                                 // Flag to start the DNS, ARP, SYN processes
602:                                 MyTCBStub.eventTime = TickGet();
9D0005D0  93828014   LBU V0, -32748(GP)
9D0005D4  00408021   ADDU S0, V0, ZERO
9D0005D8  0F405C42   JAL TickGet
9D0005DC  00000000   NOP
9D0005E0  00401821   ADDU V1, V0, ZERO
9D0005E4  3C02A000   LUI V0, -24576
9D0005E8  2444753C   ADDIU A0, V0, 30012
9D0005EC  02001021   ADDU V0, S0, ZERO
9D0005F0  00021100   SLL V0, V0, 4
9D0005F4  00022880   SLL A1, V0, 2
9D0005F8  00A21023   SUBU V0, A1, V0
9D0005FC  00821021   ADDU V0, A0, V0
9D000600  AC43001C   SW V1, 28(V0)
603:                                 MyTCBStub.Flags.bTimerEnabled = 1;
9D000604  93828014   LBU V0, -32748(GP)
9D000608  3C04A000   LUI A0, -24576
9D00060C  00021100   SLL V0, V0, 4
9D000610  00021880   SLL V1, V0, 2
9D000614  00621823   SUBU V1, V1, V0
9D000618  2482753C   ADDIU V0, A0, 30012
9D00061C  00621821   ADDU V1, V1, V0
9D000620  8C620028   LW V0, 40(V1)
9D000624  24040001   ADDIU A0, ZERO, 1
9D000628  7C822104   INS V0, A0, 4, 1
9D00062C  AC620028   SW V0, 40(V1)
604:                 
605:                                 switch(vRemoteHostType)
9D000630  93C2002C   LBU V0, 44(S8)
9D000634  24030003   ADDIU V1, ZERO, 3
9D000638  10430006   BEQ V0, V1, 0x9D000654
9D00063C  00000000   NOP
9D000640  24030004   ADDIU V1, ZERO, 4
9D000644  10430031   BEQ V0, V1, 0x9D00070C
9D000648  00000000   NOP
9D00064C  0B4001FB   J 0x9D0007EC
9D000650  00000000   NOP
606:                                 {
607:                                     #if defined(STACK_USE_DNS)
608:                                     case TCP_OPEN_RAM_HOST:
609:                                     case TCP_OPEN_ROM_HOST:
610:                                         MyTCB.remote.dwRemoteHost = dwRemoteHost;
611:                                         MyTCB.flags.bRemoteHostIsROM = (vRemoteHostType == TCP_OPEN_ROM_HOST);
612:                                         MyTCBStub.smState = TCP_GET_DNS_MODULE;
613:                                         break;
614:                                     #endif
615:                 
616:                                     case TCP_OPEN_IP_ADDRESS:
617:                                         // dwRemoteHost is a literal IP address.  This
618:                                         // doesn't need DNS and can skip directly to the
619:                                         // Gateway ARPing step.
620:                                         MyTCBStub.remoteHash.Val = (((TCPIP_UINT32_VAL*)&dwRemoteHost)->w[1]+((TCPIP_UINT32_VAL*)&dwRemoteHost)->w[0] + wPort) ^ MyTCB.localPort.Val;
9D000654  93828014   LBU V0, -32748(GP)
9D000658  27C30028   ADDIU V1, S8, 40
9D00065C  94640002   LHU A0, 2(V1)
9D000660  27C30028   ADDIU V1, S8, 40
9D000664  94630000   LHU V1, 0(V1)
9D000668  00831821   ADDU V1, A0, V1
9D00066C  3064FFFF   ANDI A0, V1, -1
9D000670  97C30030   LHU V1, 48(S8)
9D000674  00831821   ADDU V1, A0, V1
9D000678  3063FFFF   ANDI V1, V1, -1
9D00067C  7C032620   SEH A0, V1
9D000680  3C03A000   LUI V1, -24576
9D000684  2463759C   ADDIU V1, V1, 30108
9D000688  94630012   LHU V1, 18(V1)
9D00068C  7C031E20   SEH V1, V1
9D000690  00831826   XOR V1, A0, V1
9D000694  7C031E20   SEH V1, V1
9D000698  3064FFFF   ANDI A0, V1, -1
9D00069C  3C05A000   LUI A1, -24576
9D0006A0  00021100   SLL V0, V0, 4
9D0006A4  00021880   SLL V1, V0, 2
9D0006A8  00621823   SUBU V1, V1, V0
9D0006AC  24A2753C   ADDIU V0, A1, 30012
9D0006B0  00621021   ADDU V0, V1, V0
9D0006B4  A444002A   SH A0, 42(V0)
621:                                         MyTCB.remote.niRemoteMACIP.IPAddr.Val = dwRemoteHost;
9D0006B8  8FC30028   LW V1, 40(S8)
9D0006BC  3C02A000   LUI V0, -24576
9D0006C0  2442759C   ADDIU V0, V0, 30108
9D0006C4  AC430018   SW V1, 24(V0)
622:                                         MyTCB.retryCount = 0;
9D0006C8  3C02A000   LUI V0, -24576
9D0006CC  2442759C   ADDIU V0, V0, 30108
9D0006D0  A040002A   SB ZERO, 42(V0)
623:                                         MyTCB.retryInterval = (TICK_SECOND/4)/256;
9D0006D4  3C02A000   LUI V0, -24576
9D0006D8  24030131   ADDIU V1, ZERO, 305
9D0006DC  AC43759C   SW V1, 30108(V0)
624:                                         MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D0006E0  93828014   LBU V0, -32748(GP)
9D0006E4  3C03A000   LUI V1, -24576
9D0006E8  2463753C   ADDIU V1, V1, 30012
9D0006EC  00021100   SLL V0, V0, 4
9D0006F0  00022080   SLL A0, V0, 2
9D0006F4  00821023   SUBU V0, A0, V0
9D0006F8  00621021   ADDU V0, V1, V0
9D0006FC  24030002   ADDIU V1, ZERO, 2
9D000700  AC430024   SW V1, 36(V0)
625:                                         break;
9D000704  0B4001FB   J 0x9D0007EC
9D000708  00000000   NOP
626:                 
627:                                     case TCP_OPEN_NODE_INFO:
628:                                         MyTCBStub.remoteHash.Val = (((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[1]+((NODE_INFO*)(PTR_BASE)dwRemoteHost)->IPAddr.w[0] + wPort) ^ MyTCB.localPort.Val;
9D00070C  93828014   LBU V0, -32748(GP)
9D000710  00401821   ADDU V1, V0, ZERO
9D000714  8FC20028   LW V0, 40(S8)
9D000718  90440002   LBU A0, 2(V0)
9D00071C  90420003   LBU V0, 3(V0)
9D000720  00021200   SLL V0, V0, 8
9D000724  00441025   OR V0, V0, A0
9D000728  3044FFFF   ANDI A0, V0, -1
9D00072C  8FC20028   LW V0, 40(S8)
9D000730  90450000   LBU A1, 0(V0)
9D000734  90420001   LBU V0, 1(V0)
9D000738  00021200   SLL V0, V0, 8
9D00073C  00451025   OR V0, V0, A1
9D000740  3042FFFF   ANDI V0, V0, -1
9D000744  00821021   ADDU V0, A0, V0
9D000748  3044FFFF   ANDI A0, V0, -1
9D00074C  97C20030   LHU V0, 48(S8)
9D000750  00821021   ADDU V0, A0, V0
9D000754  3042FFFF   ANDI V0, V0, -1
9D000758  7C022620   SEH A0, V0
9D00075C  3C02A000   LUI V0, -24576
9D000760  2442759C   ADDIU V0, V0, 30108
9D000764  94420012   LHU V0, 18(V0)
9D000768  7C021620   SEH V0, V0
9D00076C  00821026   XOR V0, A0, V0
9D000770  7C021620   SEH V0, V0
9D000774  3044FFFF   ANDI A0, V0, -1
9D000778  3C05A000   LUI A1, -24576
9D00077C  00601021   ADDU V0, V1, ZERO
9D000780  00021100   SLL V0, V0, 4
9D000784  00021880   SLL V1, V0, 2
9D000788  00621823   SUBU V1, V1, V0
9D00078C  24A2753C   ADDIU V0, A1, 30012
9D000790  00621021   ADDU V0, V1, V0
9D000794  A444002A   SH A0, 42(V0)
629:                                         memcpy((void*)(uint8_t*)&MyTCB.remote, (void*)(uint8_t*)(PTR_BASE)dwRemoteHost, sizeof(NODE_INFO));
9D000798  8FC20028   LW V0, 40(S8)
9D00079C  3C03A000   LUI V1, -24576
9D0007A0  246475B4   ADDIU A0, V1, 30132
9D0007A4  00402821   ADDU A1, V0, ZERO
9D0007A8  2406000A   ADDIU A2, ZERO, 10
9D0007AC  0F406788   JAL 0x9D019E20
9D0007B0  00000000   NOP
630:                                         MyTCBStub.smState = TCP_SYN_SENT;
9D0007B4  93828014   LBU V0, -32748(GP)
9D0007B8  3C03A000   LUI V1, -24576
9D0007BC  2463753C   ADDIU V1, V1, 30012
9D0007C0  00021100   SLL V0, V0, 4
9D0007C4  00022080   SLL A0, V0, 2
9D0007C8  00821023   SUBU V0, A0, V0
9D0007CC  00621021   ADDU V0, V1, V0
9D0007D0  24030005   ADDIU V1, ZERO, 5
9D0007D4  AC430024   SW V1, 36(V0)
631:                                         SendTCP(SYN, SENDTCP_RESET_TIMERS);
9D0007D8  24040002   ADDIU A0, ZERO, 2
9D0007DC  24050001   ADDIU A1, ZERO, 1
9D0007E0  0F400F2C   JAL 0x9D003CB0
9D0007E4  00000000   NOP
632:                                         break;
9D0007E8  00000000   NOP
633:                                 }
634:                             }
635:                             #else
636:                             {
637:                                 return INVALID_SOCKET;
638:                             }
639:                             #endif
640:                         }
641:                 
642:                         return hTCP;
9D0007EC  93C20010   LBU V0, 16(S8)
9D0007F0  0B40020A   J 0x9D000828
9D0007F4  00000000   NOP
643:                     }
644:                 
645:                     // If there is no socket available, return error.
646:                     return INVALID_SOCKET;
9D000824  240200FE   ADDIU V0, ZERO, 254
647:                 }
9D000828  03C0E821   ADDU SP, S8, ZERO
9D00082C  8FBF0024   LW RA, 36(SP)
9D000830  8FBE0020   LW S8, 32(SP)
9D000834  8FB0001C   LW S0, 28(SP)
9D000838  27BD0028   ADDIU SP, SP, 40
9D00083C  03E00008   JR RA
9D000840  00000000   NOP
648:                 
649:                 
650:                 /*****************************************************************************
651:                   Function:
652:                     bool TCPWasReset(TCP_SOCKET hTCP)
653:                 
654:                   Summary:
655:                     Self-clearing semaphore inidicating socket reset.
656:                 
657:                   Description:
658:                     This function is a self-clearing semaphore indicating whether or not
659:                     a socket has been disconnected since the previous call.  This function
660:                     works for all possible disconnections: a call to TCPDisconnect, a FIN
661:                     from the remote node, or an acknowledgement timeout caused by the loss
662:                     of a network link.  It also returns true after the first call to TCPInit.
663:                     Applications should use this function to reset their state machines.
664:                 
665:                     This function was added due to the possibility of an error when relying
666:                     on TCPIsConnected returing false to check for a condition requiring a
667:                     state machine reset.  If a socket is closed (due to a FIN ACK) and then
668:                     immediately reopened (due to a the arrival of a new SYN) in the same
669:                     cycle of the stack, calls to TCPIsConnected by the application will
670:                     never return false even though the socket has been disconnected.  This
671:                     can cause errors for protocols such as HTTP in which a client will
672:                     immediately open a new connection upon closing of a prior one.  Relying
673:                     on this function instead allows applications to trap those conditions
674:                     and properly reset their internal state for the new connection.
675:                 
676:                   Precondition:
677:                     TCP is initialized.
678:                 
679:                   Parameters:
680:                     hTCP - The socket to check.
681:                 
682:                   Return Values:
683:                     true - The socket has been disconnected since the previous call.
684:                     false - The socket has not been disconnected since the previous call.
685:                   ***************************************************************************/
686:                 bool TCPWasReset(TCP_SOCKET hTCP)
687:                 {
9D000844  27BDFFF8   ADDIU SP, SP, -8
9D000848  AFBE0004   SW S8, 4(SP)
9D00084C  03A0F021   ADDU S8, SP, ZERO
9D000850  00801021   ADDU V0, A0, ZERO
9D000854  A3C20008   SB V0, 8(S8)
688:                     if(hTCP >= TCP_SOCKET_COUNT)
9D000858  93C20008   LBU V0, 8(S8)
9D00085C  2C420002   SLTIU V0, V0, 2
9D000860  14400004   BNE V0, ZERO, 0x9D000874
9D000864  00000000   NOP
689:                     {
690:                         return true;
9D000868  24020001   ADDIU V0, ZERO, 1
9D00086C  0B400239   J 0x9D0008E4
9D000870  00000000   NOP
691:                     }
692:                 
693:                     SyncTCBStub(hTCP);
9D000874  93C20008   LBU V0, 8(S8)
9D000878  A3828014   SB V0, -32748(GP)
694:                 
695:                     if(MyTCBStub.Flags.bSocketReset)
9D00087C  93828014   LBU V0, -32748(GP)
9D000880  3C04A000   LUI A0, -24576
9D000884  00021100   SLL V0, V0, 4
9D000888  00021880   SLL V1, V0, 2
9D00088C  00621823   SUBU V1, V1, V0
9D000890  2482753C   ADDIU V0, A0, 30012
9D000894  00621021   ADDU V0, V1, V0
9D000898  8C420028   LW V0, 40(V0)
9D00089C  7C420300   EXT V0, V0, 12, 1
9D0008A0  304200FF   ANDI V0, V0, 255
9D0008A4  1040000E   BEQ V0, ZERO, 0x9D0008E0
9D0008A8  00000000   NOP
696:                     {
697:                         MyTCBStub.Flags.bSocketReset = 0;
9D0008AC  93828014   LBU V0, -32748(GP)
9D0008B0  3C04A000   LUI A0, -24576
9D0008B4  00021100   SLL V0, V0, 4
9D0008B8  00021880   SLL V1, V0, 2
9D0008BC  00621823   SUBU V1, V1, V0
9D0008C0  2482753C   ADDIU V0, A0, 30012
9D0008C4  00621821   ADDU V1, V1, V0
9D0008C8  8C620028   LW V0, 40(V1)
9D0008CC  7C026304   INS V0, ZERO, 12, 1
9D0008D0  AC620028   SW V0, 40(V1)
698:                         return true;
9D0008D4  24020001   ADDIU V0, ZERO, 1
9D0008D8  0B400239   J 0x9D0008E4
9D0008DC  00000000   NOP
699:                     }
700:                 
701:                     return false;
9D0008E0  00001021   ADDU V0, ZERO, ZERO
702:                 }
9D0008E4  03C0E821   ADDU SP, S8, ZERO
9D0008E8  8FBE0004   LW S8, 4(SP)
9D0008EC  27BD0008   ADDIU SP, SP, 8
9D0008F0  03E00008   JR RA
9D0008F4  00000000   NOP
703:                 
704:                 
705:                 /*****************************************************************************
706:                   Function:
707:                     bool TCPIsConnected(TCP_SOCKET hTCP)
708:                 
709:                   Summary:
710:                     Determines if a socket has an established connection.
711:                 
712:                   Description:
713:                     This function determines if a socket has an established connection to
714:                     a remote node.  Call this function after calling TCPOpen to determine
715:                     when the connection is set up and ready for use.  This function was
716:                     historically used to check for disconnections, but TCPWasReset is now a
717:                     more appropriate solution.
718:                 
719:                   Precondition:
720:                     TCP is initialized.
721:                 
722:                   Parameters:
723:                     hTCP - The socket to check.
724:                 
725:                   Return Values:
726:                     true - The socket has an established connection to a remote node.
727:                     false - The socket is not currently connected.
728:                 
729:                   Remarks:
730:                     A socket is said to be connected only if it is in the TCP_ESTABLISHED
731:                     state.  Sockets in the process of opening or closing will return false.
732:                   ***************************************************************************/
733:                 bool TCPIsConnected(TCP_SOCKET hTCP)
734:                 {
9D0008F8  27BDFFF8   ADDIU SP, SP, -8
9D0008FC  AFBE0004   SW S8, 4(SP)
9D000900  03A0F021   ADDU S8, SP, ZERO
9D000904  00801021   ADDU V0, A0, ZERO
9D000908  A3C20008   SB V0, 8(S8)
735:                     if(hTCP >= TCP_SOCKET_COUNT)
9D00090C  93C20008   LBU V0, 8(S8)
9D000910  2C420002   SLTIU V0, V0, 2
9D000914  14400004   BNE V0, ZERO, 0x9D000928
9D000918  00000000   NOP
736:                     {
737:                         return false;
9D00091C  00001021   ADDU V0, ZERO, ZERO
9D000920  0B400257   J 0x9D00095C
9D000924  00000000   NOP
738:                     }
739:                 
740:                     SyncTCBStub(hTCP);
9D000928  93C20008   LBU V0, 8(S8)
9D00092C  A3828014   SB V0, -32748(GP)
741:                     return (MyTCBStub.smState == TCP_ESTABLISHED);
9D000930  93828014   LBU V0, -32748(GP)
9D000934  3C03A000   LUI V1, -24576
9D000938  2463753C   ADDIU V1, V1, 30012
9D00093C  00021100   SLL V0, V0, 4
9D000940  00022080   SLL A0, V0, 2
9D000944  00821023   SUBU V0, A0, V0
9D000948  00621021   ADDU V0, V1, V0
9D00094C  8C420024   LW V0, 36(V0)
9D000950  38420007   XORI V0, V0, 7
9D000954  2C420001   SLTIU V0, V0, 1
9D000958  304200FF   ANDI V0, V0, 255
742:                 }
9D00095C  03C0E821   ADDU SP, S8, ZERO
9D000960  8FBE0004   LW S8, 4(SP)
9D000964  27BD0008   ADDIU SP, SP, 8
9D000968  03E00008   JR RA
9D00096C  00000000   NOP
743:                 
744:                 
745:                 /*****************************************************************************
746:                   Function:
747:                     void TCPDisconnect(TCP_SOCKET hTCP)
748:                 
749:                   Summary:
750:                     Disconnects an open socket.
751:                 
752:                   Description:
753:                     This function closes a connection to a remote node by sending a FIN (if
754:                     currently connected).
755:                 
756:                     The function can be called a second time to force a socket closed by
757:                     sending a RST packet.  This is useful when the application knows that
758:                     the remote node will not send an ACK (if it has crashed or lost its link),
759:                     or when the application needs to reuse the socket immediately regardless
760:                     of whether or not the remote node would like to transmit more data before
761:                     closing.
762:                 
763:                     For client mode sockets, upon return, the hTCP handle is relinquished to
764:                     the TCP/IP stack and must no longer be used by the application (except for
765:                     an immediate subsequent call to TCPDisconnect() to force a RST
766:                     transmission, if needed).
767:                 
768:                     For server mode sockets, upon return, the hTCP handle is NOT relinquished
769:                     to the TCP/IP stack.  After closing, the socket returns to the listening
770:                     state allowing future connection requests to be serviced.  This leaves the
771:                     hTCP handle in a valid state and must be retained for future operations on
772:                     the socket.  If you want to close the server and relinquish the socket back
773:                     to the TCP/IP stack, call the TCPClose() API instead of TCPDisconnect().
774:                 
775:                   Precondition:
776:                     None
777:                 
778:                   Parameters:
779:                     hTCP - Handle of the socket to disconnect.
780:                 
781:                   Returns:
782:                     None
783:                 
784:                   Remarks:
785:                     If the socket is using SSL, a CLOSE_NOTIFY record will be transmitted
786:                     first to allow the SSL session to be resumed at a later time.
787:                   ***************************************************************************/
788:                 void TCPDisconnect(TCP_SOCKET hTCP)
789:                 {
9D000970  27BDFFE8   ADDIU SP, SP, -24
9D000974  AFBF0014   SW RA, 20(SP)
9D000978  AFBE0010   SW S8, 16(SP)
9D00097C  03A0F021   ADDU S8, SP, ZERO
9D000980  00801021   ADDU V0, A0, ZERO
9D000984  A3C20018   SB V0, 24(S8)
790:                     if(hTCP >= TCP_SOCKET_COUNT)
9D000988  93C20018   LBU V0, 24(S8)
9D00098C  2C420002   SLTIU V0, V0, 2
9D000990  10400096   BEQ V0, ZERO, 0x9D000BEC
9D000994  00000000   NOP
791:                     {
792:                         return;
9D000BEC  00000000   NOP
793:                     }
794:                 
795:                     SyncTCBStub(hTCP);
9D000998  93C20018   LBU V0, 24(S8)
9D00099C  A3828014   SB V0, -32748(GP)
796:                 
797:                     // Delete all data in the RX FIFO
798:                     // In this stack's API, the application TCP handle is
799:                     // immediately invalid after calling this function, so there
800:                     // is no longer any way to receive data from the TCP RX FIFO,
801:                     // even though the data is still there.  Leaving the data there
802:                     // could interfere with the remote node sending us a FIN if our
803:                     // RX window is zero
804:                     MyTCBStub.rxTail = MyTCBStub.rxHead;
9D0009A0  93828014   LBU V0, -32748(GP)
9D0009A4  00401821   ADDU V1, V0, ZERO
9D0009A8  93828014   LBU V0, -32748(GP)
9D0009AC  3C04A000   LUI A0, -24576
9D0009B0  2484753C   ADDIU A0, A0, 30012
9D0009B4  00021100   SLL V0, V0, 4
9D0009B8  00022880   SLL A1, V0, 2
9D0009BC  00A21023   SUBU V0, A1, V0
9D0009C0  00821021   ADDU V0, A0, V0
9D0009C4  8C440014   LW A0, 20(V0)
9D0009C8  3C05A000   LUI A1, -24576
9D0009CC  00601021   ADDU V0, V1, ZERO
9D0009D0  00021100   SLL V0, V0, 4
9D0009D4  00021880   SLL V1, V0, 2
9D0009D8  00621823   SUBU V1, V1, V0
9D0009DC  24A2753C   ADDIU V0, A1, 30012
9D0009E0  00621021   ADDU V0, V1, V0
9D0009E4  AC440018   SW A0, 24(V0)
805:                 
806:                     switch(MyTCBStub.smState)
9D0009E8  93828014   LBU V0, -32748(GP)
9D0009EC  3C03A000   LUI V1, -24576
9D0009F0  2463753C   ADDIU V1, V1, 30012
9D0009F4  00021100   SLL V0, V0, 4
9D0009F8  00022080   SLL A0, V0, 2
9D0009FC  00821023   SUBU V0, A0, V0
9D000A00  00621021   ADDU V0, V1, V0
9D000A04  8C420024   LW V0, 36(V0)
9D000A08  2C43000F   SLTIU V1, V0, 15
9D000A0C  1060006E   BEQ V1, ZERO, 0x9D000BC8
9D000A10  00000000   NOP
9D000A14  00021880   SLL V1, V0, 2
9D000A18  3C029D00   LUI V0, -25344
9D000A1C  24420A30   ADDIU V0, V0, 2608
9D000A20  00621021   ADDU V0, V1, V0
9D000A24  8C420000   LW V0, 0(V0)
9D000A28  00400008   JR V0
9D000A2C  00000000   NOP
807:                     {
808:                         #if defined(STACK_CLIENT_MODE) && defined(STACK_USE_DNS)
809:                         case TCP_DNS_RESOLVE:
810:                             DNSEndUsage();  // Release the DNS module, since the user is aborting
811:                             CloseSocket();
812:                             break;
813:                         #endif
814:                 
815:                         case TCP_GET_DNS_MODULE:
816:                         case TCP_GATEWAY_SEND_ARP:
817:                         case TCP_GATEWAY_GET_ARP:
818:                         case TCP_SYN_SENT:
819:                             CloseSocket();
9D000A6C  0F401470   JAL 0x9D0051C0
9D000A70  00000000   NOP
820:                             break;
9D000A74  0B4002FC   J 0x9D000BF0
9D000A78  00000000   NOP
821:                 
822:                         case TCP_SYN_RECEIVED:
823:                         case TCP_ESTABLISHED:
824:                             #if defined(STACK_USE_SSL)
825:                             // When disconnecting SSL sockets, send a close_notify so we can resume later
826:                             if(MyTCBStub.sslStubID != SSL_INVALID_ID)
827:                             {
828:                                 // Flush pending data and send close_notify
829:                                 SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
830:                                 SSLTxMessage(hTCP, MyTCBStub.sslStubID, SSL_ALERT_CLOSE_NOTIFY);
831:                             }
832:                             #endif
833:                 
834:                             // Send the FIN.  This is done in a loop to ensure that if we have
835:                             // more data wating in the TX FIFO than can be sent in a single
836:                             // packet (due to the remote Max Segment Size packet size limit),
837:                             // we will keep generating more packets until either all data gets
838:                             // transmitted or the remote node's receive window fills up.
839:                             do
840:                             {
841:                                 SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D000A7C  24040011   ADDIU A0, ZERO, 17
9D000A80  24050001   ADDIU A1, ZERO, 1
9D000A84  0F400F2C   JAL 0x9D003CB0
9D000A88  00000000   NOP
842:                                 if(MyTCB.remoteWindow == 0u)
9D000A8C  3C02A000   LUI V0, -24576
9D000A90  2442759C   ADDIU V0, V0, 30108
9D000A94  94420014   LHU V0, 20(V0)
9D000A98  10400010   BEQ V0, ZERO, 0x9D000ADC
9D000A9C  00000000   NOP
843:                                     break;
9D000ADC  00000000   NOP
844:                             } while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9D000AA0  93828014   LBU V0, -32748(GP)
9D000AA4  3C03A000   LUI V1, -24576
9D000AA8  2463753C   ADDIU V1, V1, 30012
9D000AAC  00021100   SLL V0, V0, 4
9D000AB0  00022080   SLL A0, V0, 2
9D000AB4  00821023   SUBU V0, A0, V0
9D000AB8  00621021   ADDU V0, V1, V0
9D000ABC  8C43000C   LW V1, 12(V0)
9D000AC0  3C02A000   LUI V0, -24576
9D000AC4  2442759C   ADDIU V0, V0, 30108
9D000AC8  8C42000C   LW V0, 12(V0)
9D000ACC  1462FFEB   BNE V1, V0, 0x9D000A7C
9D000AD0  00000000   NOP
9D000AD4  0B4002B8   J 0x9D000AE0
9D000AD8  00000000   NOP
845:                 
846:                             MyTCBStub.smState = TCP_FIN_WAIT_1;
9D000AE0  93828014   LBU V0, -32748(GP)
9D000AE4  3C03A000   LUI V1, -24576
9D000AE8  2463753C   ADDIU V1, V1, 30012
9D000AEC  00021100   SLL V0, V0, 4
9D000AF0  00022080   SLL A0, V0, 2
9D000AF4  00821023   SUBU V0, A0, V0
9D000AF8  00621021   ADDU V0, V1, V0
9D000AFC  24030008   ADDIU V1, ZERO, 8
9D000B00  AC430024   SW V1, 36(V0)
847:                             break;
9D000B04  0B4002FC   J 0x9D000BF0
9D000B08  00000000   NOP
848:                 
849:                         case TCP_CLOSE_WAIT:
850:                             // Send the FIN.  This is done in a loop to ensure that if we have
851:                             // more data wating in the TX FIFO than can be sent in a single
852:                             // packet (due to the remote Max Segment Size packet size limit),
853:                             // we will keep generating more packets until either all data gets
854:                             // transmitted or the remote node's receive window fills up.
855:                             do
856:                             {
857:                                 SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D000B0C  24040011   ADDIU A0, ZERO, 17
9D000B10  24050001   ADDIU A1, ZERO, 1
9D000B14  0F400F2C   JAL 0x9D003CB0
9D000B18  00000000   NOP
858:                                 if(MyTCB.remoteWindow == 0u)
9D000B1C  3C02A000   LUI V0, -24576
9D000B20  2442759C   ADDIU V0, V0, 30108
9D000B24  94420014   LHU V0, 20(V0)
9D000B28  10400010   BEQ V0, ZERO, 0x9D000B6C
9D000B2C  00000000   NOP
859:                                     break;
9D000B6C  00000000   NOP
860:                             } while(MyTCBStub.txHead != MyTCB.txUnackedTail);
9D000B30  93828014   LBU V0, -32748(GP)
9D000B34  3C03A000   LUI V1, -24576
9D000B38  2463753C   ADDIU V1, V1, 30012
9D000B3C  00021100   SLL V0, V0, 4
9D000B40  00022080   SLL A0, V0, 2
9D000B44  00821023   SUBU V0, A0, V0
9D000B48  00621021   ADDU V0, V1, V0
9D000B4C  8C43000C   LW V1, 12(V0)
9D000B50  3C02A000   LUI V0, -24576
9D000B54  2442759C   ADDIU V0, V0, 30108
9D000B58  8C42000C   LW V0, 12(V0)
9D000B5C  1462FFEB   BNE V1, V0, 0x9D000B0C
9D000B60  00000000   NOP
9D000B64  0B4002DC   J 0x9D000B70
9D000B68  00000000   NOP
861:                 
862:                             MyTCBStub.smState = TCP_LAST_ACK;
9D000B70  93828014   LBU V0, -32748(GP)
9D000B74  3C03A000   LUI V1, -24576
9D000B78  2463753C   ADDIU V1, V1, 30012
9D000B7C  00021100   SLL V0, V0, 4
9D000B80  00022080   SLL A0, V0, 2
9D000B84  00821023   SUBU V0, A0, V0
9D000B88  00621021   ADDU V0, V1, V0
9D000B8C  2403000C   ADDIU V1, ZERO, 12
9D000B90  AC430024   SW V1, 36(V0)
863:                             break;
9D000B94  0B4002FC   J 0x9D000BF0
9D000B98  00000000   NOP
864:                 
865:                         // These states are all already closed or don't need explicit disconnecting -- they will disconnect by themselves after a while
866:                         //case TCP_CLOSED:
867:                         //case TCP_LISTEN:
868:                         //case TCP_CLOSING:
869:                         //case TCP_TIME_WAIT:
870:                         //  return;
871:                 
872:                         case TCP_CLOSED_BUT_RESERVED:
873:                             MyTCBStub.smState = TCP_CLOSED;
9D000B9C  93828014   LBU V0, -32748(GP)
9D000BA0  3C03A000   LUI V1, -24576
9D000BA4  2463753C   ADDIU V1, V1, 30012
9D000BA8  00021100   SLL V0, V0, 4
9D000BAC  00022080   SLL A0, V0, 2
9D000BB0  00821023   SUBU V0, A0, V0
9D000BB4  00621021   ADDU V0, V1, V0
9D000BB8  2403000D   ADDIU V1, ZERO, 13
9D000BBC  AC430024   SW V1, 36(V0)
874:                             break;
9D000BC0  0B4002FC   J 0x9D000BF0
9D000BC4  00000000   NOP
875:                 
876:                         // These states will close themselves after some delay, however,
877:                         // this is handled so that the user can call TCPDisconnect()
878:                         // twice to immediately close a socket (using an RST) without
879:                         // having to get an ACK back from the remote node.  This is
880:                         // great for instance when the application determines that
881:                         // the remote node has been physically disconnected and
882:                         // already knows that no ACK will be returned.  Alternatively,
883:                         // if the application needs to immediately reuse the socket
884:                         // regardless of what the other node's state is in (half open).
885:                         case TCP_FIN_WAIT_1:
886:                         case TCP_FIN_WAIT_2:
887:                         case TCP_LAST_ACK:
888:                         default:
889:                             SendTCP(RST | ACK, 0);
9D000BC8  24040014   ADDIU A0, ZERO, 20
9D000BCC  00002821   ADDU A1, ZERO, ZERO
9D000BD0  0F400F2C   JAL 0x9D003CB0
9D000BD4  00000000   NOP
890:                             CloseSocket();
9D000BD8  0F401470   JAL 0x9D0051C0
9D000BDC  00000000   NOP
891:                             break;
9D000BE0  00000000   NOP
9D000BE4  0B4002FC   J 0x9D000BF0
9D000BE8  00000000   NOP
892:                     }
893:                 }
9D000BF0  03C0E821   ADDU SP, S8, ZERO
9D000BF4  8FBF0014   LW RA, 20(SP)
9D000BF8  8FBE0010   LW S8, 16(SP)
9D000BFC  27BD0018   ADDIU SP, SP, 24
9D000C00  03E00008   JR RA
9D000C04  00000000   NOP
894:                 
895:                 
896:                 /*****************************************************************************
897:                   Function:
898:                     void TCPClose(TCP_SOCKET hTCP)
899:                 
900:                   Summary:
901:                     Disconnects an open socket and destroys the socket handle, including server
902:                     mode socket handles.
903:                 
904:                   Description:
905:                     Disconnects an open socket and destroys the socket handle, including server
906:                     mode socket handles.  This function performs identically to the
907:                     TCPDisconnect() function, except that both client and server mode socket
908:                     handles are relinquished to the TCP/IP stack upon return.
909:                 
910:                   Precondition:
911:                     None
912:                 
913:                   Parameters:
914:                     hTCP - Handle to the socket to disconnect and close.
915:                 
916:                   Returns:
917:                     None
918:                   ***************************************************************************/
919:                 void TCPClose(TCP_SOCKET hTCP)
920:                 {
9D000C08  27BDFFE8   ADDIU SP, SP, -24
9D000C0C  AFBF0014   SW RA, 20(SP)
9D000C10  AFBE0010   SW S8, 16(SP)
9D000C14  03A0F021   ADDU S8, SP, ZERO
9D000C18  00801021   ADDU V0, A0, ZERO
9D000C1C  A3C20018   SB V0, 24(S8)
921:                     if(hTCP >= TCP_SOCKET_COUNT)
9D000C20  93C20018   LBU V0, 24(S8)
9D000C24  2C420002   SLTIU V0, V0, 2
9D000C28  10400013   BEQ V0, ZERO, 0x9D000C78
9D000C2C  00000000   NOP
922:                     {
923:                         return;
9D000C78  00000000   NOP
924:                     }
925:                 
926:                     SyncTCBStub(hTCP);
9D000C30  93C20018   LBU V0, 24(S8)
9D000C34  A3828014   SB V0, -32748(GP)
927:                     MyTCBStub.Flags.bServer = false;
9D000C38  93828014   LBU V0, -32748(GP)
9D000C3C  3C04A000   LUI A0, -24576
9D000C40  00021100   SLL V0, V0, 4
9D000C44  00021880   SLL V1, V0, 2
9D000C48  00621823   SUBU V1, V1, V0
9D000C4C  2482753C   ADDIU V0, A0, 30012
9D000C50  00621821   ADDU V1, V1, V0
9D000C54  8C620028   LW V0, 40(V1)
9D000C58  7C0218C4   INS V0, ZERO, 3, 1
9D000C5C  AC620028   SW V0, 40(V1)
928:                     TCPDisconnect(hTCP);
9D000C60  93C20018   LBU V0, 24(S8)
9D000C64  00402021   ADDU A0, V0, ZERO
9D000C68  0F40025C   JAL TCPDisconnect
9D000C6C  00000000   NOP
9D000C70  0B40031F   J 0x9D000C7C
9D000C74  00000000   NOP
929:                 }
9D000C7C  03C0E821   ADDU SP, S8, ZERO
9D000C80  8FBF0014   LW RA, 20(SP)
9D000C84  8FBE0010   LW S8, 16(SP)
9D000C88  27BD0018   ADDIU SP, SP, 24
9D000C8C  03E00008   JR RA
9D000C90  00000000   NOP
930:                 
931:                 
932:                 /*****************************************************************************
933:                   Function:
934:                     SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
935:                 
936:                   Summary:
937:                     Obtains information about a currently open socket.
938:                 
939:                   Description:
940:                     Returns the SOCKET_INFO structure associated with this socket.  This
941:                     contains the NODE_INFO structure with IP and MAC address (or gateway
942:                     MAC) and the remote port.
943:                 
944:                   Precondition:
945:                     TCP is initialized and the socket is connected.
946:                 
947:                   Parameters:
948:                     hTCP - The socket to check.
949:                 
950:                   Returns:
951:                     The SOCKET_INFO structure associated with this socket.  This structure is
952:                     allocated statically by the function and is valid only until the next
953:                     time TCPGetRemoteInfo() is called.
954:                         0 if the user specifies an invalid socket number.
955:                   ***************************************************************************/
956:                 SOCKET_INFO* TCPGetRemoteInfo(TCP_SOCKET hTCP)
957:                 {
9D000C94  27BDFFE8   ADDIU SP, SP, -24
9D000C98  AFBF0014   SW RA, 20(SP)
9D000C9C  AFBE0010   SW S8, 16(SP)
9D000CA0  03A0F021   ADDU S8, SP, ZERO
9D000CA4  00801021   ADDU V0, A0, ZERO
9D000CA8  A3C20018   SB V0, 24(S8)
958:                     static SOCKET_INFO  RemoteInfo;
959:                 
960:                     if(hTCP >= TCP_SOCKET_COUNT)
9D000CAC  93C20018   LBU V0, 24(S8)
9D000CB0  2C420002   SLTIU V0, V0, 2
9D000CB4  14400004   BNE V0, ZERO, 0x9D000CC8
9D000CB8  00000000   NOP
961:                     {
962:                         return 0;
9D000CBC  00001021   ADDU V0, ZERO, ZERO
9D000CC0  0B400345   J 0x9D000D14
9D000CC4  00000000   NOP
963:                     }
964:                 
965:                     SyncTCBStub(hTCP);
9D000CC8  93C20018   LBU V0, 24(S8)
9D000CCC  A3828014   SB V0, -32748(GP)
966:                     SyncTCB();
9D000CD0  0F400000   JAL 0x9D000000
9D000CD4  00000000   NOP
967:                     memcpy((void*)&RemoteInfo.remote, (void*)&MyTCB.remote, sizeof(NODE_INFO));
9D000CD8  3C02A000   LUI V0, -24576
9D000CDC  24447604   ADDIU A0, V0, 30212
9D000CE0  3C02A000   LUI V0, -24576
9D000CE4  244575B4   ADDIU A1, V0, 30132
9D000CE8  2406000A   ADDIU A2, ZERO, 10
9D000CEC  0F406788   JAL 0x9D019E20
9D000CF0  00000000   NOP
968:                     RemoteInfo.remotePort.Val = MyTCB.remotePort.Val;
9D000CF4  3C02A000   LUI V0, -24576
9D000CF8  2442759C   ADDIU V0, V0, 30108
9D000CFC  94430010   LHU V1, 16(V0)
9D000D00  3C02A000   LUI V0, -24576
9D000D04  24427604   ADDIU V0, V0, 30212
9D000D08  A443000A   SH V1, 10(V0)
969:                 
970:                     return &RemoteInfo;
9D000D0C  3C02A000   LUI V0, -24576
9D000D10  24427604   ADDIU V0, V0, 30212
971:                 }
9D000D14  03C0E821   ADDU SP, S8, ZERO
9D000D18  8FBF0014   LW RA, 20(SP)
9D000D1C  8FBE0010   LW S8, 16(SP)
9D000D20  27BD0018   ADDIU SP, SP, 24
9D000D24  03E00008   JR RA
9D000D28  00000000   NOP
972:                 
973:                 
974:                 
975:                 /****************************************************************************
976:                   Section:
977:                     Transmit Functions
978:                   ***************************************************************************/
979:                 
980:                 /*****************************************************************************
981:                   Function:
982:                     void TCPFlush(TCP_SOCKET hTCP)
983:                 
984:                   Summary:
985:                     Immediately transmits all pending TX data.
986:                 
987:                   Description:
988:                     This function immediately transmits all pending TX data with a PSH
989:                     flag.  If this function is not called, data will automatically be sent
990:                     when either a) the TX buffer is half full or b) the
991:                     TCP_AUTO_TRANSMIT_TIMEOUT_VAL (default: 40ms) has elapsed.
992:                 
993:                   Precondition:
994:                     TCP is initialized and the socket is connected.
995:                 
996:                   Parameters:
997:                     hTCP - The socket whose data is to be transmitted.
998:                 
999:                   Returns:
1000:                    None
1001:                
1002:                  Remarks:
1003:                    SSL application data is automatically flushed, so this function has
1004:                    no effect for SSL sockets.
1005:                  ***************************************************************************/
1006:                void TCPFlush(TCP_SOCKET hTCP)
1007:                {
9D000D2C  27BDFFE8   ADDIU SP, SP, -24
9D000D30  AFBF0014   SW RA, 20(SP)
9D000D34  AFBE0010   SW S8, 16(SP)
9D000D38  03A0F021   ADDU S8, SP, ZERO
9D000D3C  00801021   ADDU V0, A0, ZERO
9D000D40  A3C20018   SB V0, 24(S8)
1008:                    if(hTCP >= TCP_SOCKET_COUNT)
9D000D44  93C20018   LBU V0, 24(S8)
9D000D48  2C420002   SLTIU V0, V0, 2
9D000D4C  10400018   BEQ V0, ZERO, 0x9D000DB0
9D000D50  00000000   NOP
1009:                    {
1010:                        return;
9D000DB0  00000000   NOP
1011:                    }
1012:                
1013:                    SyncTCBStub(hTCP);
9D000D54  93C20018   LBU V0, 24(S8)
9D000D58  A3828014   SB V0, -32748(GP)
1014:                    SyncTCB();
9D000D5C  0F400000   JAL 0x9D000000
9D000D60  00000000   NOP
1015:                
1016:                    // NOTE: Pending SSL data will NOT be transferred here
1017:                
1018:                    if(MyTCBStub.txHead != MyTCB.txUnackedTail)
9D000D64  93828014   LBU V0, -32748(GP)
9D000D68  3C03A000   LUI V1, -24576
9D000D6C  2463753C   ADDIU V1, V1, 30012
9D000D70  00021100   SLL V0, V0, 4
9D000D74  00022080   SLL A0, V0, 2
9D000D78  00821023   SUBU V0, A0, V0
9D000D7C  00621021   ADDU V0, V1, V0
9D000D80  8C43000C   LW V1, 12(V0)
9D000D84  3C02A000   LUI V0, -24576
9D000D88  2442759C   ADDIU V0, V0, 30108
9D000D8C  8C42000C   LW V0, 12(V0)
9D000D90  10620008   BEQ V1, V0, 0x9D000DB4
9D000D94  00000000   NOP
1019:                    {
1020:                        // Send the TCP segment with all unacked bytes
1021:                        SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D000D98  24040010   ADDIU A0, ZERO, 16
9D000D9C  24050001   ADDIU A1, ZERO, 1
9D000DA0  0F400F2C   JAL 0x9D003CB0
9D000DA4  00000000   NOP
9D000DA8  0B40036D   J 0x9D000DB4
9D000DAC  00000000   NOP
1022:                    }
1023:                }
9D000DB4  03C0E821   ADDU SP, S8, ZERO
9D000DB8  8FBF0014   LW RA, 20(SP)
9D000DBC  8FBE0010   LW S8, 16(SP)
9D000DC0  27BD0018   ADDIU SP, SP, 24
9D000DC4  03E00008   JR RA
9D000DC8  00000000   NOP
1024:                
1025:                
1026:                /*****************************************************************************
1027:                  Function:
1028:                    uint16_t TCPIsPutReady(TCP_SOCKET hTCP)
1029:                
1030:                  Summary:
1031:                    Determines how much free space is available in the TCP TX buffer.
1032:                
1033:                  Description:
1034:                    Call this function to determine how many bytes can be written to the
1035:                    TCP TX buffer.  If this function returns zero, the application must
1036:                    return to the main stack loop before continuing in order to transmit
1037:                    more data.
1038:                
1039:                  Precondition:
1040:                    TCP is initialized.
1041:                
1042:                  Parameters:
1043:                    hTCP - The socket to check.
1044:                
1045:                  Returns:
1046:                    The number of bytes available to be written in the TCP TX buffer.
1047:                  ***************************************************************************/
1048:                uint16_t TCPIsPutReady(TCP_SOCKET hTCP)
1049:                {
9D000DCC  27BDFFF0   ADDIU SP, SP, -16
9D000DD0  AFBE000C   SW S8, 12(SP)
9D000DD4  03A0F021   ADDU S8, SP, ZERO
9D000DD8  00801021   ADDU V0, A0, ZERO
9D000DDC  A3C20010   SB V0, 16(S8)
1050:                    uint8_t i;
1051:                
1052:                    if(hTCP >= TCP_SOCKET_COUNT)
9D000DE0  93C20010   LBU V0, 16(S8)
9D000DE4  2C420002   SLTIU V0, V0, 2
9D000DE8  14400004   BNE V0, ZERO, 0x9D000DFC
9D000DEC  00000000   NOP
1053:                    {
1054:                        return 0;
9D000DF0  00001021   ADDU V0, ZERO, ZERO
9D000DF4  0B4003EC   J 0x9D000FB0
9D000DF8  00000000   NOP
1055:                    }
1056:                
1057:                    SyncTCBStub(hTCP);
9D000DFC  93C20010   LBU V0, 16(S8)
9D000E00  A3828014   SB V0, -32748(GP)
1058:                
1059:                    i = MyTCBStub.smState;
9D000E04  93828014   LBU V0, -32748(GP)
9D000E08  3C03A000   LUI V1, -24576
9D000E0C  2463753C   ADDIU V1, V1, 30012
9D000E10  00021100   SLL V0, V0, 4
9D000E14  00022080   SLL A0, V0, 2
9D000E18  00821023   SUBU V0, A0, V0
9D000E1C  00621021   ADDU V0, V1, V0
9D000E20  8C420024   LW V0, 36(V0)
9D000E24  A3C20000   SB V0, 0(S8)
1060:                
1061:                    // Unconnected sockets shouldn't be transmitting anything.
1062:                    if(!( (i == (uint8_t)TCP_ESTABLISHED) || (i == (uint8_t)TCP_CLOSE_WAIT) ))
9D000E28  93C30000   LBU V1, 0(S8)
9D000E2C  24020007   ADDIU V0, ZERO, 7
9D000E30  10620008   BEQ V1, V0, 0x9D000E54
9D000E34  00000000   NOP
9D000E38  93C30000   LBU V1, 0(S8)
9D000E3C  2402000B   ADDIU V0, ZERO, 11
9D000E40  10620004   BEQ V1, V0, 0x9D000E54
9D000E44  00000000   NOP
1063:                        return 0;
9D000E48  00001021   ADDU V0, ZERO, ZERO
9D000E4C  0B4003EC   J 0x9D000FB0
9D000E50  00000000   NOP
1064:                
1065:                    // Calculate the free space in this socket's TX FIFO
1066:                    #if defined(STACK_USE_SSL)
1067:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1068:                    {// Use sslTxHead as the head pointer when SSL is active
1069:                        uint16_t rem;
1070:                
1071:                        // Find out raw free space
1072:                        if(MyTCBStub.sslTxHead >= MyTCBStub.txTail)
1073:                            rem = (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.sslTxHead - MyTCBStub.txTail);
1074:                        else
1075:                            rem = MyTCBStub.txTail - MyTCBStub.sslTxHead - 1;
1076:                
1077:                        // Reserve space for a new MAC and header
1078:                        if(rem > 22u)
1079:                            return rem - 22;
1080:                        else
1081:                            return 0;
1082:                    }
1083:                    #endif
1084:                
1085:                    if(MyTCBStub.txHead >= MyTCBStub.txTail)
9D000E54  93828014   LBU V0, -32748(GP)
9D000E58  3C03A000   LUI V1, -24576
9D000E5C  2463753C   ADDIU V1, V1, 30012
9D000E60  00021100   SLL V0, V0, 4
9D000E64  00022080   SLL A0, V0, 2
9D000E68  00821023   SUBU V0, A0, V0
9D000E6C  00621021   ADDU V0, V1, V0
9D000E70  8C44000C   LW A0, 12(V0)
9D000E74  93828014   LBU V0, -32748(GP)
9D000E78  3C05A000   LUI A1, -24576
9D000E7C  00021100   SLL V0, V0, 4
9D000E80  00021880   SLL V1, V0, 2
9D000E84  00621823   SUBU V1, V1, V0
9D000E88  24A2753C   ADDIU V0, A1, 30012
9D000E8C  00621021   ADDU V0, V1, V0
9D000E90  8C420010   LW V0, 16(V0)
9D000E94  0082102B   SLTU V0, A0, V0
9D000E98  1440002F   BNE V0, ZERO, 0x9D000F58
9D000E9C  00000000   NOP
1086:                        return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.txTail);
9D000EA0  93828014   LBU V0, -32748(GP)
9D000EA4  3C03A000   LUI V1, -24576
9D000EA8  2463753C   ADDIU V1, V1, 30012
9D000EAC  00021100   SLL V0, V0, 4
9D000EB0  00022080   SLL A0, V0, 2
9D000EB4  00821023   SUBU V0, A0, V0
9D000EB8  00621021   ADDU V0, V1, V0
9D000EBC  8C420004   LW V0, 4(V0)
9D000EC0  3044FFFF   ANDI A0, V0, -1
9D000EC4  93828014   LBU V0, -32748(GP)
9D000EC8  3C05A000   LUI A1, -24576
9D000ECC  00021100   SLL V0, V0, 4
9D000ED0  00021880   SLL V1, V0, 2
9D000ED4  00621823   SUBU V1, V1, V0
9D000ED8  24A2753C   ADDIU V0, A1, 30012
9D000EDC  00621021   ADDU V0, V1, V0
9D000EE0  8C420000   LW V0, 0(V0)
9D000EE4  3042FFFF   ANDI V0, V0, -1
9D000EE8  00821023   SUBU V0, A0, V0
9D000EEC  3044FFFF   ANDI A0, V0, -1
9D000EF0  93828014   LBU V0, -32748(GP)
9D000EF4  3C05A000   LUI A1, -24576
9D000EF8  00021100   SLL V0, V0, 4
9D000EFC  00021880   SLL V1, V0, 2
9D000F00  00621823   SUBU V1, V1, V0
9D000F04  24A2753C   ADDIU V0, A1, 30012
9D000F08  00621021   ADDU V0, V1, V0
9D000F0C  8C420010   LW V0, 16(V0)
9D000F10  3043FFFF   ANDI V1, V0, -1
9D000F14  93828014   LBU V0, -32748(GP)
9D000F18  3C05A000   LUI A1, -24576
9D000F1C  24A5753C   ADDIU A1, A1, 30012
9D000F20  00021100   SLL V0, V0, 4
9D000F24  00023080   SLL A2, V0, 2
9D000F28  00C21023   SUBU V0, A2, V0
9D000F2C  00A21021   ADDU V0, A1, V0
9D000F30  8C42000C   LW V0, 12(V0)
9D000F34  3042FFFF   ANDI V0, V0, -1
9D000F38  00621023   SUBU V0, V1, V0
9D000F3C  3042FFFF   ANDI V0, V0, -1
9D000F40  00821021   ADDU V0, A0, V0
9D000F44  3042FFFF   ANDI V0, V0, -1
9D000F48  2442FFFF   ADDIU V0, V0, -1
9D000F4C  3042FFFF   ANDI V0, V0, -1
9D000F50  0B4003EC   J 0x9D000FB0
9D000F54  00000000   NOP
1087:                    else
1088:                        return MyTCBStub.txTail - MyTCBStub.txHead - 1;
9D000F58  93828014   LBU V0, -32748(GP)
9D000F5C  3C04A000   LUI A0, -24576
9D000F60  00021100   SLL V0, V0, 4
9D000F64  00021880   SLL V1, V0, 2
9D000F68  00621823   SUBU V1, V1, V0
9D000F6C  2482753C   ADDIU V0, A0, 30012
9D000F70  00621021   ADDU V0, V1, V0
9D000F74  8C420010   LW V0, 16(V0)
9D000F78  3043FFFF   ANDI V1, V0, -1
9D000F7C  93828014   LBU V0, -32748(GP)
9D000F80  3C04A000   LUI A0, -24576
9D000F84  2484753C   ADDIU A0, A0, 30012
9D000F88  00021100   SLL V0, V0, 4
9D000F8C  00022880   SLL A1, V0, 2
9D000F90  00A21023   SUBU V0, A1, V0
9D000F94  00821021   ADDU V0, A0, V0
9D000F98  8C42000C   LW V0, 12(V0)
9D000F9C  3042FFFF   ANDI V0, V0, -1
9D000FA0  00621023   SUBU V0, V1, V0
9D000FA4  3042FFFF   ANDI V0, V0, -1
9D000FA8  2442FFFF   ADDIU V0, V0, -1
9D000FAC  3042FFFF   ANDI V0, V0, -1
1089:                }
9D000FB0  03C0E821   ADDU SP, S8, ZERO
9D000FB4  8FBE000C   LW S8, 12(SP)
9D000FB8  27BD0010   ADDIU SP, SP, 16
9D000FBC  03E00008   JR RA
9D000FC0  00000000   NOP
1090:                
1091:                
1092:                /*****************************************************************************
1093:                  Function:
1094:                    bool TCPPut(TCP_SOCKET hTCP, uint8_t byte)
1095:                
1096:                  Description:
1097:                    Writes a single byte to a TCP socket.
1098:                
1099:                  Precondition:
1100:                    TCP is initialized.
1101:                
1102:                  Parameters:
1103:                    hTCP - The socket to which data is to be written.
1104:                    byte - The byte to write.
1105:                
1106:                  Return Values:
1107:                    true - The byte was written to the transmit buffer.
1108:                    false - The transmit buffer was full, or the socket is not connected.
1109:                  ***************************************************************************/
1110:                bool TCPPut(TCP_SOCKET hTCP, uint8_t byte)
1111:                {
9D000FC4  27BDFFD0   ADDIU SP, SP, -48
9D000FC8  AFBF002C   SW RA, 44(SP)
9D000FCC  AFBE0028   SW S8, 40(SP)
9D000FD0  AFB00024   SW S0, 36(SP)
9D000FD4  03A0F021   ADDU S8, SP, ZERO
9D000FD8  00801821   ADDU V1, A0, ZERO
9D000FDC  00A01021   ADDU V0, A1, ZERO
9D000FE0  A3C30030   SB V1, 48(S8)
9D000FE4  A3C20034   SB V0, 52(S8)
1112:                    uint16_t wFreeTXSpace;
1113:                
1114:                    if(hTCP >= TCP_SOCKET_COUNT)
9D000FE8  93C20030   LBU V0, 48(S8)
9D000FEC  2C420002   SLTIU V0, V0, 2
9D000FF0  14400004   BNE V0, ZERO, 0x9D001004
9D000FF4  00000000   NOP
1115:                    {
1116:                        return false;
9D000FF8  00001021   ADDU V0, ZERO, ZERO
9D000FFC  0B4004C9   J 0x9D001324
9D001000  00000000   NOP
1117:                    }
1118:                
1119:                    SyncTCBStub(hTCP);
9D001004  93C20030   LBU V0, 48(S8)
9D001008  A3828014   SB V0, -32748(GP)
1120:                
1121:                    wFreeTXSpace = TCPIsPutReady(hTCP);
9D00100C  93C20030   LBU V0, 48(S8)
9D001010  00402021   ADDU A0, V0, ZERO
9D001014  0F400373   JAL TCPIsPutReady
9D001018  00000000   NOP
9D00101C  A7C20018   SH V0, 24(S8)
1122:                    if(wFreeTXSpace == 0u)
9D001020  97C20018   LHU V0, 24(S8)
9D001024  14400004   BNE V0, ZERO, 0x9D001038
9D001028  00000000   NOP
1123:                        return false;
9D00102C  00001021   ADDU V0, ZERO, ZERO
9D001030  0B4004C9   J 0x9D001324
9D001034  00000000   NOP
1124:                    else if(wFreeTXSpace == 1u) // About to run out of space, lets transmit so the remote node might send an ACK back faster
9D001038  97C30018   LHU V1, 24(S8)
9D00103C  24020001   ADDIU V0, ZERO, 1
9D001040  14620005   BNE V1, V0, 0x9D001058
9D001044  00000000   NOP
1125:                        TCPFlush(hTCP);
9D001048  93C20030   LBU V0, 48(S8)
9D00104C  00402021   ADDU A0, V0, ZERO
9D001050  0F40034B   JAL TCPFlush
9D001054  00000000   NOP
1126:                
1127:                    // Send all current bytes if we are crossing half full
1128:                    // This is required to improve performance with the delayed
1129:                    // acknowledgement algorithm
1130:                    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9D001058  93828014   LBU V0, -32748(GP)
9D00105C  3C04A000   LUI A0, -24576
9D001060  00021100   SLL V0, V0, 4
9D001064  00021880   SLL V1, V0, 2
9D001068  00621823   SUBU V1, V1, V0
9D00106C  2482753C   ADDIU V0, A0, 30012
9D001070  00621021   ADDU V0, V1, V0
9D001074  8C420028   LW V0, 40(V0)
9D001078  7C420200   EXT V0, V0, 8, 1
9D00107C  304200FF   ANDI V0, V0, 255
9D001080  14400026   BNE V0, ZERO, 0x9D00111C
9D001084  00000000   NOP
9D001088  97C40018   LHU A0, 24(S8)
9D00108C  93828014   LBU V0, -32748(GP)
9D001090  3C03A000   LUI V1, -24576
9D001094  2463753C   ADDIU V1, V1, 30012
9D001098  00021100   SLL V0, V0, 4
9D00109C  00022880   SLL A1, V0, 2
9D0010A0  00A21023   SUBU V0, A1, V0
9D0010A4  00621021   ADDU V0, V1, V0
9D0010A8  8C450004   LW A1, 4(V0)
9D0010AC  93828014   LBU V0, -32748(GP)
9D0010B0  3C06A000   LUI A2, -24576
9D0010B4  00021100   SLL V0, V0, 4
9D0010B8  00021880   SLL V1, V0, 2
9D0010BC  00621823   SUBU V1, V1, V0
9D0010C0  24C2753C   ADDIU V0, A2, 30012
9D0010C4  00621021   ADDU V0, V1, V0
9D0010C8  8C420000   LW V0, 0(V0)
9D0010CC  00A21023   SUBU V0, A1, V0
9D0010D0  00021042   SRL V0, V0, 1
9D0010D4  0044102B   SLTU V0, V0, A0
9D0010D8  14400010   BNE V0, ZERO, 0x9D00111C
9D0010DC  00000000   NOP
1131:                    {
1132:                        TCPFlush(hTCP);
9D0010E0  93C20030   LBU V0, 48(S8)
9D0010E4  00402021   ADDU A0, V0, ZERO
9D0010E8  0F40034B   JAL TCPFlush
9D0010EC  00000000   NOP
1133:                        MyTCBStub.Flags.bHalfFullFlush = true;
9D0010F0  93828014   LBU V0, -32748(GP)
9D0010F4  3C04A000   LUI A0, -24576
9D0010F8  00021100   SLL V0, V0, 4
9D0010FC  00021880   SLL V1, V0, 2
9D001100  00621823   SUBU V1, V1, V0
9D001104  2482753C   ADDIU V0, A0, 30012
9D001108  00621821   ADDU V1, V1, V0
9D00110C  8C620028   LW V0, 40(V1)
9D001110  24040001   ADDIU A0, ZERO, 1
9D001114  7C824204   INS V0, A0, 8, 1
9D001118  AC620028   SW V0, 40(V1)
1134:                    }
1135:                
1136:                    #if defined(STACK_USE_SSL)
1137:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1138:                    {
1139:                        TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
1140:                        if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
1141:                            MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1142:                    }
1143:                    else
1144:                    {
1145:                        TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
1146:                        if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
1147:                            MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1148:                    }
1149:                    #else
1150:                    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&byte, TCP_PIC_RAM, sizeof(byte));
9D00111C  93828014   LBU V0, -32748(GP)
9D001120  3C03A000   LUI V1, -24576
9D001124  2463753C   ADDIU V1, V1, 30012
9D001128  00021100   SLL V0, V0, 4
9D00112C  00022080   SLL A0, V0, 2
9D001130  00821023   SUBU V0, A0, V0
9D001134  00621021   ADDU V0, V1, V0
9D001138  8C44000C   LW A0, 12(V0)
9D00113C  93828014   LBU V0, -32748(GP)
9D001140  3C05A000   LUI A1, -24576
9D001144  00021100   SLL V0, V0, 4
9D001148  00021880   SLL V1, V0, 2
9D00114C  00621823   SUBU V1, V1, V0
9D001150  24A2753C   ADDIU V0, A1, 30012
9D001154  00621021   ADDU V0, V1, V0
9D001158  9042002C   LBU V0, 44(V0)
9D00115C  00401821   ADDU V1, V0, ZERO
9D001160  27C20034   ADDIU V0, S8, 52
9D001164  24050001   ADDIU A1, ZERO, 1
9D001168  AFA50010   SW A1, 16(SP)
9D00116C  00602821   ADDU A1, V1, ZERO
9D001170  00403021   ADDU A2, V0, ZERO
9D001174  24070001   ADDIU A3, ZERO, 1
9D001178  0F4020A8   JAL 0x9D0082A0
9D00117C  00000000   NOP
1151:                    if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
9D001180  93828014   LBU V0, -32748(GP)
9D001184  00401821   ADDU V1, V0, ZERO
9D001188  3C02A000   LUI V0, -24576
9D00118C  2444753C   ADDIU A0, V0, 30012
9D001190  00601021   ADDU V0, V1, ZERO
9D001194  00021100   SLL V0, V0, 4
9D001198  00022880   SLL A1, V0, 2
9D00119C  00A21023   SUBU V0, A1, V0
9D0011A0  00821021   ADDU V0, A0, V0
9D0011A4  8C42000C   LW V0, 12(V0)
9D0011A8  24440001   ADDIU A0, V0, 1
9D0011AC  3C02A000   LUI V0, -24576
9D0011B0  2445753C   ADDIU A1, V0, 30012
9D0011B4  00601021   ADDU V0, V1, ZERO
9D0011B8  00021100   SLL V0, V0, 4
9D0011BC  00023080   SLL A2, V0, 2
9D0011C0  00C21023   SUBU V0, A2, V0
9D0011C4  00A21021   ADDU V0, A1, V0
9D0011C8  AC44000C   SW A0, 12(V0)
9D0011CC  3C02A000   LUI V0, -24576
9D0011D0  2444753C   ADDIU A0, V0, 30012
9D0011D4  00601021   ADDU V0, V1, ZERO
9D0011D8  00021100   SLL V0, V0, 4
9D0011DC  00021880   SLL V1, V0, 2
9D0011E0  00621023   SUBU V0, V1, V0
9D0011E4  00821021   ADDU V0, A0, V0
9D0011E8  8C43000C   LW V1, 12(V0)
9D0011EC  93828014   LBU V0, -32748(GP)
9D0011F0  3C04A000   LUI A0, -24576
9D0011F4  2484753C   ADDIU A0, A0, 30012
9D0011F8  00021100   SLL V0, V0, 4
9D0011FC  00022880   SLL A1, V0, 2
9D001200  00A21023   SUBU V0, A1, V0
9D001204  00821021   ADDU V0, A0, V0
9D001208  8C420004   LW V0, 4(V0)
9D00120C  0062102B   SLTU V0, V1, V0
9D001210  14400013   BNE V0, ZERO, 0x9D001260
9D001214  00000000   NOP
1152:                        MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D001218  93828014   LBU V0, -32748(GP)
9D00121C  00402821   ADDU A1, V0, ZERO
9D001220  93828014   LBU V0, -32748(GP)
9D001224  3C04A000   LUI A0, -24576
9D001228  00021100   SLL V0, V0, 4
9D00122C  00021880   SLL V1, V0, 2
9D001230  00621823   SUBU V1, V1, V0
9D001234  2482753C   ADDIU V0, A0, 30012
9D001238  00621021   ADDU V0, V1, V0
9D00123C  8C430000   LW V1, 0(V0)
9D001240  3C02A000   LUI V0, -24576
9D001244  2444753C   ADDIU A0, V0, 30012
9D001248  00A01021   ADDU V0, A1, ZERO
9D00124C  00021100   SLL V0, V0, 4
9D001250  00022880   SLL A1, V0, 2
9D001254  00A21023   SUBU V0, A1, V0
9D001258  00821021   ADDU V0, A0, V0
9D00125C  AC43000C   SW V1, 12(V0)
1153:                    #endif
1154:                
1155:                
1156:                    // Send the last byte as a separate packet (likely will make the remote node send back ACK faster)
1157:                    if(wFreeTXSpace == 1u)
9D001260  97C30018   LHU V1, 24(S8)
9D001264  24020001   ADDIU V0, ZERO, 1
9D001268  14620007   BNE V1, V0, 0x9D001288
9D00126C  00000000   NOP
1158:                    {
1159:                        TCPFlush(hTCP);
9D001270  93C20030   LBU V0, 48(S8)
9D001274  00402021   ADDU A0, V0, ZERO
9D001278  0F40034B   JAL TCPFlush
9D00127C  00000000   NOP
9D001280  0B4004C8   J 0x9D001320
9D001284  00000000   NOP
1160:                    }
1161:                    // If not already enabled, start a timer so this data will
1162:                    // eventually get sent even if the application doens't call
1163:                    // TCPFlush()
1164:                    else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001288  93828014   LBU V0, -32748(GP)
9D00128C  3C04A000   LUI A0, -24576
9D001290  00021100   SLL V0, V0, 4
9D001294  00021880   SLL V1, V0, 2
9D001298  00621823   SUBU V1, V1, V0
9D00129C  2482753C   ADDIU V0, A0, 30012
9D0012A0  00621021   ADDU V0, V1, V0
9D0012A4  8C420028   LW V0, 40(V0)
9D0012A8  7C420140   EXT V0, V0, 5, 1
9D0012AC  304200FF   ANDI V0, V0, 255
9D0012B0  1440001B   BNE V0, ZERO, 0x9D001320
9D0012B4  00000000   NOP
1165:                    {
1166:                        MyTCBStub.Flags.bTimer2Enabled = true;
9D0012B8  93828014   LBU V0, -32748(GP)
9D0012BC  3C04A000   LUI A0, -24576
9D0012C0  00021100   SLL V0, V0, 4
9D0012C4  00021880   SLL V1, V0, 2
9D0012C8  00621823   SUBU V1, V1, V0
9D0012CC  2482753C   ADDIU V0, A0, 30012
9D0012D0  00621821   ADDU V1, V1, V0
9D0012D4  8C620028   LW V0, 40(V1)
9D0012D8  24040001   ADDIU A0, ZERO, 1
9D0012DC  7C822944   INS V0, A0, 5, 1
9D0012E0  AC620028   SW V0, 40(V1)
1167:                        MyTCBStub.eventTime2 = (uint16_t)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9D0012E4  93828014   LBU V0, -32748(GP)
9D0012E8  00408021   ADDU S0, V0, ZERO
9D0012EC  0F405C62   JAL TickGetDiv256
9D0012F0  00000000   NOP
9D0012F4  3042FFFF   ANDI V0, V0, -1
9D0012F8  24420030   ADDIU V0, V0, 48
9D0012FC  3044FFFF   ANDI A0, V0, -1
9D001300  3C05A000   LUI A1, -24576
9D001304  02001021   ADDU V0, S0, ZERO
9D001308  00021100   SLL V0, V0, 4
9D00130C  00021880   SLL V1, V0, 2
9D001310  00621823   SUBU V1, V1, V0
9D001314  24A2753C   ADDIU V0, A1, 30012
9D001318  00621021   ADDU V0, V1, V0
9D00131C  A4440020   SH A0, 32(V0)
1168:                    }
1169:                
1170:                    return true;
9D001320  24020001   ADDIU V0, ZERO, 1
1171:                }
9D001324  03C0E821   ADDU SP, S8, ZERO
9D001328  8FBF002C   LW RA, 44(SP)
9D00132C  8FBE0028   LW S8, 40(SP)
9D001330  8FB00024   LW S0, 36(SP)
9D001334  27BD0030   ADDIU SP, SP, 48
9D001338  03E00008   JR RA
9D00133C  00000000   NOP
1172:                
1173:                /*****************************************************************************
1174:                  Function:
1175:                    uint16_t TCPPutArray(TCP_SOCKET hTCP, uint8_t* data, uint16_t len)
1176:                
1177:                  Description:
1178:                    Writes an array from RAM to a TCP socket.
1179:                
1180:                  Precondition:
1181:                    TCP is initialized.
1182:                
1183:                  Parameters:
1184:                    hTCP - The socket to which data is to be written.
1185:                    data - Pointer to the array to be written.
1186:                    len  - Number of bytes to be written.
1187:                
1188:                  Returns:
1189:                    The number of bytes written to the socket.  If less than len, the
1190:                    buffer became full or the socket is not conected.
1191:                  ***************************************************************************/
1192:                uint16_t TCPPutArray(TCP_SOCKET hTCP, uint8_t* data, uint16_t len)
1193:                {
9D001340  27BDFFD0   ADDIU SP, SP, -48
9D001344  AFBF002C   SW RA, 44(SP)
9D001348  AFBE0028   SW S8, 40(SP)
9D00134C  AFB00024   SW S0, 36(SP)
9D001350  03A0F021   ADDU S8, SP, ZERO
9D001354  00801821   ADDU V1, A0, ZERO
9D001358  AFC50034   SW A1, 52(S8)
9D00135C  00C01021   ADDU V0, A2, ZERO
9D001360  A3C30030   SB V1, 48(S8)
9D001364  A7C20038   SH V0, 56(S8)
1194:                    uint16_t wActualLen;
1195:                    uint16_t wFreeTXSpace;
1196:                    uint16_t wRightLen = 0;
9D001368  A7C0001A   SH ZERO, 26(S8)
1197:                
1198:                    if(hTCP >= TCP_SOCKET_COUNT)
9D00136C  93C20030   LBU V0, 48(S8)
9D001370  2C420002   SLTIU V0, V0, 2
9D001374  14400004   BNE V0, ZERO, 0x9D001388
9D001378  00000000   NOP
1199:                    {
1200:                        return 0;
9D00137C  00001021   ADDU V0, ZERO, ZERO
9D001380  0B4005EB   J 0x9D0017AC
9D001384  00000000   NOP
1201:                    }
1202:                
1203:                    SyncTCBStub(hTCP);
9D001388  93C20030   LBU V0, 48(S8)
9D00138C  A3828014   SB V0, -32748(GP)
1204:                
1205:                    wFreeTXSpace = TCPIsPutReady(hTCP);
9D001390  93C20030   LBU V0, 48(S8)
9D001394  00402021   ADDU A0, V0, ZERO
9D001398  0F400373   JAL TCPIsPutReady
9D00139C  00000000   NOP
9D0013A0  A7C2001C   SH V0, 28(S8)
1206:                    if(wFreeTXSpace == 0u)
9D0013A4  97C2001C   LHU V0, 28(S8)
9D0013A8  14400008   BNE V0, ZERO, 0x9D0013CC
9D0013AC  00000000   NOP
1207:                    {
1208:                        TCPFlush(hTCP);
9D0013B0  93C20030   LBU V0, 48(S8)
9D0013B4  00402021   ADDU A0, V0, ZERO
9D0013B8  0F40034B   JAL TCPFlush
9D0013BC  00000000   NOP
1209:                        return 0;
9D0013C0  00001021   ADDU V0, ZERO, ZERO
9D0013C4  0B4005EB   J 0x9D0017AC
9D0013C8  00000000   NOP
1210:                    }
1211:                
1212:                    wActualLen = wFreeTXSpace;
9D0013CC  97C2001C   LHU V0, 28(S8)
9D0013D0  A7C20018   SH V0, 24(S8)
1213:                    if(wFreeTXSpace > len)
9D0013D4  97C3001C   LHU V1, 28(S8)
9D0013D8  97C20038   LHU V0, 56(S8)
9D0013DC  0043102B   SLTU V0, V0, V1
9D0013E0  10400003   BEQ V0, ZERO, 0x9D0013F0
9D0013E4  00000000   NOP
1214:                        wActualLen = len;
9D0013E8  97C20038   LHU V0, 56(S8)
9D0013EC  A7C20018   SH V0, 24(S8)
1215:                
1216:                    // Send all current bytes if we are crossing half full
1217:                    // This is required to improve performance with the delayed
1218:                    // acknowledgement algorithm
1219:                    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
9D0013F0  93828014   LBU V0, -32748(GP)
9D0013F4  3C04A000   LUI A0, -24576
9D0013F8  00021100   SLL V0, V0, 4
9D0013FC  00021880   SLL V1, V0, 2
9D001400  00621823   SUBU V1, V1, V0
9D001404  2482753C   ADDIU V0, A0, 30012
9D001408  00621021   ADDU V0, V1, V0
9D00140C  8C420028   LW V0, 40(V0)
9D001410  7C420200   EXT V0, V0, 8, 1
9D001414  304200FF   ANDI V0, V0, 255
9D001418  14400026   BNE V0, ZERO, 0x9D0014B4
9D00141C  00000000   NOP
9D001420  97C4001C   LHU A0, 28(S8)
9D001424  93828014   LBU V0, -32748(GP)
9D001428  3C03A000   LUI V1, -24576
9D00142C  2463753C   ADDIU V1, V1, 30012
9D001430  00021100   SLL V0, V0, 4
9D001434  00022880   SLL A1, V0, 2
9D001438  00A21023   SUBU V0, A1, V0
9D00143C  00621021   ADDU V0, V1, V0
9D001440  8C450004   LW A1, 4(V0)
9D001444  93828014   LBU V0, -32748(GP)
9D001448  3C06A000   LUI A2, -24576
9D00144C  00021100   SLL V0, V0, 4
9D001450  00021880   SLL V1, V0, 2
9D001454  00621823   SUBU V1, V1, V0
9D001458  24C2753C   ADDIU V0, A2, 30012
9D00145C  00621021   ADDU V0, V1, V0
9D001460  8C420000   LW V0, 0(V0)
9D001464  00A21023   SUBU V0, A1, V0
9D001468  00021042   SRL V0, V0, 1
9D00146C  0044102B   SLTU V0, V0, A0
9D001470  14400010   BNE V0, ZERO, 0x9D0014B4
9D001474  00000000   NOP
1220:                    {
1221:                        TCPFlush(hTCP);
9D001478  93C20030   LBU V0, 48(S8)
9D00147C  00402021   ADDU A0, V0, ZERO
9D001480  0F40034B   JAL TCPFlush
9D001484  00000000   NOP
1222:                        MyTCBStub.Flags.bHalfFullFlush = true;
9D001488  93828014   LBU V0, -32748(GP)
9D00148C  3C04A000   LUI A0, -24576
9D001490  00021100   SLL V0, V0, 4
9D001494  00021880   SLL V1, V0, 2
9D001498  00621823   SUBU V1, V1, V0
9D00149C  2482753C   ADDIU V0, A0, 30012
9D0014A0  00621821   ADDU V1, V1, V0
9D0014A4  8C620028   LW V0, 40(V1)
9D0014A8  24040001   ADDIU A0, ZERO, 1
9D0014AC  7C824204   INS V0, A0, 8, 1
9D0014B0  AC620028   SW V0, 40(V1)
1223:                    }
1224:                
1225:                    #if defined(STACK_USE_SSL)
1226:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1227:                    {
1228:                        // See if we need a two part put
1229:                        if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
1230:                        {
1231:                            wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
1232:                            TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
1233:                            data += wRightLen;
1234:                            wActualLen -= wRightLen;
1235:                            MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1236:                        }
1237:                
1238:                        TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
1239:                        MyTCBStub.sslTxHead += wActualLen;
1240:                    }
1241:                    else
1242:                    {
1243:                        // See if we need a two part put
1244:                        if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1245:                        {
1246:                            wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1247:                            TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
1248:                            data += wRightLen;
1249:                            wActualLen -= wRightLen;
1250:                            MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1251:                        }
1252:                
1253:                        TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
1254:                        MyTCBStub.txHead += wActualLen;
1255:                    }
1256:                    #else
1257:                    // See if we need a two part put
1258:                    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
9D0014B4  93828014   LBU V0, -32748(GP)
9D0014B8  3C03A000   LUI V1, -24576
9D0014BC  2463753C   ADDIU V1, V1, 30012
9D0014C0  00021100   SLL V0, V0, 4
9D0014C4  00022080   SLL A0, V0, 2
9D0014C8  00821023   SUBU V0, A0, V0
9D0014CC  00621021   ADDU V0, V1, V0
9D0014D0  8C43000C   LW V1, 12(V0)
9D0014D4  97C20018   LHU V0, 24(S8)
9D0014D8  00621821   ADDU V1, V1, V0
9D0014DC  93828014   LBU V0, -32748(GP)
9D0014E0  3C04A000   LUI A0, -24576
9D0014E4  2484753C   ADDIU A0, A0, 30012
9D0014E8  00021100   SLL V0, V0, 4
9D0014EC  00022880   SLL A1, V0, 2
9D0014F0  00A21023   SUBU V0, A1, V0
9D0014F4  00821021   ADDU V0, A0, V0
9D0014F8  8C420004   LW V0, 4(V0)
9D0014FC  0062102B   SLTU V0, V1, V0
9D001500  14400048   BNE V0, ZERO, 0x9D001624
9D001504  00000000   NOP
1259:                    {
1260:                        wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
9D001508  93828014   LBU V0, -32748(GP)
9D00150C  3C03A000   LUI V1, -24576
9D001510  2463753C   ADDIU V1, V1, 30012
9D001514  00021100   SLL V0, V0, 4
9D001518  00022080   SLL A0, V0, 2
9D00151C  00821023   SUBU V0, A0, V0
9D001520  00621021   ADDU V0, V1, V0
9D001524  8C420004   LW V0, 4(V0)
9D001528  3043FFFF   ANDI V1, V0, -1
9D00152C  93828014   LBU V0, -32748(GP)
9D001530  3C04A000   LUI A0, -24576
9D001534  2484753C   ADDIU A0, A0, 30012
9D001538  00021100   SLL V0, V0, 4
9D00153C  00022880   SLL A1, V0, 2
9D001540  00A21023   SUBU V0, A1, V0
9D001544  00821021   ADDU V0, A0, V0
9D001548  8C42000C   LW V0, 12(V0)
9D00154C  3042FFFF   ANDI V0, V0, -1
9D001550  00621023   SUBU V0, V1, V0
9D001554  A7C2001A   SH V0, 26(S8)
1261:                        TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wRightLen);
9D001558  93828014   LBU V0, -32748(GP)
9D00155C  3C03A000   LUI V1, -24576
9D001560  2463753C   ADDIU V1, V1, 30012
9D001564  00021100   SLL V0, V0, 4
9D001568  00022080   SLL A0, V0, 2
9D00156C  00821023   SUBU V0, A0, V0
9D001570  00621021   ADDU V0, V1, V0
9D001574  8C44000C   LW A0, 12(V0)
9D001578  93828014   LBU V0, -32748(GP)
9D00157C  3C05A000   LUI A1, -24576
9D001580  00021100   SLL V0, V0, 4
9D001584  00021880   SLL V1, V0, 2
9D001588  00621823   SUBU V1, V1, V0
9D00158C  24A2753C   ADDIU V0, A1, 30012
9D001590  00621021   ADDU V0, V1, V0
9D001594  9042002C   LBU V0, 44(V0)
9D001598  00401821   ADDU V1, V0, ZERO
9D00159C  8FC20034   LW V0, 52(S8)
9D0015A0  97C5001A   LHU A1, 26(S8)
9D0015A4  AFA50010   SW A1, 16(SP)
9D0015A8  00602821   ADDU A1, V1, ZERO
9D0015AC  00403021   ADDU A2, V0, ZERO
9D0015B0  24070001   ADDIU A3, ZERO, 1
9D0015B4  0F4020A8   JAL 0x9D0082A0
9D0015B8  00000000   NOP
1262:                        data += wRightLen;
9D0015BC  97C2001A   LHU V0, 26(S8)
9D0015C0  8FC30034   LW V1, 52(S8)
9D0015C4  00621021   ADDU V0, V1, V0
9D0015C8  AFC20034   SW V0, 52(S8)
1263:                        wActualLen -= wRightLen;
9D0015CC  97C30018   LHU V1, 24(S8)
9D0015D0  97C2001A   LHU V0, 26(S8)
9D0015D4  00621023   SUBU V0, V1, V0
9D0015D8  A7C20018   SH V0, 24(S8)
1264:                        MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D0015DC  93828014   LBU V0, -32748(GP)
9D0015E0  00402821   ADDU A1, V0, ZERO
9D0015E4  93828014   LBU V0, -32748(GP)
9D0015E8  3C04A000   LUI A0, -24576
9D0015EC  00021100   SLL V0, V0, 4
9D0015F0  00021880   SLL V1, V0, 2
9D0015F4  00621823   SUBU V1, V1, V0
9D0015F8  2482753C   ADDIU V0, A0, 30012
9D0015FC  00621021   ADDU V0, V1, V0
9D001600  8C430000   LW V1, 0(V0)
9D001604  3C02A000   LUI V0, -24576
9D001608  2444753C   ADDIU A0, V0, 30012
9D00160C  00A01021   ADDU V0, A1, ZERO
9D001610  00021100   SLL V0, V0, 4
9D001614  00022880   SLL A1, V0, 2
9D001618  00A21023   SUBU V0, A1, V0
9D00161C  00821021   ADDU V0, A0, V0
9D001620  AC43000C   SW V1, 12(V0)
1265:                    }
1266:                
1267:                    TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)data, TCP_PIC_RAM, wActualLen);
9D001624  93828014   LBU V0, -32748(GP)
9D001628  3C03A000   LUI V1, -24576
9D00162C  2463753C   ADDIU V1, V1, 30012
9D001630  00021100   SLL V0, V0, 4
9D001634  00022080   SLL A0, V0, 2
9D001638  00821023   SUBU V0, A0, V0
9D00163C  00621021   ADDU V0, V1, V0
9D001640  8C44000C   LW A0, 12(V0)
9D001644  93828014   LBU V0, -32748(GP)
9D001648  3C05A000   LUI A1, -24576
9D00164C  00021100   SLL V0, V0, 4
9D001650  00021880   SLL V1, V0, 2
9D001654  00621823   SUBU V1, V1, V0
9D001658  24A2753C   ADDIU V0, A1, 30012
9D00165C  00621021   ADDU V0, V1, V0
9D001660  9042002C   LBU V0, 44(V0)
9D001664  00401821   ADDU V1, V0, ZERO
9D001668  8FC20034   LW V0, 52(S8)
9D00166C  97C50018   LHU A1, 24(S8)
9D001670  AFA50010   SW A1, 16(SP)
9D001674  00602821   ADDU A1, V1, ZERO
9D001678  00403021   ADDU A2, V0, ZERO
9D00167C  24070001   ADDIU A3, ZERO, 1
9D001680  0F4020A8   JAL 0x9D0082A0
9D001684  00000000   NOP
1268:                    MyTCBStub.txHead += wActualLen;
9D001688  93828014   LBU V0, -32748(GP)
9D00168C  00402821   ADDU A1, V0, ZERO
9D001690  93828014   LBU V0, -32748(GP)
9D001694  3C03A000   LUI V1, -24576
9D001698  2463753C   ADDIU V1, V1, 30012
9D00169C  00021100   SLL V0, V0, 4
9D0016A0  00022080   SLL A0, V0, 2
9D0016A4  00821023   SUBU V0, A0, V0
9D0016A8  00621021   ADDU V0, V1, V0
9D0016AC  8C43000C   LW V1, 12(V0)
9D0016B0  97C20018   LHU V0, 24(S8)
9D0016B4  00621821   ADDU V1, V1, V0
9D0016B8  3C02A000   LUI V0, -24576
9D0016BC  2444753C   ADDIU A0, V0, 30012
9D0016C0  00A01021   ADDU V0, A1, ZERO
9D0016C4  00021100   SLL V0, V0, 4
9D0016C8  00022880   SLL A1, V0, 2
9D0016CC  00A21023   SUBU V0, A1, V0
9D0016D0  00821021   ADDU V0, A0, V0
9D0016D4  AC43000C   SW V1, 12(V0)
1269:                    #endif
1270:                
1271:                    // Send these bytes right now if we are out of TX buffer space
1272:                    if(wFreeTXSpace <= len)
9D0016D8  97C3001C   LHU V1, 28(S8)
9D0016DC  97C20038   LHU V0, 56(S8)
9D0016E0  0043102B   SLTU V0, V0, V1
9D0016E4  14400007   BNE V0, ZERO, 0x9D001704
9D0016E8  00000000   NOP
1273:                    {
1274:                        TCPFlush(hTCP);
9D0016EC  93C20030   LBU V0, 48(S8)
9D0016F0  00402021   ADDU A0, V0, ZERO
9D0016F4  0F40034B   JAL TCPFlush
9D0016F8  00000000   NOP
9D0016FC  0B4005E7   J 0x9D00179C
9D001700  00000000   NOP
1275:                    }
1276:                    // If not already enabled, start a timer so this data will
1277:                    // eventually get sent even if the application doens't call
1278:                    // TCPFlush()
1279:                    else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001704  93828014   LBU V0, -32748(GP)
9D001708  3C04A000   LUI A0, -24576
9D00170C  00021100   SLL V0, V0, 4
9D001710  00021880   SLL V1, V0, 2
9D001714  00621823   SUBU V1, V1, V0
9D001718  2482753C   ADDIU V0, A0, 30012
9D00171C  00621021   ADDU V0, V1, V0
9D001720  8C420028   LW V0, 40(V0)
9D001724  7C420140   EXT V0, V0, 5, 1
9D001728  304200FF   ANDI V0, V0, 255
9D00172C  1440001B   BNE V0, ZERO, 0x9D00179C
9D001730  00000000   NOP
1280:                    {
1281:                        MyTCBStub.Flags.bTimer2Enabled = true;
9D001734  93828014   LBU V0, -32748(GP)
9D001738  3C04A000   LUI A0, -24576
9D00173C  00021100   SLL V0, V0, 4
9D001740  00021880   SLL V1, V0, 2
9D001744  00621823   SUBU V1, V1, V0
9D001748  2482753C   ADDIU V0, A0, 30012
9D00174C  00621821   ADDU V1, V1, V0
9D001750  8C620028   LW V0, 40(V1)
9D001754  24040001   ADDIU A0, ZERO, 1
9D001758  7C822944   INS V0, A0, 5, 1
9D00175C  AC620028   SW V0, 40(V1)
1282:                        MyTCBStub.eventTime2 = (uint16_t)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
9D001760  93828014   LBU V0, -32748(GP)
9D001764  00408021   ADDU S0, V0, ZERO
9D001768  0F405C62   JAL TickGetDiv256
9D00176C  00000000   NOP
9D001770  3042FFFF   ANDI V0, V0, -1
9D001774  24420030   ADDIU V0, V0, 48
9D001778  3044FFFF   ANDI A0, V0, -1
9D00177C  3C05A000   LUI A1, -24576
9D001780  02001021   ADDU V0, S0, ZERO
9D001784  00021100   SLL V0, V0, 4
9D001788  00021880   SLL V1, V0, 2
9D00178C  00621823   SUBU V1, V1, V0
9D001790  24A2753C   ADDIU V0, A1, 30012
9D001794  00621021   ADDU V0, V1, V0
9D001798  A4440020   SH A0, 32(V0)
1283:                    }
1284:                
1285:                    return wActualLen + wRightLen;
9D00179C  97C30018   LHU V1, 24(S8)
9D0017A0  97C2001A   LHU V0, 26(S8)
9D0017A4  00621021   ADDU V0, V1, V0
9D0017A8  3042FFFF   ANDI V0, V0, -1
1286:                }
9D0017AC  03C0E821   ADDU SP, S8, ZERO
9D0017B0  8FBF002C   LW RA, 44(SP)
9D0017B4  8FBE0028   LW S8, 40(SP)
9D0017B8  8FB00024   LW S0, 36(SP)
9D0017BC  27BD0030   ADDIU SP, SP, 48
9D0017C0  03E00008   JR RA
9D0017C4  00000000   NOP
1287:                
1288:                /*****************************************************************************
1289:                  Function:
1290:                    uint16_t TCPPutROMArray(TCP_SOCKET hTCP, ROM uint8_t* data, uint16_t len)
1291:                
1292:                  Description:
1293:                    Writes an array from ROM to a TCP socket.
1294:                
1295:                  Precondition:
1296:                    TCP is initialized.
1297:                
1298:                  Parameters:
1299:                    hTCP - The socket to which data is to be written.
1300:                    data - Pointer to the array to be written.
1301:                    len  - Number of bytes to be written.
1302:                
1303:                  Returns:
1304:                    The number of bytes written to the socket.  If less than len, the
1305:                    buffer became full or the socket is not conected.
1306:                
1307:                  Remarks:
1308:                    This function is aliased to TCPPutArray on non-PIC18 platforms.
1309:                  ***************************************************************************/
1310:                #if defined(__XC8)
1311:                uint16_t TCPPutROMArray(TCP_SOCKET hTCP, ROM uint8_t* data, uint16_t len)
1312:                {
1313:                    uint16_t wActualLen;
1314:                    uint16_t wFreeTXSpace;
1315:                    uint16_t wRightLen = 0;
1316:                
1317:                    if(hTCP >= TCP_SOCKET_COUNT)
1318:                    {
1319:                        return 0;
1320:                    }
1321:                
1322:                    SyncTCBStub(hTCP);
1323:                
1324:                    wFreeTXSpace = TCPIsPutReady(hTCP);
1325:                    if(wFreeTXSpace == 0u)
1326:                    {
1327:                        TCPFlush(hTCP);
1328:                        return 0;
1329:                    }
1330:                
1331:                    // Send all current bytes if we are crossing half full
1332:                    // This is required to improve performance with the delayed
1333:                    // acknowledgement algorithm
1334:                    if((!MyTCBStub.Flags.bHalfFullFlush) && (wFreeTXSpace <= ((MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart)>>1)))
1335:                    {
1336:                        TCPFlush(hTCP);
1337:                        MyTCBStub.Flags.bHalfFullFlush = true;
1338:                    }
1339:                
1340:                    wActualLen = wFreeTXSpace;
1341:                    if(wFreeTXSpace > len)
1342:                        wActualLen = len;
1343:                
1344:                    #if defined(STACK_USE_SSL)
1345:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1346:                    {
1347:                        // See if we need a two part put
1348:                        if(MyTCBStub.sslTxHead + wActualLen >= MyTCBStub.bufferRxStart)
1349:                        {
1350:                            wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
1351:                            TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1352:                            data += wRightLen;
1353:                            wActualLen -= wRightLen;
1354:                            MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
1355:                        }
1356:                
1357:                        TCPRAMCopyROM(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1358:                        MyTCBStub.sslTxHead += wActualLen;
1359:                    }
1360:                    else
1361:                    {
1362:                        // See if we need a two part put
1363:                        if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1364:                        {
1365:                            wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1366:                            TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1367:                            data += wRightLen;
1368:                            wActualLen -= wRightLen;
1369:                            MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1370:                        }
1371:                
1372:                        TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1373:                        MyTCBStub.txHead += wActualLen;
1374:                    }
1375:                    #else
1376:                    // See if we need a two part put
1377:                    if(MyTCBStub.txHead + wActualLen >= MyTCBStub.bufferRxStart)
1378:                    {
1379:                        wRightLen = MyTCBStub.bufferRxStart-MyTCBStub.txHead;
1380:                        TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wRightLen);
1381:                        data += wRightLen;
1382:                        wActualLen -= wRightLen;
1383:                        MyTCBStub.txHead = MyTCBStub.bufferTxStart;
1384:                    }
1385:                
1386:                    TCPRAMCopyROM(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, data, wActualLen);
1387:                    MyTCBStub.txHead += wActualLen;
1388:                    #endif
1389:                
1390:                    // Send these bytes right now if we are out of TX buffer space
1391:                    if(wFreeTXSpace <= len)
1392:                    {
1393:                        TCPFlush(hTCP);
1394:                    }
1395:                    // If not already enabled, start a timer so this data will
1396:                    // eventually get sent even if the application doens't call
1397:                    // TCPFlush()
1398:                    else if(!MyTCBStub.Flags.bTimer2Enabled)
1399:                    {
1400:                        MyTCBStub.Flags.bTimer2Enabled = true;
1401:                        MyTCBStub.eventTime2 = (uint16_t)TickGetDiv256() + TCP_AUTO_TRANSMIT_TIMEOUT_VAL/256ull;
1402:                    }
1403:                
1404:                    return wActualLen + wRightLen;
1405:                }
1406:                #endif
1407:                
1408:                /*****************************************************************************
1409:                  Function:
1410:                    uint8_t* TCPPutString(TCP_SOCKET hTCP, uint8_t* data)
1411:                
1412:                  Description:
1413:                    Writes a null-terminated string from RAM to a TCP socket.  The
1414:                    null-terminator is not copied to the socket.
1415:                
1416:                  Precondition:
1417:                    TCP is initialized.
1418:                
1419:                  Parameters:
1420:                    hTCP - The socket to which data is to be written.
1421:                    data - Pointer to the string to be written.
1422:                
1423:                  Returns:
1424:                    Pointer to the byte following the last byte written to the socket.  If
1425:                    this pointer does not dereference to a NUL byte, the buffer became full
1426:                    or the socket is not connected.
1427:                
1428:                  Remarks:
1429:                    The return value of this function differs from that of TCPPutArray.  To
1430:                    write long strings in a single state, initialize the *data pointer to the
1431:                    first byte, then call this function repeatedly (breaking to the main
1432:                    stack loop after each call) until the return value dereferences to a NUL
1433:                    byte.  Save the return value as the new starting *data pointer otherwise.
1434:                  ***************************************************************************/
1435:                uint8_t* TCPPutString(TCP_SOCKET hTCP, uint8_t* data)
1436:                {
9D0017C8  27BDFFE0   ADDIU SP, SP, -32
9D0017CC  AFBF001C   SW RA, 28(SP)
9D0017D0  AFBE0018   SW S8, 24(SP)
9D0017D4  AFB00014   SW S0, 20(SP)
9D0017D8  03A0F021   ADDU S8, SP, ZERO
9D0017DC  00801021   ADDU V0, A0, ZERO
9D0017E0  AFC50024   SW A1, 36(S8)
9D0017E4  A3C20020   SB V0, 32(S8)
1437:                    return data + TCPPutArray(hTCP, data, strlen((char*)data));
9D0017E8  93D00020   LBU S0, 32(S8)
9D0017EC  8FC20024   LW V0, 36(S8)
9D0017F0  00402021   ADDU A0, V0, ZERO
9D0017F4  0F4067E2   JAL 0x9D019F88
9D0017F8  00000000   NOP
9D0017FC  3042FFFF   ANDI V0, V0, -1
9D001800  02002021   ADDU A0, S0, ZERO
9D001804  8FC50024   LW A1, 36(S8)
9D001808  00403021   ADDU A2, V0, ZERO
9D00180C  0F4004D0   JAL TCPPutArray
9D001810  00000000   NOP
9D001814  8FC30024   LW V1, 36(S8)
9D001818  00621021   ADDU V0, V1, V0
1438:                }
9D00181C  03C0E821   ADDU SP, S8, ZERO
9D001820  8FBF001C   LW RA, 28(SP)
9D001824  8FBE0018   LW S8, 24(SP)
9D001828  8FB00014   LW S0, 20(SP)
9D00182C  27BD0020   ADDIU SP, SP, 32
9D001830  03E00008   JR RA
9D001834  00000000   NOP
1439:                
1440:                /*****************************************************************************
1441:                  Function:
1442:                    uint8_t* TCPPutROMString(TCP_SOCKET hTCP, ROM uint8_t* data)
1443:                
1444:                  Description:
1445:                    Writes a null-terminated string from ROM to a TCP socket.  The
1446:                    null-terminator is not copied to the socket.
1447:                
1448:                  Precondition:
1449:                    TCP is initialized.
1450:                
1451:                  Parameters:
1452:                    hTCP - The socket to which data is to be written.
1453:                    data - Pointer to the string to be written.
1454:                
1455:                  Returns:
1456:                    Pointer to the byte following the last byte written to the socket.  If
1457:                    this pointer does not dereference to a NUL byte, the buffer became full
1458:                    or the socket is not connected.
1459:                
1460:                  Remarks:
1461:                    The return value of this function differs from that of TCPPutArray.  To
1462:                    write long strings in a single state, initialize the *data pointer to the
1463:                    first byte, then call this function repeatedly (breaking to the main
1464:                    stack loop after each call) until the return value dereferences to a NUL
1465:                    byte.  Save the return value as the new starting *data pointer otherwise.
1466:                
1467:                    This function is aliased to TCPPutString on non-PIC18 platforms.
1468:                  ***************************************************************************/
1469:                #if defined(__XC8)
1470:                ROM uint8_t* TCPPutROMString(TCP_SOCKET hTCP, ROM uint8_t* data)
1471:                {
1472:                    return data + TCPPutROMArray(hTCP, data, strlenpgm((ROM char*)data));
1473:                }
1474:                #endif
1475:                
1476:                /*****************************************************************************
1477:                  Function:
1478:                    uint16_t TCPGetTxFIFOFull(TCP_SOCKET hTCP)
1479:                
1480:                  Description:
1481:                    Determines how many bytes are pending in the TCP TX FIFO.
1482:                
1483:                  Precondition:
1484:                    TCP is initialized.
1485:                
1486:                  Parameters:
1487:                    hTCP - The socket to check.
1488:                
1489:                  Returns:
1490:                    Number of bytes pending to be flushed in the TCP TX FIFO.
1491:                  ***************************************************************************/
1492:                uint16_t TCPGetTxFIFOFull(TCP_SOCKET hTCP)
1493:                {
9D001838  27BDFFE0   ADDIU SP, SP, -32
9D00183C  AFBF001C   SW RA, 28(SP)
9D001840  AFBE0018   SW S8, 24(SP)
9D001844  03A0F021   ADDU S8, SP, ZERO
9D001848  00801021   ADDU V0, A0, ZERO
9D00184C  A3C20020   SB V0, 32(S8)
1494:                    uint16_t wDataLen;
1495:                    uint16_t wFIFOSize;
1496:                
1497:                    if(hTCP >= TCP_SOCKET_COUNT)
9D001850  93C20020   LBU V0, 32(S8)
9D001854  2C420002   SLTIU V0, V0, 2
9D001858  14400004   BNE V0, ZERO, 0x9D00186C
9D00185C  00000000   NOP
1498:                    {
1499:                        return 0;
9D001860  00001021   ADDU V0, ZERO, ZERO
9D001864  0B40063C   J 0x9D0018F0
9D001868  00000000   NOP
1500:                    }
1501:                
1502:                    SyncTCBStub(hTCP);
9D00186C  93C20020   LBU V0, 32(S8)
9D001870  A3828014   SB V0, -32748(GP)
1503:                
1504:                    // Calculate total usable FIFO size
1505:                    wFIFOSize = MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1;
9D001874  93828014   LBU V0, -32748(GP)
9D001878  3C03A000   LUI V1, -24576
9D00187C  2463753C   ADDIU V1, V1, 30012
9D001880  00021100   SLL V0, V0, 4
9D001884  00022080   SLL A0, V0, 2
9D001888  00821023   SUBU V0, A0, V0
9D00188C  00621021   ADDU V0, V1, V0
9D001890  8C420004   LW V0, 4(V0)
9D001894  3044FFFF   ANDI A0, V0, -1
9D001898  93828014   LBU V0, -32748(GP)
9D00189C  3C05A000   LUI A1, -24576
9D0018A0  00021100   SLL V0, V0, 4
9D0018A4  00021880   SLL V1, V0, 2
9D0018A8  00621823   SUBU V1, V1, V0
9D0018AC  24A2753C   ADDIU V0, A1, 30012
9D0018B0  00621021   ADDU V0, V1, V0
9D0018B4  8C420000   LW V0, 0(V0)
9D0018B8  3042FFFF   ANDI V0, V0, -1
9D0018BC  00821023   SUBU V0, A0, V0
9D0018C0  3042FFFF   ANDI V0, V0, -1
9D0018C4  2442FFFF   ADDIU V0, V0, -1
9D0018C8  A7C20010   SH V0, 16(S8)
1506:                
1507:                    // Find out how many data bytes are free in the TX FIFO
1508:                    wDataLen = TCPIsPutReady(hTCP);
9D0018CC  93C20020   LBU V0, 32(S8)
9D0018D0  00402021   ADDU A0, V0, ZERO
9D0018D4  0F400373   JAL TCPIsPutReady
9D0018D8  00000000   NOP
9D0018DC  A7C20012   SH V0, 18(S8)
1509:                
1510:                    return wFIFOSize - wDataLen;
9D0018E0  97C30010   LHU V1, 16(S8)
9D0018E4  97C20012   LHU V0, 18(S8)
9D0018E8  00621023   SUBU V0, V1, V0
9D0018EC  3042FFFF   ANDI V0, V0, -1
1511:                }
9D0018F0  03C0E821   ADDU SP, S8, ZERO
9D0018F4  8FBF001C   LW RA, 28(SP)
9D0018F8  8FBE0018   LW S8, 24(SP)
9D0018FC  27BD0020   ADDIU SP, SP, 32
9D001900  03E00008   JR RA
9D001904  00000000   NOP
1512:                
1513:                
1514:                
1515:                /****************************************************************************
1516:                  Section:
1517:                    Receive Functions
1518:                  ***************************************************************************/
1519:                
1520:                /*****************************************************************************
1521:                  Function:
1522:                    void TCPDiscard(TCP_SOCKET hTCP)
1523:                
1524:                  Description:
1525:                    Discards any pending data in the TCP RX FIFO.
1526:                
1527:                  Precondition:
1528:                    TCP is initialized.
1529:                
1530:                  Parameters:
1531:                    hTCP - The socket whose RX FIFO is to be cleared.
1532:                
1533:                  Returns:
1534:                    None
1535:                  ***************************************************************************/
1536:                void TCPDiscard(TCP_SOCKET hTCP)
1537:                {
9D001908  27BDFFE8   ADDIU SP, SP, -24
9D00190C  AFBF0014   SW RA, 20(SP)
9D001910  AFBE0010   SW S8, 16(SP)
9D001914  03A0F021   ADDU S8, SP, ZERO
9D001918  00801021   ADDU V0, A0, ZERO
9D00191C  A3C20018   SB V0, 24(S8)
1538:                    if(TCPIsGetReady(hTCP))
9D001920  93C20018   LBU V0, 24(S8)
9D001924  00402021   ADDU A0, V0, ZERO
9D001928  0F40066C   JAL TCPIsGetReady
9D00192C  00000000   NOP
9D001930  10400019   BEQ V0, ZERO, 0x9D001998
9D001934  00000000   NOP
1539:                    {
1540:                        SyncTCBStub(hTCP);
9D001938  93C20018   LBU V0, 24(S8)
9D00193C  A3828014   SB V0, -32748(GP)
1541:                
1542:                        // Delete all data in the RX buffer
1543:                        MyTCBStub.rxTail = MyTCBStub.rxHead;
9D001940  93828014   LBU V0, -32748(GP)
9D001944  00401821   ADDU V1, V0, ZERO
9D001948  93828014   LBU V0, -32748(GP)
9D00194C  3C04A000   LUI A0, -24576
9D001950  2484753C   ADDIU A0, A0, 30012
9D001954  00021100   SLL V0, V0, 4
9D001958  00022880   SLL A1, V0, 2
9D00195C  00A21023   SUBU V0, A1, V0
9D001960  00821021   ADDU V0, A0, V0
9D001964  8C440014   LW A0, 20(V0)
9D001968  3C05A000   LUI A1, -24576
9D00196C  00601021   ADDU V0, V1, ZERO
9D001970  00021100   SLL V0, V0, 4
9D001974  00021880   SLL V1, V0, 2
9D001978  00621823   SUBU V1, V1, V0
9D00197C  24A2753C   ADDIU V0, A1, 30012
9D001980  00621021   ADDU V0, V1, V0
9D001984  AC440018   SW A0, 24(V0)
1544:                
1545:                        // Send a Window update message to the remote node
1546:                        SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D001988  24040010   ADDIU A0, ZERO, 16
9D00198C  24050001   ADDIU A1, ZERO, 1
9D001990  0F400F2C   JAL 0x9D003CB0
9D001994  00000000   NOP
1547:                    }
1548:                }
9D001998  03C0E821   ADDU SP, S8, ZERO
9D00199C  8FBF0014   LW RA, 20(SP)
9D0019A0  8FBE0010   LW S8, 16(SP)
9D0019A4  27BD0018   ADDIU SP, SP, 24
9D0019A8  03E00008   JR RA
9D0019AC  00000000   NOP
1549:                
1550:                
1551:                /*****************************************************************************
1552:                  Function:
1553:                    void uint16_t TCPIsGetReady(TCP_SOCKET hTCP)
1554:                
1555:                  Summary:
1556:                    Determines how many bytes can be read from the TCP RX buffer.
1557:                
1558:                  Description:
1559:                    Call this function to determine how many bytes can be read from the
1560:                    TCP RX buffer.  If this function returns zero, the application must
1561:                    return to the main stack loop before continuing in order to wait for
1562:                    more data to arrive.
1563:                
1564:                  Precondition:
1565:                    TCP is initialized.
1566:                
1567:                  Parameters:
1568:                    hTCP - The socket to check.
1569:                
1570:                  Returns:
1571:                    The number of bytes available to be read from the TCP RX buffer.
1572:                  ***************************************************************************/
1573:                uint16_t TCPIsGetReady(TCP_SOCKET hTCP)
1574:                {
9D0019B0  27BDFFF8   ADDIU SP, SP, -8
9D0019B4  AFBE0004   SW S8, 4(SP)
9D0019B8  03A0F021   ADDU S8, SP, ZERO
9D0019BC  00801021   ADDU V0, A0, ZERO
9D0019C0  A3C20008   SB V0, 8(S8)
1575:                    if(hTCP >= TCP_SOCKET_COUNT)
9D0019C4  93C20008   LBU V0, 8(S8)
9D0019C8  2C420002   SLTIU V0, V0, 2
9D0019CC  14400004   BNE V0, ZERO, 0x9D0019E0
9D0019D0  00000000   NOP
1576:                    {
1577:                        return 0;
9D0019D4  00001021   ADDU V0, ZERO, ZERO
9D0019D8  0B4006CF   J 0x9D001B3C
9D0019DC  00000000   NOP
1578:                    }
1579:                
1580:                    SyncTCBStub(hTCP);
9D0019E0  93C20008   LBU V0, 8(S8)
9D0019E4  A3828014   SB V0, -32748(GP)
1581:                
1582:                    if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D0019E8  93828014   LBU V0, -32748(GP)
9D0019EC  3C03A000   LUI V1, -24576
9D0019F0  2463753C   ADDIU V1, V1, 30012
9D0019F4  00021100   SLL V0, V0, 4
9D0019F8  00022080   SLL A0, V0, 2
9D0019FC  00821023   SUBU V0, A0, V0
9D001A00  00621021   ADDU V0, V1, V0
9D001A04  8C440014   LW A0, 20(V0)
9D001A08  93828014   LBU V0, -32748(GP)
9D001A0C  3C05A000   LUI A1, -24576
9D001A10  00021100   SLL V0, V0, 4
9D001A14  00021880   SLL V1, V0, 2
9D001A18  00621823   SUBU V1, V1, V0
9D001A1C  24A2753C   ADDIU V0, A1, 30012
9D001A20  00621021   ADDU V0, V1, V0
9D001A24  8C420018   LW V0, 24(V0)
9D001A28  0082102B   SLTU V0, A0, V0
9D001A2C  14400017   BNE V0, ZERO, 0x9D001A8C
9D001A30  00000000   NOP
1583:                        return MyTCBStub.rxHead - MyTCBStub.rxTail;
9D001A34  93828014   LBU V0, -32748(GP)
9D001A38  3C03A000   LUI V1, -24576
9D001A3C  2463753C   ADDIU V1, V1, 30012
9D001A40  00021100   SLL V0, V0, 4
9D001A44  00022080   SLL A0, V0, 2
9D001A48  00821023   SUBU V0, A0, V0
9D001A4C  00621021   ADDU V0, V1, V0
9D001A50  8C420014   LW V0, 20(V0)
9D001A54  3044FFFF   ANDI A0, V0, -1
9D001A58  93828014   LBU V0, -32748(GP)
9D001A5C  3C05A000   LUI A1, -24576
9D001A60  00021100   SLL V0, V0, 4
9D001A64  00021880   SLL V1, V0, 2
9D001A68  00621823   SUBU V1, V1, V0
9D001A6C  24A2753C   ADDIU V0, A1, 30012
9D001A70  00621021   ADDU V0, V1, V0
9D001A74  8C420018   LW V0, 24(V0)
9D001A78  3042FFFF   ANDI V0, V0, -1
9D001A7C  00821023   SUBU V0, A0, V0
9D001A80  3042FFFF   ANDI V0, V0, -1
9D001A84  0B4006CF   J 0x9D001B3C
9D001A88  00000000   NOP
1584:                    else
1585:                        return (MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1) + (MyTCBStub.rxHead - MyTCBStub.bufferRxStart);
9D001A8C  93828014   LBU V0, -32748(GP)
9D001A90  3C04A000   LUI A0, -24576
9D001A94  00021100   SLL V0, V0, 4
9D001A98  00021880   SLL V1, V0, 2
9D001A9C  00621823   SUBU V1, V1, V0
9D001AA0  2482753C   ADDIU V0, A0, 30012
9D001AA4  00621021   ADDU V0, V1, V0
9D001AA8  8C420008   LW V0, 8(V0)
9D001AAC  3044FFFF   ANDI A0, V0, -1
9D001AB0  93828014   LBU V0, -32748(GP)
9D001AB4  3C05A000   LUI A1, -24576
9D001AB8  00021100   SLL V0, V0, 4
9D001ABC  00021880   SLL V1, V0, 2
9D001AC0  00621823   SUBU V1, V1, V0
9D001AC4  24A2753C   ADDIU V0, A1, 30012
9D001AC8  00621021   ADDU V0, V1, V0
9D001ACC  8C420018   LW V0, 24(V0)
9D001AD0  3042FFFF   ANDI V0, V0, -1
9D001AD4  00821023   SUBU V0, A0, V0
9D001AD8  3043FFFF   ANDI V1, V0, -1
9D001ADC  93828014   LBU V0, -32748(GP)
9D001AE0  3C04A000   LUI A0, -24576
9D001AE4  2484753C   ADDIU A0, A0, 30012
9D001AE8  00021100   SLL V0, V0, 4
9D001AEC  00022880   SLL A1, V0, 2
9D001AF0  00A21023   SUBU V0, A1, V0
9D001AF4  00821021   ADDU V0, A0, V0
9D001AF8  8C420014   LW V0, 20(V0)
9D001AFC  3044FFFF   ANDI A0, V0, -1
9D001B00  93828014   LBU V0, -32748(GP)
9D001B04  3C05A000   LUI A1, -24576
9D001B08  24A5753C   ADDIU A1, A1, 30012
9D001B0C  00021100   SLL V0, V0, 4
9D001B10  00023080   SLL A2, V0, 2
9D001B14  00C21023   SUBU V0, A2, V0
9D001B18  00A21021   ADDU V0, A1, V0
9D001B1C  8C420004   LW V0, 4(V0)
9D001B20  3042FFFF   ANDI V0, V0, -1
9D001B24  00821023   SUBU V0, A0, V0
9D001B28  3042FFFF   ANDI V0, V0, -1
9D001B2C  00621021   ADDU V0, V1, V0
9D001B30  3042FFFF   ANDI V0, V0, -1
9D001B34  24420001   ADDIU V0, V0, 1
9D001B38  3042FFFF   ANDI V0, V0, -1
1586:                }
9D001B3C  03C0E821   ADDU SP, S8, ZERO
9D001B40  8FBE0004   LW S8, 4(SP)
9D001B44  27BD0008   ADDIU SP, SP, 8
9D001B48  03E00008   JR RA
9D001B4C  00000000   NOP
1587:                
1588:                
1589:                /*****************************************************************************
1590:                  Function:
1591:                    bool TCPGet(TCP_SOCKET hTCP, uint8_t* byte)
1592:                
1593:                  Description:
1594:                    Retrieves a single byte to a TCP socket.
1595:                
1596:                  Precondition:
1597:                    TCP is initialized.
1598:                
1599:                  Parameters:
1600:                    hTCP - The socket from which to read.
1601:                    byte - Pointer to location in which the read byte should be stored.
1602:                
1603:                  Return Values:
1604:                    true - A byte was read from the buffer.
1605:                    false - The buffer was empty, or the socket is not connected.
1606:                  ***************************************************************************/
1607:                bool TCPGet(TCP_SOCKET hTCP, uint8_t* byte)
1608:                {
9D001B50  27BDFFD0   ADDIU SP, SP, -48
9D001B54  AFBF002C   SW RA, 44(SP)
9D001B58  AFBE0028   SW S8, 40(SP)
9D001B5C  AFB00024   SW S0, 36(SP)
9D001B60  03A0F021   ADDU S8, SP, ZERO
9D001B64  00801021   ADDU V0, A0, ZERO
9D001B68  AFC50034   SW A1, 52(S8)
9D001B6C  A3C20030   SB V0, 48(S8)
1609:                    uint16_t wGetReadyCount;
1610:                
1611:                    // See if there is any data which can be read
1612:                    wGetReadyCount = TCPIsGetReady(hTCP);
9D001B70  93C20030   LBU V0, 48(S8)
9D001B74  00402021   ADDU A0, V0, ZERO
9D001B78  0F40066C   JAL TCPIsGetReady
9D001B7C  00000000   NOP
9D001B80  A7C20018   SH V0, 24(S8)
1613:                    if(wGetReadyCount == 0u)
9D001B84  97C20018   LHU V0, 24(S8)
9D001B88  14400004   BNE V0, ZERO, 0x9D001B9C
9D001B8C  00000000   NOP
1614:                        return false;
9D001B90  00001021   ADDU V0, ZERO, ZERO
9D001B94  0B400773   J 0x9D001DCC
9D001B98  00000000   NOP
1615:                
1616:                    SyncTCBStub(hTCP);
9D001B9C  93C20030   LBU V0, 48(S8)
9D001BA0  A3828014   SB V0, -32748(GP)
1617:                
1618:                    if(byte)
9D001BA4  8FC20034   LW V0, 52(S8)
9D001BA8  10400018   BEQ V0, ZERO, 0x9D001C0C
9D001BAC  00000000   NOP
1619:                        TCPRAMCopy((PTR_BASE)byte, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, 1);
9D001BB0  8FC40034   LW A0, 52(S8)
9D001BB4  93828014   LBU V0, -32748(GP)
9D001BB8  3C05A000   LUI A1, -24576
9D001BBC  00021100   SLL V0, V0, 4
9D001BC0  00021880   SLL V1, V0, 2
9D001BC4  00621823   SUBU V1, V1, V0
9D001BC8  24A2753C   ADDIU V0, A1, 30012
9D001BCC  00621021   ADDU V0, V1, V0
9D001BD0  8C460018   LW A2, 24(V0)
9D001BD4  93828014   LBU V0, -32748(GP)
9D001BD8  3C05A000   LUI A1, -24576
9D001BDC  00021100   SLL V0, V0, 4
9D001BE0  00021880   SLL V1, V0, 2
9D001BE4  00621823   SUBU V1, V1, V0
9D001BE8  24A2753C   ADDIU V0, A1, 30012
9D001BEC  00621021   ADDU V0, V1, V0
9D001BF0  9042002C   LBU V0, 44(V0)
9D001BF4  24030001   ADDIU V1, ZERO, 1
9D001BF8  AFA30010   SW V1, 16(SP)
9D001BFC  24050001   ADDIU A1, ZERO, 1
9D001C00  00403821   ADDU A3, V0, ZERO
9D001C04  0F4020A8   JAL 0x9D0082A0
9D001C08  00000000   NOP
1620:                    if(++MyTCBStub.rxTail > MyTCBStub.bufferEnd)
9D001C0C  93828014   LBU V0, -32748(GP)
9D001C10  00401821   ADDU V1, V0, ZERO
9D001C14  3C05A000   LUI A1, -24576
9D001C18  00601021   ADDU V0, V1, ZERO
9D001C1C  00021100   SLL V0, V0, 4
9D001C20  00022080   SLL A0, V0, 2
9D001C24  00822023   SUBU A0, A0, V0
9D001C28  24A2753C   ADDIU V0, A1, 30012
9D001C2C  00821021   ADDU V0, A0, V0
9D001C30  8C420018   LW V0, 24(V0)
9D001C34  24450001   ADDIU A1, V0, 1
9D001C38  3C06A000   LUI A2, -24576
9D001C3C  00601021   ADDU V0, V1, ZERO
9D001C40  00021100   SLL V0, V0, 4
9D001C44  00022080   SLL A0, V0, 2
9D001C48  00822023   SUBU A0, A0, V0
9D001C4C  24C2753C   ADDIU V0, A2, 30012
9D001C50  00821021   ADDU V0, A0, V0
9D001C54  AC450018   SW A1, 24(V0)
9D001C58  3C04A000   LUI A0, -24576
9D001C5C  00601021   ADDU V0, V1, ZERO
9D001C60  00021100   SLL V0, V0, 4
9D001C64  00021880   SLL V1, V0, 2
9D001C68  00621823   SUBU V1, V1, V0
9D001C6C  2482753C   ADDIU V0, A0, 30012
9D001C70  00621021   ADDU V0, V1, V0
9D001C74  8C440018   LW A0, 24(V0)
9D001C78  93828014   LBU V0, -32748(GP)
9D001C7C  3C05A000   LUI A1, -24576
9D001C80  00021100   SLL V0, V0, 4
9D001C84  00021880   SLL V1, V0, 2
9D001C88  00621823   SUBU V1, V1, V0
9D001C8C  24A2753C   ADDIU V0, A1, 30012
9D001C90  00621021   ADDU V0, V1, V0
9D001C94  8C420008   LW V0, 8(V0)
9D001C98  0044102B   SLTU V0, V0, A0
9D001C9C  10400013   BEQ V0, ZERO, 0x9D001CEC
9D001CA0  00000000   NOP
1621:                        MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D001CA4  93828014   LBU V0, -32748(GP)
9D001CA8  00401821   ADDU V1, V0, ZERO
9D001CAC  93828014   LBU V0, -32748(GP)
9D001CB0  3C04A000   LUI A0, -24576
9D001CB4  2484753C   ADDIU A0, A0, 30012
9D001CB8  00021100   SLL V0, V0, 4
9D001CBC  00022880   SLL A1, V0, 2
9D001CC0  00A21023   SUBU V0, A1, V0
9D001CC4  00821021   ADDU V0, A0, V0
9D001CC8  8C440004   LW A0, 4(V0)
9D001CCC  3C05A000   LUI A1, -24576
9D001CD0  00601021   ADDU V0, V1, ZERO
9D001CD4  00021100   SLL V0, V0, 4
9D001CD8  00021880   SLL V1, V0, 2
9D001CDC  00621823   SUBU V1, V1, V0
9D001CE0  24A2753C   ADDIU V0, A1, 30012
9D001CE4  00621021   ADDU V0, V1, V0
9D001CE8  AC440018   SW A0, 24(V0)
1622:                
1623:                    // Send a window update if we've run out of data
1624:                    if(wGetReadyCount == 1u)
9D001CEC  97C30018   LHU V1, 24(S8)
9D001CF0  24020001   ADDIU V0, ZERO, 1
9D001CF4  1462000E   BNE V1, V0, 0x9D001D30
9D001CF8  00000000   NOP
1625:                    {
1626:                        MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D001CFC  93828014   LBU V0, -32748(GP)
9D001D00  3C04A000   LUI A0, -24576
9D001D04  00021100   SLL V0, V0, 4
9D001D08  00021880   SLL V1, V0, 2
9D001D0C  00621823   SUBU V1, V1, V0
9D001D10  2482753C   ADDIU V0, A0, 30012
9D001D14  00621821   ADDU V1, V1, V0
9D001D18  8C620028   LW V0, 40(V1)
9D001D1C  24040001   ADDIU A0, ZERO, 1
9D001D20  7C825284   INS V0, A0, 10, 1
9D001D24  AC620028   SW V0, 40(V1)
9D001D28  0B400772   J 0x9D001DC8
9D001D2C  00000000   NOP
1627:                    }
1628:                    // If not already enabled, start a timer so a window
1629:                    // update will get sent to the remote node at some point
1630:                    else if(!MyTCBStub.Flags.bTimer2Enabled)
9D001D30  93828014   LBU V0, -32748(GP)
9D001D34  3C04A000   LUI A0, -24576
9D001D38  00021100   SLL V0, V0, 4
9D001D3C  00021880   SLL V1, V0, 2
9D001D40  00621823   SUBU V1, V1, V0
9D001D44  2482753C   ADDIU V0, A0, 30012
9D001D48  00621021   ADDU V0, V1, V0
9D001D4C  8C420028   LW V0, 40(V0)
9D001D50  7C420140   EXT V0, V0, 5, 1
9D001D54  304200FF   ANDI V0, V0, 255
9D001D58  1440001B   BNE V0, ZERO, 0x9D001DC8
9D001D5C  00000000   NOP
1631:                    {
1632:                        MyTCBStub.Flags.bTimer2Enabled = true;
9D001D60  93828014   LBU V0, -32748(GP)
9D001D64  3C04A000   LUI A0, -24576
9D001D68  00021100   SLL V0, V0, 4
9D001D6C  00021880   SLL V1, V0, 2
9D001D70  00621823   SUBU V1, V1, V0
9D001D74  2482753C   ADDIU V0, A0, 30012
9D001D78  00621821   ADDU V1, V1, V0
9D001D7C  8C620028   LW V0, 40(V1)
9D001D80  24040001   ADDIU A0, ZERO, 1
9D001D84  7C822944   INS V0, A0, 5, 1
9D001D88  AC620028   SW V0, 40(V1)
1633:                        MyTCBStub.eventTime2 = (uint16_t)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9D001D8C  93828014   LBU V0, -32748(GP)
9D001D90  00408021   ADDU S0, V0, ZERO
9D001D94  0F405C62   JAL TickGetDiv256
9D001D98  00000000   NOP
9D001D9C  3042FFFF   ANDI V0, V0, -1
9D001DA0  244200F4   ADDIU V0, V0, 244
9D001DA4  3044FFFF   ANDI A0, V0, -1
9D001DA8  3C05A000   LUI A1, -24576
9D001DAC  02001021   ADDU V0, S0, ZERO
9D001DB0  00021100   SLL V0, V0, 4
9D001DB4  00021880   SLL V1, V0, 2
9D001DB8  00621823   SUBU V1, V1, V0
9D001DBC  24A2753C   ADDIU V0, A1, 30012
9D001DC0  00621021   ADDU V0, V1, V0
9D001DC4  A4440020   SH A0, 32(V0)
1634:                    }
1635:                
1636:                
1637:                    return true;
9D001DC8  24020001   ADDIU V0, ZERO, 1
1638:                }
9D001DCC  03C0E821   ADDU SP, S8, ZERO
9D001DD0  8FBF002C   LW RA, 44(SP)
9D001DD4  8FBE0028   LW S8, 40(SP)
9D001DD8  8FB00024   LW S0, 36(SP)
9D001DDC  27BD0030   ADDIU SP, SP, 48
9D001DE0  03E00008   JR RA
9D001DE4  00000000   NOP
1639:                
1640:                
1641:                /*****************************************************************************
1642:                  Function:
1643:                    uint16_t TCPGetArray(TCP_SOCKET hTCP, uint8_t* buffer, uint16_t len)
1644:                
1645:                  Description:
1646:                    Reads an array of data bytes from a TCP socket's receive FIFO.  The data
1647:                    is removed from the FIFO in the process.
1648:                
1649:                  Precondition:
1650:                    TCP is initialized.
1651:                
1652:                  Parameters:
1653:                    hTCP - The socket from which data is to be read.
1654:                    buffer - Pointer to the array to store data that was read.
1655:                    len  - Number of bytes to be read.
1656:                
1657:                  Returns:
1658:                    The number of bytes read from the socket.  If less than len, the
1659:                    RX FIFO buffer became empty or the socket is not conected.
1660:                  ***************************************************************************/
1661:                uint16_t TCPGetArray(TCP_SOCKET hTCP, uint8_t* buffer, uint16_t len)
1662:                {
9D001DE8  27BDFFD0   ADDIU SP, SP, -48
9D001DEC  AFBF002C   SW RA, 44(SP)
9D001DF0  AFBE0028   SW S8, 40(SP)
9D001DF4  AFB00024   SW S0, 36(SP)
9D001DF8  03A0F021   ADDU S8, SP, ZERO
9D001DFC  00801821   ADDU V1, A0, ZERO
9D001E00  AFC50034   SW A1, 52(S8)
9D001E04  00C01021   ADDU V0, A2, ZERO
9D001E08  A3C30030   SB V1, 48(S8)
9D001E0C  A7C20038   SH V0, 56(S8)
1663:                    uint16_t wGetReadyCount;
1664:                    uint16_t RightLen = 0;
9D001E10  A7C00018   SH ZERO, 24(S8)
1665:                
1666:                    // See if there is any data which can be read
1667:                    wGetReadyCount = TCPIsGetReady(hTCP);
9D001E14  93C20030   LBU V0, 48(S8)
9D001E18  00402021   ADDU A0, V0, ZERO
9D001E1C  0F40066C   JAL TCPIsGetReady
9D001E20  00000000   NOP
9D001E24  A7C2001A   SH V0, 26(S8)
1668:                    if(wGetReadyCount == 0u)
9D001E28  97C2001A   LHU V0, 26(S8)
9D001E2C  14400004   BNE V0, ZERO, 0x9D001E40
9D001E30  00000000   NOP
1669:                        return 0x0000u;
9D001E34  00001021   ADDU V0, ZERO, ZERO
9D001E38  0B400865   J 0x9D002194
9D001E3C  00000000   NOP
1670:                
1671:                    SyncTCBStub(hTCP);
9D001E40  93C20030   LBU V0, 48(S8)
9D001E44  A3828014   SB V0, -32748(GP)
1672:                
1673:                    // Make sure we don't try to read more data than is available
1674:                    if(len > wGetReadyCount)
9D001E48  97C30038   LHU V1, 56(S8)
9D001E4C  97C2001A   LHU V0, 26(S8)
9D001E50  0043102B   SLTU V0, V0, V1
9D001E54  10400003   BEQ V0, ZERO, 0x9D001E64
9D001E58  00000000   NOP
1675:                        len = wGetReadyCount;
9D001E5C  97C2001A   LHU V0, 26(S8)
9D001E60  A7C20038   SH V0, 56(S8)
1676:                
1677:                    // See if we need a two part get
1678:                    if(MyTCBStub.rxTail + len > MyTCBStub.bufferEnd)
9D001E64  93828014   LBU V0, -32748(GP)
9D001E68  3C04A000   LUI A0, -24576
9D001E6C  00021100   SLL V0, V0, 4
9D001E70  00021880   SLL V1, V0, 2
9D001E74  00621823   SUBU V1, V1, V0
9D001E78  2482753C   ADDIU V0, A0, 30012
9D001E7C  00621021   ADDU V0, V1, V0
9D001E80  8C430018   LW V1, 24(V0)
9D001E84  97C20038   LHU V0, 56(S8)
9D001E88  00622021   ADDU A0, V1, V0
9D001E8C  93828014   LBU V0, -32748(GP)
9D001E90  3C05A000   LUI A1, -24576
9D001E94  00021100   SLL V0, V0, 4
9D001E98  00021880   SLL V1, V0, 2
9D001E9C  00621823   SUBU V1, V1, V0
9D001EA0  24A2753C   ADDIU V0, A1, 30012
9D001EA4  00621021   ADDU V0, V1, V0
9D001EA8  8C420008   LW V0, 8(V0)
9D001EAC  0044102B   SLTU V0, V0, A0
9D001EB0  1040004B   BEQ V0, ZERO, 0x9D001FE0
9D001EB4  00000000   NOP
1679:                    {
1680:                        RightLen = MyTCBStub.bufferEnd - MyTCBStub.rxTail + 1;
9D001EB8  93828014   LBU V0, -32748(GP)
9D001EBC  3C04A000   LUI A0, -24576
9D001EC0  00021100   SLL V0, V0, 4
9D001EC4  00021880   SLL V1, V0, 2
9D001EC8  00621823   SUBU V1, V1, V0
9D001ECC  2482753C   ADDIU V0, A0, 30012
9D001ED0  00621021   ADDU V0, V1, V0
9D001ED4  8C420008   LW V0, 8(V0)
9D001ED8  3044FFFF   ANDI A0, V0, -1
9D001EDC  93828014   LBU V0, -32748(GP)
9D001EE0  3C05A000   LUI A1, -24576
9D001EE4  00021100   SLL V0, V0, 4
9D001EE8  00021880   SLL V1, V0, 2
9D001EEC  00621823   SUBU V1, V1, V0
9D001EF0  24A2753C   ADDIU V0, A1, 30012
9D001EF4  00621021   ADDU V0, V1, V0
9D001EF8  8C420018   LW V0, 24(V0)
9D001EFC  3042FFFF   ANDI V0, V0, -1
9D001F00  00821023   SUBU V0, A0, V0
9D001F04  3042FFFF   ANDI V0, V0, -1
9D001F08  24420001   ADDIU V0, V0, 1
9D001F0C  A7C20018   SH V0, 24(S8)
1681:                        if(buffer)
9D001F10  8FC20034   LW V0, 52(S8)
9D001F14  1040001C   BEQ V0, ZERO, 0x9D001F88
9D001F18  00000000   NOP
1682:                        {
1683:                            TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, RightLen);
9D001F1C  8FC40034   LW A0, 52(S8)
9D001F20  93828014   LBU V0, -32748(GP)
9D001F24  3C05A000   LUI A1, -24576
9D001F28  00021100   SLL V0, V0, 4
9D001F2C  00021880   SLL V1, V0, 2
9D001F30  00621823   SUBU V1, V1, V0
9D001F34  24A2753C   ADDIU V0, A1, 30012
9D001F38  00621021   ADDU V0, V1, V0
9D001F3C  8C460018   LW A2, 24(V0)
9D001F40  93828014   LBU V0, -32748(GP)
9D001F44  3C05A000   LUI A1, -24576
9D001F48  00021100   SLL V0, V0, 4
9D001F4C  00021880   SLL V1, V0, 2
9D001F50  00621823   SUBU V1, V1, V0
9D001F54  24A2753C   ADDIU V0, A1, 30012
9D001F58  00621021   ADDU V0, V1, V0
9D001F5C  9042002C   LBU V0, 44(V0)
9D001F60  97C30018   LHU V1, 24(S8)
9D001F64  AFA30010   SW V1, 16(SP)
9D001F68  24050001   ADDIU A1, ZERO, 1
9D001F6C  00403821   ADDU A3, V0, ZERO
9D001F70  0F4020A8   JAL 0x9D0082A0
9D001F74  00000000   NOP
1684:                            buffer += RightLen;
9D001F78  97C20018   LHU V0, 24(S8)
9D001F7C  8FC30034   LW V1, 52(S8)
9D001F80  00621021   ADDU V0, V1, V0
9D001F84  AFC20034   SW V0, 52(S8)
1685:                        }
1686:                        len -= RightLen;
9D001F88  97C30038   LHU V1, 56(S8)
9D001F8C  97C20018   LHU V0, 24(S8)
9D001F90  00621023   SUBU V0, V1, V0
9D001F94  A7C20038   SH V0, 56(S8)
1687:                        MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D001F98  93828014   LBU V0, -32748(GP)
9D001F9C  00401821   ADDU V1, V0, ZERO
9D001FA0  93828014   LBU V0, -32748(GP)
9D001FA4  3C04A000   LUI A0, -24576
9D001FA8  2484753C   ADDIU A0, A0, 30012
9D001FAC  00021100   SLL V0, V0, 4
9D001FB0  00022880   SLL A1, V0, 2
9D001FB4  00A21023   SUBU V0, A1, V0
9D001FB8  00821021   ADDU V0, A0, V0
9D001FBC  8C440004   LW A0, 4(V0)
9D001FC0  3C05A000   LUI A1, -24576
9D001FC4  00601021   ADDU V0, V1, ZERO
9D001FC8  00021100   SLL V0, V0, 4
9D001FCC  00021880   SLL V1, V0, 2
9D001FD0  00621823   SUBU V1, V1, V0
9D001FD4  24A2753C   ADDIU V0, A1, 30012
9D001FD8  00621021   ADDU V0, V1, V0
9D001FDC  AC440018   SW A0, 24(V0)
1688:                    }
1689:                
1690:                    if(buffer)
9D001FE0  8FC20034   LW V0, 52(S8)
9D001FE4  10400018   BEQ V0, ZERO, 0x9D002048
9D001FE8  00000000   NOP
1691:                        TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, MyTCBStub.rxTail, MyTCBStub.vMemoryMedium, len);
9D001FEC  8FC40034   LW A0, 52(S8)
9D001FF0  93828014   LBU V0, -32748(GP)
9D001FF4  3C05A000   LUI A1, -24576
9D001FF8  00021100   SLL V0, V0, 4
9D001FFC  00021880   SLL V1, V0, 2
9D002000  00621823   SUBU V1, V1, V0
9D002004  24A2753C   ADDIU V0, A1, 30012
9D002008  00621021   ADDU V0, V1, V0
9D00200C  8C460018   LW A2, 24(V0)
9D002010  93828014   LBU V0, -32748(GP)
9D002014  3C05A000   LUI A1, -24576
9D002018  00021100   SLL V0, V0, 4
9D00201C  00021880   SLL V1, V0, 2
9D002020  00621823   SUBU V1, V1, V0
9D002024  24A2753C   ADDIU V0, A1, 30012
9D002028  00621021   ADDU V0, V1, V0
9D00202C  9042002C   LBU V0, 44(V0)
9D002030  97C30038   LHU V1, 56(S8)
9D002034  AFA30010   SW V1, 16(SP)
9D002038  24050001   ADDIU A1, ZERO, 1
9D00203C  00403821   ADDU A3, V0, ZERO
9D002040  0F4020A8   JAL 0x9D0082A0
9D002044  00000000   NOP
1692:                    MyTCBStub.rxTail += len;
9D002048  93828014   LBU V0, -32748(GP)
9D00204C  00403021   ADDU A2, V0, ZERO
9D002050  93828014   LBU V0, -32748(GP)
9D002054  3C04A000   LUI A0, -24576
9D002058  00021100   SLL V0, V0, 4
9D00205C  00021880   SLL V1, V0, 2
9D002060  00621823   SUBU V1, V1, V0
9D002064  2482753C   ADDIU V0, A0, 30012
9D002068  00621021   ADDU V0, V1, V0
9D00206C  8C430018   LW V1, 24(V0)
9D002070  97C20038   LHU V0, 56(S8)
9D002074  00622021   ADDU A0, V1, V0
9D002078  3C05A000   LUI A1, -24576
9D00207C  00C01021   ADDU V0, A2, ZERO
9D002080  00021100   SLL V0, V0, 4
9D002084  00021880   SLL V1, V0, 2
9D002088  00621823   SUBU V1, V1, V0
9D00208C  24A2753C   ADDIU V0, A1, 30012
9D002090  00621021   ADDU V0, V1, V0
9D002094  AC440018   SW A0, 24(V0)
1693:                    len += RightLen;
9D002098  97C30038   LHU V1, 56(S8)
9D00209C  97C20018   LHU V0, 24(S8)
9D0020A0  00621021   ADDU V0, V1, V0
9D0020A4  A7C20038   SH V0, 56(S8)
1694:                
1695:                    // Send a window update if we've run low on data
1696:                    if(wGetReadyCount - len <= len)
9D0020A8  97C3001A   LHU V1, 26(S8)
9D0020AC  97C20038   LHU V0, 56(S8)
9D0020B0  00621823   SUBU V1, V1, V0
9D0020B4  97C20038   LHU V0, 56(S8)
9D0020B8  0043102A   SLT V0, V0, V1
9D0020BC  1440000E   BNE V0, ZERO, 0x9D0020F8
9D0020C0  00000000   NOP
1697:                    {
1698:                        MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D0020C4  93828014   LBU V0, -32748(GP)
9D0020C8  3C04A000   LUI A0, -24576
9D0020CC  00021100   SLL V0, V0, 4
9D0020D0  00021880   SLL V1, V0, 2
9D0020D4  00621823   SUBU V1, V1, V0
9D0020D8  2482753C   ADDIU V0, A0, 30012
9D0020DC  00621821   ADDU V1, V1, V0
9D0020E0  8C620028   LW V0, 40(V1)
9D0020E4  24040001   ADDIU A0, ZERO, 1
9D0020E8  7C825284   INS V0, A0, 10, 1
9D0020EC  AC620028   SW V0, 40(V1)
9D0020F0  0B400864   J 0x9D002190
9D0020F4  00000000   NOP
1699:                    }
1700:                    else if(!MyTCBStub.Flags.bTimer2Enabled)
9D0020F8  93828014   LBU V0, -32748(GP)
9D0020FC  3C04A000   LUI A0, -24576
9D002100  00021100   SLL V0, V0, 4
9D002104  00021880   SLL V1, V0, 2
9D002108  00621823   SUBU V1, V1, V0
9D00210C  2482753C   ADDIU V0, A0, 30012
9D002110  00621021   ADDU V0, V1, V0
9D002114  8C420028   LW V0, 40(V0)
9D002118  7C420140   EXT V0, V0, 5, 1
9D00211C  304200FF   ANDI V0, V0, 255
9D002120  1440001B   BNE V0, ZERO, 0x9D002190
9D002124  00000000   NOP
1701:                    // If not already enabled, start a timer so a window
1702:                    // update will get sent to the remote node at some point
1703:                    {
1704:                        MyTCBStub.Flags.bTimer2Enabled = true;
9D002128  93828014   LBU V0, -32748(GP)
9D00212C  3C04A000   LUI A0, -24576
9D002130  00021100   SLL V0, V0, 4
9D002134  00021880   SLL V1, V0, 2
9D002138  00621823   SUBU V1, V1, V0
9D00213C  2482753C   ADDIU V0, A0, 30012
9D002140  00621821   ADDU V1, V1, V0
9D002144  8C620028   LW V0, 40(V1)
9D002148  24040001   ADDIU A0, ZERO, 1
9D00214C  7C822944   INS V0, A0, 5, 1
9D002150  AC620028   SW V0, 40(V1)
1705:                        MyTCBStub.eventTime2 = (uint16_t)TickGetDiv256() + TCP_WINDOW_UPDATE_TIMEOUT_VAL/256ull;
9D002154  93828014   LBU V0, -32748(GP)
9D002158  00408021   ADDU S0, V0, ZERO
9D00215C  0F405C62   JAL TickGetDiv256
9D002160  00000000   NOP
9D002164  3042FFFF   ANDI V0, V0, -1
9D002168  244200F4   ADDIU V0, V0, 244
9D00216C  3044FFFF   ANDI A0, V0, -1
9D002170  3C05A000   LUI A1, -24576
9D002174  02001021   ADDU V0, S0, ZERO
9D002178  00021100   SLL V0, V0, 4
9D00217C  00021880   SLL V1, V0, 2
9D002180  00621823   SUBU V1, V1, V0
9D002184  24A2753C   ADDIU V0, A1, 30012
9D002188  00621021   ADDU V0, V1, V0
9D00218C  A4440020   SH A0, 32(V0)
1706:                    }
1707:                
1708:                    return len;
9D002190  97C20038   LHU V0, 56(S8)
1709:                }
9D002194  03C0E821   ADDU SP, S8, ZERO
9D002198  8FBF002C   LW RA, 44(SP)
9D00219C  8FBE0028   LW S8, 40(SP)
9D0021A0  8FB00024   LW S0, 36(SP)
9D0021A4  27BD0030   ADDIU SP, SP, 48
9D0021A8  03E00008   JR RA
9D0021AC  00000000   NOP
1710:                
1711:                
1712:                /*****************************************************************************
1713:                  Function:
1714:                    uint16_t TCPGetRxFIFOFree(TCP_SOCKET hTCP)
1715:                
1716:                  Description:
1717:                    Determines how many bytes are free in the RX FIFO.
1718:                
1719:                  Precondition:
1720:                    TCP is initialized.
1721:                
1722:                  Parameters:
1723:                    hTCP - The socket to check.
1724:                
1725:                  Returns:
1726:                    The number of bytes free in the TCP RX FIFO.  If zero, no additional
1727:                    data can be received until the application removes some data using one
1728:                    of the TCPGet family functions.
1729:                  ***************************************************************************/
1730:                uint16_t TCPGetRxFIFOFree(TCP_SOCKET hTCP)
1731:                {
9D0021B0  27BDFFE0   ADDIU SP, SP, -32
9D0021B4  AFBF001C   SW RA, 28(SP)
9D0021B8  AFBE0018   SW S8, 24(SP)
9D0021BC  03A0F021   ADDU S8, SP, ZERO
9D0021C0  00801021   ADDU V0, A0, ZERO
9D0021C4  A3C20020   SB V0, 32(S8)
1732:                    uint16_t wDataLen;
1733:                    uint16_t wFIFOSize;
1734:                
1735:                    if(hTCP >= TCP_SOCKET_COUNT)
9D0021C8  93C20020   LBU V0, 32(S8)
9D0021CC  2C420002   SLTIU V0, V0, 2
9D0021D0  14400004   BNE V0, ZERO, 0x9D0021E4
9D0021D4  00000000   NOP
1736:                    {
1737:                        return 0;
9D0021D8  00001021   ADDU V0, ZERO, ZERO
9D0021DC  0B400898   J 0x9D002260
9D0021E0  00000000   NOP
1738:                    }
1739:                
1740:                    SyncTCBStub(hTCP);
9D0021E4  93C20020   LBU V0, 32(S8)
9D0021E8  A3828014   SB V0, -32748(GP)
1741:                
1742:                    // Calculate total usable FIFO size
1743:                    wFIFOSize = MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart;
9D0021EC  93828014   LBU V0, -32748(GP)
9D0021F0  3C04A000   LUI A0, -24576
9D0021F4  00021100   SLL V0, V0, 4
9D0021F8  00021880   SLL V1, V0, 2
9D0021FC  00621823   SUBU V1, V1, V0
9D002200  2482753C   ADDIU V0, A0, 30012
9D002204  00621021   ADDU V0, V1, V0
9D002208  8C420008   LW V0, 8(V0)
9D00220C  3043FFFF   ANDI V1, V0, -1
9D002210  93828014   LBU V0, -32748(GP)
9D002214  3C04A000   LUI A0, -24576
9D002218  2484753C   ADDIU A0, A0, 30012
9D00221C  00021100   SLL V0, V0, 4
9D002220  00022880   SLL A1, V0, 2
9D002224  00A21023   SUBU V0, A1, V0
9D002228  00821021   ADDU V0, A0, V0
9D00222C  8C420004   LW V0, 4(V0)
9D002230  3042FFFF   ANDI V0, V0, -1
9D002234  00621023   SUBU V0, V1, V0
9D002238  A7C20010   SH V0, 16(S8)
1744:                
1745:                    #if defined(STACK_USE_SSL)
1746:                    {
1747:                        PTR_BASE SSLtemp = MyTCBStub.rxHead;
1748:                
1749:                        // Move SSL pointer to determine full buffer size
1750:                        if(MyTCBStub.sslStubID != SSL_INVALID_ID)
1751:                            MyTCBStub.rxHead = MyTCBStub.sslRxHead;
1752:                
1753:                        // Find out how many data bytes are actually in the RX FIFO
1754:                        wDataLen = TCPIsGetReady(hTCP);
1755:                
1756:                        // Move SSL pointer back to proper location (if we changed it)
1757:                        MyTCBStub.rxHead = SSLtemp;
1758:                    }
1759:                    #else
1760:                    {
1761:                        // Find out how many data bytes are actually in the RX FIFO
1762:                        wDataLen = TCPIsGetReady(hTCP);
9D00223C  93C20020   LBU V0, 32(S8)
9D002240  00402021   ADDU A0, V0, ZERO
9D002244  0F40066C   JAL TCPIsGetReady
9D002248  00000000   NOP
9D00224C  A7C20012   SH V0, 18(S8)
1763:                    }
1764:                    #endif
1765:                
1766:                    // Perform the calculation
1767:                    return wFIFOSize - wDataLen;
9D002250  97C30010   LHU V1, 16(S8)
9D002254  97C20012   LHU V0, 18(S8)
9D002258  00621023   SUBU V0, V1, V0
9D00225C  3042FFFF   ANDI V0, V0, -1
1768:                }
9D002260  03C0E821   ADDU SP, S8, ZERO
9D002264  8FBF001C   LW RA, 28(SP)
9D002268  8FBE0018   LW S8, 24(SP)
9D00226C  27BD0020   ADDIU SP, SP, 32
9D002270  03E00008   JR RA
9D002274  00000000   NOP
1769:                
1770:                /*****************************************************************************
1771:                  Function:
1772:                    uint16_t TCPPeekArray(TCP_SOCKET hTCP, uint8_t *vBuffer, uint16_t wLen, uint16_t wStart)
1773:                
1774:                  Summary:
1775:                    Reads a specified number of data bytes from the TCP RX FIFO without
1776:                    removing them from the buffer.
1777:                
1778:                  Description:
1779:                    Reads a specified number of data bytes from the TCP RX FIFO without
1780:                    removing them from the buffer.  No TCP control actions are taken as a
1781:                    result of this function (ex: no window update is sent to the remote node).
1782:                
1783:                  Precondition:
1784:                    TCP is initialized.
1785:                
1786:                  Parameters:
1787:                    hTCP - The socket to peak from (read without removing from stream).
1788:                    vBuffer - Destination to write the peeked data bytes.
1789:                    wLen - Length of bytes to peak from the RX FIFO and copy to vBuffer.
1790:                    wStart - Zero-indexed starting position within the FIFO to start peeking
1791:                        from.
1792:                
1793:                  Return Values:
1794:                    Number of bytes actually peeked from the stream and copied to vBuffer.
1795:                    This value can be less than wLen if wStart + wLen is greater than the
1796:                    deepest possible character in the RX FIFO.
1797:                
1798:                  Remarks:
1799:                    None
1800:                  ***************************************************************************/
1801:                uint16_t TCPPeekArray(TCP_SOCKET hTCP, uint8_t *vBuffer, uint16_t wLen, uint16_t wStart)
1802:                {
9D002278  27BDFFD8   ADDIU SP, SP, -40
9D00227C  AFBF0024   SW RA, 36(SP)
9D002280  AFBE0020   SW S8, 32(SP)
9D002284  03A0F021   ADDU S8, SP, ZERO
9D002288  AFC5002C   SW A1, 44(S8)
9D00228C  00C01821   ADDU V1, A2, ZERO
9D002290  00E01021   ADDU V0, A3, ZERO
9D002294  A3C40028   SB A0, 40(S8)
9D002298  A7C30030   SH V1, 48(S8)
9D00229C  A7C20034   SH V0, 52(S8)
1803:                    PTR_BASE ptrRead;
1804:                    uint16_t w;
1805:                    uint16_t wBytesUntilWrap;
1806:                
1807:                    if(hTCP >= TCP_SOCKET_COUNT || wLen == 0)
9D0022A0  93C20028   LBU V0, 40(S8)
9D0022A4  2C420002   SLTIU V0, V0, 2
9D0022A8  10400004   BEQ V0, ZERO, 0x9D0022BC
9D0022AC  00000000   NOP
9D0022B0  97C20030   LHU V0, 48(S8)
9D0022B4  14400004   BNE V0, ZERO, 0x9D0022C8
9D0022B8  00000000   NOP
1808:                    {
1809:                        return 0;
9D0022BC  00001021   ADDU V0, ZERO, ZERO
9D0022C0  0B400943   J 0x9D00250C
9D0022C4  00000000   NOP
1810:                    }
1811:                
1812:                    SyncTCBStub(hTCP);
9D0022C8  93C20028   LBU V0, 40(S8)
9D0022CC  A3828014   SB V0, -32748(GP)
1813:                
1814:                    // Find out how many bytes are in the RX FIFO and decrease read length
1815:                    // if the start offset + read length is beyond the end of the FIFO
1816:                    w = TCPIsGetReady(hTCP);
9D0022D0  93C20028   LBU V0, 40(S8)
9D0022D4  00402021   ADDU A0, V0, ZERO
9D0022D8  0F40066C   JAL TCPIsGetReady
9D0022DC  00000000   NOP
9D0022E0  A7C2001C   SH V0, 28(S8)
1817:                    if(wStart + wLen > w)
9D0022E4  97C30034   LHU V1, 52(S8)
9D0022E8  97C20030   LHU V0, 48(S8)
9D0022EC  00621821   ADDU V1, V1, V0
9D0022F0  97C2001C   LHU V0, 28(S8)
9D0022F4  0043102A   SLT V0, V0, V1
9D0022F8  10400005   BEQ V0, ZERO, 0x9D002310
9D0022FC  00000000   NOP
1818:                        wLen = w - wStart;
9D002300  97C3001C   LHU V1, 28(S8)
9D002304  97C20034   LHU V0, 52(S8)
9D002308  00621023   SUBU V0, V1, V0
9D00230C  A7C20030   SH V0, 48(S8)
1819:                
1820:                    // Find the read start location
1821:                    ptrRead = MyTCBStub.rxTail + wStart;
9D002310  93828014   LBU V0, -32748(GP)
9D002314  3C04A000   LUI A0, -24576
9D002318  00021100   SLL V0, V0, 4
9D00231C  00021880   SLL V1, V0, 2
9D002320  00621823   SUBU V1, V1, V0
9D002324  2482753C   ADDIU V0, A0, 30012
9D002328  00621021   ADDU V0, V1, V0
9D00232C  8C430018   LW V1, 24(V0)
9D002330  97C20034   LHU V0, 52(S8)
9D002334  00621021   ADDU V0, V1, V0
9D002338  AFC20018   SW V0, 24(S8)
1822:                    if(ptrRead > MyTCBStub.bufferEnd)
9D00233C  93828014   LBU V0, -32748(GP)
9D002340  3C04A000   LUI A0, -24576
9D002344  00021100   SLL V0, V0, 4
9D002348  00021880   SLL V1, V0, 2
9D00234C  00621823   SUBU V1, V1, V0
9D002350  2482753C   ADDIU V0, A0, 30012
9D002354  00621021   ADDU V0, V1, V0
9D002358  8C430008   LW V1, 8(V0)
9D00235C  8FC20018   LW V0, 24(S8)
9D002360  0062102B   SLTU V0, V1, V0
9D002364  10400016   BEQ V0, ZERO, 0x9D0023C0
9D002368  00000000   NOP
1823:                        ptrRead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D00236C  93828014   LBU V0, -32748(GP)
9D002370  3C04A000   LUI A0, -24576
9D002374  00021100   SLL V0, V0, 4
9D002378  00021880   SLL V1, V0, 2
9D00237C  00621823   SUBU V1, V1, V0
9D002380  2482753C   ADDIU V0, A0, 30012
9D002384  00621021   ADDU V0, V1, V0
9D002388  8C430008   LW V1, 8(V0)
9D00238C  93828014   LBU V0, -32748(GP)
9D002390  3C04A000   LUI A0, -24576
9D002394  2484753C   ADDIU A0, A0, 30012
9D002398  00021100   SLL V0, V0, 4
9D00239C  00022880   SLL A1, V0, 2
9D0023A0  00A21023   SUBU V0, A1, V0
9D0023A4  00821021   ADDU V0, A0, V0
9D0023A8  8C420004   LW V0, 4(V0)
9D0023AC  00621023   SUBU V0, V1, V0
9D0023B0  00021027   NOR V0, ZERO, V0
9D0023B4  8FC30018   LW V1, 24(S8)
9D0023B8  00621021   ADDU V0, V1, V0
9D0023BC  AFC20018   SW V0, 24(S8)
1824:                
1825:                    // Calculate how many bytes can be read in a single go
1826:                    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrRead + 1;
9D0023C0  93828014   LBU V0, -32748(GP)
9D0023C4  3C04A000   LUI A0, -24576
9D0023C8  00021100   SLL V0, V0, 4
9D0023CC  00021880   SLL V1, V0, 2
9D0023D0  00621823   SUBU V1, V1, V0
9D0023D4  2482753C   ADDIU V0, A0, 30012
9D0023D8  00621021   ADDU V0, V1, V0
9D0023DC  8C420008   LW V0, 8(V0)
9D0023E0  3043FFFF   ANDI V1, V0, -1
9D0023E4  8FC20018   LW V0, 24(S8)
9D0023E8  3042FFFF   ANDI V0, V0, -1
9D0023EC  00621023   SUBU V0, V1, V0
9D0023F0  3042FFFF   ANDI V0, V0, -1
9D0023F4  24420001   ADDIU V0, V0, 1
9D0023F8  A7C2001E   SH V0, 30(S8)
1827:                    if(wLen <= wBytesUntilWrap)
9D0023FC  97C30030   LHU V1, 48(S8)
9D002400  97C2001E   LHU V0, 30(S8)
9D002404  0043102B   SLTU V0, V0, V1
9D002408  14400013   BNE V0, ZERO, 0x9D002458
9D00240C  00000000   NOP
1828:                    {
1829:                        // Read all at once
1830:                        TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wLen);
9D002410  8FC4002C   LW A0, 44(S8)
9D002414  93828014   LBU V0, -32748(GP)
9D002418  3C05A000   LUI A1, -24576
9D00241C  00021100   SLL V0, V0, 4
9D002420  00021880   SLL V1, V0, 2
9D002424  00621823   SUBU V1, V1, V0
9D002428  24A2753C   ADDIU V0, A1, 30012
9D00242C  00621021   ADDU V0, V1, V0
9D002430  9042002C   LBU V0, 44(V0)
9D002434  97C30030   LHU V1, 48(S8)
9D002438  AFA30010   SW V1, 16(SP)
9D00243C  24050001   ADDIU A1, ZERO, 1
9D002440  8FC60018   LW A2, 24(S8)
9D002444  00403821   ADDU A3, V0, ZERO
9D002448  0F4020A8   JAL 0x9D0082A0
9D00244C  00000000   NOP
9D002450  0B400942   J 0x9D002508
9D002454  00000000   NOP
1831:                    }
1832:                    else
1833:                    {
1834:                        // Read all bytes up to the wrap position and then read remaining bytes
1835:                        // at the start of the buffer
1836:                        TCPRAMCopy((PTR_BASE)vBuffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, wBytesUntilWrap);
9D002458  8FC4002C   LW A0, 44(S8)
9D00245C  93828014   LBU V0, -32748(GP)
9D002460  3C05A000   LUI A1, -24576
9D002464  00021100   SLL V0, V0, 4
9D002468  00021880   SLL V1, V0, 2
9D00246C  00621823   SUBU V1, V1, V0
9D002470  24A2753C   ADDIU V0, A1, 30012
9D002474  00621021   ADDU V0, V1, V0
9D002478  9042002C   LBU V0, 44(V0)
9D00247C  97C3001E   LHU V1, 30(S8)
9D002480  AFA30010   SW V1, 16(SP)
9D002484  24050001   ADDIU A1, ZERO, 1
9D002488  8FC60018   LW A2, 24(S8)
9D00248C  00403821   ADDU A3, V0, ZERO
9D002490  0F4020A8   JAL 0x9D0082A0
9D002494  00000000   NOP
1837:                        TCPRAMCopy((PTR_BASE)vBuffer+wBytesUntilWrap, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wLen - wBytesUntilWrap);
9D002498  97C3001E   LHU V1, 30(S8)
9D00249C  8FC2002C   LW V0, 44(S8)
9D0024A0  00622021   ADDU A0, V1, V0
9D0024A4  93828014   LBU V0, -32748(GP)
9D0024A8  3C03A000   LUI V1, -24576
9D0024AC  2463753C   ADDIU V1, V1, 30012
9D0024B0  00021100   SLL V0, V0, 4
9D0024B4  00022880   SLL A1, V0, 2
9D0024B8  00A21023   SUBU V0, A1, V0
9D0024BC  00621021   ADDU V0, V1, V0
9D0024C0  8C460004   LW A2, 4(V0)
9D0024C4  93828014   LBU V0, -32748(GP)
9D0024C8  3C05A000   LUI A1, -24576
9D0024CC  00021100   SLL V0, V0, 4
9D0024D0  00021880   SLL V1, V0, 2
9D0024D4  00621823   SUBU V1, V1, V0
9D0024D8  24A2753C   ADDIU V0, A1, 30012
9D0024DC  00621021   ADDU V0, V1, V0
9D0024E0  9042002C   LBU V0, 44(V0)
9D0024E4  97C50030   LHU A1, 48(S8)
9D0024E8  97C3001E   LHU V1, 30(S8)
9D0024EC  00A31823   SUBU V1, A1, V1
9D0024F0  3063FFFF   ANDI V1, V1, -1
9D0024F4  AFA30010   SW V1, 16(SP)
9D0024F8  24050001   ADDIU A1, ZERO, 1
9D0024FC  00403821   ADDU A3, V0, ZERO
9D002500  0F4020A8   JAL 0x9D0082A0
9D002504  00000000   NOP
1838:                    }
1839:                
1840:                    return wLen;
9D002508  97C20030   LHU V0, 48(S8)
1841:                }
9D00250C  03C0E821   ADDU SP, S8, ZERO
9D002510  8FBF0024   LW RA, 36(SP)
9D002514  8FBE0020   LW S8, 32(SP)
9D002518  27BD0028   ADDIU SP, SP, 40
9D00251C  03E00008   JR RA
9D002520  00000000   NOP
1842:                
1843:                /*****************************************************************************
1844:                  Function:
1845:                    uint8_t TCPPeek(TCP_SOCKET hTCP, uint16_t wStart)
1846:                
1847:                  Summary:
1848:                    Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
1849:                
1850:                  Description:
1851:                    Peaks at one byte in the TCP RX FIFO without removing it from the buffer.
1852:                
1853:                  Precondition:
1854:                    TCP is initialized.
1855:                
1856:                  Parameters:
1857:                    hTCP - The socket to peak from (read without removing from stream).
1858:                    wStart - Zero-indexed starting position within the FIFO to peek from.
1859:                
1860:                  Return Values:
1861:                    Byte peeked from the RX FIFO.  If there is no data in the buffer or an
1862:                    illegal wStart starting offset is given, then an indeterminate value is
1863:                    returned.  The caller must ensure that valid parameters are passed to avoid
1864:                    (i.e ensure that TCPIsGetReady() returns a number that is less than wStart
1865:                    before calling TCPPeek()).
1866:                
1867:                  Remarks:
1868:                    Use the TCPPeekArray() function to read more than one byte.  It will
1869:                    perform better than calling TCPPeek() in a loop.
1870:                  ***************************************************************************/
1871:                uint8_t TCPPeek(TCP_SOCKET hTCP, uint16_t wStart)
1872:                {
9D002524  27BDFFE0   ADDIU SP, SP, -32
9D002528  AFBF001C   SW RA, 28(SP)
9D00252C  AFBE0018   SW S8, 24(SP)
9D002530  03A0F021   ADDU S8, SP, ZERO
9D002534  00801821   ADDU V1, A0, ZERO
9D002538  00A01021   ADDU V0, A1, ZERO
9D00253C  A3C30020   SB V1, 32(S8)
9D002540  A7C20024   SH V0, 36(S8)
1873:                    uint8_t i;
1874:                
1875:                    TCPPeekArray(hTCP, &i, 1, wStart);
9D002544  93C30020   LBU V1, 32(S8)
9D002548  97C20024   LHU V0, 36(S8)
9D00254C  00602021   ADDU A0, V1, ZERO
9D002550  27C30010   ADDIU V1, S8, 16
9D002554  00602821   ADDU A1, V1, ZERO
9D002558  24060001   ADDIU A2, ZERO, 1
9D00255C  00403821   ADDU A3, V0, ZERO
9D002560  0F40089E   JAL TCPPeekArray
9D002564  00000000   NOP
1876:                    return i;
9D002568  93C20010   LBU V0, 16(S8)
1877:                }
9D00256C  03C0E821   ADDU SP, S8, ZERO
9D002570  8FBF001C   LW RA, 28(SP)
9D002574  8FBE0018   LW S8, 24(SP)
9D002578  27BD0020   ADDIU SP, SP, 32
9D00257C  03E00008   JR RA
9D002580  00000000   NOP
1878:                
1879:                
1880:                /****************************************************************************
1881:                  Section:
1882:                    Search Functions
1883:                  ***************************************************************************/
1884:                
1885:                /*****************************************************************************
1886:                  Function:
1887:                    uint16_t TCPFindArrayEx(TCP_SOCKET hTCP, uint8_t* cFindArray, uint16_t wLen,
1888:                                        uint16_t wStart, uint16_t wSearchLen, bool bTextCompare)
1889:                
1890:                  Summary:
1891:                    Searches for a string in the TCP RX buffer.
1892:                
1893:                  Description:
1894:                    This function finds the first occurrance of an array of bytes in the
1895:                    TCP RX buffer.  It can be used by an application to abstract searches
1896:                    out of their own application code.  For increased efficiency, the
1897:                    function is capable of limiting the scope of search to a specific
1898:                    range of bytes.  It can also perform a case-insensitive search if
1899:                    required.
1900:                
1901:                    For example, if the buffer contains "I love PIC MCUs!" and the search
1902:                    array is "love" with a length of 4, a value of 2 will be returned.
1903:                
1904:                  Precondition:
1905:                    TCP is initialized.
1906:                
1907:                  Parameters:
1908:                    hTCP - The socket to search within.
1909:                    cFindArray - The array of bytes to find in the buffer.
1910:                    wLen - Length of cFindArray.
1911:                    wStart - Zero-indexed starting position within the buffer.
1912:                    wSearchLen - Length from wStart to search in the buffer.
1913:                    bTextCompare - true for case-insensitive text search, false for binary search
1914:                
1915:                  Return Values:
1916:                    0xFFFF - Search array not found
1917:                    Otherwise - Zero-indexed position of the first occurrance
1918:                
1919:                  Remarks:
1920:                    Since this function usually must transfer data from external storage
1921:                    to internal RAM for comparison, its performance degrades significantly
1922:                    when the buffer is full and the array is not found.  For better
1923:                    performance, try to search for characters that are expected to exist or
1924:                    limit the scope of the search as much as possible.  The HTTP2 module,
1925:                    for example, uses this function to parse headers.  However, it searches
1926:                    for newlines, then the separating colon, then reads the header name to
1927:                    RAM for final comparison.  This has proven to be significantly faster
1928:                    than searching for full header name strings outright.
1929:                  ***************************************************************************/
1930:                uint16_t TCPFindArrayEx(TCP_SOCKET hTCP, uint8_t* cFindArray, uint16_t wLen, uint16_t wStart, uint16_t wSearchLen, bool bTextCompare)
1931:                {
9D002584  27BDFFA0   ADDIU SP, SP, -96
9D002588  AFBF005C   SW RA, 92(SP)
9D00258C  AFBE0058   SW S8, 88(SP)
9D002590  03A0F021   ADDU S8, SP, ZERO
9D002594  00804021   ADDU T0, A0, ZERO
9D002598  AFC50064   SW A1, 100(S8)
9D00259C  00C02821   ADDU A1, A2, ZERO
9D0025A0  00E02021   ADDU A0, A3, ZERO
9D0025A4  8FC30070   LW V1, 112(S8)
9D0025A8  8FC20074   LW V0, 116(S8)
9D0025AC  A3C80060   SB T0, 96(S8)
9D0025B0  A7C50068   SH A1, 104(S8)
9D0025B4  A7C4006C   SH A0, 108(S8)
9D0025B8  A7C30050   SH V1, 80(S8)
9D0025BC  A3C20054   SB V0, 84(S8)
1932:                    PTR_BASE ptrRead;
1933:                    uint16_t wDataLen;
1934:                    uint16_t wBytesUntilWrap;
1935:                    PTR_BASE ptrLocation;
1936:                    uint16_t wLenStart;
1937:                    uint8_t *cFindArrayStart;
1938:                    uint8_t i, j, k;
1939:                    bool isFinding;
1940:                    uint8_t buffer[32];
1941:                
1942:                        if (hTCP >= TCP_SOCKET_COUNT)
9D0025C0  93C20060   LBU V0, 96(S8)
9D0025C4  2C420002   SLTIU V0, V0, 2
9D0025C8  14400004   BNE V0, ZERO, 0x9D0025DC
9D0025CC  00000000   NOP
1943:                        {
1944:                            return 0xFFFF;
9D0025D0  3402FFFF   ORI V0, ZERO, -1
9D0025D4  0B400AEA   J 0x9D002BA8
9D0025D8  00000000   NOP
1945:                        }
1946:                
1947:                    if(wLen == 0)
9D0025DC  97C20068   LHU V0, 104(S8)
9D0025E0  14400004   BNE V0, ZERO, 0x9D0025F4
9D0025E4  00000000   NOP
1948:                    {
1949:                        return 0;
9D0025E8  00001021   ADDU V0, ZERO, ZERO
9D0025EC  0B400AEA   J 0x9D002BA8
9D0025F0  00000000   NOP
1950:                    }
1951:                
1952:                    SyncTCBStub(hTCP);
9D0025F4  93C20060   LBU V0, 96(S8)
9D0025F8  A3828014   SB V0, -32748(GP)
1953:                
1954:                    // Find out how many bytes are in the RX FIFO and return
1955:                    // immediately if we won't possibly find a match
1956:                    wDataLen = TCPIsGetReady(hTCP) - wStart;
9D0025FC  93C20060   LBU V0, 96(S8)
9D002600  00402021   ADDU A0, V0, ZERO
9D002604  0F40066C   JAL TCPIsGetReady
9D002608  00000000   NOP
9D00260C  00401821   ADDU V1, V0, ZERO
9D002610  97C2006C   LHU V0, 108(S8)
9D002614  00621023   SUBU V0, V1, V0
9D002618  A7C2001C   SH V0, 28(S8)
1957:                    if(wDataLen < wLen)
9D00261C  97C3001C   LHU V1, 28(S8)
9D002620  97C20068   LHU V0, 104(S8)
9D002624  0062102B   SLTU V0, V1, V0
9D002628  10400004   BEQ V0, ZERO, 0x9D00263C
9D00262C  00000000   NOP
1958:                        return 0xFFFFu;
9D002630  3402FFFF   ORI V0, ZERO, -1
9D002634  0B400AEA   J 0x9D002BA8
9D002638  00000000   NOP
1959:                    if(wSearchLen && (wDataLen > wSearchLen))
9D00263C  97C20050   LHU V0, 80(S8)
9D002640  10400008   BEQ V0, ZERO, 0x9D002664
9D002644  00000000   NOP
9D002648  97C3001C   LHU V1, 28(S8)
9D00264C  97C20050   LHU V0, 80(S8)
9D002650  0043102B   SLTU V0, V0, V1
9D002654  10400003   BEQ V0, ZERO, 0x9D002664
9D002658  00000000   NOP
1960:                        wDataLen = wSearchLen;
9D00265C  97C20050   LHU V0, 80(S8)
9D002660  A7C2001C   SH V0, 28(S8)
1961:                
1962:                    ptrLocation = MyTCBStub.rxTail + wStart;
9D002664  93828014   LBU V0, -32748(GP)
9D002668  3C04A000   LUI A0, -24576
9D00266C  00021100   SLL V0, V0, 4
9D002670  00021880   SLL V1, V0, 2
9D002674  00621823   SUBU V1, V1, V0
9D002678  2482753C   ADDIU V0, A0, 30012
9D00267C  00621021   ADDU V0, V1, V0
9D002680  8C430018   LW V1, 24(V0)
9D002684  97C2006C   LHU V0, 108(S8)
9D002688  00621021   ADDU V0, V1, V0
9D00268C  AFC20020   SW V0, 32(S8)
1963:                    if(ptrLocation > MyTCBStub.bufferEnd)
9D002690  93828014   LBU V0, -32748(GP)
9D002694  3C04A000   LUI A0, -24576
9D002698  00021100   SLL V0, V0, 4
9D00269C  00021880   SLL V1, V0, 2
9D0026A0  00621823   SUBU V1, V1, V0
9D0026A4  2482753C   ADDIU V0, A0, 30012
9D0026A8  00621021   ADDU V0, V1, V0
9D0026AC  8C430008   LW V1, 8(V0)
9D0026B0  8FC20020   LW V0, 32(S8)
9D0026B4  0062102B   SLTU V0, V1, V0
9D0026B8  10400016   BEQ V0, ZERO, 0x9D002714
9D0026BC  00000000   NOP
1964:                        ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D0026C0  93828014   LBU V0, -32748(GP)
9D0026C4  3C04A000   LUI A0, -24576
9D0026C8  00021100   SLL V0, V0, 4
9D0026CC  00021880   SLL V1, V0, 2
9D0026D0  00621823   SUBU V1, V1, V0
9D0026D4  2482753C   ADDIU V0, A0, 30012
9D0026D8  00621021   ADDU V0, V1, V0
9D0026DC  8C430008   LW V1, 8(V0)
9D0026E0  93828014   LBU V0, -32748(GP)
9D0026E4  3C04A000   LUI A0, -24576
9D0026E8  2484753C   ADDIU A0, A0, 30012
9D0026EC  00021100   SLL V0, V0, 4
9D0026F0  00022880   SLL A1, V0, 2
9D0026F4  00A21023   SUBU V0, A1, V0
9D0026F8  00821021   ADDU V0, A0, V0
9D0026FC  8C420004   LW V0, 4(V0)
9D002700  00621023   SUBU V0, V1, V0
9D002704  00021027   NOR V0, ZERO, V0
9D002708  8FC30020   LW V1, 32(S8)
9D00270C  00621021   ADDU V0, V1, V0
9D002710  AFC20020   SW V0, 32(S8)
1965:                    ptrRead = ptrLocation;
9D002714  8FC20020   LW V0, 32(S8)
9D002718  AFC20018   SW V0, 24(S8)
1966:                    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
9D00271C  93828014   LBU V0, -32748(GP)
9D002720  3C04A000   LUI A0, -24576
9D002724  00021100   SLL V0, V0, 4
9D002728  00021880   SLL V1, V0, 2
9D00272C  00621823   SUBU V1, V1, V0
9D002730  2482753C   ADDIU V0, A0, 30012
9D002734  00621021   ADDU V0, V1, V0
9D002738  8C420008   LW V0, 8(V0)
9D00273C  3043FFFF   ANDI V1, V0, -1
9D002740  8FC20020   LW V0, 32(S8)
9D002744  3042FFFF   ANDI V0, V0, -1
9D002748  00621023   SUBU V0, V1, V0
9D00274C  3042FFFF   ANDI V0, V0, -1
9D002750  24420001   ADDIU V0, V0, 1
9D002754  A7C2001E   SH V0, 30(S8)
1967:                    ptrLocation = wStart;
9D002758  97C2006C   LHU V0, 108(S8)
9D00275C  AFC20020   SW V0, 32(S8)
1968:                    wLenStart = wLen;
9D002760  97C20068   LHU V0, 104(S8)
9D002764  A7C20028   SH V0, 40(S8)
1969:                    cFindArrayStart = cFindArray;
9D002768  8FC20064   LW V0, 100(S8)
9D00276C  AFC2002C   SW V0, 44(S8)
1970:                    j = *cFindArray++;
9D002770  8FC20064   LW V0, 100(S8)
9D002774  90420000   LBU V0, 0(V0)
9D002778  A3C20025   SB V0, 37(S8)
9D00277C  8FC20064   LW V0, 100(S8)
9D002780  24420001   ADDIU V0, V0, 1
9D002784  AFC20064   SW V0, 100(S8)
1971:                    isFinding = false;
9D002788  A3C00027   SB ZERO, 39(S8)
1972:                    if(bTextCompare)
9D00278C  93C20054   LBU V0, 84(S8)
9D002790  1040000C   BEQ V0, ZERO, 0x9D0027C4
9D002794  00000000   NOP
1973:                    {
1974:                        if(j >= 'a' && j <= 'z')
9D002798  93C20025   LBU V0, 37(S8)
9D00279C  2C420061   SLTIU V0, V0, 97
9D0027A0  14400008   BNE V0, ZERO, 0x9D0027C4
9D0027A4  00000000   NOP
9D0027A8  93C20025   LBU V0, 37(S8)
9D0027AC  2C42007B   SLTIU V0, V0, 123
9D0027B0  10400004   BEQ V0, ZERO, 0x9D0027C4
9D0027B4  00000000   NOP
1975:                            j += 'A'-'a';
9D0027B8  93C20025   LBU V0, 37(S8)
9D0027BC  2442FFE0   ADDIU V0, V0, -32
9D0027C0  A3C20025   SB V0, 37(S8)
1976:                    }
1977:                
1978:                    // Search for the array
1979:                    while(1)
1980:                    {
1981:                        // Figure out how big of a chunk to read
1982:                        k = sizeof(buffer);
9D0027C4  24020020   ADDIU V0, ZERO, 32
9D0027C8  A3C20026   SB V0, 38(S8)
1983:                        if(k > wBytesUntilWrap)
9D0027CC  93C20026   LBU V0, 38(S8)
9D0027D0  3042FFFF   ANDI V0, V0, -1
9D0027D4  97C3001E   LHU V1, 30(S8)
9D0027D8  0062102B   SLTU V0, V1, V0
9D0027DC  10400003   BEQ V0, ZERO, 0x9D0027EC
9D0027E0  00000000   NOP
1984:                            k = wBytesUntilWrap;
9D0027E4  97C2001E   LHU V0, 30(S8)
9D0027E8  A3C20026   SB V0, 38(S8)
1985:                        if((uint16_t)k > wDataLen)
9D0027EC  93C20026   LBU V0, 38(S8)
9D0027F0  3042FFFF   ANDI V0, V0, -1
9D0027F4  97C3001C   LHU V1, 28(S8)
9D0027F8  0062102B   SLTU V0, V1, V0
9D0027FC  10400003   BEQ V0, ZERO, 0x9D00280C
9D002800  00000000   NOP
1986:                            k = wDataLen;
9D002804  97C2001C   LHU V0, 28(S8)
9D002808  A3C20026   SB V0, 38(S8)
1987:                
1988:                        // Read a chunk of data into the buffer
1989:                        TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (uint16_t)k);
9D00280C  27C40030   ADDIU A0, S8, 48
9D002810  93828014   LBU V0, -32748(GP)
9D002814  3C05A000   LUI A1, -24576
9D002818  00021100   SLL V0, V0, 4
9D00281C  00021880   SLL V1, V0, 2
9D002820  00621823   SUBU V1, V1, V0
9D002824  24A2753C   ADDIU V0, A1, 30012
9D002828  00621021   ADDU V0, V1, V0
9D00282C  9042002C   LBU V0, 44(V0)
9D002830  93C30026   LBU V1, 38(S8)
9D002834  AFA30010   SW V1, 16(SP)
9D002838  24050001   ADDIU A1, ZERO, 1
9D00283C  8FC60018   LW A2, 24(S8)
9D002840  00403821   ADDU A3, V0, ZERO
9D002844  0F4020A8   JAL 0x9D0082A0
9D002848  00000000   NOP
1990:                        ptrRead += k;
9D00284C  93C20026   LBU V0, 38(S8)
9D002850  8FC30018   LW V1, 24(S8)
9D002854  00621021   ADDU V0, V1, V0
9D002858  AFC20018   SW V0, 24(S8)
1991:                        wBytesUntilWrap -= k;
9D00285C  93C20026   LBU V0, 38(S8)
9D002860  3042FFFF   ANDI V0, V0, -1
9D002864  97C3001E   LHU V1, 30(S8)
9D002868  00621023   SUBU V0, V1, V0
9D00286C  A7C2001E   SH V0, 30(S8)
1992:                
1993:                        if(wBytesUntilWrap == 0u)
9D002870  97C2001E   LHU V0, 30(S8)
9D002874  1440000C   BNE V0, ZERO, 0x9D0028A8
9D002878  00000000   NOP
1994:                        {
1995:                            ptrRead = MyTCBStub.bufferRxStart;
9D00287C  93828014   LBU V0, -32748(GP)
9D002880  3C03A000   LUI V1, -24576
9D002884  2463753C   ADDIU V1, V1, 30012
9D002888  00021100   SLL V0, V0, 4
9D00288C  00022080   SLL A0, V0, 2
9D002890  00821023   SUBU V0, A0, V0
9D002894  00621021   ADDU V0, V1, V0
9D002898  8C420004   LW V0, 4(V0)
9D00289C  AFC20018   SW V0, 24(S8)
1996:                            wBytesUntilWrap = 0xFFFFu;
9D0028A0  2402FFFF   ADDIU V0, ZERO, -1
9D0028A4  A7C2001E   SH V0, 30(S8)
1997:                        }
1998:                
1999:                        // Convert everything to uppercase
2000:                        if(bTextCompare)
9D0028A8  93C20054   LBU V0, 84(S8)
9D0028AC  1040006E   BEQ V0, ZERO, 0x9D002A68
9D0028B0  00000000   NOP
2001:                        {
2002:                            for(i = 0; i < k; i++)
9D0028B4  A3C00024   SB ZERO, 36(S8)
9D0028B8  0B400A93   J 0x9D002A4C
9D0028BC  00000000   NOP
9D002A40  93C20024   LBU V0, 36(S8)
9D002A44  24420001   ADDIU V0, V0, 1
9D002A48  A3C20024   SB V0, 36(S8)
9D002A4C  93C30024   LBU V1, 36(S8)
9D002A50  93C20026   LBU V0, 38(S8)
9D002A54  0062102B   SLTU V0, V1, V0
9D002A58  1440FF99   BNE V0, ZERO, 0x9D0028C0
9D002A5C  00000000   NOP
9D002A60  0B400AD7   J 0x9D002B5C
9D002A64  00000000   NOP
2003:                            {
2004:                                if(buffer[i] >= 'a' && buffer[i] <= 'z')
9D0028C0  93C20024   LBU V0, 36(S8)
9D0028C4  27C30018   ADDIU V1, S8, 24
9D0028C8  00621021   ADDU V0, V1, V0
9D0028CC  90420018   LBU V0, 24(V0)
9D0028D0  2C420061   SLTIU V0, V0, 97
9D0028D4  14400012   BNE V0, ZERO, 0x9D002920
9D0028D8  00000000   NOP
9D0028DC  93C20024   LBU V0, 36(S8)
9D0028E0  27C30018   ADDIU V1, S8, 24
9D0028E4  00621021   ADDU V0, V1, V0
9D0028E8  90420018   LBU V0, 24(V0)
9D0028EC  2C42007B   SLTIU V0, V0, 123
9D0028F0  1040000B   BEQ V0, ZERO, 0x9D002920
9D0028F4  00000000   NOP
2005:                                    buffer[i] += 'A'-'a';
9D0028F8  93C20024   LBU V0, 36(S8)
9D0028FC  93C30024   LBU V1, 36(S8)
9D002900  27C40018   ADDIU A0, S8, 24
9D002904  00831821   ADDU V1, A0, V1
9D002908  90630018   LBU V1, 24(V1)
9D00290C  2463FFE0   ADDIU V1, V1, -32
9D002910  306300FF   ANDI V1, V1, 255
9D002914  27C40018   ADDIU A0, S8, 24
9D002918  00821021   ADDU V0, A0, V0
9D00291C  A0430018   SB V1, 24(V0)
2006:                
2007:                                if(j == buffer[i])
9D002920  93C20024   LBU V0, 36(S8)
9D002924  27C30018   ADDIU V1, S8, 24
9D002928  00621021   ADDU V0, V1, V0
9D00292C  90420018   LBU V0, 24(V0)
9D002930  93C30025   LBU V1, 37(S8)
9D002934  14620029   BNE V1, V0, 0x9D0029DC
9D002938  00000000   NOP
2008:                                {
2009:                                    if(--wLen == 0u)
9D00293C  97C20068   LHU V0, 104(S8)
9D002940  2442FFFF   ADDIU V0, V0, -1
9D002944  A7C20068   SH V0, 104(S8)
9D002948  97C20068   LHU V0, 104(S8)
9D00294C  1440000E   BNE V0, ZERO, 0x9D002988
9D002950  00000000   NOP
2010:                                        return ptrLocation-wLenStart + i + 1;
9D002954  8FC20020   LW V0, 32(S8)
9D002958  3043FFFF   ANDI V1, V0, -1
9D00295C  97C20028   LHU V0, 40(S8)
9D002960  00621023   SUBU V0, V1, V0
9D002964  3043FFFF   ANDI V1, V0, -1
9D002968  93C20024   LBU V0, 36(S8)
9D00296C  3042FFFF   ANDI V0, V0, -1
9D002970  00621021   ADDU V0, V1, V0
9D002974  3042FFFF   ANDI V0, V0, -1
9D002978  24420001   ADDIU V0, V0, 1
9D00297C  3042FFFF   ANDI V0, V0, -1
9D002980  0B400AEA   J 0x9D002BA8
9D002984  00000000   NOP
2011:                                    j = *cFindArray++;
9D002988  8FC20064   LW V0, 100(S8)
9D00298C  90420000   LBU V0, 0(V0)
9D002990  A3C20025   SB V0, 37(S8)
9D002994  8FC20064   LW V0, 100(S8)
9D002998  24420001   ADDIU V0, V0, 1
9D00299C  AFC20064   SW V0, 100(S8)
2012:                                    isFinding = true;
9D0029A0  24020001   ADDIU V0, ZERO, 1
9D0029A4  A3C20027   SB V0, 39(S8)
2013:                                    if(j >= 'a' && j <= 'z')
9D0029A8  93C20025   LBU V0, 37(S8)
9D0029AC  2C420061   SLTIU V0, V0, 97
9D0029B0  14400023   BNE V0, ZERO, 0x9D002A40
9D0029B4  00000000   NOP
9D0029B8  93C20025   LBU V0, 37(S8)
9D0029BC  2C42007B   SLTIU V0, V0, 123
9D0029C0  1040001F   BEQ V0, ZERO, 0x9D002A40
9D0029C4  00000000   NOP
2014:                                        j += 'A'-'a';
9D0029C8  93C20025   LBU V0, 37(S8)
9D0029CC  2442FFE0   ADDIU V0, V0, -32
9D0029D0  A3C20025   SB V0, 37(S8)
9D0029D4  0B400A90   J 0x9D002A40
9D0029D8  00000000   NOP
2015:                                }
2016:                                else
2017:                                {
2018:                                    wLen = wLenStart;
9D0029DC  97C20028   LHU V0, 40(S8)
9D0029E0  A7C20068   SH V0, 104(S8)
2019:                                    if(isFinding)
9D0029E4  93C20027   LBU V0, 39(S8)
9D0029E8  10400015   BEQ V0, ZERO, 0x9D002A40
9D0029EC  00000000   NOP
2020:                                    {
2021:                                        cFindArray = cFindArrayStart;
9D0029F0  8FC2002C   LW V0, 44(S8)
9D0029F4  AFC20064   SW V0, 100(S8)
2022:                                        j = *cFindArray++;
9D0029F8  8FC20064   LW V0, 100(S8)
9D0029FC  90420000   LBU V0, 0(V0)
9D002A00  A3C20025   SB V0, 37(S8)
9D002A04  8FC20064   LW V0, 100(S8)
9D002A08  24420001   ADDIU V0, V0, 1
9D002A0C  AFC20064   SW V0, 100(S8)
2023:                                        if(j >= 'a' && j <= 'z')
9D002A10  93C20025   LBU V0, 37(S8)
9D002A14  2C420061   SLTIU V0, V0, 97
9D002A18  14400008   BNE V0, ZERO, 0x9D002A3C
9D002A1C  00000000   NOP
9D002A20  93C20025   LBU V0, 37(S8)
9D002A24  2C42007B   SLTIU V0, V0, 123
9D002A28  10400004   BEQ V0, ZERO, 0x9D002A3C
9D002A2C  00000000   NOP
2024:                                            j += 'A'-'a';
9D002A30  93C20025   LBU V0, 37(S8)
9D002A34  2442FFE0   ADDIU V0, V0, -32
9D002A38  A3C20025   SB V0, 37(S8)
2025:                                        isFinding = false;
9D002A3C  A3C00027   SB ZERO, 39(S8)
2026:                                    }
2027:                                }
2028:                            }
2029:                        }
2030:                        else    // Compare as is
2031:                        {
2032:                            for(i = 0; i < k; i++)
9D002A68  A3C00024   SB ZERO, 36(S8)
9D002A6C  0B400AD2   J 0x9D002B48
9D002A70  00000000   NOP
9D002B3C  93C20024   LBU V0, 36(S8)
9D002B40  24420001   ADDIU V0, V0, 1
9D002B44  A3C20024   SB V0, 36(S8)
9D002B48  93C30024   LBU V1, 36(S8)
9D002B4C  93C20026   LBU V0, 38(S8)
9D002B50  0062102B   SLTU V0, V1, V0
9D002B54  1440FFC7   BNE V0, ZERO, 0x9D002A74
9D002B58  00000000   NOP
2033:                            {
2034:                                if(j == buffer[i])
9D002A74  93C20024   LBU V0, 36(S8)
9D002A78  27C30018   ADDIU V1, S8, 24
9D002A7C  00621021   ADDU V0, V1, V0
9D002A80  90420018   LBU V0, 24(V0)
9D002A84  93C30025   LBU V1, 37(S8)
9D002A88  1462001E   BNE V1, V0, 0x9D002B04
9D002A8C  00000000   NOP
2035:                                {
2036:                                    if(--wLen == 0u)
9D002A90  97C20068   LHU V0, 104(S8)
9D002A94  2442FFFF   ADDIU V0, V0, -1
9D002A98  A7C20068   SH V0, 104(S8)
9D002A9C  97C20068   LHU V0, 104(S8)
9D002AA0  1440000E   BNE V0, ZERO, 0x9D002ADC
9D002AA4  00000000   NOP
2037:                                        return ptrLocation-wLenStart + i + 1;
9D002AA8  8FC20020   LW V0, 32(S8)
9D002AAC  3043FFFF   ANDI V1, V0, -1
9D002AB0  97C20028   LHU V0, 40(S8)
9D002AB4  00621023   SUBU V0, V1, V0
9D002AB8  3043FFFF   ANDI V1, V0, -1
9D002ABC  93C20024   LBU V0, 36(S8)
9D002AC0  3042FFFF   ANDI V0, V0, -1
9D002AC4  00621021   ADDU V0, V1, V0
9D002AC8  3042FFFF   ANDI V0, V0, -1
9D002ACC  24420001   ADDIU V0, V0, 1
9D002AD0  3042FFFF   ANDI V0, V0, -1
9D002AD4  0B400AEA   J 0x9D002BA8
9D002AD8  00000000   NOP
2038:                                    j = *cFindArray++;
9D002ADC  8FC20064   LW V0, 100(S8)
9D002AE0  90420000   LBU V0, 0(V0)
9D002AE4  A3C20025   SB V0, 37(S8)
9D002AE8  8FC20064   LW V0, 100(S8)
9D002AEC  24420001   ADDIU V0, V0, 1
9D002AF0  AFC20064   SW V0, 100(S8)
2039:                                    isFinding = true;
9D002AF4  24020001   ADDIU V0, ZERO, 1
9D002AF8  A3C20027   SB V0, 39(S8)
9D002AFC  0B400ACF   J 0x9D002B3C
9D002B00  00000000   NOP
2040:                                }
2041:                                else
2042:                                {
2043:                                    wLen = wLenStart;
9D002B04  97C20028   LHU V0, 40(S8)
9D002B08  A7C20068   SH V0, 104(S8)
2044:                                    if(isFinding)
9D002B0C  93C20027   LBU V0, 39(S8)
9D002B10  1040000A   BEQ V0, ZERO, 0x9D002B3C
9D002B14  00000000   NOP
2045:                                    {
2046:                                        cFindArray = cFindArrayStart;
9D002B18  8FC2002C   LW V0, 44(S8)
9D002B1C  AFC20064   SW V0, 100(S8)
2047:                                        j = *cFindArray++;
9D002B20  8FC20064   LW V0, 100(S8)
9D002B24  90420000   LBU V0, 0(V0)
9D002B28  A3C20025   SB V0, 37(S8)
9D002B2C  8FC20064   LW V0, 100(S8)
9D002B30  24420001   ADDIU V0, V0, 1
9D002B34  AFC20064   SW V0, 100(S8)
2048:                                        isFinding = false;
9D002B38  A3C00027   SB ZERO, 39(S8)
2049:                                    }
2050:                                }
2051:                            }
2052:                        }
2053:                
2054:                        // Check to see if it is impossible to find a match
2055:                        wDataLen -= k;
9D002B5C  93C20026   LBU V0, 38(S8)
9D002B60  3042FFFF   ANDI V0, V0, -1
9D002B64  97C3001C   LHU V1, 28(S8)
9D002B68  00621023   SUBU V0, V1, V0
9D002B6C  A7C2001C   SH V0, 28(S8)
2056:                        if(wDataLen < wLen)
9D002B70  97C3001C   LHU V1, 28(S8)
9D002B74  97C20068   LHU V0, 104(S8)
9D002B78  0062102B   SLTU V0, V1, V0
9D002B7C  10400004   BEQ V0, ZERO, 0x9D002B90
9D002B80  00000000   NOP
2057:                            return 0xFFFFu;
9D002B84  3402FFFF   ORI V0, ZERO, -1
9D002B88  0B400AEA   J 0x9D002BA8
9D002B8C  00000000   NOP
2058:                
2059:                        ptrLocation += k;
9D002B90  93C20026   LBU V0, 38(S8)
9D002B94  8FC30020   LW V1, 32(S8)
9D002B98  00621021   ADDU V0, V1, V0
9D002B9C  AFC20020   SW V0, 32(S8)
2060:                    }
9D002BA0  0B4009F1   J 0x9D0027C4
9D002BA4  00000000   NOP
2061:                }
9D002BA8  03C0E821   ADDU SP, S8, ZERO
9D002BAC  8FBF005C   LW RA, 92(SP)
9D002BB0  8FBE0058   LW S8, 88(SP)
9D002BB4  27BD0060   ADDIU SP, SP, 96
9D002BB8  03E00008   JR RA
9D002BBC  00000000   NOP
2062:                
2063:                /*****************************************************************************
2064:                  Function:
2065:                    uint16_t TCPFindROMArrayEx(TCP_SOCKET hTCP, uint8_t* cFindArray, uint16_t wLen,
2066:                                        uint16_t wStart, uint16_t wSearchLen, bool bTextCompare)
2067:                
2068:                  Summary:
2069:                    Searches for a ROM string in the TCP RX buffer.
2070:                
2071:                  Description:
2072:                    This function finds the first occurrance of an array of bytes in the
2073:                    TCP RX buffer.  It can be used by an application to abstract searches
2074:                    out of their own application code.  For increased efficiency, the
2075:                    function is capable of limiting the scope of search to a specific
2076:                    range of bytes.  It can also perform a case-insensitive search if
2077:                    required.
2078:                
2079:                    For example, if the buffer contains "I love PIC MCUs!" and the search
2080:                    array is "love" with a length of 4, a value of 2 will be returned.
2081:                
2082:                  Precondition:
2083:                    TCP is initialized.
2084:                
2085:                  Parameters:
2086:                    hTCP - The socket to search within.
2087:                    cFindArray - The array of bytes to find in the buffer.
2088:                    wLen - Length of cFindArray.
2089:                    wStart - Zero-indexed starting position within the buffer.
2090:                    wSearchLen - Length from wStart to search in the buffer.
2091:                    bTextCompare - true for case-insensitive text search, false for binary search
2092:                
2093:                  Return Values:
2094:                    0xFFFF - Search array not found
2095:                    Otherwise - Zero-indexed position of the first occurrance
2096:                
2097:                  Remarks:
2098:                    Since this function usually must transfer data from external storage
2099:                    to internal RAM for comparison, its performance degrades significantly
2100:                    when the buffer is full and the array is not found.  For better
2101:                    performance, try to search for characters that are expected to exist or
2102:                    limit the scope of the search as much as possible.  The HTTP2 module,
2103:                    for example, uses this function to parse headers.  However, it searches
2104:                    for newlines, then the separating colon, then reads the header name to
2105:                    RAM for final comparison.  This has proven to be significantly faster
2106:                    than searching for full header name strings outright.
2107:                
2108:                    This function is aliased to TCPFindArrayEx on non-PIC18 platforms.
2109:                  ***************************************************************************/
2110:                #if defined(__XC8)
2111:                uint16_t TCPFindROMArrayEx(TCP_SOCKET hTCP, ROM uint8_t* cFindArray, uint16_t wLen, uint16_t wStart, uint16_t wSearchLen, bool bTextCompare)
2112:                {
2113:                    PTR_BASE ptrRead;
2114:                    uint16_t wDataLen;
2115:                    uint16_t wBytesUntilWrap;
2116:                    PTR_BASE ptrLocation;
2117:                    uint16_t wLenStart;
2118:                    ROM uint8_t *cFindArrayStart;
2119:                    uint8_t i, j, k;
2120:                    bool isFinding;
2121:                    uint8_t buffer[32];
2122:                
2123:                        if (hTCP >= TCP_SOCKET_COUNT)
2124:                        {
2125:                            return 0xFFFF;
2126:                        }
2127:                
2128:                    if(wLen == 0)
2129:                    {
2130:                        return 0;
2131:                    }
2132:                
2133:                    SyncTCBStub(hTCP);
2134:                
2135:                    // Find out how many bytes are in the RX FIFO and return
2136:                    // immediately if we won't possibly find a match
2137:                    wDataLen = TCPIsGetReady(hTCP) - wStart;
2138:                    if(wDataLen < wLen)
2139:                        return 0xFFFFu;
2140:                    if(wSearchLen && (wDataLen > wSearchLen))
2141:                        wDataLen = wSearchLen;
2142:                
2143:                    ptrLocation = MyTCBStub.rxTail + wStart;
2144:                    if(ptrLocation > MyTCBStub.bufferEnd)
2145:                        ptrLocation -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
2146:                    ptrRead = ptrLocation;
2147:                    wBytesUntilWrap = MyTCBStub.bufferEnd - ptrLocation + 1;
2148:                    ptrLocation = wStart;
2149:                    wLenStart = wLen;
2150:                    cFindArrayStart = cFindArray;
2151:                    j = *cFindArray++;
2152:                    isFinding = false;
2153:                    if(bTextCompare)
2154:                    {
2155:                        if(j >= 'a' && j <= 'z')
2156:                            j += 'A'-'a';
2157:                    }
2158:                
2159:                    // Search for the array
2160:                    while(1)
2161:                    {
2162:                        // Figure out how big of a chunk to read
2163:                        k = sizeof(buffer);
2164:                        if(k > wBytesUntilWrap)
2165:                            k = wBytesUntilWrap;
2166:                        if((uint16_t)k > wDataLen)
2167:                            k = wDataLen;
2168:                
2169:                        // Read a chunk of data into the buffer
2170:                        TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, ptrRead, MyTCBStub.vMemoryMedium, (uint16_t)k);
2171:                        ptrRead += k;
2172:                        wBytesUntilWrap -= k;
2173:                
2174:                        if(wBytesUntilWrap == 0u)
2175:                        {
2176:                            ptrRead = MyTCBStub.bufferRxStart;
2177:                            wBytesUntilWrap = 0xFFFFu;
2178:                        }
2179:                
2180:                        // Convert everything to uppercase
2181:                        if(bTextCompare)
2182:                        {
2183:                            for(i = 0; i < k; i++)
2184:                            {
2185:                                if(buffer[i] >= 'a' && buffer[i] <= 'z')
2186:                                    buffer[i] += 'A'-'a';
2187:                
2188:                                if(j == buffer[i])
2189:                                {
2190:                                    if(--wLen == 0u)
2191:                                        return ptrLocation-wLenStart + i + 1;
2192:                                    j = *cFindArray++;
2193:                                    isFinding = true;
2194:                                    if(j >= 'a' && j <= 'z')
2195:                                        j += 'A'-'a';
2196:                                }
2197:                                else
2198:                                {
2199:                                    wLen = wLenStart;
2200:                                    if(isFinding)
2201:                                    {
2202:                                        cFindArray = cFindArrayStart;
2203:                                        j = *cFindArray++;
2204:                                        if(j >= 'a' && j <= 'z')
2205:                                            j += 'A'-'a';
2206:                                        isFinding = false;
2207:                                    }
2208:                                }
2209:                            }
2210:                        }
2211:                        else    // Compare as is
2212:                        {
2213:                            for(i = 0; i < k; i++)
2214:                            {
2215:                                if(j == buffer[i])
2216:                                {
2217:                                    if(--wLen == 0u)
2218:                                        return ptrLocation-wLenStart + i + 1;
2219:                                    j = *cFindArray++;
2220:                                    isFinding = true;
2221:                                }
2222:                                else
2223:                                {
2224:                                    wLen = wLenStart;
2225:                                    if(isFinding)
2226:                                    {
2227:                                        cFindArray = cFindArrayStart;
2228:                                        j = *cFindArray++;
2229:                                        isFinding = false;
2230:                                    }
2231:                                }
2232:                            }
2233:                        }
2234:                
2235:                        // Check to see if it is impossible to find a match
2236:                        wDataLen -= k;
2237:                        if(wDataLen < wLen)
2238:                            return 0xFFFFu;
2239:                
2240:                        ptrLocation += k;
2241:                    }
2242:                }
2243:                #endif
2244:                
2245:                
2246:                /*****************************************************************************
2247:                  Function:
2248:                    uint16_t TCPFindEx(TCP_SOCKET hTCP, uint8_t cFind,
2249:                                        uint16_t wStart, uint16_t wSearchLen, bool bTextCompare)
2250:                
2251:                  Summary:
2252:                    Searches for a byte in the TCP RX buffer.
2253:                
2254:                  Description:
2255:                    This function finds the first occurrance of a byte in the TCP RX
2256:                    buffer.  It can be used by an application to abstract searches
2257:                    out of their own application code.  For increased efficiency, the
2258:                    function is capable of limiting the scope of search to a specific
2259:                    range of bytes.  It can also perform a case-insensitive search if
2260:                    required.
2261:                
2262:                    For example, if the buffer contains "I love PIC MCUs!" and the cFind
2263:                    byte is ' ', a value of 1 will be returned.
2264:                
2265:                  Precondition:
2266:                    TCP is initialized.
2267:                
2268:                  Parameters:
2269:                    hTCP - The socket to search within.
2270:                    cFind - The byte to find in the buffer.
2271:                    wStart - Zero-indexed starting position within the buffer.
2272:                    wSearchLen - Length from wStart to search in the buffer.
2273:                    bTextCompare - true for case-insensitive text search, false for binary search
2274:                
2275:                  Return Values:
2276:                    0xFFFF - Search array not found
2277:                    Otherwise - Zero-indexed position of the first occurrance
2278:                
2279:                  Remarks:
2280:                    Since this function usually must transfer data from external storage
2281:                    to internal RAM for comparison, its performance degrades significantly
2282:                    when the buffer is full and the array is not found.  For better
2283:                    performance, try to search for characters that are expected to exist or
2284:                    limit the scope of the search as much as possible.  The HTTP2 module,
2285:                    for example, uses this function to parse headers.  However, it searches
2286:                    for newlines, then the separating colon, then reads the header name to
2287:                    RAM for final comparison.  This has proven to be significantly faster
2288:                    than searching for full header name strings outright.
2289:                  ***************************************************************************/
2290:                uint16_t TCPFindEx(TCP_SOCKET hTCP, uint8_t cFind, uint16_t wStart, uint16_t wSearchLen, bool bTextCompare)
2291:                {
9D002BC0  27BDFFD8   ADDIU SP, SP, -40
9D002BC4  AFBF0024   SW RA, 36(SP)
9D002BC8  AFBE0020   SW S8, 32(SP)
9D002BCC  03A0F021   ADDU S8, SP, ZERO
9D002BD0  00804021   ADDU T0, A0, ZERO
9D002BD4  00C02021   ADDU A0, A2, ZERO
9D002BD8  00E01821   ADDU V1, A3, ZERO
9D002BDC  8FC20038   LW V0, 56(S8)
9D002BE0  A3C80028   SB T0, 40(S8)
9D002BE4  A3C5002C   SB A1, 44(S8)
9D002BE8  A7C40030   SH A0, 48(S8)
9D002BEC  A7C30034   SH V1, 52(S8)
9D002BF0  A3C20018   SB V0, 24(S8)
2292:                    return TCPFindArrayEx(hTCP, &cFind, sizeof(cFind), wStart, wSearchLen, bTextCompare);
9D002BF4  93C40028   LBU A0, 40(S8)
9D002BF8  97C20030   LHU V0, 48(S8)
9D002BFC  97C60034   LHU A2, 52(S8)
9D002C00  93C50018   LBU A1, 24(S8)
9D002C04  27C3002C   ADDIU V1, S8, 44
9D002C08  AFA60010   SW A2, 16(SP)
9D002C0C  AFA50014   SW A1, 20(SP)
9D002C10  00602821   ADDU A1, V1, ZERO
9D002C14  24060001   ADDIU A2, ZERO, 1
9D002C18  00403821   ADDU A3, V0, ZERO
9D002C1C  0F400961   JAL TCPFindArrayEx
9D002C20  00000000   NOP
2293:                }
9D002C24  03C0E821   ADDU SP, S8, ZERO
9D002C28  8FBF0024   LW RA, 36(SP)
9D002C2C  8FBE0020   LW S8, 32(SP)
9D002C30  27BD0028   ADDIU SP, SP, 40
9D002C34  03E00008   JR RA
9D002C38  00000000   NOP
2294:                
2295:                
2296:                
2297:                /****************************************************************************
2298:                  Section:
2299:                    Data Processing Functions
2300:                  ***************************************************************************/
2301:                
2302:                /*****************************************************************************
2303:                  Function:
2304:                    void TCPTick(void)
2305:                
2306:                  Summary:
2307:                    Performs periodic TCP tasks.
2308:                
2309:                  Description:
2310:                    This function performs any required periodic TCP tasks.  Each
2311:                    socket's state machine is checked, and any elapsed timeout periods
2312:                    are handled.
2313:                
2314:                  Precondition:
2315:                    TCP is initialized.
2316:                
2317:                  Parameters:
2318:                    None
2319:                
2320:                  Returns:
2321:                    None
2322:                  ***************************************************************************/
2323:                void TCPTick(void)
2324:                {
9D002C3C  27BDFFD0   ADDIU SP, SP, -48
9D002C40  AFBF002C   SW RA, 44(SP)
9D002C44  AFBE0028   SW S8, 40(SP)
9D002C48  AFB00024   SW S0, 36(SP)
9D002C4C  03A0F021   ADDU S8, SP, ZERO
2325:                    TCP_SOCKET hTCP;
2326:                    bool bRetransmit;
2327:                    bool bCloseSocket;
2328:                    uint8_t vFlags;
2329:                    uint16_t w;
2330:                
2331:                    // Periodically all "not closed" sockets must perform timed operations
2332:                    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D002C50  A3C00018   SB ZERO, 24(S8)
9D002C54  0B400E74   J 0x9D0039D0
9D002C58  00000000   NOP
9D0039C4  93C20018   LBU V0, 24(S8)
9D0039C8  24420001   ADDIU V0, V0, 1
9D0039CC  A3C20018   SB V0, 24(S8)
9D0039D0  93C20018   LBU V0, 24(S8)
9D0039D4  2C420002   SLTIU V0, V0, 2
9D0039D8  1440FCA0   BNE V0, ZERO, 0x9D002C5C
9D0039DC  00000000   NOP
2333:                    {
2334:                        SyncTCBStub(hTCP);
9D002C5C  93C20018   LBU V0, 24(S8)
9D002C60  A3828014   SB V0, -32748(GP)
2335:                
2336:                        // Handle any SSL Processing and Message Transmission
2337:                        #if defined(STACK_USE_SSL)
2338:                        if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2339:                        {
2340:                            // Handle any periodic tasks, such as RSA operations
2341:                            SSLPeriodic(hTCP, MyTCBStub.sslStubID);
2342:                
2343:                            // If unsent data is waiting, transmit it as an application record
2344:                            if(MyTCBStub.sslTxHead != MyTCBStub.txHead && TCPSSLGetPendingTxSize(hTCP) != 0u)
2345:                                SSLTxRecord(hTCP, MyTCBStub.sslStubID, SSL_APPLICATION);
2346:                
2347:                            // If an SSL message is requested, send it now
2348:                            if(MyTCBStub.sslReqMessage != SSL_NO_MESSAGE)
2349:                                SSLTxMessage(hTCP, MyTCBStub.sslStubID, MyTCBStub.sslReqMessage);
2350:                        }
2351:                        #endif
2352:                
2353:                        vFlags = 0x00;
9D002C64  A3C0001B   SB ZERO, 27(S8)
2354:                        bRetransmit = false;
9D002C68  A3C00019   SB ZERO, 25(S8)
2355:                        bCloseSocket = false;
9D002C6C  A3C0001A   SB ZERO, 26(S8)
2356:                
2357:                        // Transmit ASAP data if the medium is available
2358:                        if(MyTCBStub.Flags.bTXASAP || MyTCBStub.Flags.bTXASAPWithoutTimerReset)
9D002C70  93828014   LBU V0, -32748(GP)
9D002C74  3C04A000   LUI A0, -24576
9D002C78  00021100   SLL V0, V0, 4
9D002C7C  00021880   SLL V1, V0, 2
9D002C80  00621823   SUBU V1, V1, V0
9D002C84  2482753C   ADDIU V0, A0, 30012
9D002C88  00621021   ADDU V0, V1, V0
9D002C8C  8C420028   LW V0, 40(V0)
9D002C90  7C420240   EXT V0, V0, 9, 1
9D002C94  304200FF   ANDI V0, V0, 255
9D002C98  1440000D   BNE V0, ZERO, 0x9D002CD0
9D002C9C  00000000   NOP
9D002CA0  93828014   LBU V0, -32748(GP)
9D002CA4  3C04A000   LUI A0, -24576
9D002CA8  00021100   SLL V0, V0, 4
9D002CAC  00021880   SLL V1, V0, 2
9D002CB0  00621823   SUBU V1, V1, V0
9D002CB4  2482753C   ADDIU V0, A0, 30012
9D002CB8  00621021   ADDU V0, V1, V0
9D002CBC  8C420028   LW V0, 40(V0)
9D002CC0  7C420280   EXT V0, V0, 10, 1
9D002CC4  304200FF   ANDI V0, V0, 255
9D002CC8  10400013   BEQ V0, ZERO, 0x9D002D18
9D002CCC  00000000   NOP
2359:                        {
2360:                            if(MACIsTxReady())
9D002CD0  0F40453A   JAL MACIsTxReady
9D002CD4  00000000   NOP
9D002CD8  1040000F   BEQ V0, ZERO, 0x9D002D18
9D002CDC  00000000   NOP
2361:                            {
2362:                                vFlags = ACK;
9D002CE0  24020010   ADDIU V0, ZERO, 16
9D002CE4  A3C2001B   SB V0, 27(S8)
2363:                                bRetransmit = MyTCBStub.Flags.bTXASAPWithoutTimerReset;
9D002CE8  93828014   LBU V0, -32748(GP)
9D002CEC  3C04A000   LUI A0, -24576
9D002CF0  00021100   SLL V0, V0, 4
9D002CF4  00021880   SLL V1, V0, 2
9D002CF8  00621823   SUBU V1, V1, V0
9D002CFC  2482753C   ADDIU V0, A0, 30012
9D002D00  00621021   ADDU V0, V1, V0
9D002D04  8C420028   LW V0, 40(V0)
9D002D08  7C420280   EXT V0, V0, 10, 1
9D002D0C  304200FF   ANDI V0, V0, 255
9D002D10  0002102B   SLTU V0, ZERO, V0
9D002D14  A3C20019   SB V0, 25(S8)
2364:                            }
2365:                        }
2366:                
2367:                        // Perform any needed window updates and data transmissions
2368:                        if(MyTCBStub.Flags.bTimer2Enabled)
9D002D18  93828014   LBU V0, -32748(GP)
9D002D1C  3C04A000   LUI A0, -24576
9D002D20  00021100   SLL V0, V0, 4
9D002D24  00021880   SLL V1, V0, 2
9D002D28  00621823   SUBU V1, V1, V0
9D002D2C  2482753C   ADDIU V0, A0, 30012
9D002D30  00621021   ADDU V0, V1, V0
9D002D34  8C420028   LW V0, 40(V0)
9D002D38  7C420140   EXT V0, V0, 5, 1
9D002D3C  304200FF   ANDI V0, V0, 255
9D002D40  10400013   BEQ V0, ZERO, 0x9D002D90
9D002D44  00000000   NOP
2369:                        {
2370:                            // See if the timeout has occured, and we need to send a new window update and pending data
2371:                            if((int16_t)(MyTCBStub.eventTime2 - (uint16_t)TickGetDiv256()) <= (int16_t)0)
9D002D48  93828014   LBU V0, -32748(GP)
9D002D4C  3C04A000   LUI A0, -24576
9D002D50  00021100   SLL V0, V0, 4
9D002D54  00021880   SLL V1, V0, 2
9D002D58  00621823   SUBU V1, V1, V0
9D002D5C  2482753C   ADDIU V0, A0, 30012
9D002D60  00621021   ADDU V0, V1, V0
9D002D64  94500020   LHU S0, 32(V0)
9D002D68  0F405C62   JAL TickGetDiv256
9D002D6C  00000000   NOP
9D002D70  3042FFFF   ANDI V0, V0, -1
9D002D74  02021023   SUBU V0, S0, V0
9D002D78  3042FFFF   ANDI V0, V0, -1
9D002D7C  7C021620   SEH V0, V0
9D002D80  1C400003   BGTZ V0, 0x9D002D90
9D002D84  00000000   NOP
2372:                                vFlags = ACK;
9D002D88  24020010   ADDIU V0, ZERO, 16
9D002D8C  A3C2001B   SB V0, 27(S8)
2373:                        }
2374:                
2375:                        // Process Delayed ACKnowledgement timer
2376:                        if(MyTCBStub.Flags.bDelayedACKTimerEnabled)
9D002D90  93828014   LBU V0, -32748(GP)
9D002D94  3C04A000   LUI A0, -24576
9D002D98  00021100   SLL V0, V0, 4
9D002D9C  00021880   SLL V1, V0, 2
9D002DA0  00621823   SUBU V1, V1, V0
9D002DA4  2482753C   ADDIU V0, A0, 30012
9D002DA8  00621021   ADDU V0, V1, V0
9D002DAC  8C420028   LW V0, 40(V0)
9D002DB0  7C420180   EXT V0, V0, 6, 1
9D002DB4  304200FF   ANDI V0, V0, 255
9D002DB8  10400013   BEQ V0, ZERO, 0x9D002E08
9D002DBC  00000000   NOP
2377:                        {
2378:                            // See if the timeout has occured and delayed ACK needs to be sent
2379:                            if((int16_t)(MyTCBStub.OverlappedTimers.delayedACKTime - (uint16_t)TickGetDiv256()) <= (int16_t)0)
9D002DC0  93828014   LBU V0, -32748(GP)
9D002DC4  3C04A000   LUI A0, -24576
9D002DC8  00021100   SLL V0, V0, 4
9D002DCC  00021880   SLL V1, V0, 2
9D002DD0  00621823   SUBU V1, V1, V0
9D002DD4  2482753C   ADDIU V0, A0, 30012
9D002DD8  00621021   ADDU V0, V1, V0
9D002DDC  94500022   LHU S0, 34(V0)
9D002DE0  0F405C62   JAL TickGetDiv256
9D002DE4  00000000   NOP
9D002DE8  3042FFFF   ANDI V0, V0, -1
9D002DEC  02021023   SUBU V0, S0, V0
9D002DF0  3042FFFF   ANDI V0, V0, -1
9D002DF4  7C021620   SEH V0, V0
9D002DF8  1C400003   BGTZ V0, 0x9D002E08
9D002DFC  00000000   NOP
2380:                                vFlags = ACK;
9D002E00  24020010   ADDIU V0, ZERO, 16
9D002E04  A3C2001B   SB V0, 27(S8)
2381:                        }
2382:                
2383:                        // Process TCP_CLOSE_WAIT timer
2384:                        if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9D002E08  93828014   LBU V0, -32748(GP)
9D002E0C  3C03A000   LUI V1, -24576
9D002E10  2463753C   ADDIU V1, V1, 30012
9D002E14  00021100   SLL V0, V0, 4
9D002E18  00022080   SLL A0, V0, 2
9D002E1C  00821023   SUBU V0, A0, V0
9D002E20  00621021   ADDU V0, V1, V0
9D002E24  8C430024   LW V1, 36(V0)
9D002E28  2402000B   ADDIU V0, ZERO, 11
9D002E2C  1462001C   BNE V1, V0, 0x9D002EA0
9D002E30  00000000   NOP
2385:                        {
2386:                            // Automatically close the socket on our end if the application
2387:                            // fails to call TCPDisconnect() is a reasonable amount of time.
2388:                            if((int16_t)(MyTCBStub.OverlappedTimers.closeWaitTime - (uint16_t)TickGetDiv256()) <= (int16_t)0)
9D002E34  93828014   LBU V0, -32748(GP)
9D002E38  3C04A000   LUI A0, -24576
9D002E3C  00021100   SLL V0, V0, 4
9D002E40  00021880   SLL V1, V0, 2
9D002E44  00621823   SUBU V1, V1, V0
9D002E48  2482753C   ADDIU V0, A0, 30012
9D002E4C  00621021   ADDU V0, V1, V0
9D002E50  94500022   LHU S0, 34(V0)
9D002E54  0F405C62   JAL TickGetDiv256
9D002E58  00000000   NOP
9D002E5C  3042FFFF   ANDI V0, V0, -1
9D002E60  02021023   SUBU V0, S0, V0
9D002E64  3042FFFF   ANDI V0, V0, -1
9D002E68  7C021620   SEH V0, V0
9D002E6C  1C40000C   BGTZ V0, 0x9D002EA0
9D002E70  00000000   NOP
2389:                            {
2390:                                vFlags = FIN | ACK;
9D002E74  24020011   ADDIU V0, ZERO, 17
9D002E78  A3C2001B   SB V0, 27(S8)
2391:                                MyTCBStub.smState = TCP_LAST_ACK;
9D002E7C  93828014   LBU V0, -32748(GP)
9D002E80  3C03A000   LUI V1, -24576
9D002E84  2463753C   ADDIU V1, V1, 30012
9D002E88  00021100   SLL V0, V0, 4
9D002E8C  00022080   SLL A0, V0, 2
9D002E90  00821023   SUBU V0, A0, V0
9D002E94  00621021   ADDU V0, V1, V0
9D002E98  2403000C   ADDIU V1, ZERO, 12
9D002E9C  AC430024   SW V1, 36(V0)
2392:                            }
2393:                        }
2394:                
2395:                        // Process listening server sockets that might have a SYN waiting in the SYNQueue[]
2396:                        #if TCP_SYN_QUEUE_MAX_ENTRIES
2397:                            if(MyTCBStub.smState == TCP_LISTEN)
9D002EA0  93828014   LBU V0, -32748(GP)
9D002EA4  3C03A000   LUI V1, -24576
9D002EA8  2463753C   ADDIU V1, V1, 30012
9D002EAC  00021100   SLL V0, V0, 4
9D002EB0  00022080   SLL A0, V0, 2
9D002EB4  00821023   SUBU V0, A0, V0
9D002EB8  00621021   ADDU V0, V1, V0
9D002EBC  8C430024   LW V1, 36(V0)
9D002EC0  24020004   ADDIU V0, ZERO, 4
9D002EC4  1462009C   BNE V1, V0, 0x9D003138
9D002EC8  00000000   NOP
2398:                            {
2399:                                for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9D002ECC  A7C0001C   SH ZERO, 28(S8)
9D002ED0  0B400C47   J 0x9D00311C
9D002ED4  00000000   NOP
9D003110  97C2001C   LHU V0, 28(S8)
9D003114  24420001   ADDIU V0, V0, 1
9D003118  A7C2001C   SH V0, 28(S8)
9D00311C  97C2001C   LHU V0, 28(S8)
9D003120  2C420003   SLTIU V0, V0, 3
9D003124  1440FF6C   BNE V0, ZERO, 0x9D002ED8
9D003128  00000000   NOP
9D00312C  0B400C4E   J 0x9D003138
9D003130  00000000   NOP
2400:                                {
2401:                                    // Abort search if there are no more valid records
2402:                                    if(SYNQueue[w].wDestPort == 0u)
9D002ED8  97C2001C   LHU V0, 28(S8)
9D002EDC  3C03A000   LUI V1, -24576
9D002EE0  00021080   SLL V0, V0, 2
9D002EE4  00022080   SLL A0, V0, 2
9D002EE8  00441021   ADDU V0, V0, A0
9D002EEC  246375C8   ADDIU V1, V1, 30152
9D002EF0  00431021   ADDU V0, V0, V1
9D002EF4  94420010   LHU V0, 16(V0)
9D002EF8  1040008E   BEQ V0, ZERO, 0x9D003134
9D002EFC  00000000   NOP
2403:                                        break;
9D003134  00000000   NOP
2404:                
2405:                                    // Stop searching if this SYN queue entry can be used by this socket
2406:                                    #if defined(STACK_USE_SSL_SERVER)
2407:                                    if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val || SYNQueue[w].wDestPort == MyTCBStub.sslTxHead)
2408:                                    #else
2409:                                    if(SYNQueue[w].wDestPort == MyTCBStub.remoteHash.Val)
9D002F00  97C2001C   LHU V0, 28(S8)
9D002F04  3C03A000   LUI V1, -24576
9D002F08  00021080   SLL V0, V0, 2
9D002F0C  00022080   SLL A0, V0, 2
9D002F10  00441021   ADDU V0, V0, A0
9D002F14  246375C8   ADDIU V1, V1, 30152
9D002F18  00431021   ADDU V0, V0, V1
9D002F1C  94440010   LHU A0, 16(V0)
9D002F20  93828014   LBU V0, -32748(GP)
9D002F24  3C05A000   LUI A1, -24576
9D002F28  00021100   SLL V0, V0, 4
9D002F2C  00021880   SLL V1, V0, 2
9D002F30  00621823   SUBU V1, V1, V0
9D002F34  24A2753C   ADDIU V0, A1, 30012
9D002F38  00621021   ADDU V0, V1, V0
9D002F3C  9442002A   LHU V0, 42(V0)
9D002F40  14820073   BNE A0, V0, 0x9D003110
9D002F44  00000000   NOP
2410:                                    #endif
2411:                                    {
2412:                                        // Set up our socket and generate a reponse SYN+ACK packet
2413:                                        SyncTCB();
9D002F48  0F400000   JAL 0x9D000000
9D002F4C  00000000   NOP
2414:                
2415:                                        #if defined(STACK_USE_SSL_SERVER)
2416:                                        // If this matches the SSL port, make sure that can be configured
2417:                                        // before continuing.  If not, break and leave this in the queue
2418:                                        if(SYNQueue[w].wDestPort == MyTCBStub.sslTxHead && !TCPStartSSLServer(hTCP))
2419:                                            break;
2420:                                        #endif
2421:                
2422:                                        memcpy((void*)&MyTCB.remote.niRemoteMACIP, (void*)&SYNQueue[w].niSourceAddress, sizeof(NODE_INFO));
9D002F50  97C2001C   LHU V0, 28(S8)
9D002F54  00021080   SLL V0, V0, 2
9D002F58  00021880   SLL V1, V0, 2
9D002F5C  00431021   ADDU V0, V0, V1
9D002F60  3C03A000   LUI V1, -24576
9D002F64  246375C8   ADDIU V1, V1, 30152
9D002F68  00431021   ADDU V0, V0, V1
9D002F6C  3C03A000   LUI V1, -24576
9D002F70  246475B4   ADDIU A0, V1, 30132
9D002F74  00402821   ADDU A1, V0, ZERO
9D002F78  2406000A   ADDIU A2, ZERO, 10
9D002F7C  0F406788   JAL 0x9D019E20
9D002F80  00000000   NOP
2423:                                        MyTCB.remotePort.Val = SYNQueue[w].wSourcePort;
9D002F84  97C2001C   LHU V0, 28(S8)
9D002F88  3C03A000   LUI V1, -24576
9D002F8C  00021080   SLL V0, V0, 2
9D002F90  00022080   SLL A0, V0, 2
9D002F94  00441021   ADDU V0, V0, A0
9D002F98  246375C8   ADDIU V1, V1, 30152
9D002F9C  00431021   ADDU V0, V0, V1
9D002FA0  9443000A   LHU V1, 10(V0)
9D002FA4  3C02A000   LUI V0, -24576
9D002FA8  2442759C   ADDIU V0, V0, 30108
9D002FAC  A4430010   SH V1, 16(V0)
2424:                                        MyTCB.RemoteSEQ = SYNQueue[w].dwSourceSEQ + 1;
9D002FB0  97C2001C   LHU V0, 28(S8)
9D002FB4  3C03A000   LUI V1, -24576
9D002FB8  246375C8   ADDIU V1, V1, 30152
9D002FBC  00021080   SLL V0, V0, 2
9D002FC0  00022080   SLL A0, V0, 2
9D002FC4  00441021   ADDU V0, V0, A0
9D002FC8  00621021   ADDU V0, V1, V0
9D002FCC  8C42000C   LW V0, 12(V0)
9D002FD0  24430001   ADDIU V1, V0, 1
9D002FD4  3C02A000   LUI V0, -24576
9D002FD8  2442759C   ADDIU V0, V0, 30108
9D002FDC  AC430008   SW V1, 8(V0)
2425:                                        MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1] + MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
9D002FE0  93828014   LBU V0, -32748(GP)
9D002FE4  3C03A000   LUI V1, -24576
9D002FE8  2463759C   ADDIU V1, V1, 30108
9D002FEC  9464001A   LHU A0, 26(V1)
9D002FF0  3C03A000   LUI V1, -24576
9D002FF4  2463759C   ADDIU V1, V1, 30108
9D002FF8  94630018   LHU V1, 24(V1)
9D002FFC  00831821   ADDU V1, A0, V1
9D003000  3064FFFF   ANDI A0, V1, -1
9D003004  3C03A000   LUI V1, -24576
9D003008  2463759C   ADDIU V1, V1, 30108
9D00300C  94630010   LHU V1, 16(V1)
9D003010  00831821   ADDU V1, A0, V1
9D003014  3063FFFF   ANDI V1, V1, -1
9D003018  7C032620   SEH A0, V1
9D00301C  3C03A000   LUI V1, -24576
9D003020  2463759C   ADDIU V1, V1, 30108
9D003024  94630012   LHU V1, 18(V1)
9D003028  7C031E20   SEH V1, V1
9D00302C  00831826   XOR V1, A0, V1
9D003030  7C031E20   SEH V1, V1
9D003034  3064FFFF   ANDI A0, V1, -1
9D003038  3C05A000   LUI A1, -24576
9D00303C  00021100   SLL V0, V0, 4
9D003040  00021880   SLL V1, V0, 2
9D003044  00621823   SUBU V1, V1, V0
9D003048  24A2753C   ADDIU V0, A1, 30012
9D00304C  00621021   ADDU V0, V1, V0
9D003050  A444002A   SH A0, 42(V0)
2426:                                        vFlags = SYN | ACK;
9D003054  24020012   ADDIU V0, ZERO, 18
9D003058  A3C2001B   SB V0, 27(S8)
2427:                                        MyTCBStub.smState = TCP_SYN_RECEIVED;
9D00305C  93828014   LBU V0, -32748(GP)
9D003060  3C03A000   LUI V1, -24576
9D003064  2463753C   ADDIU V1, V1, 30012
9D003068  00021100   SLL V0, V0, 4
9D00306C  00022080   SLL A0, V0, 2
9D003070  00821023   SUBU V0, A0, V0
9D003074  00621021   ADDU V0, V1, V0
9D003078  24030006   ADDIU V1, ZERO, 6
9D00307C  AC430024   SW V1, 36(V0)
2428:                
2429:                                        // Delete this SYN from the SYNQueue and compact the SYNQueue[] array
2430:                                        TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9D003080  97C2001C   LHU V0, 28(S8)
9D003084  00021080   SLL V0, V0, 2
9D003088  00021880   SLL V1, V0, 2
9D00308C  00431821   ADDU V1, V0, V1
9D003090  3C02A000   LUI V0, -24576
9D003094  244275C8   ADDIU V0, V0, 30152
9D003098  00621021   ADDU V0, V1, V0
9D00309C  00402021   ADDU A0, V0, ZERO
9D0030A0  97C2001C   LHU V0, 28(S8)
9D0030A4  24420001   ADDIU V0, V0, 1
9D0030A8  00021080   SLL V0, V0, 2
9D0030AC  00021880   SLL V1, V0, 2
9D0030B0  00431821   ADDU V1, V0, V1
9D0030B4  3C02A000   LUI V0, -24576
9D0030B8  244275C8   ADDIU V0, V0, 30152
9D0030BC  00621021   ADDU V0, V1, V0
9D0030C0  00401821   ADDU V1, V0, ZERO
9D0030C4  97C2001C   LHU V0, 28(S8)
9D0030C8  00021080   SLL V0, V0, 2
9D0030CC  00022880   SLL A1, V0, 2
9D0030D0  00451021   ADDU V0, V0, A1
9D0030D4  00021023   SUBU V0, ZERO, V0
9D0030D8  3042FFFF   ANDI V0, V0, -1
9D0030DC  24420028   ADDIU V0, V0, 40
9D0030E0  3042FFFF   ANDI V0, V0, -1
9D0030E4  AFA20010   SW V0, 16(SP)
9D0030E8  24050001   ADDIU A1, ZERO, 1
9D0030EC  00603021   ADDU A2, V1, ZERO
9D0030F0  24070001   ADDIU A3, ZERO, 1
9D0030F4  0F4020A8   JAL 0x9D0082A0
9D0030F8  00000000   NOP
2431:                                        SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9D0030FC  3C02A000   LUI V0, -24576
9D003100  244275C8   ADDIU V0, V0, 30152
9D003104  A4400038   SH ZERO, 56(V0)
2432:                
2433:                                        break;
9D003108  0B400C4E   J 0x9D003138
9D00310C  00000000   NOP
2434:                                    }
2435:                                }
2436:                            }
2437:                        #endif
2438:                
2439:                        if(vFlags)
9D003138  93C2001B   LBU V0, 27(S8)
9D00313C  1040000D   BEQ V0, ZERO, 0x9D003174
9D003140  00000000   NOP
2440:                            SendTCP(vFlags, bRetransmit ? 0 : SENDTCP_RESET_TIMERS);
9D003144  93C3001B   LBU V1, 27(S8)
9D003148  93C20019   LBU V0, 25(S8)
9D00314C  10400004   BEQ V0, ZERO, 0x9D003160
9D003150  00000000   NOP
9D003154  00001021   ADDU V0, ZERO, ZERO
9D003158  0B400C59   J 0x9D003164
9D00315C  00000000   NOP
9D003160  24020001   ADDIU V0, ZERO, 1
9D003164  00602021   ADDU A0, V1, ZERO
9D003168  00402821   ADDU A1, V0, ZERO
9D00316C  0F400F2C   JAL 0x9D003CB0
9D003170  00000000   NOP
2441:                
2442:                        // The TCP_CLOSED, TCP_LISTEN, and sometimes the TCP_ESTABLISHED
2443:                        // state don't need any timeout events, so see if the timer is enabled
2444:                        if(!MyTCBStub.Flags.bTimerEnabled)
9D003174  93828014   LBU V0, -32748(GP)
9D003178  3C04A000   LUI A0, -24576
9D00317C  00021100   SLL V0, V0, 4
9D003180  00021880   SLL V1, V0, 2
9D003184  00621823   SUBU V1, V1, V0
9D003188  2482753C   ADDIU V0, A0, 30012
9D00318C  00621021   ADDU V0, V1, V0
9D003190  8C420028   LW V0, 40(V0)
9D003194  7C420100   EXT V0, V0, 4, 1
9D003198  304200FF   ANDI V0, V0, 255
9D00319C  14400060   BNE V0, ZERO, 0x9D003320
9D0031A0  00000000   NOP
2445:                        {
2446:                            #if defined(TCP_KEEP_ALIVE_TIMEOUT)
2447:                                // Only the established state has any use for keep-alives
2448:                                if(MyTCBStub.smState == TCP_ESTABLISHED)
9D0031A4  93828014   LBU V0, -32748(GP)
9D0031A8  3C03A000   LUI V1, -24576
9D0031AC  2463753C   ADDIU V1, V1, 30012
9D0031B0  00021100   SLL V0, V0, 4
9D0031B4  00022080   SLL A0, V0, 2
9D0031B8  00821023   SUBU V0, A0, V0
9D0031BC  00621021   ADDU V0, V1, V0
9D0031C0  8C430024   LW V1, 36(V0)
9D0031C4  24020007   ADDIU V0, ZERO, 7
9D0031C8  146201F4   BNE V1, V0, 0x9D00399C
9D0031CC  00000000   NOP
2449:                                {
2450:                                    // If timeout has not occured, do not do anything.
2451:                                    if((int32_t)(TickGet() - MyTCBStub.eventTime) < (int32_t)0)
9D0031D0  0F405C42   JAL TickGet
9D0031D4  00000000   NOP
9D0031D8  00401821   ADDU V1, V0, ZERO
9D0031DC  93828014   LBU V0, -32748(GP)
9D0031E0  3C04A000   LUI A0, -24576
9D0031E4  2484753C   ADDIU A0, A0, 30012
9D0031E8  00021100   SLL V0, V0, 4
9D0031EC  00022880   SLL A1, V0, 2
9D0031F0  00A21023   SUBU V0, A1, V0
9D0031F4  00821021   ADDU V0, A0, V0
9D0031F8  8C42001C   LW V0, 28(V0)
9D0031FC  00621023   SUBU V0, V1, V0
9D003200  044001E9   BLTZ V0, 0x9D0039A8
9D003204  00000000   NOP
2452:                                        continue;
9D0039A8  00000000   NOP
9D0039AC  0B400E71   J 0x9D0039C4
9D0039B0  00000000   NOP
2453:                
2454:                                    // If timeout has occured and the connection appears to be dead (no
2455:                                    // responses from remote node at all), close the connection so the
2456:                                    // application doesn't sit around indefinitely with a useless socket
2457:                                    // that it thinks is still open
2458:                                    if(MyTCBStub.Flags.vUnackedKeepalives == TCP_MAX_UNACKED_KEEP_ALIVES)
9D003208  93828014   LBU V0, -32748(GP)
9D00320C  3C04A000   LUI A0, -24576
9D003210  00021100   SLL V0, V0, 4
9D003214  00021880   SLL V1, V0, 2
9D003218  00621823   SUBU V1, V1, V0
9D00321C  2482753C   ADDIU V0, A0, 30012
9D003220  00621021   ADDU V0, V1, V0
9D003224  8C420028   LW V0, 40(V0)
9D003228  7C421000   EXT V0, V0, 0, 3
9D00322C  304300FF   ANDI V1, V0, 255
9D003230  24020006   ADDIU V0, ZERO, 6
9D003234  14620022   BNE V1, V0, 0x9D0032C0
9D003238  00000000   NOP
2459:                                    {
2460:                                        vFlags = MyTCBStub.Flags.bServer;
9D00323C  93828014   LBU V0, -32748(GP)
9D003240  3C04A000   LUI A0, -24576
9D003244  00021100   SLL V0, V0, 4
9D003248  00021880   SLL V1, V0, 2
9D00324C  00621823   SUBU V1, V1, V0
9D003250  2482753C   ADDIU V0, A0, 30012
9D003254  00621021   ADDU V0, V1, V0
9D003258  8C420028   LW V0, 40(V0)
9D00325C  7C4200C0   EXT V0, V0, 3, 1
9D003260  304200FF   ANDI V0, V0, 255
9D003264  A3C2001B   SB V0, 27(S8)
2461:                
2462:                                        // Force an immediate FIN and RST transmission
2463:                                        // Double calling TCPDisconnect() will also place us
2464:                                        // back in the listening state immediately if a server socket.
2465:                                        TCPDisconnect(hTCP);
9D003268  93C20018   LBU V0, 24(S8)
9D00326C  00402021   ADDU A0, V0, ZERO
9D003270  0F40025C   JAL TCPDisconnect
9D003274  00000000   NOP
2466:                                        TCPDisconnect(hTCP);
9D003278  93C20018   LBU V0, 24(S8)
9D00327C  00402021   ADDU A0, V0, ZERO
9D003280  0F40025C   JAL TCPDisconnect
9D003284  00000000   NOP
2467:                
2468:                                        // Prevent client mode sockets from getting reused by other applications.
2469:                                        // The application must call TCPDisconnect() with the handle to free this
2470:                                        // socket (and the handle associated with it)
2471:                                        if(!vFlags)
9D003288  93C2001B   LBU V0, 27(S8)
9D00328C  144001C9   BNE V0, ZERO, 0x9D0039B4
9D003290  00000000   NOP
2472:                                            MyTCBStub.smState = TCP_CLOSED_BUT_RESERVED;
9D003294  93828014   LBU V0, -32748(GP)
9D003298  3C03A000   LUI V1, -24576
9D00329C  2463753C   ADDIU V1, V1, 30012
9D0032A0  00021100   SLL V0, V0, 4
9D0032A4  00022080   SLL A0, V0, 2
9D0032A8  00821023   SUBU V0, A0, V0
9D0032AC  00621021   ADDU V0, V1, V0
9D0032B0  2403000E   ADDIU V1, ZERO, 14
9D0032B4  AC430024   SW V1, 36(V0)
2473:                
2474:                                        continue;
9D0032B8  0B400E71   J 0x9D0039C4
9D0032BC  00000000   NOP
9D0039B4  00000000   NOP
9D0039B8  0B400E71   J 0x9D0039C4
9D0039BC  00000000   NOP
2475:                                    }
2476:                
2477:                                    // Otherwise, if a timeout occured, simply send a keep-alive packet
2478:                                    SyncTCB();
9D0032C0  0F400000   JAL 0x9D000000
9D0032C4  00000000   NOP
2479:                                    SendTCP(ACK, SENDTCP_KEEP_ALIVE);
9D0032C8  24040010   ADDIU A0, ZERO, 16
9D0032CC  24050002   ADDIU A1, ZERO, 2
9D0032D0  0F400F2C   JAL 0x9D003CB0
9D0032D4  00000000   NOP
2480:                                    MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D0032D8  93828014   LBU V0, -32748(GP)
9D0032DC  00408021   ADDU S0, V0, ZERO
9D0032E0  0F405C42   JAL TickGet
9D0032E4  00000000   NOP
9D0032E8  00401821   ADDU V1, V0, ZERO
9D0032EC  3C02002F   LUI V0, 47
9D0032F0  3442AF08   ORI V0, V0, -20728
9D0032F4  00621821   ADDU V1, V1, V0
9D0032F8  3C02A000   LUI V0, -24576
9D0032FC  2444753C   ADDIU A0, V0, 30012
9D003300  02001021   ADDU V0, S0, ZERO
9D003304  00021100   SLL V0, V0, 4
9D003308  00022880   SLL A1, V0, 2
9D00330C  00A21023   SUBU V0, A1, V0
9D003310  00821021   ADDU V0, A0, V0
9D003314  AC43001C   SW V1, 28(V0)
2481:                                }
2482:                            #endif
2483:                            continue;
9D003318  0B400E71   J 0x9D0039C4
9D00331C  00000000   NOP
9D00399C  00000000   NOP
9D0039A0  0B400E71   J 0x9D0039C4
9D0039A4  00000000   NOP
2484:                        }
2485:                
2486:                        // If timeout has not occured, do not do anything.
2487:                        if((int32_t)(TickGet() - MyTCBStub.eventTime) < (int32_t)0)
9D003320  0F405C42   JAL TickGet
9D003324  00000000   NOP
9D003328  00401821   ADDU V1, V0, ZERO
9D00332C  93828014   LBU V0, -32748(GP)
9D003330  3C04A000   LUI A0, -24576
9D003334  2484753C   ADDIU A0, A0, 30012
9D003338  00021100   SLL V0, V0, 4
9D00333C  00022880   SLL A1, V0, 2
9D003340  00A21023   SUBU V0, A1, V0
9D003344  00821021   ADDU V0, A0, V0
9D003348  8C42001C   LW V0, 28(V0)
9D00334C  00621023   SUBU V0, V1, V0
9D003350  0440019B   BLTZ V0, 0x9D0039C0
9D003354  00000000   NOP
2488:                            continue;
9D0039C0  00000000   NOP
2489:                
2490:                        // Load up extended TCB information
2491:                        SyncTCB();
9D003358  0F400000   JAL 0x9D000000
9D00335C  00000000   NOP
2492:                
2493:                        // A timeout has occured.  Respond to this timeout condition
2494:                        // depending on what state this socket is in.
2495:                        switch(MyTCBStub.smState)
9D003360  93828014   LBU V0, -32748(GP)
9D003364  3C03A000   LUI V1, -24576
9D003368  2463753C   ADDIU V1, V1, 30012
9D00336C  00021100   SLL V0, V0, 4
9D003370  00022080   SLL A0, V0, 2
9D003374  00821023   SUBU V0, A0, V0
9D003378  00621021   ADDU V0, V1, V0
9D00337C  8C420024   LW V0, 36(V0)
9D003380  2C43000D   SLTIU V1, V0, 13
9D003384  10600105   BEQ V1, ZERO, 0x9D00379C
9D003388  00000000   NOP
9D00338C  00021880   SLL V1, V0, 2
9D003390  3C029D00   LUI V0, -25344
9D003394  244233A8   ADDIU V0, V0, 13224
9D003398  00621021   ADDU V0, V1, V0
9D00339C  8C420000   LW V0, 0(V0)
9D0033A0  00400008   JR V0
9D0033A4  00000000   NOP
2496:                        {
2497:                            #if defined(STACK_CLIENT_MODE)
2498:                            #if defined(STACK_USE_DNS)
2499:                            case TCP_GET_DNS_MODULE:
2500:                                if(DNSBeginUsage())
2501:                                {
2502:                                    MyTCBStub.smState = TCP_DNS_RESOLVE;
2503:                                    if(MyTCB.flags.bRemoteHostIsROM)
2504:                                        DNSResolveROM((ROM uint8_t*)(ROM_PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
2505:                                    else
2506:                                        DNSResolve((uint8_t*)(PTR_BASE)MyTCB.remote.dwRemoteHost, DNS_TYPE_A);
2507:                                }
2508:                                break;
2509:                
2510:                            case TCP_DNS_RESOLVE:
2511:                            {
2512:                                IP_ADDR ipResolvedDNSIP;
2513:                
2514:                                // See if DNS resolution has finished.  Note that if the DNS
2515:                                // fails, the &ipResolvedDNSIP will be written with 0x00000000.
2516:                                // MyTCB.remote.dwRemoteHost is unioned with
2517:                                // MyTCB.remote.niRemoteMACIP.IPAddr, so we can't directly write
2518:                                // the DNS result into MyTCB.remote.niRemoteMACIP.IPAddr.  We
2519:                                // must copy it over only if the DNS is resolution step was
2520:                                // successful.
2521:                                if(DNSIsResolved(&ipResolvedDNSIP))
2522:                                {
2523:                                    if(DNSEndUsage())
2524:                                    {
2525:                                        MyTCB.remote.niRemoteMACIP.IPAddr.Val = ipResolvedDNSIP.Val;
2526:                                        MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
2527:                                        MyTCBStub.remoteHash.Val = (MyTCB.remote.niRemoteMACIP.IPAddr.w[1]+MyTCB.remote.niRemoteMACIP.IPAddr.w[0] + MyTCB.remotePort.Val) ^ MyTCB.localPort.Val;
2528:                                        MyTCB.retryCount = 0;
2529:                                        MyTCB.retryInterval = (TICK_SECOND/4)/256;
2530:                                    }
2531:                                    else
2532:                                    {
2533:                                        MyTCBStub.eventTime = TickGet() + 10*TICK_SECOND;
2534:                                        MyTCBStub.smState = TCP_GET_DNS_MODULE;
2535:                                    }
2536:                                }
2537:                                break;
2538:                            }
2539:                            #endif // #if defined(STACK_USE_DNS)
2540:                
2541:                            case TCP_GATEWAY_SEND_ARP:
2542:                                // Obtain the MAC address associated with the server's IP address (either direct MAC address on same subnet, or the MAC address of the Gateway machine)
2543:                                MyTCBStub.eventTime2 = (uint16_t)TickGetDiv256();
9D0033DC  93828014   LBU V0, -32748(GP)
9D0033E0  00408021   ADDU S0, V0, ZERO
9D0033E4  0F405C62   JAL TickGetDiv256
9D0033E8  00000000   NOP
9D0033EC  3044FFFF   ANDI A0, V0, -1
9D0033F0  3C05A000   LUI A1, -24576
9D0033F4  02001021   ADDU V0, S0, ZERO
9D0033F8  00021100   SLL V0, V0, 4
9D0033FC  00021880   SLL V1, V0, 2
9D003400  00621823   SUBU V1, V1, V0
9D003404  24A2753C   ADDIU V0, A1, 30012
9D003408  00621021   ADDU V0, V1, V0
9D00340C  A4440020   SH A0, 32(V0)
2544:                                ARPResolve(&MyTCB.remote.niRemoteMACIP.IPAddr);
9D003410  3C02A000   LUI V0, -24576
9D003414  244475B4   ADDIU A0, V0, 30132
9D003418  0F40536D   JAL ARPResolve
9D00341C  00000000   NOP
2545:                                MyTCBStub.smState = TCP_GATEWAY_GET_ARP;
9D003420  93828014   LBU V0, -32748(GP)
9D003424  3C03A000   LUI V1, -24576
9D003428  2463753C   ADDIU V1, V1, 30012
9D00342C  00021100   SLL V0, V0, 4
9D003430  00022080   SLL A0, V0, 2
9D003434  00821023   SUBU V0, A0, V0
9D003438  00621021   ADDU V0, V1, V0
9D00343C  24030003   ADDIU V1, ZERO, 3
9D003440  AC430024   SW V1, 36(V0)
2546:                                break;
9D003444  0B400DF1   J 0x9D0037C4
9D003448  00000000   NOP
2547:                
2548:                            case TCP_GATEWAY_GET_ARP:
2549:                                // Wait for the MAC address to finish being obtained
2550:                                if(!ARPIsResolved(&MyTCB.remote.niRemoteMACIP.IPAddr, &MyTCB.remote.niRemoteMACIP.MACAddr))
9D00344C  3C02A000   LUI V0, -24576
9D003450  244475B4   ADDIU A0, V0, 30132
9D003454  3C02A000   LUI V0, -24576
9D003458  244575B8   ADDIU A1, V0, 30136
9D00345C  0F4053A6   JAL ARPIsResolved
9D003460  00000000   NOP
9D003464  38420001   XORI V0, V0, 1
9D003468  304200FF   ANDI V0, V0, 255
9D00346C  10400032   BEQ V0, ZERO, 0x9D003538
9D003470  00000000   NOP
2551:                                {
2552:                                    // Time out if too much time is spent in this state
2553:                                    // Note that this will continuously send out ARP
2554:                                    // requests for an infinite time if the Gateway
2555:                                    // never responds
2556:                                    if((uint16_t)TickGetDiv256() - MyTCBStub.eventTime2 > (uint16_t)MyTCB.retryInterval)
9D003474  0F405C62   JAL TickGetDiv256
9D003478  00000000   NOP
9D00347C  3042FFFF   ANDI V0, V0, -1
9D003480  00402021   ADDU A0, V0, ZERO
9D003484  93828014   LBU V0, -32748(GP)
9D003488  3C05A000   LUI A1, -24576
9D00348C  00021100   SLL V0, V0, 4
9D003490  00021880   SLL V1, V0, 2
9D003494  00621823   SUBU V1, V1, V0
9D003498  24A2753C   ADDIU V0, A1, 30012
9D00349C  00621021   ADDU V0, V1, V0
9D0034A0  94420020   LHU V0, 32(V0)
9D0034A4  00821823   SUBU V1, A0, V0
9D0034A8  3C02A000   LUI V0, -24576
9D0034AC  8C42759C   LW V0, 30108(V0)
9D0034B0  3042FFFF   ANDI V0, V0, -1
9D0034B4  0043102A   SLT V0, V0, V1
9D0034B8  104000BE   BEQ V0, ZERO, 0x9D0037B4
9D0034BC  00000000   NOP
2557:                                    {
2558:                                        // Exponentially increase timeout until we reach 6 attempts then stay constant
2559:                                        if(MyTCB.retryCount < 6u)
9D0034C0  3C02A000   LUI V0, -24576
9D0034C4  2442759C   ADDIU V0, V0, 30108
9D0034C8  9042002A   LBU V0, 42(V0)
9D0034CC  2C420006   SLTIU V0, V0, 6
9D0034D0  1040000E   BEQ V0, ZERO, 0x9D00350C
9D0034D4  00000000   NOP
2560:                                        {
2561:                                            MyTCB.retryCount++;
9D0034D8  3C02A000   LUI V0, -24576
9D0034DC  2442759C   ADDIU V0, V0, 30108
9D0034E0  9042002A   LBU V0, 42(V0)
9D0034E4  24420001   ADDIU V0, V0, 1
9D0034E8  304300FF   ANDI V1, V0, 255
9D0034EC  3C02A000   LUI V0, -24576
9D0034F0  2442759C   ADDIU V0, V0, 30108
9D0034F4  A043002A   SB V1, 42(V0)
2562:                                            MyTCB.retryInterval <<= 1;
9D0034F8  3C02A000   LUI V0, -24576
9D0034FC  8C42759C   LW V0, 30108(V0)
9D003500  00021840   SLL V1, V0, 1
9D003504  3C02A000   LUI V0, -24576
9D003508  AC43759C   SW V1, 30108(V0)
2563:                                        }
2564:                
2565:                                        // Retransmit ARP request
2566:                                        MyTCBStub.smState = TCP_GATEWAY_SEND_ARP;
9D00350C  93828014   LBU V0, -32748(GP)
9D003510  3C03A000   LUI V1, -24576
9D003514  2463753C   ADDIU V1, V1, 30012
9D003518  00021100   SLL V0, V0, 4
9D00351C  00022080   SLL A0, V0, 2
9D003520  00821023   SUBU V0, A0, V0
9D003524  00621021   ADDU V0, V1, V0
9D003528  24030002   ADDIU V1, ZERO, 2
9D00352C  AC430024   SW V1, 36(V0)
2567:                                    }
2568:                                    break;
9D003530  0B400DF1   J 0x9D0037C4
9D003534  00000000   NOP
9D0037B4  00000000   NOP
9D0037B8  0B400DF1   J 0x9D0037C4
9D0037BC  00000000   NOP
2569:                                }
2570:                
2571:                                // Send out SYN connection request to remote node
2572:                                // This automatically disables the Timer from
2573:                                // continuously firing for this socket
2574:                                vFlags = SYN;
9D003538  24020002   ADDIU V0, ZERO, 2
9D00353C  A3C2001B   SB V0, 27(S8)
2575:                                bRetransmit = false;
9D003540  A3C00019   SB ZERO, 25(S8)
2576:                                MyTCBStub.smState = TCP_SYN_SENT;
9D003544  93828014   LBU V0, -32748(GP)
9D003548  3C03A000   LUI V1, -24576
9D00354C  2463753C   ADDIU V1, V1, 30012
9D003550  00021100   SLL V0, V0, 4
9D003554  00022080   SLL A0, V0, 2
9D003558  00821023   SUBU V0, A0, V0
9D00355C  00621021   ADDU V0, V1, V0
9D003560  24030005   ADDIU V1, ZERO, 5
9D003564  AC430024   SW V1, 36(V0)
2577:                                break;
9D003568  0B400DF1   J 0x9D0037C4
9D00356C  00000000   NOP
2578:                            #endif // #if defined(STACK_CLIENT_MODE)
2579:                
2580:                            case TCP_SYN_SENT:
2581:                                // Keep sending SYN until we hear from remote node.
2582:                                // This may be for infinite time, in that case
2583:                                // caller must detect it and do something.
2584:                                vFlags = SYN;
9D003570  24020002   ADDIU V0, ZERO, 2
9D003574  A3C2001B   SB V0, 27(S8)
2585:                                bRetransmit = true;
9D003578  24020001   ADDIU V0, ZERO, 1
9D00357C  A3C20019   SB V0, 25(S8)
2586:                
2587:                                // Exponentially increase timeout until we reach TCP_MAX_RETRIES attempts then stay constant
2588:                                if(MyTCB.retryCount >= (TCP_MAX_RETRIES - 1))
9D003580  3C02A000   LUI V0, -24576
9D003584  2442759C   ADDIU V0, V0, 30108
9D003588  9042002A   LBU V0, 42(V0)
9D00358C  2C420004   SLTIU V0, V0, 4
9D003590  1440008B   BNE V0, ZERO, 0x9D0037C0
9D003594  00000000   NOP
2589:                                {
2590:                                    MyTCB.retryCount = TCP_MAX_RETRIES - 1;
9D003598  3C02A000   LUI V0, -24576
9D00359C  2442759C   ADDIU V0, V0, 30108
9D0035A0  24030004   ADDIU V1, ZERO, 4
9D0035A4  A043002A   SB V1, 42(V0)
2591:                                    MyTCB.retryInterval = TCP_START_TIMEOUT_VAL<<(TCP_MAX_RETRIES-1);
9D0035A8  3C02A000   LUI V0, -24576
9D0035AC  3C03004C   LUI V1, 76
9D0035B0  34634B40   ORI V1, V1, 19264
9D0035B4  AC43759C   SW V1, 30108(V0)
2592:                                }
2593:                                break;
9D0035B8  0B400DF1   J 0x9D0037C4
9D0035BC  00000000   NOP
9D0037C0  00000000   NOP
2594:                
2595:                            case TCP_SYN_RECEIVED:
2596:                                // We must receive ACK before timeout expires.
2597:                                // If not, resend SYN+ACK.
2598:                                // Abort, if maximum attempts counts are reached.
2599:                                if(MyTCB.retryCount < TCP_MAX_SYN_RETRIES)
9D0035C0  3C02A000   LUI V0, -24576
9D0035C4  2442759C   ADDIU V0, V0, 30108
9D0035C8  9042002A   LBU V0, 42(V0)
9D0035CC  2C420002   SLTIU V0, V0, 2
9D0035D0  10400007   BEQ V0, ZERO, 0x9D0035F0
9D0035D4  00000000   NOP
2600:                                {
2601:                                    vFlags = SYN | ACK;
9D0035D8  24020012   ADDIU V0, ZERO, 18
9D0035DC  A3C2001B   SB V0, 27(S8)
2602:                                    bRetransmit = true;
9D0035E0  24020001   ADDIU V0, ZERO, 1
9D0035E4  A3C20019   SB V0, 25(S8)
2603:                                }
2604:                                else
2605:                                {
2606:                                    if(MyTCBStub.Flags.bServer)
9D0035F0  93828014   LBU V0, -32748(GP)
9D0035F4  3C04A000   LUI A0, -24576
9D0035F8  00021100   SLL V0, V0, 4
9D0035FC  00021880   SLL V1, V0, 2
9D003600  00621823   SUBU V1, V1, V0
9D003604  2482753C   ADDIU V0, A0, 30012
9D003608  00621021   ADDU V0, V1, V0
9D00360C  8C420028   LW V0, 40(V0)
9D003610  7C4200C0   EXT V0, V0, 3, 1
9D003614  304200FF   ANDI V0, V0, 255
9D003618  10400007   BEQ V0, ZERO, 0x9D003638
9D00361C  00000000   NOP
2607:                                    {
2608:                                        vFlags = RST | ACK;
9D003620  24020014   ADDIU V0, ZERO, 20
9D003624  A3C2001B   SB V0, 27(S8)
2609:                                        bCloseSocket = true;
9D003628  24020001   ADDIU V0, ZERO, 1
9D00362C  A3C2001A   SB V0, 26(S8)
2610:                                    }
2611:                                    else
2612:                                    {
2613:                                        vFlags = SYN;
9D003638  24020002   ADDIU V0, ZERO, 2
9D00363C  A3C2001B   SB V0, 27(S8)
2614:                                    }
2615:                                }
2616:                                break;
9D0035E8  0B400DF1   J 0x9D0037C4
9D0035EC  00000000   NOP
9D003630  0B400DF1   J 0x9D0037C4
9D003634  00000000   NOP
9D003640  0B400DF1   J 0x9D0037C4
9D003644  00000000   NOP
2617:                
2618:                            case TCP_ESTABLISHED:
2619:                            case TCP_CLOSE_WAIT:
2620:                                // Retransmit any unacknowledged data
2621:                                if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D003648  3C02A000   LUI V0, -24576
9D00364C  2442759C   ADDIU V0, V0, 30108
9D003650  9042002A   LBU V0, 42(V0)
9D003654  2C420005   SLTIU V0, V0, 5
9D003658  10400007   BEQ V0, ZERO, 0x9D003678
9D00365C  00000000   NOP
2622:                                {
2623:                                    vFlags = ACK;
9D003660  24020010   ADDIU V0, ZERO, 16
9D003664  A3C2001B   SB V0, 27(S8)
2624:                                    bRetransmit = true;
9D003668  24020001   ADDIU V0, ZERO, 1
9D00366C  A3C20019   SB V0, 25(S8)
2625:                                }
2626:                                else
2627:                                {
2628:                                    // No response back for too long, close connection
2629:                                    // This could happen, for instance, if the communication
2630:                                    // medium was lost
2631:                                    MyTCBStub.smState = TCP_FIN_WAIT_1;
9D003678  93828014   LBU V0, -32748(GP)
9D00367C  3C03A000   LUI V1, -24576
9D003680  2463753C   ADDIU V1, V1, 30012
9D003684  00021100   SLL V0, V0, 4
9D003688  00022080   SLL A0, V0, 2
9D00368C  00821023   SUBU V0, A0, V0
9D003690  00621021   ADDU V0, V1, V0
9D003694  24030008   ADDIU V1, ZERO, 8
9D003698  AC430024   SW V1, 36(V0)
2632:                                    vFlags = FIN | ACK;
9D00369C  24020011   ADDIU V0, ZERO, 17
9D0036A0  A3C2001B   SB V0, 27(S8)
2633:                                }
2634:                                break;
9D003670  0B400DF1   J 0x9D0037C4
9D003674  00000000   NOP
9D0036A4  0B400DF1   J 0x9D0037C4
9D0036A8  00000000   NOP
2635:                
2636:                            case TCP_FIN_WAIT_1:
2637:                                if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D0036AC  3C02A000   LUI V0, -24576
9D0036B0  2442759C   ADDIU V0, V0, 30108
9D0036B4  9042002A   LBU V0, 42(V0)
9D0036B8  2C420005   SLTIU V0, V0, 5
9D0036BC  10400007   BEQ V0, ZERO, 0x9D0036DC
9D0036C0  00000000   NOP
2638:                                {
2639:                                    // Send another FIN
2640:                                    vFlags = FIN | ACK;
9D0036C4  24020011   ADDIU V0, ZERO, 17
9D0036C8  A3C2001B   SB V0, 27(S8)
2641:                                    bRetransmit = true;
9D0036CC  24020001   ADDIU V0, ZERO, 1
9D0036D0  A3C20019   SB V0, 25(S8)
2642:                                }
2643:                                else
2644:                                {
2645:                                    // Close on our own, we can't seem to communicate
2646:                                    // with the remote node anymore
2647:                                    vFlags = RST | ACK;
9D0036DC  24020014   ADDIU V0, ZERO, 20
9D0036E0  A3C2001B   SB V0, 27(S8)
2648:                                    bCloseSocket = true;
9D0036E4  24020001   ADDIU V0, ZERO, 1
9D0036E8  A3C2001A   SB V0, 26(S8)
2649:                                }
2650:                                break;
9D0036D4  0B400DF1   J 0x9D0037C4
9D0036D8  00000000   NOP
9D0036EC  0B400DF1   J 0x9D0037C4
9D0036F0  00000000   NOP
2651:                
2652:                            case TCP_FIN_WAIT_2:
2653:                                // Close on our own, we can't seem to communicate
2654:                                // with the remote node anymore
2655:                                vFlags = RST | ACK;
9D0036F4  24020014   ADDIU V0, ZERO, 20
9D0036F8  A3C2001B   SB V0, 27(S8)
2656:                                bCloseSocket = true;
9D0036FC  24020001   ADDIU V0, ZERO, 1
9D003700  A3C2001A   SB V0, 26(S8)
2657:                                break;
9D003704  0B400DF1   J 0x9D0037C4
9D003708  00000000   NOP
2658:                
2659:                            case TCP_CLOSING:
2660:                                if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D00370C  3C02A000   LUI V0, -24576
9D003710  2442759C   ADDIU V0, V0, 30108
9D003714  9042002A   LBU V0, 42(V0)
9D003718  2C420005   SLTIU V0, V0, 5
9D00371C  10400007   BEQ V0, ZERO, 0x9D00373C
9D003720  00000000   NOP
2661:                                {
2662:                                    // Send another ACK+FIN (the FIN is retransmitted
2663:                                    // automatically since it hasn't been acknowledged by
2664:                                    // the remote node yet)
2665:                                    vFlags = ACK;
9D003724  24020010   ADDIU V0, ZERO, 16
9D003728  A3C2001B   SB V0, 27(S8)
2666:                                    bRetransmit = true;
9D00372C  24020001   ADDIU V0, ZERO, 1
9D003730  A3C20019   SB V0, 25(S8)
2667:                                }
2668:                                else
2669:                                {
2670:                                    // Close on our own, we can't seem to communicate
2671:                                    // with the remote node anymore
2672:                                    vFlags = RST | ACK;
9D00373C  24020014   ADDIU V0, ZERO, 20
9D003740  A3C2001B   SB V0, 27(S8)
2673:                                    bCloseSocket = true;
9D003744  24020001   ADDIU V0, ZERO, 1
9D003748  A3C2001A   SB V0, 26(S8)
2674:                                }
2675:                                break;
9D003734  0B400DF1   J 0x9D0037C4
9D003738  00000000   NOP
9D00374C  0B400DF1   J 0x9D0037C4
9D003750  00000000   NOP
2676:                
2677:                //          case TCP_TIME_WAIT:
2678:                //              // Wait around for a while (2MSL) and then goto closed state
2679:                //              bCloseSocket = true;
2680:                //              break;
2681:                //
2682:                
2683:                            case TCP_LAST_ACK:
2684:                                // Send some more FINs or close anyway
2685:                                if(MyTCB.retryCount < TCP_MAX_RETRIES)
9D003754  3C02A000   LUI V0, -24576
9D003758  2442759C   ADDIU V0, V0, 30108
9D00375C  9042002A   LBU V0, 42(V0)
9D003760  2C420005   SLTIU V0, V0, 5
9D003764  10400007   BEQ V0, ZERO, 0x9D003784
9D003768  00000000   NOP
2686:                                {
2687:                                    vFlags = FIN | ACK;
9D00376C  24020011   ADDIU V0, ZERO, 17
9D003770  A3C2001B   SB V0, 27(S8)
2688:                                    bRetransmit = true;
9D003774  24020001   ADDIU V0, ZERO, 1
9D003778  A3C20019   SB V0, 25(S8)
2689:                                }
2690:                                else
2691:                                {
2692:                                    vFlags = RST | ACK;
9D003784  24020014   ADDIU V0, ZERO, 20
9D003788  A3C2001B   SB V0, 27(S8)
2693:                                    bCloseSocket = true;
9D00378C  24020001   ADDIU V0, ZERO, 1
9D003790  A3C2001A   SB V0, 26(S8)
2694:                                }
2695:                                break;
9D00377C  0B400DF1   J 0x9D0037C4
9D003780  00000000   NOP
9D003794  0B400DF1   J 0x9D0037C4
9D003798  00000000   NOP
2696:                
2697:                            default:
2698:                                break;
9D00379C  00000000   NOP
9D0037A0  0B400DF1   J 0x9D0037C4
9D0037A4  00000000   NOP
9D0037A8  00000000   NOP
9D0037AC  0B400DF1   J 0x9D0037C4
9D0037B0  00000000   NOP
2699:                        }
2700:                
2701:                        if(vFlags)
9D0037C4  93C2001B   LBU V0, 27(S8)
9D0037C8  1040006D   BEQ V0, ZERO, 0x9D003980
9D0037CC  00000000   NOP
2702:                        {
2703:                            // Transmit all unacknowledged data over again
2704:                            if(bRetransmit)
9D0037D0  93C20019   LBU V0, 25(S8)
9D0037D4  10400065   BEQ V0, ZERO, 0x9D00396C
9D0037D8  00000000   NOP
2705:                            {
2706:                                // Set the appropriate retry time
2707:                                MyTCB.retryCount++;
9D0037DC  3C02A000   LUI V0, -24576
9D0037E0  2442759C   ADDIU V0, V0, 30108
9D0037E4  9042002A   LBU V0, 42(V0)
9D0037E8  24420001   ADDIU V0, V0, 1
9D0037EC  304300FF   ANDI V1, V0, 255
9D0037F0  3C02A000   LUI V0, -24576
9D0037F4  2442759C   ADDIU V0, V0, 30108
9D0037F8  A043002A   SB V1, 42(V0)
2708:                                MyTCB.retryInterval <<= 1;
9D0037FC  3C02A000   LUI V0, -24576
9D003800  8C42759C   LW V0, 30108(V0)
9D003804  00021840   SLL V1, V0, 1
9D003808  3C02A000   LUI V0, -24576
9D00380C  AC43759C   SW V1, 30108(V0)
2709:                
2710:                                // Calculate how many bytes we have to roll back and retransmit
2711:                                w = MyTCB.txUnackedTail - MyTCBStub.txTail;
9D003810  3C02A000   LUI V0, -24576
9D003814  2442759C   ADDIU V0, V0, 30108
9D003818  8C42000C   LW V0, 12(V0)
9D00381C  3044FFFF   ANDI A0, V0, -1
9D003820  93828014   LBU V0, -32748(GP)
9D003824  3C05A000   LUI A1, -24576
9D003828  00021100   SLL V0, V0, 4
9D00382C  00021880   SLL V1, V0, 2
9D003830  00621823   SUBU V1, V1, V0
9D003834  24A2753C   ADDIU V0, A1, 30012
9D003838  00621021   ADDU V0, V1, V0
9D00383C  8C420010   LW V0, 16(V0)
9D003840  3042FFFF   ANDI V0, V0, -1
9D003844  00821023   SUBU V0, A0, V0
9D003848  A7C2001C   SH V0, 28(S8)
2712:                                if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D00384C  3C02A000   LUI V0, -24576
9D003850  2442759C   ADDIU V0, V0, 30108
9D003854  8C44000C   LW A0, 12(V0)
9D003858  93828014   LBU V0, -32748(GP)
9D00385C  3C05A000   LUI A1, -24576
9D003860  00021100   SLL V0, V0, 4
9D003864  00021880   SLL V1, V0, 2
9D003868  00621823   SUBU V1, V1, V0
9D00386C  24A2753C   ADDIU V0, A1, 30012
9D003870  00621021   ADDU V0, V1, V0
9D003874  8C420010   LW V0, 16(V0)
9D003878  0082102B   SLTU V0, A0, V0
9D00387C  10400018   BEQ V0, ZERO, 0x9D0038E0
9D003880  00000000   NOP
2713:                                    w += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D003884  93828014   LBU V0, -32748(GP)
9D003888  3C03A000   LUI V1, -24576
9D00388C  2463753C   ADDIU V1, V1, 30012
9D003890  00021100   SLL V0, V0, 4
9D003894  00022080   SLL A0, V0, 2
9D003898  00821023   SUBU V0, A0, V0
9D00389C  00621021   ADDU V0, V1, V0
9D0038A0  8C420004   LW V0, 4(V0)
9D0038A4  3044FFFF   ANDI A0, V0, -1
9D0038A8  93828014   LBU V0, -32748(GP)
9D0038AC  3C05A000   LUI A1, -24576
9D0038B0  00021100   SLL V0, V0, 4
9D0038B4  00021880   SLL V1, V0, 2
9D0038B8  00621823   SUBU V1, V1, V0
9D0038BC  24A2753C   ADDIU V0, A1, 30012
9D0038C0  00621021   ADDU V0, V1, V0
9D0038C4  8C420000   LW V0, 0(V0)
9D0038C8  3042FFFF   ANDI V0, V0, -1
9D0038CC  00821023   SUBU V0, A0, V0
9D0038D0  3043FFFF   ANDI V1, V0, -1
9D0038D4  97C2001C   LHU V0, 28(S8)
9D0038D8  00621021   ADDU V0, V1, V0
9D0038DC  A7C2001C   SH V0, 28(S8)
2714:                
2715:                                // Perform roll back of local SEQuence counter, remote window
2716:                                // adjustment, and cause all unacknowledged data to be
2717:                                // retransmitted by moving the unacked tail pointer.
2718:                                MyTCB.MySEQ -= w;
9D0038E0  3C02A000   LUI V0, -24576
9D0038E4  2442759C   ADDIU V0, V0, 30108
9D0038E8  8C430004   LW V1, 4(V0)
9D0038EC  97C2001C   LHU V0, 28(S8)
9D0038F0  00621823   SUBU V1, V1, V0
9D0038F4  3C02A000   LUI V0, -24576
9D0038F8  2442759C   ADDIU V0, V0, 30108
9D0038FC  AC430004   SW V1, 4(V0)
2719:                                MyTCB.remoteWindow += w;
9D003900  3C02A000   LUI V0, -24576
9D003904  2442759C   ADDIU V0, V0, 30108
9D003908  94430014   LHU V1, 20(V0)
9D00390C  97C2001C   LHU V0, 28(S8)
9D003910  00621021   ADDU V0, V1, V0
9D003914  3043FFFF   ANDI V1, V0, -1
9D003918  3C02A000   LUI V0, -24576
9D00391C  2442759C   ADDIU V0, V0, 30108
9D003920  A4430014   SH V1, 20(V0)
2720:                                MyTCB.txUnackedTail = MyTCBStub.txTail;
9D003924  93828014   LBU V0, -32748(GP)
9D003928  3C04A000   LUI A0, -24576
9D00392C  00021100   SLL V0, V0, 4
9D003930  00021880   SLL V1, V0, 2
9D003934  00621823   SUBU V1, V1, V0
9D003938  2482753C   ADDIU V0, A0, 30012
9D00393C  00621021   ADDU V0, V1, V0
9D003940  8C430010   LW V1, 16(V0)
9D003944  3C02A000   LUI V0, -24576
9D003948  2442759C   ADDIU V0, V0, 30108
9D00394C  AC43000C   SW V1, 12(V0)
2721:                                SendTCP(vFlags, 0);
9D003950  93C2001B   LBU V0, 27(S8)
9D003954  00402021   ADDU A0, V0, ZERO
9D003958  00002821   ADDU A1, ZERO, ZERO
9D00395C  0F400F2C   JAL 0x9D003CB0
9D003960  00000000   NOP
9D003964  0B400E60   J 0x9D003980
9D003968  00000000   NOP
2722:                            }
2723:                            else
2724:                                SendTCP(vFlags, SENDTCP_RESET_TIMERS);
9D00396C  93C2001B   LBU V0, 27(S8)
9D003970  00402021   ADDU A0, V0, ZERO
9D003974  24050001   ADDIU A1, ZERO, 1
9D003978  0F400F2C   JAL 0x9D003CB0
9D00397C  00000000   NOP
2725:                
2726:                        }
2727:                
2728:                        if(bCloseSocket)
9D003980  93C2001A   LBU V0, 26(S8)
9D003984  1040000F   BEQ V0, ZERO, 0x9D0039C4
9D003988  00000000   NOP
2729:                            CloseSocket();
9D00398C  0F401470   JAL 0x9D0051C0
9D003990  00000000   NOP
9D003994  0B400E71   J 0x9D0039C4
9D003998  00000000   NOP
2730:                    }
2731:                
2732:                
2733:                    #if TCP_SYN_QUEUE_MAX_ENTRIES
2734:                        // Process SYN Queue entry timeouts
2735:                        for(w = 0; w < TCP_SYN_QUEUE_MAX_ENTRIES; w++)
9D0039E0  A7C0001C   SH ZERO, 28(S8)
9D0039E4  0B400EBD   J 0x9D003AF4
9D0039E8  00000000   NOP
9D003AE8  97C2001C   LHU V0, 28(S8)
9D003AEC  24420001   ADDIU V0, V0, 1
9D003AF0  A7C2001C   SH V0, 28(S8)
9D003AF4  97C2001C   LHU V0, 28(S8)
9D003AF8  2C420003   SLTIU V0, V0, 3
9D003AFC  1440FFBB   BNE V0, ZERO, 0x9D0039EC
9D003B00  00000000   NOP
9D003B04  0B400EC4   J 0x9D003B10
9D003B08  00000000   NOP
2736:                        {
2737:                            // Abort search if there are no more valid records
2738:                            if(SYNQueue[w].wDestPort == 0u)
9D0039EC  97C2001C   LHU V0, 28(S8)
9D0039F0  3C03A000   LUI V1, -24576
9D0039F4  00021080   SLL V0, V0, 2
9D0039F8  00022080   SLL A0, V0, 2
9D0039FC  00441021   ADDU V0, V0, A0
9D003A00  246375C8   ADDIU V1, V1, 30152
9D003A04  00431021   ADDU V0, V0, V1
9D003A08  94420010   LHU V0, 16(V0)
9D003A0C  1040003F   BEQ V0, ZERO, 0x9D003B0C
9D003A10  00000000   NOP
2739:                                break;
9D003B0C  00000000   NOP
2740:                
2741:                            // See if this SYN has timed out
2742:                            if((uint16_t)TickGetDiv256() - SYNQueue[w].wTimestamp > (uint16_t)(TCP_SYN_QUEUE_TIMEOUT/256ull))
9D003A14  0F405C62   JAL TickGetDiv256
9D003A18  00000000   NOP
9D003A1C  3042FFFF   ANDI V0, V0, -1
9D003A20  00401821   ADDU V1, V0, ZERO
9D003A24  97C2001C   LHU V0, 28(S8)
9D003A28  3C04A000   LUI A0, -24576
9D003A2C  00021080   SLL V0, V0, 2
9D003A30  00022880   SLL A1, V0, 2
9D003A34  00451021   ADDU V0, V0, A1
9D003A38  248475C8   ADDIU A0, A0, 30152
9D003A3C  00441021   ADDU V0, V0, A0
9D003A40  94420012   LHU V0, 18(V0)
9D003A44  00621023   SUBU V0, V1, V0
9D003A48  28420E4F   SLTI V0, V0, 3663
9D003A4C  14400026   BNE V0, ZERO, 0x9D003AE8
9D003A50  00000000   NOP
2743:                            {
2744:                                // Delete this SYN from the SYNQueue and compact the SYNQueue[] array
2745:                                TCPRAMCopy((PTR_BASE)&SYNQueue[w], TCP_PIC_RAM, (PTR_BASE)&SYNQueue[w+1], TCP_PIC_RAM, (TCP_SYN_QUEUE_MAX_ENTRIES-1u-w)*sizeof(TCP_SYN_QUEUE));
9D003A54  97C2001C   LHU V0, 28(S8)
9D003A58  00021080   SLL V0, V0, 2
9D003A5C  00021880   SLL V1, V0, 2
9D003A60  00431821   ADDU V1, V0, V1
9D003A64  3C02A000   LUI V0, -24576
9D003A68  244275C8   ADDIU V0, V0, 30152
9D003A6C  00621021   ADDU V0, V1, V0
9D003A70  00402021   ADDU A0, V0, ZERO
9D003A74  97C2001C   LHU V0, 28(S8)
9D003A78  24420001   ADDIU V0, V0, 1
9D003A7C  00021080   SLL V0, V0, 2
9D003A80  00021880   SLL V1, V0, 2
9D003A84  00431821   ADDU V1, V0, V1
9D003A88  3C02A000   LUI V0, -24576
9D003A8C  244275C8   ADDIU V0, V0, 30152
9D003A90  00621021   ADDU V0, V1, V0
9D003A94  00401821   ADDU V1, V0, ZERO
9D003A98  97C2001C   LHU V0, 28(S8)
9D003A9C  00021080   SLL V0, V0, 2
9D003AA0  00022880   SLL A1, V0, 2
9D003AA4  00451021   ADDU V0, V0, A1
9D003AA8  00021023   SUBU V0, ZERO, V0
9D003AAC  3042FFFF   ANDI V0, V0, -1
9D003AB0  24420028   ADDIU V0, V0, 40
9D003AB4  3042FFFF   ANDI V0, V0, -1
9D003AB8  AFA20010   SW V0, 16(SP)
9D003ABC  24050001   ADDIU A1, ZERO, 1
9D003AC0  00603021   ADDU A2, V1, ZERO
9D003AC4  24070001   ADDIU A3, ZERO, 1
9D003AC8  0F4020A8   JAL 0x9D0082A0
9D003ACC  00000000   NOP
2746:                                SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort = 0u;
9D003AD0  3C02A000   LUI V0, -24576
9D003AD4  244275C8   ADDIU V0, V0, 30152
9D003AD8  A4400038   SH ZERO, 56(V0)
2747:                
2748:                                // Since we deleted an entry, we need to roll back one
2749:                                // index so next loop will process the correct record
2750:                                w--;
9D003ADC  97C2001C   LHU V0, 28(S8)
9D003AE0  2442FFFF   ADDIU V0, V0, -1
9D003AE4  A7C2001C   SH V0, 28(S8)
2751:                            }
2752:                        }
2753:                    #endif
2754:                }
9D003B10  03C0E821   ADDU SP, S8, ZERO
9D003B14  8FBF002C   LW RA, 44(SP)
9D003B18  8FBE0028   LW S8, 40(SP)
9D003B1C  8FB00024   LW S0, 36(SP)
9D003B20  27BD0030   ADDIU SP, SP, 48
9D003B24  03E00008   JR RA
9D003B28  00000000   NOP
2755:                
2756:                
2757:                /*****************************************************************************
2758:                  Function:
2759:                    bool TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, uint16_t len)
2760:                
2761:                  Summary:
2762:                    Handles incoming TCP segments.
2763:                
2764:                  Description:
2765:                    This function handles incoming TCP segments.  When a segment arrives, it
2766:                    is compared to open sockets using a hash of the remote port and IP.
2767:                    On a match, the data is passed to HandleTCPSeg for further processing.
2768:                
2769:                  Precondition:
2770:                    TCP is initialized and a TCP segment is ready in the MAC buffer.
2771:                
2772:                  Parameters:
2773:                    remote - Remote NODE_INFO structure
2774:                    localIP - This stack's IP address (for header checking)
2775:                    len - Total length of the waiting TCP segment
2776:                
2777:                  Return Values:
2778:                    true - the segment was properly handled.
2779:                    false - otherwise
2780:                  ***************************************************************************/
2781:                bool TCPProcess(NODE_INFO* remote, IP_ADDR* localIP, uint16_t len)
2782:                {
9D003B2C  27BDFFB8   ADDIU SP, SP, -72
9D003B30  AFBF0044   SW RA, 68(SP)
9D003B34  AFBE0040   SW S8, 64(SP)
9D003B38  03A0F021   ADDU S8, SP, ZERO
9D003B3C  AFC40048   SW A0, 72(S8)
9D003B40  AFC5004C   SW A1, 76(S8)
9D003B44  00C01021   ADDU V0, A2, ZERO
9D003B48  A7C20050   SH V0, 80(S8)
2783:                    TCP_HEADER      TCPHeader;
2784:                    PSEUDO_HEADER   pseudoHeader;
2785:                    TCPIP_UINT16_VAL        checksum1;
2786:                    TCPIP_UINT16_VAL        checksum2;
2787:                    uint8_t            optionsSize;
2788:                
2789:                    // Calculate IP pseudoheader checksum.
2790:                    pseudoHeader.SourceAddress      = remote->IPAddr;
9D003B4C  8FC20048   LW V0, 72(S8)
9D003B50  88430003   LWL V1, 3(V0)
9D003B54  00602021   ADDU A0, V1, ZERO
9D003B58  98440000   LWR A0, 0(V0)
9D003B5C  00801021   ADDU V0, A0, ZERO
9D003B60  AFC20028   SW V0, 40(S8)
2791:                    pseudoHeader.DestAddress        = *localIP;
9D003B64  8FC2004C   LW V0, 76(S8)
9D003B68  8C420000   LW V0, 0(V0)
9D003B6C  AFC2002C   SW V0, 44(S8)
2792:                    pseudoHeader.Zero               = 0x0;
9D003B70  A3C00030   SB ZERO, 48(S8)
2793:                    pseudoHeader.Protocol           = IP_PROT_TCP;
9D003B74  24020006   ADDIU V0, ZERO, 6
9D003B78  A3C20031   SB V0, 49(S8)
2794:                    pseudoHeader.Length             = len;
9D003B7C  97C20050   LHU V0, 80(S8)
9D003B80  A7C20032   SH V0, 50(S8)
2795:                
2796:                    SwapPseudoHeader(pseudoHeader);
9D003B84  97C20032   LHU V0, 50(S8)
9D003B88  00402021   ADDU A0, V0, ZERO
9D003B8C  0F403F50   JAL swaps
9D003B90  00000000   NOP
9D003B94  A7C20032   SH V0, 50(S8)
2797:                
2798:                    checksum1.Val = ~CalcIPChecksum((uint8_t*)&pseudoHeader,
9D003B98  27C20028   ADDIU V0, S8, 40
9D003B9C  00402021   ADDU A0, V0, ZERO
9D003BA0  2405000C   ADDIU A1, ZERO, 12
9D003BA4  0F403F9D   JAL CalcIPChecksum
9D003BA8  00000000   NOP
9D003BAC  00021027   NOR V0, ZERO, V0
9D003BB0  3042FFFF   ANDI V0, V0, -1
9D003BB4  A7C20034   SH V0, 52(S8)
2799:                        sizeof(pseudoHeader));
2800:                
2801:                    // Now calculate TCP packet checksum in NIC RAM - should match
2802:                    // pesudo header checksum
2803:                    checksum2.Val = CalcIPBufferChecksum(len);
9D003BB8  97C20050   LHU V0, 80(S8)
9D003BBC  00402021   ADDU A0, V0, ZERO
9D003BC0  0F404733   JAL CalcIPBufferChecksum
9D003BC4  00000000   NOP
9D003BC8  A7C20038   SH V0, 56(S8)
2804:                
2805:                    // Compare checksums.
2806:                    if(checksum1.Val != checksum2.Val)
9D003BCC  97C30034   LHU V1, 52(S8)
9D003BD0  97C20038   LHU V0, 56(S8)
9D003BD4  10620006   BEQ V1, V0, 0x9D003BF0
9D003BD8  00000000   NOP
2807:                    {
2808:                        MACDiscardRx();
9D003BDC  0F40462A   JAL MACDiscardRx
9D003BE0  00000000   NOP
2809:                        return true;
9D003BE4  24020001   ADDIU V0, ZERO, 1
9D003BE8  0B400F26   J 0x9D003C98
9D003BEC  00000000   NOP
2810:                    }
2811:                
2812:                #if defined(DEBUG_GENERATE_RX_LOSS)
2813:                    // Throw RX packets away randomly
2814:                    if(LFSRRand() > DEBUG_GENERATE_RX_LOSS)
2815:                    {
2816:                        MACDiscardRx();
2817:                        return true;
2818:                    }
2819:                #endif
2820:                
2821:                    // Retrieve TCP header.
2822:                    IPSetRxBuffer(0);
9D003BF0  00002021   ADDU A0, ZERO, ZERO
9D003BF4  0F406020   JAL IPSetRxBuffer
9D003BF8  00000000   NOP
2823:                    MACGetArray((uint8_t*)&TCPHeader, sizeof(TCPHeader));
9D003BFC  27C20014   ADDIU V0, S8, 20
9D003C00  00402021   ADDU A0, V0, ZERO
9D003C04  24050014   ADDIU A1, ZERO, 20
9D003C08  0F4046D1   JAL MACGetArray
9D003C0C  00000000   NOP
2824:                    SwapTCPHeader(&TCPHeader);
9D003C10  27C20014   ADDIU V0, S8, 20
9D003C14  00402021   ADDU A0, V0, ZERO
9D003C18  0F40142D   JAL 0x9D0050B4
9D003C1C  00000000   NOP
2825:                
2826:                
2827:                    // Skip over options to retrieve data bytes
2828:                    optionsSize = (uint8_t)((TCPHeader.DataOffset.Val << 2)-
9D003C20  8FC20020   LW V0, 32(S8)
9D003C24  7C421900   EXT V0, V0, 4, 4
9D003C28  304200FF   ANDI V0, V0, 255
9D003C2C  00021080   SLL V0, V0, 2
9D003C30  304200FF   ANDI V0, V0, 255
9D003C34  2442FFEC   ADDIU V0, V0, -20
9D003C38  A3C20010   SB V0, 16(S8)
2829:                        sizeof(TCPHeader));
2830:                    len = len - optionsSize - sizeof(TCPHeader);
9D003C3C  93C20010   LBU V0, 16(S8)
9D003C40  3042FFFF   ANDI V0, V0, -1
9D003C44  97C30050   LHU V1, 80(S8)
9D003C48  00621023   SUBU V0, V1, V0
9D003C4C  3042FFFF   ANDI V0, V0, -1
9D003C50  2442FFEC   ADDIU V0, V0, -20
9D003C54  A7C20050   SH V0, 80(S8)
2831:                
2832:                    // Find matching socket.
2833:                    if(FindMatchingSocket(&TCPHeader, remote))
9D003C58  27C20014   ADDIU V0, S8, 20
9D003C5C  00402021   ADDU A0, V0, ZERO
9D003C60  8FC50048   LW A1, 72(S8)
9D003C64  0F4012A8   JAL 0x9D004AA0
9D003C68  00000000   NOP
9D003C6C  10400007   BEQ V0, ZERO, 0x9D003C8C
9D003C70  00000000   NOP
2834:                    {
2835:                        #if defined(STACK_USE_SSL)
2836:                        PTR_BASE prevRxHead;
2837:                        // For SSL connections, show HandleTCPSeg() the full data buffer
2838:                        prevRxHead = MyTCBStub.rxHead;
2839:                        if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2840:                            MyTCBStub.rxHead = MyTCBStub.sslRxHead;
2841:                        #endif
2842:                
2843:                        HandleTCPSeg(&TCPHeader, len);
9D003C74  97C20050   LHU V0, 80(S8)
9D003C78  27C30014   ADDIU V1, S8, 20
9D003C7C  00602021   ADDU A0, V1, ZERO
9D003C80  00402821   ADDU A1, V0, ZERO
9D003C84  0F401606   JAL 0x9D005818
9D003C88  00000000   NOP
2844:                
2845:                        #if defined(STACK_USE_SSL)
2846:                        if(MyTCBStub.sslStubID != SSL_INVALID_ID)
2847:                        {
2848:                            // Restore the buffer state
2849:                            MyTCBStub.sslRxHead = MyTCBStub.rxHead;
2850:                            MyTCBStub.rxHead = prevRxHead;
2851:                
2852:                            // Process the new SSL data, using the currently loaded stub
2853:                            TCPSSLHandleIncoming(hCurrentTCP);
2854:                        }
2855:                        #endif
2856:                    }
2857:                //  else
2858:                //  {
2859:                //      // NOTE: RFC 793 specifies that if the socket is closed and a segment
2860:                //      // arrives, we should send back a RST if the RST bit in the incoming
2861:                //      // packet is not set.  Instead, we will just silently ignore such a
2862:                //      // packet since this is what firewalls do on purpose to enhance
2863:                //      // security.
2864:                //      //if(!TCPHeader.Flags.bits.flagRST)
2865:                //      //  SendTCP(RST, SENDTCP_RESET_TIMERS);
2866:                //  }
2867:                
2868:                    // Finished with this packet, discard it and free the Ethernet RAM for new packets
2869:                    MACDiscardRx();
9D003C8C  0F40462A   JAL MACDiscardRx
9D003C90  00000000   NOP
2870:                
2871:                    return true;
9D003C94  24020001   ADDIU V0, ZERO, 1
2872:                }
9D003C98  03C0E821   ADDU SP, S8, ZERO
9D003C9C  8FBF0044   LW RA, 68(SP)
9D003CA0  8FBE0040   LW S8, 64(SP)
9D003CA4  27BD0048   ADDIU SP, SP, 72
9D003CA8  03E00008   JR RA
9D003CAC  00000000   NOP
2873:                
2874:                
2875:                /*****************************************************************************
2876:                  Function:
2877:                    static void SendTCP(uint8_t vTCPFlags, uint8_t vSendFlags)
2878:                
2879:                  Summary:
2880:                    Transmits a TPC segment.
2881:                
2882:                  Description:
2883:                    This function assembles and transmits a TCP segment, including any
2884:                    pending data.  It also supports retransmissions, keep-alives, and
2885:                    other packet types.
2886:                
2887:                  Precondition:
2888:                    TCP is initialized.
2889:                
2890:                  Parameters:
2891:                    vTCPFlags - Additional TCP flags to include
2892:                    vSendFlags - Any combinations of SENDTCP_* constants to modify the
2893:                                 transmit behavior or contents.
2894:                
2895:                  Returns:
2896:                    None
2897:                  ***************************************************************************/
2898:                static void SendTCP(uint8_t vTCPFlags, uint8_t vSendFlags)
2899:                {
9D003CB0  27BDFFA8   ADDIU SP, SP, -88
9D003CB4  AFBF0054   SW RA, 84(SP)
9D003CB8  AFBE0050   SW S8, 80(SP)
9D003CBC  AFB0004C   SW S0, 76(SP)
9D003CC0  03A0F021   ADDU S8, SP, ZERO
9D003CC4  00801821   ADDU V1, A0, ZERO
9D003CC8  00A01021   ADDU V0, A1, ZERO
9D003CCC  A3C30058   SB V1, 88(S8)
9D003CD0  A3C2005C   SB V0, 92(S8)
2900:                    TCPIP_UINT16_VAL        wVal;
2901:                    TCP_HEADER      header;
2902:                    TCP_OPTIONS     options;
2903:                    PSEUDO_HEADER   pseudoHeader;
2904:                    uint16_t            len;
2905:                
2906:                    SyncTCB();
9D003CD4  0F400000   JAL 0x9D000000
9D003CD8  00000000   NOP
2907:                
2908:                    // FINs must be handled specially
2909:                    if(vTCPFlags & FIN)
9D003CDC  93C20058   LBU V0, 88(S8)
9D003CE0  30420001   ANDI V0, V0, 1
9D003CE4  304200FF   ANDI V0, V0, 255
9D003CE8  10400010   BEQ V0, ZERO, 0x9D003D2C
9D003CEC  00000000   NOP
2910:                    {
2911:                        MyTCBStub.Flags.bTXFIN = 1;
9D003CF0  93828014   LBU V0, -32748(GP)
9D003CF4  3C04A000   LUI A0, -24576
9D003CF8  00021100   SLL V0, V0, 4
9D003CFC  00021880   SLL V1, V0, 2
9D003D00  00621823   SUBU V1, V1, V0
9D003D04  2482753C   ADDIU V0, A0, 30012
9D003D08  00621821   ADDU V1, V1, V0
9D003D0C  8C620028   LW V0, 40(V1)
9D003D10  24040001   ADDIU A0, ZERO, 1
9D003D14  7C825AC4   INS V0, A0, 11, 1
9D003D18  AC620028   SW V0, 40(V1)
2912:                        vTCPFlags &= ~FIN;
9D003D1C  93C30058   LBU V1, 88(S8)
9D003D20  2402FFFE   ADDIU V0, ZERO, -2
9D003D24  00621024   AND V0, V1, V0
9D003D28  A3C20058   SB V0, 88(S8)
2913:                    }
2914:                
2915:                    // Status will now be synched, disable automatic future
2916:                    // status transmissions
2917:                    MyTCBStub.Flags.bTimer2Enabled = 0;
9D003D2C  93828014   LBU V0, -32748(GP)
9D003D30  3C04A000   LUI A0, -24576
9D003D34  00021100   SLL V0, V0, 4
9D003D38  00021880   SLL V1, V0, 2
9D003D3C  00621823   SUBU V1, V1, V0
9D003D40  2482753C   ADDIU V0, A0, 30012
9D003D44  00621821   ADDU V1, V1, V0
9D003D48  8C620028   LW V0, 40(V1)
9D003D4C  7C022944   INS V0, ZERO, 5, 1
9D003D50  AC620028   SW V0, 40(V1)
2918:                    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9D003D54  93828014   LBU V0, -32748(GP)
9D003D58  3C04A000   LUI A0, -24576
9D003D5C  00021100   SLL V0, V0, 4
9D003D60  00021880   SLL V1, V0, 2
9D003D64  00621823   SUBU V1, V1, V0
9D003D68  2482753C   ADDIU V0, A0, 30012
9D003D6C  00621821   ADDU V1, V1, V0
9D003D70  8C620028   LW V0, 40(V1)
9D003D74  7C023184   INS V0, ZERO, 6, 1
9D003D78  AC620028   SW V0, 40(V1)
2919:                    MyTCBStub.Flags.bOneSegmentReceived = 0;
9D003D7C  93828014   LBU V0, -32748(GP)
9D003D80  3C04A000   LUI A0, -24576
9D003D84  00021100   SLL V0, V0, 4
9D003D88  00021880   SLL V1, V0, 2
9D003D8C  00621823   SUBU V1, V1, V0
9D003D90  2482753C   ADDIU V0, A0, 30012
9D003D94  00621821   ADDU V1, V1, V0
9D003D98  8C620028   LW V0, 40(V1)
9D003D9C  7C0239C4   INS V0, ZERO, 7, 1
9D003DA0  AC620028   SW V0, 40(V1)
2920:                    MyTCBStub.Flags.bTXASAP = 0;
9D003DA4  93828014   LBU V0, -32748(GP)
9D003DA8  3C04A000   LUI A0, -24576
9D003DAC  00021100   SLL V0, V0, 4
9D003DB0  00021880   SLL V1, V0, 2
9D003DB4  00621823   SUBU V1, V1, V0
9D003DB8  2482753C   ADDIU V0, A0, 30012
9D003DBC  00621821   ADDU V1, V1, V0
9D003DC0  8C620028   LW V0, 40(V1)
9D003DC4  7C024A44   INS V0, ZERO, 9, 1
9D003DC8  AC620028   SW V0, 40(V1)
2921:                    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9D003DCC  93828014   LBU V0, -32748(GP)
9D003DD0  3C04A000   LUI A0, -24576
9D003DD4  00021100   SLL V0, V0, 4
9D003DD8  00021880   SLL V1, V0, 2
9D003DDC  00621823   SUBU V1, V1, V0
9D003DE0  2482753C   ADDIU V0, A0, 30012
9D003DE4  00621821   ADDU V1, V1, V0
9D003DE8  8C620028   LW V0, 40(V1)
9D003DEC  7C025284   INS V0, ZERO, 10, 1
9D003DF0  AC620028   SW V0, 40(V1)
2922:                    MyTCBStub.Flags.bHalfFullFlush = 0;
9D003DF4  93828014   LBU V0, -32748(GP)
9D003DF8  3C04A000   LUI A0, -24576
9D003DFC  00021100   SLL V0, V0, 4
9D003E00  00021880   SLL V1, V0, 2
9D003E04  00621823   SUBU V1, V1, V0
9D003E08  2482753C   ADDIU V0, A0, 30012
9D003E0C  00621821   ADDU V1, V1, V0
9D003E10  8C620028   LW V0, 40(V1)
9D003E14  7C024204   INS V0, ZERO, 8, 1
9D003E18  AC620028   SW V0, 40(V1)
2923:                
2924:                    //  Make sure that we can write to the MAC transmit area
2925:                    while(!IPIsTxReady());
9D003E1C  00000000   NOP
9D003E20  0F40453A   JAL MACIsTxReady
9D003E24  00000000   NOP
9D003E28  38420001   XORI V0, V0, 1
9D003E2C  304200FF   ANDI V0, V0, 255
9D003E30  1440FFFB   BNE V0, ZERO, 0x9D003E20
9D003E34  00000000   NOP
2926:                
2927:                    // Put all socket application data in the TX space
2928:                    if(vTCPFlags & (SYN | RST))
9D003E38  93C20058   LBU V0, 88(S8)
9D003E3C  30420006   ANDI V0, V0, 6
9D003E40  10400004   BEQ V0, ZERO, 0x9D003E54
9D003E44  00000000   NOP
2929:                    {
2930:                        // Don't put any data in SYN and RST messages
2931:                        len = 0;
9D003E48  A7C00018   SH ZERO, 24(S8)
9D003E4C  0B4010DC   J 0x9D004370
9D003E50  00000000   NOP
2932:                    }
2933:                    else
2934:                    {
2935:                        // Begin copying any application data over to the TX space
2936:                        if(MyTCBStub.txHead == MyTCB.txUnackedTail)
9D003E54  93828014   LBU V0, -32748(GP)
9D003E58  3C03A000   LUI V1, -24576
9D003E5C  2463753C   ADDIU V1, V1, 30012
9D003E60  00021100   SLL V0, V0, 4
9D003E64  00022080   SLL A0, V0, 2
9D003E68  00821023   SUBU V0, A0, V0
9D003E6C  00621021   ADDU V0, V1, V0
9D003E70  8C43000C   LW V1, 12(V0)
9D003E74  3C02A000   LUI V0, -24576
9D003E78  2442759C   ADDIU V0, V0, 30108
9D003E7C  8C42000C   LW V0, 12(V0)
9D003E80  14620004   BNE V1, V0, 0x9D003E94
9D003E84  00000000   NOP
2937:                        {
2938:                            // All caught up on data TX, no real data for this packet
2939:                            len = 0;
9D003E88  A7C00018   SH ZERO, 24(S8)
9D003E8C  0B4010C1   J 0x9D004304
9D003E90  00000000   NOP
2940:                        }
2941:                        else if(MyTCBStub.txHead > MyTCB.txUnackedTail)
9D003E94  93828014   LBU V0, -32748(GP)
9D003E98  3C03A000   LUI V1, -24576
9D003E9C  2463753C   ADDIU V1, V1, 30012
9D003EA0  00021100   SLL V0, V0, 4
9D003EA4  00022080   SLL A0, V0, 2
9D003EA8  00821023   SUBU V0, A0, V0
9D003EAC  00621021   ADDU V0, V1, V0
9D003EB0  8C43000C   LW V1, 12(V0)
9D003EB4  3C02A000   LUI V0, -24576
9D003EB8  2442759C   ADDIU V0, V0, 30108
9D003EBC  8C42000C   LW V0, 12(V0)
9D003EC0  0043102B   SLTU V0, V0, V1
9D003EC4  1040004F   BEQ V0, ZERO, 0x9D004004
9D003EC8  00000000   NOP
2942:                        {
2943:                            len = MyTCBStub.txHead - MyTCB.txUnackedTail;
9D003ECC  93828014   LBU V0, -32748(GP)
9D003ED0  3C03A000   LUI V1, -24576
9D003ED4  2463753C   ADDIU V1, V1, 30012
9D003ED8  00021100   SLL V0, V0, 4
9D003EDC  00022080   SLL A0, V0, 2
9D003EE0  00821023   SUBU V0, A0, V0
9D003EE4  00621021   ADDU V0, V1, V0
9D003EE8  8C42000C   LW V0, 12(V0)
9D003EEC  3043FFFF   ANDI V1, V0, -1
9D003EF0  3C02A000   LUI V0, -24576
9D003EF4  2442759C   ADDIU V0, V0, 30108
9D003EF8  8C42000C   LW V0, 12(V0)
9D003EFC  3042FFFF   ANDI V0, V0, -1
9D003F00  00621023   SUBU V0, V1, V0
9D003F04  A7C20018   SH V0, 24(S8)
2944:                
2945:                            if(len > MyTCB.remoteWindow)
9D003F08  3C02A000   LUI V0, -24576
9D003F0C  2442759C   ADDIU V0, V0, 30108
9D003F10  94420014   LHU V0, 20(V0)
9D003F14  97C30018   LHU V1, 24(S8)
9D003F18  0043102B   SLTU V0, V0, V1
9D003F1C  10400005   BEQ V0, ZERO, 0x9D003F34
9D003F20  00000000   NOP
2946:                                len = MyTCB.remoteWindow;
9D003F24  3C02A000   LUI V0, -24576
9D003F28  2442759C   ADDIU V0, V0, 30108
9D003F2C  94420014   LHU V0, 20(V0)
9D003F30  A7C20018   SH V0, 24(S8)
2947:                
2948:                            if(len > MyTCB.wRemoteMSS)
9D003F34  3C02A000   LUI V0, -24576
9D003F38  2442759C   ADDIU V0, V0, 30108
9D003F3C  94420028   LHU V0, 40(V0)
9D003F40  97C30018   LHU V1, 24(S8)
9D003F44  0043102B   SLTU V0, V0, V1
9D003F48  10400010   BEQ V0, ZERO, 0x9D003F8C
9D003F4C  00000000   NOP
2949:                            {
2950:                                len = MyTCB.wRemoteMSS;
9D003F50  3C02A000   LUI V0, -24576
9D003F54  2442759C   ADDIU V0, V0, 30108
9D003F58  94420028   LHU V0, 40(V0)
9D003F5C  A7C20018   SH V0, 24(S8)
2951:                                MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D003F60  93828014   LBU V0, -32748(GP)
9D003F64  3C04A000   LUI A0, -24576
9D003F68  00021100   SLL V0, V0, 4
9D003F6C  00021880   SLL V1, V0, 2
9D003F70  00621823   SUBU V1, V1, V0
9D003F74  2482753C   ADDIU V0, A0, 30012
9D003F78  00621821   ADDU V1, V1, V0
9D003F7C  8C620028   LW V0, 40(V1)
9D003F80  24040001   ADDIU A0, ZERO, 1
9D003F84  7C825284   INS V0, A0, 10, 1
9D003F88  AC620028   SW V0, 40(V1)
2952:                            }
2953:                
2954:                            // Copy application data into the raw TX buffer
2955:                            TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, len);
9D003F8C  0F404508   JAL MACGetTxBaseAddr
9D003F90  00000000   NOP
9D003F94  24440036   ADDIU A0, V0, 54
9D003F98  3C02A000   LUI V0, -24576
9D003F9C  2442759C   ADDIU V0, V0, 30108
9D003FA0  8C46000C   LW A2, 12(V0)
9D003FA4  93828014   LBU V0, -32748(GP)
9D003FA8  3C05A000   LUI A1, -24576
9D003FAC  00021100   SLL V0, V0, 4
9D003FB0  00021880   SLL V1, V0, 2
9D003FB4  00621823   SUBU V1, V1, V0
9D003FB8  24A2753C   ADDIU V0, A1, 30012
9D003FBC  00621021   ADDU V0, V1, V0
9D003FC0  9042002C   LBU V0, 44(V0)
9D003FC4  97C30018   LHU V1, 24(S8)
9D003FC8  AFA30010   SW V1, 16(SP)
9D003FCC  00002821   ADDU A1, ZERO, ZERO
9D003FD0  00403821   ADDU A3, V0, ZERO
9D003FD4  0F4020A8   JAL 0x9D0082A0
9D003FD8  00000000   NOP
2956:                            MyTCB.txUnackedTail += len;
9D003FDC  3C02A000   LUI V0, -24576
9D003FE0  2442759C   ADDIU V0, V0, 30108
9D003FE4  8C43000C   LW V1, 12(V0)
9D003FE8  97C20018   LHU V0, 24(S8)
9D003FEC  00621821   ADDU V1, V1, V0
9D003FF0  3C02A000   LUI V0, -24576
9D003FF4  2442759C   ADDIU V0, V0, 30108
9D003FF8  AC43000C   SW V1, 12(V0)
9D003FFC  0B4010C1   J 0x9D004304
9D004000  00000000   NOP
2957:                        }
2958:                        else
2959:                        {
2960:                            pseudoHeader.Length = MyTCBStub.bufferRxStart - MyTCB.txUnackedTail;
9D004004  93828014   LBU V0, -32748(GP)
9D004008  3C03A000   LUI V1, -24576
9D00400C  2463753C   ADDIU V1, V1, 30012
9D004010  00021100   SLL V0, V0, 4
9D004014  00022080   SLL A0, V0, 2
9D004018  00821023   SUBU V0, A0, V0
9D00401C  00621021   ADDU V0, V1, V0
9D004020  8C420004   LW V0, 4(V0)
9D004024  3043FFFF   ANDI V1, V0, -1
9D004028  3C02A000   LUI V0, -24576
9D00402C  2442759C   ADDIU V0, V0, 30108
9D004030  8C42000C   LW V0, 12(V0)
9D004034  3042FFFF   ANDI V0, V0, -1
9D004038  00621023   SUBU V0, V1, V0
9D00403C  3042FFFF   ANDI V0, V0, -1
9D004040  A7C20042   SH V0, 66(S8)
2961:                            len = pseudoHeader.Length + MyTCBStub.txHead - MyTCBStub.bufferTxStart;
9D004044  97C30042   LHU V1, 66(S8)
9D004048  93828014   LBU V0, -32748(GP)
9D00404C  3C04A000   LUI A0, -24576
9D004050  2484753C   ADDIU A0, A0, 30012
9D004054  00021100   SLL V0, V0, 4
9D004058  00022880   SLL A1, V0, 2
9D00405C  00A21023   SUBU V0, A1, V0
9D004060  00821021   ADDU V0, A0, V0
9D004064  8C42000C   LW V0, 12(V0)
9D004068  3042FFFF   ANDI V0, V0, -1
9D00406C  00621021   ADDU V0, V1, V0
9D004070  3044FFFF   ANDI A0, V0, -1
9D004074  93828014   LBU V0, -32748(GP)
9D004078  3C05A000   LUI A1, -24576
9D00407C  00021100   SLL V0, V0, 4
9D004080  00021880   SLL V1, V0, 2
9D004084  00621823   SUBU V1, V1, V0
9D004088  24A2753C   ADDIU V0, A1, 30012
9D00408C  00621021   ADDU V0, V1, V0
9D004090  8C420000   LW V0, 0(V0)
9D004094  3042FFFF   ANDI V0, V0, -1
9D004098  00821023   SUBU V0, A0, V0
9D00409C  A7C20018   SH V0, 24(S8)
2962:                
2963:                            if(len > MyTCB.remoteWindow)
9D0040A0  3C02A000   LUI V0, -24576
9D0040A4  2442759C   ADDIU V0, V0, 30108
9D0040A8  94420014   LHU V0, 20(V0)
9D0040AC  97C30018   LHU V1, 24(S8)
9D0040B0  0043102B   SLTU V0, V0, V1
9D0040B4  10400005   BEQ V0, ZERO, 0x9D0040CC
9D0040B8  00000000   NOP
2964:                                len = MyTCB.remoteWindow;
9D0040BC  3C02A000   LUI V0, -24576
9D0040C0  2442759C   ADDIU V0, V0, 30108
9D0040C4  94420014   LHU V0, 20(V0)
9D0040C8  A7C20018   SH V0, 24(S8)
2965:                
2966:                            if(len > MyTCB.wRemoteMSS)
9D0040CC  3C02A000   LUI V0, -24576
9D0040D0  2442759C   ADDIU V0, V0, 30108
9D0040D4  94420028   LHU V0, 40(V0)
9D0040D8  97C30018   LHU V1, 24(S8)
9D0040DC  0043102B   SLTU V0, V0, V1
9D0040E0  10400010   BEQ V0, ZERO, 0x9D004124
9D0040E4  00000000   NOP
2967:                            {
2968:                                len = MyTCB.wRemoteMSS;
9D0040E8  3C02A000   LUI V0, -24576
9D0040EC  2442759C   ADDIU V0, V0, 30108
9D0040F0  94420028   LHU V0, 40(V0)
9D0040F4  A7C20018   SH V0, 24(S8)
2969:                                MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D0040F8  93828014   LBU V0, -32748(GP)
9D0040FC  3C04A000   LUI A0, -24576
9D004100  00021100   SLL V0, V0, 4
9D004104  00021880   SLL V1, V0, 2
9D004108  00621823   SUBU V1, V1, V0
9D00410C  2482753C   ADDIU V0, A0, 30012
9D004110  00621821   ADDU V1, V1, V0
9D004114  8C620028   LW V0, 40(V1)
9D004118  24040001   ADDIU A0, ZERO, 1
9D00411C  7C825284   INS V0, A0, 10, 1
9D004120  AC620028   SW V0, 40(V1)
2970:                            }
2971:                
2972:                            if(pseudoHeader.Length > len)
9D004124  97C20042   LHU V0, 66(S8)
9D004128  97C30018   LHU V1, 24(S8)
9D00412C  0062102B   SLTU V0, V1, V0
9D004130  10400003   BEQ V0, ZERO, 0x9D004140
9D004134  00000000   NOP
2973:                                pseudoHeader.Length = len;
9D004138  97C20018   LHU V0, 24(S8)
9D00413C  A7C20042   SH V0, 66(S8)
2974:                
2975:                            // Copy application data into the raw TX buffer
2976:                            TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER), TCP_ETH_RAM, MyTCB.txUnackedTail, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9D004140  0F404508   JAL MACGetTxBaseAddr
9D004144  00000000   NOP
9D004148  24440036   ADDIU A0, V0, 54
9D00414C  3C02A000   LUI V0, -24576
9D004150  2442759C   ADDIU V0, V0, 30108
9D004154  8C46000C   LW A2, 12(V0)
9D004158  93828014   LBU V0, -32748(GP)
9D00415C  3C05A000   LUI A1, -24576
9D004160  00021100   SLL V0, V0, 4
9D004164  00021880   SLL V1, V0, 2
9D004168  00621823   SUBU V1, V1, V0
9D00416C  24A2753C   ADDIU V0, A1, 30012
9D004170  00621021   ADDU V0, V1, V0
9D004174  9042002C   LBU V0, 44(V0)
9D004178  97C30042   LHU V1, 66(S8)
9D00417C  AFA30010   SW V1, 16(SP)
9D004180  00002821   ADDU A1, ZERO, ZERO
9D004184  00403821   ADDU A3, V0, ZERO
9D004188  0F4020A8   JAL 0x9D0082A0
9D00418C  00000000   NOP
2977:                            pseudoHeader.Length = len - pseudoHeader.Length;
9D004190  97C20042   LHU V0, 66(S8)
9D004194  97C30018   LHU V1, 24(S8)
9D004198  00621023   SUBU V0, V1, V0
9D00419C  3042FFFF   ANDI V0, V0, -1
9D0041A0  A7C20042   SH V0, 66(S8)
2978:                
2979:                            // Copy any left over chunks of application data over
2980:                            if(pseudoHeader.Length)
9D0041A4  97C20042   LHU V0, 66(S8)
9D0041A8  10400028   BEQ V0, ZERO, 0x9D00424C
9D0041AC  00000000   NOP
2981:                            {
2982:                                TCPRAMCopy(BASE_TX_ADDR+sizeof(ETHER_HEADER)+sizeof(IP_HEADER)+sizeof(TCP_HEADER)+(MyTCBStub.bufferRxStart-MyTCB.txUnackedTail), TCP_ETH_RAM, MyTCBStub.bufferTxStart, MyTCBStub.vMemoryMedium, pseudoHeader.Length);
9D0041B0  0F404508   JAL MACGetTxBaseAddr
9D0041B4  00000000   NOP
9D0041B8  00401821   ADDU V1, V0, ZERO
9D0041BC  93828014   LBU V0, -32748(GP)
9D0041C0  3C04A000   LUI A0, -24576
9D0041C4  2484753C   ADDIU A0, A0, 30012
9D0041C8  00021100   SLL V0, V0, 4
9D0041CC  00022880   SLL A1, V0, 2
9D0041D0  00A21023   SUBU V0, A1, V0
9D0041D4  00821021   ADDU V0, A0, V0
9D0041D8  8C440004   LW A0, 4(V0)
9D0041DC  3C02A000   LUI V0, -24576
9D0041E0  2442759C   ADDIU V0, V0, 30108
9D0041E4  8C42000C   LW V0, 12(V0)
9D0041E8  00821023   SUBU V0, A0, V0
9D0041EC  00621021   ADDU V0, V1, V0
9D0041F0  24440036   ADDIU A0, V0, 54
9D0041F4  93828014   LBU V0, -32748(GP)
9D0041F8  3C05A000   LUI A1, -24576
9D0041FC  00021100   SLL V0, V0, 4
9D004200  00021880   SLL V1, V0, 2
9D004204  00621823   SUBU V1, V1, V0
9D004208  24A2753C   ADDIU V0, A1, 30012
9D00420C  00621021   ADDU V0, V1, V0
9D004210  8C460000   LW A2, 0(V0)
9D004214  93828014   LBU V0, -32748(GP)
9D004218  3C05A000   LUI A1, -24576
9D00421C  00021100   SLL V0, V0, 4
9D004220  00021880   SLL V1, V0, 2
9D004224  00621823   SUBU V1, V1, V0
9D004228  24A2753C   ADDIU V0, A1, 30012
9D00422C  00621021   ADDU V0, V1, V0
9D004230  9042002C   LBU V0, 44(V0)
9D004234  97C30042   LHU V1, 66(S8)
9D004238  AFA30010   SW V1, 16(SP)
9D00423C  00002821   ADDU A1, ZERO, ZERO
9D004240  00403821   ADDU A3, V0, ZERO
9D004244  0F4020A8   JAL 0x9D0082A0
9D004248  00000000   NOP
2983:                            }
2984:                
2985:                            MyTCB.txUnackedTail += len;
9D00424C  3C02A000   LUI V0, -24576
9D004250  2442759C   ADDIU V0, V0, 30108
9D004254  8C43000C   LW V1, 12(V0)
9D004258  97C20018   LHU V0, 24(S8)
9D00425C  00621821   ADDU V1, V1, V0
9D004260  3C02A000   LUI V0, -24576
9D004264  2442759C   ADDIU V0, V0, 30108
9D004268  AC43000C   SW V1, 12(V0)
2986:                            if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9D00426C  3C02A000   LUI V0, -24576
9D004270  2442759C   ADDIU V0, V0, 30108
9D004274  8C43000C   LW V1, 12(V0)
9D004278  93828014   LBU V0, -32748(GP)
9D00427C  3C04A000   LUI A0, -24576
9D004280  2484753C   ADDIU A0, A0, 30012
9D004284  00021100   SLL V0, V0, 4
9D004288  00022880   SLL A1, V0, 2
9D00428C  00A21023   SUBU V0, A1, V0
9D004290  00821021   ADDU V0, A0, V0
9D004294  8C420004   LW V0, 4(V0)
9D004298  0062102B   SLTU V0, V1, V0
9D00429C  14400019   BNE V0, ZERO, 0x9D004304
9D0042A0  00000000   NOP
2987:                                MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart-MyTCBStub.bufferTxStart;
9D0042A4  3C02A000   LUI V0, -24576
9D0042A8  2442759C   ADDIU V0, V0, 30108
9D0042AC  8C44000C   LW A0, 12(V0)
9D0042B0  93828014   LBU V0, -32748(GP)
9D0042B4  3C05A000   LUI A1, -24576
9D0042B8  00021100   SLL V0, V0, 4
9D0042BC  00021880   SLL V1, V0, 2
9D0042C0  00621823   SUBU V1, V1, V0
9D0042C4  24A2753C   ADDIU V0, A1, 30012
9D0042C8  00621021   ADDU V0, V1, V0
9D0042CC  8C430000   LW V1, 0(V0)
9D0042D0  93828014   LBU V0, -32748(GP)
9D0042D4  3C05A000   LUI A1, -24576
9D0042D8  24A5753C   ADDIU A1, A1, 30012
9D0042DC  00021100   SLL V0, V0, 4
9D0042E0  00023080   SLL A2, V0, 2
9D0042E4  00C21023   SUBU V0, A2, V0
9D0042E8  00A21021   ADDU V0, A1, V0
9D0042EC  8C420004   LW V0, 4(V0)
9D0042F0  00621023   SUBU V0, V1, V0
9D0042F4  00821821   ADDU V1, A0, V0
9D0042F8  3C02A000   LUI V0, -24576
9D0042FC  2442759C   ADDIU V0, V0, 30108
9D004300  AC43000C   SW V1, 12(V0)
2988:                        }
2989:                
2990:                        // If we are to transmit a FIN, make sure we can put one in this packet
2991:                        if(MyTCBStub.Flags.bTXFIN)
9D004304  93828014   LBU V0, -32748(GP)
9D004308  3C04A000   LUI A0, -24576
9D00430C  00021100   SLL V0, V0, 4
9D004310  00021880   SLL V1, V0, 2
9D004314  00621823   SUBU V1, V1, V0
9D004318  2482753C   ADDIU V0, A0, 30012
9D00431C  00621021   ADDU V0, V1, V0
9D004320  8C420028   LW V0, 40(V0)
9D004324  7C4202C0   EXT V0, V0, 11, 1
9D004328  304200FF   ANDI V0, V0, 255
9D00432C  10400010   BEQ V0, ZERO, 0x9D004370
9D004330  00000000   NOP
2992:                        {
2993:                            if((len != MyTCB.remoteWindow) && (len != MyTCB.wRemoteMSS))
9D004334  3C02A000   LUI V0, -24576
9D004338  2442759C   ADDIU V0, V0, 30108
9D00433C  94420014   LHU V0, 20(V0)
9D004340  97C30018   LHU V1, 24(S8)
9D004344  1062000A   BEQ V1, V0, 0x9D004370
9D004348  00000000   NOP
9D00434C  3C02A000   LUI V0, -24576
9D004350  2442759C   ADDIU V0, V0, 30108
9D004354  94420028   LHU V0, 40(V0)
9D004358  97C30018   LHU V1, 24(S8)
9D00435C  10620004   BEQ V1, V0, 0x9D004370
9D004360  00000000   NOP
2994:                                vTCPFlags |= FIN;
9D004364  93C20058   LBU V0, 88(S8)
9D004368  34420001   ORI V0, V0, 1
9D00436C  A3C20058   SB V0, 88(S8)
2995:                        }
2996:                    }
2997:                
2998:                    // Ensure that all packets with data of some kind are
2999:                    // retransmitted by TCPTick() until acknowledged
3000:                    // Pure ACK packets with no data are not ACKed back in TCP
3001:                    if(len || (vTCPFlags & (SYN | FIN)))
9D004370  97C20018   LHU V0, 24(S8)
9D004374  14400005   BNE V0, ZERO, 0x9D00438C
9D004378  00000000   NOP
9D00437C  93C20058   LBU V0, 88(S8)
9D004380  30420003   ANDI V0, V0, 3
9D004384  10400039   BEQ V0, ZERO, 0x9D00446C
9D004388  00000000   NOP
3002:                    {
3003:                        // Transmitting data, update remote window variable to reflect smaller
3004:                        // window.
3005:                        MyTCB.remoteWindow -= len;
9D00438C  3C02A000   LUI V0, -24576
9D004390  2442759C   ADDIU V0, V0, 30108
9D004394  94430014   LHU V1, 20(V0)
9D004398  97C20018   LHU V0, 24(S8)
9D00439C  00621023   SUBU V0, V1, V0
9D0043A0  3043FFFF   ANDI V1, V0, -1
9D0043A4  3C02A000   LUI V0, -24576
9D0043A8  2442759C   ADDIU V0, V0, 30108
9D0043AC  A4430014   SH V1, 20(V0)
3006:                
3007:                        // Push (PSH) all data for enhanced responsiveness on
3008:                        // the remote end, especially with GUIs
3009:                        if(len)
9D0043B0  97C20018   LHU V0, 24(S8)
9D0043B4  10400004   BEQ V0, ZERO, 0x9D0043C8
9D0043B8  00000000   NOP
3010:                            vTCPFlags |= PSH;
9D0043BC  93C20058   LBU V0, 88(S8)
9D0043C0  34420008   ORI V0, V0, 8
9D0043C4  A3C20058   SB V0, 88(S8)
3011:                
3012:                        if(vSendFlags & SENDTCP_RESET_TIMERS)
9D0043C8  93C2005C   LBU V0, 92(S8)
9D0043CC  30420001   ANDI V0, V0, 1
9D0043D0  304200FF   ANDI V0, V0, 255
9D0043D4  10400008   BEQ V0, ZERO, 0x9D0043F8
9D0043D8  00000000   NOP
3013:                        {
3014:                            MyTCB.retryCount = 0;
9D0043DC  3C02A000   LUI V0, -24576
9D0043E0  2442759C   ADDIU V0, V0, 30108
9D0043E4  A040002A   SB ZERO, 42(V0)
3015:                            MyTCB.retryInterval = TCP_START_TIMEOUT_VAL;
9D0043E8  3C02A000   LUI V0, -24576
9D0043EC  3C030004   LUI V1, 4
9D0043F0  3463C4B4   ORI V1, V1, -15180
9D0043F4  AC43759C   SW V1, 30108(V0)
3016:                        }
3017:                
3018:                        MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9D0043F8  93828014   LBU V0, -32748(GP)
9D0043FC  00408021   ADDU S0, V0, ZERO
9D004400  0F405C42   JAL TickGet
9D004404  00000000   NOP
9D004408  00401821   ADDU V1, V0, ZERO
9D00440C  3C02A000   LUI V0, -24576
9D004410  8C42759C   LW V0, 30108(V0)
9D004414  00621821   ADDU V1, V1, V0
9D004418  3C02A000   LUI V0, -24576
9D00441C  2444753C   ADDIU A0, V0, 30012
9D004420  02001021   ADDU V0, S0, ZERO
9D004424  00021100   SLL V0, V0, 4
9D004428  00022880   SLL A1, V0, 2
9D00442C  00A21023   SUBU V0, A1, V0
9D004430  00821021   ADDU V0, A0, V0
9D004434  AC43001C   SW V1, 28(V0)
3019:                        MyTCBStub.Flags.bTimerEnabled = 1;
9D004438  93828014   LBU V0, -32748(GP)
9D00443C  3C04A000   LUI A0, -24576
9D004440  00021100   SLL V0, V0, 4
9D004444  00021880   SLL V1, V0, 2
9D004448  00621823   SUBU V1, V1, V0
9D00444C  2482753C   ADDIU V0, A0, 30012
9D004450  00621821   ADDU V1, V1, V0
9D004454  8C620028   LW V0, 40(V1)
9D004458  24040001   ADDIU A0, ZERO, 1
9D00445C  7C822104   INS V0, A0, 4, 1
9D004460  AC620028   SW V0, 40(V1)
9D004464  0B401175   J 0x9D0045D4
9D004468  00000000   NOP
3020:                    }
3021:                    else if(vSendFlags & SENDTCP_KEEP_ALIVE)
9D00446C  93C2005C   LBU V0, 92(S8)
9D004470  30420002   ANDI V0, V0, 2
9D004474  10400025   BEQ V0, ZERO, 0x9D00450C
9D004478  00000000   NOP
3022:                    {
3023:                        // Increment Keep Alive TX counter to handle disconnection if not response is returned
3024:                        MyTCBStub.Flags.vUnackedKeepalives++;
9D00447C  93828014   LBU V0, -32748(GP)
9D004480  00402021   ADDU A0, V0, ZERO
9D004484  3C05A000   LUI A1, -24576
9D004488  00801021   ADDU V0, A0, ZERO
9D00448C  00021100   SLL V0, V0, 4
9D004490  00021880   SLL V1, V0, 2
9D004494  00621823   SUBU V1, V1, V0
9D004498  24A2753C   ADDIU V0, A1, 30012
9D00449C  00621021   ADDU V0, V1, V0
9D0044A0  8C420028   LW V0, 40(V0)
9D0044A4  7C421000   EXT V0, V0, 0, 3
9D0044A8  304200FF   ANDI V0, V0, 255
9D0044AC  24420001   ADDIU V0, V0, 1
9D0044B0  30420007   ANDI V0, V0, 7
9D0044B4  304500FF   ANDI A1, V0, 255
9D0044B8  3C06A000   LUI A2, -24576
9D0044BC  00801021   ADDU V0, A0, ZERO
9D0044C0  00021100   SLL V0, V0, 4
9D0044C4  00021880   SLL V1, V0, 2
9D0044C8  00621823   SUBU V1, V1, V0
9D0044CC  24C2753C   ADDIU V0, A2, 30012
9D0044D0  00621821   ADDU V1, V1, V0
9D0044D4  8C620028   LW V0, 40(V1)
9D0044D8  7CA21004   INS V0, A1, 0, 3
9D0044DC  AC620028   SW V0, 40(V1)
3025:                
3026:                        // Generate a dummy byte
3027:                        MyTCB.MySEQ -= 1;
9D0044E0  3C02A000   LUI V0, -24576
9D0044E4  2442759C   ADDIU V0, V0, 30108
9D0044E8  8C420004   LW V0, 4(V0)
9D0044EC  2443FFFF   ADDIU V1, V0, -1
9D0044F0  3C02A000   LUI V0, -24576
9D0044F4  2442759C   ADDIU V0, V0, 30108
9D0044F8  AC430004   SW V1, 4(V0)
3028:                        len = 1;
9D0044FC  24020001   ADDIU V0, ZERO, 1
9D004500  A7C20018   SH V0, 24(S8)
9D004504  0B401175   J 0x9D0045D4
9D004508  00000000   NOP
3029:                    }
3030:                    else if(MyTCBStub.Flags.bTimerEnabled)
9D00450C  93828014   LBU V0, -32748(GP)
9D004510  3C04A000   LUI A0, -24576
9D004514  00021100   SLL V0, V0, 4
9D004518  00021880   SLL V1, V0, 2
9D00451C  00621823   SUBU V1, V1, V0
9D004520  2482753C   ADDIU V0, A0, 30012
9D004524  00621021   ADDU V0, V1, V0
9D004528  8C420028   LW V0, 40(V0)
9D00452C  7C420100   EXT V0, V0, 4, 1
9D004530  304200FF   ANDI V0, V0, 255
9D004534  10400027   BEQ V0, ZERO, 0x9D0045D4
9D004538  00000000   NOP
3031:                    {
3032:                        // If we have data to transmit, but the remote RX window is zero,
3033:                        // so we aren't transmitting any right now then make sure to not
3034:                        // extend the retry counter or timer.  This will stall our TX
3035:                        // with a periodic ACK sent to the remote node.
3036:                        if(!(vSendFlags & SENDTCP_RESET_TIMERS))
9D00453C  93C2005C   LBU V0, 92(S8)
9D004540  30420001   ANDI V0, V0, 1
9D004544  14400013   BNE V0, ZERO, 0x9D004594
9D004548  00000000   NOP
3037:                        {
3038:                            // Roll back retry counters since we can't send anything,
3039:                            // but only if we incremented it in the first place
3040:                            if(MyTCB.retryCount)
9D00454C  3C02A000   LUI V0, -24576
9D004550  2442759C   ADDIU V0, V0, 30108
9D004554  9042002A   LBU V0, 42(V0)
9D004558  1040000E   BEQ V0, ZERO, 0x9D004594
9D00455C  00000000   NOP
3041:                            {
3042:                                MyTCB.retryCount--;
9D004560  3C02A000   LUI V0, -24576
9D004564  2442759C   ADDIU V0, V0, 30108
9D004568  9042002A   LBU V0, 42(V0)
9D00456C  2442FFFF   ADDIU V0, V0, -1
9D004570  304300FF   ANDI V1, V0, 255
9D004574  3C02A000   LUI V0, -24576
9D004578  2442759C   ADDIU V0, V0, 30108
9D00457C  A043002A   SB V1, 42(V0)
3043:                                MyTCB.retryInterval >>= 1;
9D004580  3C02A000   LUI V0, -24576
9D004584  8C42759C   LW V0, 30108(V0)
9D004588  00021842   SRL V1, V0, 1
9D00458C  3C02A000   LUI V0, -24576
9D004590  AC43759C   SW V1, 30108(V0)
3044:                            }
3045:                        }
3046:                
3047:                        MyTCBStub.eventTime = TickGet() + MyTCB.retryInterval;
9D004594  93828014   LBU V0, -32748(GP)
9D004598  00408021   ADDU S0, V0, ZERO
9D00459C  0F405C42   JAL TickGet
9D0045A0  00000000   NOP
9D0045A4  00401821   ADDU V1, V0, ZERO
9D0045A8  3C02A000   LUI V0, -24576
9D0045AC  8C42759C   LW V0, 30108(V0)
9D0045B0  00621821   ADDU V1, V1, V0
9D0045B4  3C02A000   LUI V0, -24576
9D0045B8  2444753C   ADDIU A0, V0, 30012
9D0045BC  02001021   ADDU V0, S0, ZERO
9D0045C0  00021100   SLL V0, V0, 4
9D0045C4  00022880   SLL A1, V0, 2
9D0045C8  00A21023   SUBU V0, A1, V0
9D0045CC  00821021   ADDU V0, A0, V0
9D0045D0  AC43001C   SW V1, 28(V0)
3048:                    }
3049:                
3050:                
3051:                    header.SourcePort           = MyTCB.localPort.Val;
9D0045D4  3C02A000   LUI V0, -24576
9D0045D8  2442759C   ADDIU V0, V0, 30108
9D0045DC  94420012   LHU V0, 18(V0)
9D0045E0  A7C20020   SH V0, 32(S8)
3052:                    header.DestPort             = MyTCB.remotePort.Val;
9D0045E4  3C02A000   LUI V0, -24576
9D0045E8  2442759C   ADDIU V0, V0, 30108
9D0045EC  94420010   LHU V0, 16(V0)
9D0045F0  A7C20022   SH V0, 34(S8)
3053:                    header.SeqNumber            = MyTCB.MySEQ;
9D0045F4  3C02A000   LUI V0, -24576
9D0045F8  2442759C   ADDIU V0, V0, 30108
9D0045FC  8C420004   LW V0, 4(V0)
9D004600  AFC20024   SW V0, 36(S8)
3054:                    header.AckNumber            = MyTCB.RemoteSEQ;
9D004604  3C02A000   LUI V0, -24576
9D004608  2442759C   ADDIU V0, V0, 30108
9D00460C  8C420008   LW V0, 8(V0)
9D004610  AFC20028   SW V0, 40(S8)
3055:                    header.Flags.bits.Reserved2 = 0;
9D004614  8FC2002C   LW V0, 44(S8)
9D004618  7C027B84   INS V0, ZERO, 14, 2
9D00461C  AFC2002C   SW V0, 44(S8)
3056:                    header.DataOffset.Reserved3 = 0;
9D004620  8FC2002C   LW V0, 44(S8)
9D004624  7C021804   INS V0, ZERO, 0, 4
9D004628  AFC2002C   SW V0, 44(S8)
3057:                    header.Flags.byte           = vTCPFlags;
9D00462C  93C20058   LBU V0, 88(S8)
9D004630  A3C2002D   SB V0, 45(S8)
3058:                    header.UrgentPointer        = 0;
9D004634  A7C00032   SH ZERO, 50(S8)
3059:                
3060:                    // Update our send sequence number and ensure retransmissions
3061:                    // of SYNs and FINs use the right sequence number
3062:                    MyTCB.MySEQ += (uint32_t)len;
9D004638  3C02A000   LUI V0, -24576
9D00463C  2442759C   ADDIU V0, V0, 30108
9D004640  8C430004   LW V1, 4(V0)
9D004644  97C20018   LHU V0, 24(S8)
9D004648  00621821   ADDU V1, V1, V0
9D00464C  3C02A000   LUI V0, -24576
9D004650  2442759C   ADDIU V0, V0, 30108
9D004654  AC430004   SW V1, 4(V0)
3063:                    if(vTCPFlags & SYN)
9D004658  93C20058   LBU V0, 88(S8)
9D00465C  30420002   ANDI V0, V0, 2
9D004660  1040001F   BEQ V0, ZERO, 0x9D0046E0
9D004664  00000000   NOP
3064:                    {
3065:                        // SEG.ACK needs to be zero for the first SYN packet for compatibility
3066:                        // with certain paranoid TCP/IP stacks, even though the ACK flag isn't
3067:                        // set (indicating that the AckNumber field is unused).
3068:                        if(!(vTCPFlags & ACK))
9D004668  93C20058   LBU V0, 88(S8)
9D00466C  30420010   ANDI V0, V0, 16
9D004670  14400002   BNE V0, ZERO, 0x9D00467C
9D004674  00000000   NOP
3069:                            header.AckNumber = 0x00000000;
9D004678  AFC00028   SW ZERO, 40(S8)
3070:                
3071:                        if(MyTCB.flags.bSYNSent)
9D00467C  3C02A000   LUI V0, -24576
9D004680  2442759C   ADDIU V0, V0, 30108
9D004684  8C430024   LW V1, 36(V0)
9D004688  3C020002   LUI V0, 2
9D00468C  00621024   AND V0, V1, V0
9D004690  10400006   BEQ V0, ZERO, 0x9D0046AC
9D004694  00000000   NOP
3072:                            header.SeqNumber--;
9D004698  8FC20024   LW V0, 36(S8)
9D00469C  2442FFFF   ADDIU V0, V0, -1
9D0046A0  AFC20024   SW V0, 36(S8)
9D0046A4  0B4011B8   J 0x9D0046E0
9D0046A8  00000000   NOP
3073:                        else
3074:                        {
3075:                            MyTCB.MySEQ++;
9D0046AC  3C02A000   LUI V0, -24576
9D0046B0  2442759C   ADDIU V0, V0, 30108
9D0046B4  8C420004   LW V0, 4(V0)
9D0046B8  24430001   ADDIU V1, V0, 1
9D0046BC  3C02A000   LUI V0, -24576
9D0046C0  2442759C   ADDIU V0, V0, 30108
9D0046C4  AC430004   SW V1, 4(V0)
3076:                            MyTCB.flags.bSYNSent = 1;
9D0046C8  3C02A000   LUI V0, -24576
9D0046CC  2443759C   ADDIU V1, V0, 30108
9D0046D0  8C620024   LW V0, 36(V1)
9D0046D4  24040001   ADDIU A0, ZERO, 1
9D0046D8  7C828C44   INS V0, A0, 17, 1
9D0046DC  AC620024   SW V0, 36(V1)
3077:                        }
3078:                    }
3079:                    if(vTCPFlags & FIN)
9D0046E0  93C20058   LBU V0, 88(S8)
9D0046E4  30420001   ANDI V0, V0, 1
9D0046E8  304200FF   ANDI V0, V0, 255
9D0046EC  10400007   BEQ V0, ZERO, 0x9D00470C
9D0046F0  00000000   NOP
3080:                    {
3081:                        MyTCB.flags.bFINSent = 1;   // do not advance the seq no for FIN!
9D0046F4  3C02A000   LUI V0, -24576
9D0046F8  2443759C   ADDIU V1, V0, 30108
9D0046FC  8C620024   LW V0, 36(V1)
9D004700  24040001   ADDIU A0, ZERO, 1
9D004704  7C828404   INS V0, A0, 16, 1
9D004708  AC620024   SW V0, 36(V1)
3082:                    }
3083:                
3084:                    // Calculate the amount of free space in the RX buffer area of this socket
3085:                    if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D00470C  93828014   LBU V0, -32748(GP)
9D004710  3C03A000   LUI V1, -24576
9D004714  2463753C   ADDIU V1, V1, 30012
9D004718  00021100   SLL V0, V0, 4
9D00471C  00022080   SLL A0, V0, 2
9D004720  00821023   SUBU V0, A0, V0
9D004724  00621021   ADDU V0, V1, V0
9D004728  8C440014   LW A0, 20(V0)
9D00472C  93828014   LBU V0, -32748(GP)
9D004730  3C05A000   LUI A1, -24576
9D004734  00021100   SLL V0, V0, 4
9D004738  00021880   SLL V1, V0, 2
9D00473C  00621823   SUBU V1, V1, V0
9D004740  24A2753C   ADDIU V0, A1, 30012
9D004744  00621021   ADDU V0, V1, V0
9D004748  8C420018   LW V0, 24(V0)
9D00474C  0082102B   SLTU V0, A0, V0
9D004750  1440002E   BNE V0, ZERO, 0x9D00480C
9D004754  00000000   NOP
3086:                        header.Window = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9D004758  93828014   LBU V0, -32748(GP)
9D00475C  3C04A000   LUI A0, -24576
9D004760  00021100   SLL V0, V0, 4
9D004764  00021880   SLL V1, V0, 2
9D004768  00621823   SUBU V1, V1, V0
9D00476C  2482753C   ADDIU V0, A0, 30012
9D004770  00621021   ADDU V0, V1, V0
9D004774  8C420008   LW V0, 8(V0)
9D004778  3043FFFF   ANDI V1, V0, -1
9D00477C  93828014   LBU V0, -32748(GP)
9D004780  3C04A000   LUI A0, -24576
9D004784  2484753C   ADDIU A0, A0, 30012
9D004788  00021100   SLL V0, V0, 4
9D00478C  00022880   SLL A1, V0, 2
9D004790  00A21023   SUBU V0, A1, V0
9D004794  00821021   ADDU V0, A0, V0
9D004798  8C420004   LW V0, 4(V0)
9D00479C  3042FFFF   ANDI V0, V0, -1
9D0047A0  00621023   SUBU V0, V1, V0
9D0047A4  3044FFFF   ANDI A0, V0, -1
9D0047A8  93828014   LBU V0, -32748(GP)
9D0047AC  3C05A000   LUI A1, -24576
9D0047B0  00021100   SLL V0, V0, 4
9D0047B4  00021880   SLL V1, V0, 2
9D0047B8  00621823   SUBU V1, V1, V0
9D0047BC  24A2753C   ADDIU V0, A1, 30012
9D0047C0  00621021   ADDU V0, V1, V0
9D0047C4  8C420018   LW V0, 24(V0)
9D0047C8  3043FFFF   ANDI V1, V0, -1
9D0047CC  93828014   LBU V0, -32748(GP)
9D0047D0  3C05A000   LUI A1, -24576
9D0047D4  24A5753C   ADDIU A1, A1, 30012
9D0047D8  00021100   SLL V0, V0, 4
9D0047DC  00023080   SLL A2, V0, 2
9D0047E0  00C21023   SUBU V0, A2, V0
9D0047E4  00A21021   ADDU V0, A1, V0
9D0047E8  8C420014   LW V0, 20(V0)
9D0047EC  3042FFFF   ANDI V0, V0, -1
9D0047F0  00621023   SUBU V0, V1, V0
9D0047F4  3042FFFF   ANDI V0, V0, -1
9D0047F8  00821021   ADDU V0, A0, V0
9D0047FC  3042FFFF   ANDI V0, V0, -1
9D004800  A7C2002E   SH V0, 46(S8)
9D004804  0B40121A   J 0x9D004868
9D004808  00000000   NOP
3087:                    else
3088:                        header.Window = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9D00480C  93828014   LBU V0, -32748(GP)
9D004810  3C04A000   LUI A0, -24576
9D004814  00021100   SLL V0, V0, 4
9D004818  00021880   SLL V1, V0, 2
9D00481C  00621823   SUBU V1, V1, V0
9D004820  2482753C   ADDIU V0, A0, 30012
9D004824  00621021   ADDU V0, V1, V0
9D004828  8C420018   LW V0, 24(V0)
9D00482C  3043FFFF   ANDI V1, V0, -1
9D004830  93828014   LBU V0, -32748(GP)
9D004834  3C04A000   LUI A0, -24576
9D004838  2484753C   ADDIU A0, A0, 30012
9D00483C  00021100   SLL V0, V0, 4
9D004840  00022880   SLL A1, V0, 2
9D004844  00A21023   SUBU V0, A1, V0
9D004848  00821021   ADDU V0, A0, V0
9D00484C  8C420014   LW V0, 20(V0)
9D004850  3042FFFF   ANDI V0, V0, -1
9D004854  00621023   SUBU V0, V1, V0
9D004858  3042FFFF   ANDI V0, V0, -1
9D00485C  2442FFFF   ADDIU V0, V0, -1
9D004860  3042FFFF   ANDI V0, V0, -1
9D004864  A7C2002E   SH V0, 46(S8)
3089:                
3090:                    // Calculate the amount of free space in the MAC RX buffer area and adjust window if needed
3091:                    wVal.Val = MACGetFreeRxSize();
9D004868  0F4046ED   JAL MACGetFreeRxSize
9D00486C  00000000   NOP
9D004870  A7C2001C   SH V0, 28(S8)
3092:                    if(wVal.Val < 64)
9D004874  97C2001C   LHU V0, 28(S8)
9D004878  2C420040   SLTIU V0, V0, 64
9D00487C  10400004   BEQ V0, ZERO, 0x9D004890
9D004880  00000000   NOP
3093:                    {
3094:                        wVal.Val = 0;
9D004884  A7C0001C   SH ZERO, 28(S8)
9D004888  0B401228   J 0x9D0048A0
9D00488C  00000000   NOP
3095:                    }
3096:                    else
3097:                    {
3098:                        wVal.Val -= 64;
9D004890  97C2001C   LHU V0, 28(S8)
9D004894  2442FFC0   ADDIU V0, V0, -64
9D004898  3042FFFF   ANDI V0, V0, -1
9D00489C  A7C2001C   SH V0, 28(S8)
3099:                    }
3100:                    // Force the remote node to throttle back if we are running low on general RX buffer space
3101:                    if(header.Window > wVal.Val)
9D0048A0  97C3002E   LHU V1, 46(S8)
9D0048A4  97C2001C   LHU V0, 28(S8)
9D0048A8  0043102B   SLTU V0, V0, V1
9D0048AC  10400003   BEQ V0, ZERO, 0x9D0048BC
9D0048B0  00000000   NOP
3102:                        header.Window = wVal.Val;
9D0048B4  97C2001C   LHU V0, 28(S8)
9D0048B8  A7C2002E   SH V0, 46(S8)
3103:                
3104:                    SwapTCPHeader(&header);
9D0048BC  27C20020   ADDIU V0, S8, 32
9D0048C0  00402021   ADDU A0, V0, ZERO
9D0048C4  0F40142D   JAL 0x9D0050B4
9D0048C8  00000000   NOP
3105:                
3106:                
3107:                    len += sizeof(header);
9D0048CC  97C20018   LHU V0, 24(S8)
9D0048D0  24420014   ADDIU V0, V0, 20
9D0048D4  A7C20018   SH V0, 24(S8)
3108:                    header.DataOffset.Val   = sizeof(header) >> 2;
9D0048D8  8FC2002C   LW V0, 44(S8)
9D0048DC  24030005   ADDIU V1, ZERO, 5
9D0048E0  7C623904   INS V0, V1, 4, 4
9D0048E4  AFC2002C   SW V0, 44(S8)
3109:                
3110:                    // Insert the MSS (Maximum Segment Size) TCP option if this is SYN packet
3111:                    if(vTCPFlags & SYN)
9D0048E8  93C20058   LBU V0, 88(S8)
9D0048EC  30420002   ANDI V0, V0, 2
9D0048F0  10400014   BEQ V0, ZERO, 0x9D004944
9D0048F4  00000000   NOP
3112:                    {
3113:                        len += sizeof(options);
9D0048F8  97C20018   LHU V0, 24(S8)
9D0048FC  24420004   ADDIU V0, V0, 4
9D004900  A7C20018   SH V0, 24(S8)
3114:                        options.Kind = TCP_OPTIONS_MAX_SEG_SIZE;
9D004904  24020002   ADDIU V0, ZERO, 2
9D004908  A3C20034   SB V0, 52(S8)
3115:                        options.Length = 0x04;
9D00490C  24020004   ADDIU V0, ZERO, 4
9D004910  A3C20035   SB V0, 53(S8)
3116:                
3117:                        // Load MSS and swap to big endian
3118:                        options.MaxSegSize.Val = (((TCP_MAX_SEG_SIZE_RX)&0x00FF)<<8) | (((TCP_MAX_SEG_SIZE_RX)&0xFF00)>>8);
9D004914  24021802   ADDIU V0, ZERO, 6146
9D004918  A7C20036   SH V0, 54(S8)
3119:                
3120:                        header.DataOffset.Val   += sizeof(options) >> 2;
9D00491C  8FC2002C   LW V0, 44(S8)
9D004920  7C421900   EXT V0, V0, 4, 4
9D004924  304200FF   ANDI V0, V0, 255
9D004928  24420001   ADDIU V0, V0, 1
9D00492C  304200FF   ANDI V0, V0, 255
9D004930  3042000F   ANDI V0, V0, 15
9D004934  304300FF   ANDI V1, V0, 255
9D004938  8FC2002C   LW V0, 44(S8)
9D00493C  7C623904   INS V0, V1, 4, 4
9D004940  AFC2002C   SW V0, 44(S8)
3121:                    }
3122:                
3123:                    // Calculate IP pseudoheader checksum.
3124:                    pseudoHeader.SourceAddress  = AppConfig.MyIPAddr;
9D004944  3C02A000   LUI V0, -24576
9D004948  244308D8   ADDIU V1, V0, 2264
9D00494C  88630003   LWL V1, 3(V1)
9D004950  00602021   ADDU A0, V1, ZERO
9D004954  984408D8   LWR A0, 2264(V0)
9D004958  00801021   ADDU V0, A0, ZERO
9D00495C  AFC20038   SW V0, 56(S8)
3125:                    pseudoHeader.DestAddress    = MyTCB.remote.niRemoteMACIP.IPAddr;
9D004960  3C02A000   LUI V0, -24576
9D004964  2442759C   ADDIU V0, V0, 30108
9D004968  8C420018   LW V0, 24(V0)
9D00496C  AFC2003C   SW V0, 60(S8)
3126:                    pseudoHeader.Zero           = 0x0;
9D004970  A3C00040   SB ZERO, 64(S8)
3127:                    pseudoHeader.Protocol       = IP_PROT_TCP;
9D004974  24020006   ADDIU V0, ZERO, 6
9D004978  A3C20041   SB V0, 65(S8)
3128:                    pseudoHeader.Length         = len;
9D00497C  97C20018   LHU V0, 24(S8)
9D004980  A7C20042   SH V0, 66(S8)
3129:                    SwapPseudoHeader(pseudoHeader);
9D004984  97C20042   LHU V0, 66(S8)
9D004988  00402021   ADDU A0, V0, ZERO
9D00498C  0F403F50   JAL swaps
9D004990  00000000   NOP
9D004994  A7C20042   SH V0, 66(S8)
3130:                    header.Checksum = ~CalcIPChecksum((uint8_t*)&pseudoHeader, sizeof(pseudoHeader));
9D004998  27C20038   ADDIU V0, S8, 56
9D00499C  00402021   ADDU A0, V0, ZERO
9D0049A0  2405000C   ADDIU A1, ZERO, 12
9D0049A4  0F403F9D   JAL CalcIPChecksum
9D0049A8  00000000   NOP
9D0049AC  00021027   NOR V0, ZERO, V0
9D0049B0  3042FFFF   ANDI V0, V0, -1
9D0049B4  A7C20030   SH V0, 48(S8)
3131:                
3132:                    // Write IP header
3133:                    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D0049B8  0F404508   JAL MACGetTxBaseAddr
9D0049BC  00000000   NOP
9D0049C0  2442000E   ADDIU V0, V0, 14
9D0049C4  00402021   ADDU A0, V0, ZERO
9D0049C8  0F40452C   JAL MACSetWritePtr
9D0049CC  00000000   NOP
3134:                    IPPutHeader(&MyTCB.remote.niRemoteMACIP, IP_PROT_TCP, len);
9D0049D0  97C20018   LHU V0, 24(S8)
9D0049D4  3C03A000   LUI V1, -24576
9D0049D8  246475B4   ADDIU A0, V1, 30132
9D0049DC  24050006   ADDIU A1, ZERO, 6
9D0049E0  00403021   ADDU A2, V0, ZERO
9D0049E4  0F405FD5   JAL IPPutHeader
9D0049E8  00000000   NOP
3135:                    MACPutArray((uint8_t*)&header, sizeof(header));
9D0049EC  27C20020   ADDIU V0, S8, 32
9D0049F0  00402021   ADDU A0, V0, ZERO
9D0049F4  24050014   ADDIU A1, ZERO, 20
9D0049F8  0F4045BD   JAL MACPutArray
9D0049FC  00000000   NOP
3136:                    if(vTCPFlags & SYN)
9D004A00  93C20058   LBU V0, 88(S8)
9D004A04  30420002   ANDI V0, V0, 2
9D004A08  10400006   BEQ V0, ZERO, 0x9D004A24
9D004A0C  00000000   NOP
3137:                        MACPutArray((uint8_t*)&options, sizeof(options));
9D004A10  27C20034   ADDIU V0, S8, 52
9D004A14  00402021   ADDU A0, V0, ZERO
9D004A18  24050004   ADDIU A1, ZERO, 4
9D004A1C  0F4045BD   JAL MACPutArray
9D004A20  00000000   NOP
3138:                
3139:                    // Update the TCP checksum
3140:                    MACSetReadPtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER));
9D004A24  0F404508   JAL MACGetTxBaseAddr
9D004A28  00000000   NOP
9D004A2C  24420022   ADDIU V0, V0, 34
9D004A30  00402021   ADDU A0, V0, ZERO
9D004A34  0F4046B6   JAL MACSetReadPtr
9D004A38  00000000   NOP
3141:                    wVal.Val = CalcIPBufferChecksum(len);
9D004A3C  97C20018   LHU V0, 24(S8)
9D004A40  00402021   ADDU A0, V0, ZERO
9D004A44  0F404733   JAL CalcIPBufferChecksum
9D004A48  00000000   NOP
9D004A4C  A7C2001C   SH V0, 28(S8)
3142:                #if defined(DEBUG_GENERATE_TX_LOSS)
3143:                    // Damage TCP checksums on TX packets randomly
3144:                    if(LFSRRand() > DEBUG_GENERATE_TX_LOSS)
3145:                    {
3146:                        wVal.Val++;
3147:                    }
3148:                #endif
3149:                    MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER) + sizeof(IP_HEADER) + 16);
9D004A50  0F404508   JAL MACGetTxBaseAddr
9D004A54  00000000   NOP
9D004A58  24420032   ADDIU V0, V0, 50
9D004A5C  00402021   ADDU A0, V0, ZERO
9D004A60  0F40452C   JAL MACSetWritePtr
9D004A64  00000000   NOP
3150:                    MACPutArray((uint8_t*)&wVal, sizeof(uint16_t));
9D004A68  27C2001C   ADDIU V0, S8, 28
9D004A6C  00402021   ADDU A0, V0, ZERO
9D004A70  24050002   ADDIU A1, ZERO, 2
9D004A74  0F4045BD   JAL MACPutArray
9D004A78  00000000   NOP
3151:                
3152:                    // Physically start the packet transmission over the network
3153:                    MACFlush();
9D004A7C  0F40460E   JAL MACFlush
9D004A80  00000000   NOP
3154:                }
9D004A84  03C0E821   ADDU SP, S8, ZERO
9D004A88  8FBF0054   LW RA, 84(SP)
9D004A8C  8FBE0050   LW S8, 80(SP)
9D004A90  8FB0004C   LW S0, 76(SP)
9D004A94  27BD0058   ADDIU SP, SP, 88
9D004A98  03E00008   JR RA
9D004A9C  00000000   NOP
3155:                
3156:                /*****************************************************************************
3157:                  Function:
3158:                    static bool FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
3159:                
3160:                  Summary:
3161:                    Finds a suitable socket for a TCP segment.
3162:                
3163:                  Description:
3164:                    This function searches through the sockets and attempts to match one with
3165:                    a given TCP header and NODE_INFO structure.  If a socket is found, its
3166:                    index is saved in hCurrentTCP and the associated MyTCBStub and MyTCB are
3167:                    loaded. Otherwise, INVALID_SOCKET is placed in hCurrentTCP.
3168:                
3169:                  Precondition:
3170:                    TCP is initialized.
3171:                
3172:                  Parameters:
3173:                    h - TCP header to be matched against
3174:                    remote - The remote node who sent this header
3175:                
3176:                  Return Values:
3177:                    true - A match was found and is loaded in hCurrentTCP
3178:                    false - No suitable socket was found and hCurrentTCP is INVALID_SOCKET
3179:                  ***************************************************************************/
3180:                static bool FindMatchingSocket(TCP_HEADER* h, NODE_INFO* remote)
3181:                {
9D004AA0  27BDFFD8   ADDIU SP, SP, -40
9D004AA4  AFBF0024   SW RA, 36(SP)
9D004AA8  AFBE0020   SW S8, 32(SP)
9D004AAC  AFB0001C   SW S0, 28(SP)
9D004AB0  03A0F021   ADDU S8, SP, ZERO
9D004AB4  AFC40028   SW A0, 40(S8)
9D004AB8  AFC5002C   SW A1, 44(S8)
3182:                    TCP_SOCKET hTCP;
3183:                    TCP_SOCKET partialMatch;
3184:                    uint16_t hash;
3185:                
3186:                    // Prevent connections on invalid port 0
3187:                    if(h->DestPort == 0u)
9D004ABC  8FC20028   LW V0, 40(S8)
9D004AC0  94420002   LHU V0, 2(V0)
9D004AC4  14400004   BNE V0, ZERO, 0x9D004AD8
9D004AC8  00000000   NOP
3188:                        return false;
9D004ACC  00001021   ADDU V0, ZERO, ZERO
9D004AD0  0B401426   J 0x9D005098
9D004AD4  00000000   NOP
3189:                
3190:                    partialMatch = INVALID_SOCKET;
9D004AD8  2402FFFE   ADDIU V0, ZERO, -2
9D004ADC  A3C20011   SB V0, 17(S8)
3191:                    hash = (remote->IPAddr.w[1]+remote->IPAddr.w[0] + h->SourcePort) ^ h->DestPort;
9D004AE0  8FC2002C   LW V0, 44(S8)
9D004AE4  90430002   LBU V1, 2(V0)
9D004AE8  90420003   LBU V0, 3(V0)
9D004AEC  00021200   SLL V0, V0, 8
9D004AF0  00431025   OR V0, V0, V1
9D004AF4  3043FFFF   ANDI V1, V0, -1
9D004AF8  8FC2002C   LW V0, 44(S8)
9D004AFC  90440000   LBU A0, 0(V0)
9D004B00  90420001   LBU V0, 1(V0)
9D004B04  00021200   SLL V0, V0, 8
9D004B08  00441025   OR V0, V0, A0
9D004B0C  3042FFFF   ANDI V0, V0, -1
9D004B10  00621021   ADDU V0, V1, V0
9D004B14  3043FFFF   ANDI V1, V0, -1
9D004B18  8FC20028   LW V0, 40(S8)
9D004B1C  94420000   LHU V0, 0(V0)
9D004B20  00621021   ADDU V0, V1, V0
9D004B24  3042FFFF   ANDI V0, V0, -1
9D004B28  7C021E20   SEH V1, V0
9D004B2C  8FC20028   LW V0, 40(S8)
9D004B30  94420002   LHU V0, 2(V0)
9D004B34  7C021620   SEH V0, V0
9D004B38  00621026   XOR V0, V1, V0
9D004B3C  7C021620   SEH V0, V0
9D004B40  A7C20014   SH V0, 20(S8)
3192:                
3193:                    // Loop through all sockets looking for a socket that is expecting this
3194:                    // packet or can handle it.
3195:                    for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++ )
9D004B44  A3C00010   SB ZERO, 16(S8)
9D004B48  0B40132C   J 0x9D004CB0
9D004B4C  00000000   NOP
9D004CA4  93C20010   LBU V0, 16(S8)
9D004CA8  24420001   ADDIU V0, V0, 1
9D004CAC  A3C20010   SB V0, 16(S8)
9D004CB0  93C20010   LBU V0, 16(S8)
9D004CB4  2C420002   SLTIU V0, V0, 2
9D004CB8  1440FFA5   BNE V0, ZERO, 0x9D004B50
9D004CBC  00000000   NOP
3196:                    {
3197:                        SyncTCBStub(hTCP);
9D004B50  93C20010   LBU V0, 16(S8)
9D004B54  A3828014   SB V0, -32748(GP)
3198:                
3199:                        if(MyTCBStub.smState == TCP_CLOSED)
9D004B58  93828014   LBU V0, -32748(GP)
9D004B5C  3C03A000   LUI V1, -24576
9D004B60  2463753C   ADDIU V1, V1, 30012
9D004B64  00021100   SLL V0, V0, 4
9D004B68  00022080   SLL A0, V0, 2
9D004B6C  00821023   SUBU V0, A0, V0
9D004B70  00621021   ADDU V0, V1, V0
9D004B74  8C430024   LW V1, 36(V0)
9D004B78  2402000D   ADDIU V0, ZERO, 13
9D004B7C  10620042   BEQ V1, V0, 0x9D004C88
9D004B80  00000000   NOP
3200:                        {
3201:                            continue;
9D004C88  00000000   NOP
9D004C8C  0B401329   J 0x9D004CA4
9D004C90  00000000   NOP
3202:                        }
3203:                        else if(MyTCBStub.smState == TCP_LISTEN)
9D004B84  93828014   LBU V0, -32748(GP)
9D004B88  3C03A000   LUI V1, -24576
9D004B8C  2463753C   ADDIU V1, V1, 30012
9D004B90  00021100   SLL V0, V0, 4
9D004B94  00022080   SLL A0, V0, 2
9D004B98  00821023   SUBU V0, A0, V0
9D004B9C  00621021   ADDU V0, V1, V0
9D004BA0  8C430024   LW V1, 36(V0)
9D004BA4  24020004   ADDIU V0, ZERO, 4
9D004BA8  14620011   BNE V1, V0, 0x9D004BF0
9D004BAC  00000000   NOP
3204:                        {// For listening ports, check if this is the correct port
3205:                            if(MyTCBStub.remoteHash.Val == h->DestPort)
9D004BB0  93828014   LBU V0, -32748(GP)
9D004BB4  3C04A000   LUI A0, -24576
9D004BB8  00021100   SLL V0, V0, 4
9D004BBC  00021880   SLL V1, V0, 2
9D004BC0  00621823   SUBU V1, V1, V0
9D004BC4  2482753C   ADDIU V0, A0, 30012
9D004BC8  00621021   ADDU V0, V1, V0
9D004BCC  9443002A   LHU V1, 42(V0)
9D004BD0  8FC20028   LW V0, 40(S8)
9D004BD4  94420002   LHU V0, 2(V0)
9D004BD8  1462002E   BNE V1, V0, 0x9D004C94
9D004BDC  00000000   NOP
3206:                                partialMatch = hTCP;
9D004BE0  93C20010   LBU V0, 16(S8)
9D004BE4  A3C20011   SB V0, 17(S8)
3207:                
3208:                            #if defined(STACK_USE_SSL_SERVER)
3209:                            // Check the SSL port as well for SSL Servers
3210:                            // 0 is defined as an invalid port number
3211:                            if(MyTCBStub.sslTxHead == h->DestPort)
3212:                                partialMatch = hTCP;
3213:                            #endif
3214:                
3215:                            continue;
9D004BE8  0B401329   J 0x9D004CA4
9D004BEC  00000000   NOP
9D004C94  00000000   NOP
9D004C98  0B401329   J 0x9D004CA4
9D004C9C  00000000   NOP
3216:                        }
3217:                        else if(MyTCBStub.remoteHash.Val != hash)
9D004BF0  93828014   LBU V0, -32748(GP)
9D004BF4  3C04A000   LUI A0, -24576
9D004BF8  00021100   SLL V0, V0, 4
9D004BFC  00021880   SLL V1, V0, 2
9D004C00  00621823   SUBU V1, V1, V0
9D004C04  2482753C   ADDIU V0, A0, 30012
9D004C08  00621021   ADDU V0, V1, V0
9D004C0C  9442002A   LHU V0, 42(V0)
9D004C10  97C30014   LHU V1, 20(S8)
9D004C14  14620022   BNE V1, V0, 0x9D004CA0
9D004C18  00000000   NOP
3218:                        {// Ignore if the hash doesn't match
3219:                            continue;
9D004CA0  00000000   NOP
3220:                        }
3221:                
3222:                        SyncTCB();
9D004C1C  0F400000   JAL 0x9D000000
9D004C20  00000000   NOP
3223:                        if( h->DestPort == MyTCB.localPort.Val &&
9D004C24  8FC20028   LW V0, 40(S8)
9D004C28  94430002   LHU V1, 2(V0)
9D004C2C  3C02A000   LUI V0, -24576
9D004C30  2442759C   ADDIU V0, V0, 30108
9D004C34  94420012   LHU V0, 18(V0)
9D004C38  1462001A   BNE V1, V0, 0x9D004CA4
9D004C3C  00000000   NOP
9D004C54  14620013   BNE V1, V0, 0x9D004CA4
9D004C58  00000000   NOP
3224:                            h->SourcePort == MyTCB.remotePort.Val &&
9D004C40  8FC20028   LW V0, 40(S8)
9D004C44  94430000   LHU V1, 0(V0)
9D004C48  3C02A000   LUI V0, -24576
9D004C4C  2442759C   ADDIU V0, V0, 30108
9D004C50  94420010   LHU V0, 16(V0)
9D004C74  1462000B   BNE V1, V0, 0x9D004CA4
9D004C78  00000000   NOP
3225:                            remote->IPAddr.Val == MyTCB.remote.niRemoteMACIP.IPAddr.Val)
9D004C5C  8FC2002C   LW V0, 44(S8)
9D004C60  88430003   LWL V1, 3(V0)
9D004C64  98430000   LWR V1, 0(V0)
9D004C68  3C02A000   LUI V0, -24576
9D004C6C  2442759C   ADDIU V0, V0, 30108
9D004C70  8C420018   LW V0, 24(V0)
3226:                        {
3227:                            return true;
9D004C7C  24020001   ADDIU V0, ZERO, 1
9D004C80  0B401426   J 0x9D005098
9D004C84  00000000   NOP
3228:                        }
3229:                    }
3230:                
3231:                
3232:                    // If there is a partial match, then a listening socket is currently
3233:                    // available.  Set up the extended TCB with the info needed
3234:                    // to establish a connection and return this socket to the
3235:                    // caller.
3236:                    if(partialMatch != INVALID_SOCKET)
9D004CC0  93C30011   LBU V1, 17(S8)
9D004CC4  240200FE   ADDIU V0, ZERO, 254
9D004CC8  10620030   BEQ V1, V0, 0x9D004D8C
9D004CCC  00000000   NOP
3237:                    {
3238:                        SyncTCBStub(partialMatch);
9D004CD0  93C20011   LBU V0, 17(S8)
9D004CD4  A3828014   SB V0, -32748(GP)
3239:                        SyncTCB();
9D004CD8  0F400000   JAL 0x9D000000
9D004CDC  00000000   NOP
3240:                
3241:                        // For SSL ports, begin the SSL Handshake
3242:                        #if defined(STACK_USE_SSL_SERVER)
3243:                        if(MyTCBStub.sslTxHead == h->DestPort)
3244:                        {
3245:                            // Try to start an SSL session.  If no stubs are available,
3246:                            // we can't service this request right now, so ignore it.
3247:                            if(!TCPStartSSLServer(partialMatch))
3248:                                partialMatch = INVALID_SOCKET;
3249:                        }
3250:                        #endif
3251:                
3252:                        // Make sure the above check didn't fail (this is unfortunately
3253:                        // redundant for non-SSL sockets).  Otherwise, fall out to below
3254:                        // and add to the SYN queue.
3255:                        if(partialMatch != INVALID_SOCKET)
9D004CE0  93C30011   LBU V1, 17(S8)
9D004CE4  240200FE   ADDIU V0, ZERO, 254
9D004CE8  10620028   BEQ V1, V0, 0x9D004D8C
9D004CEC  00000000   NOP
3256:                        {
3257:                            MyTCBStub.remoteHash.Val = hash;
9D004CF0  93828014   LBU V0, -32748(GP)
9D004CF4  3C04A000   LUI A0, -24576
9D004CF8  00021100   SLL V0, V0, 4
9D004CFC  00021880   SLL V1, V0, 2
9D004D00  00621823   SUBU V1, V1, V0
9D004D04  2482753C   ADDIU V0, A0, 30012
9D004D08  00621021   ADDU V0, V1, V0
9D004D0C  97C30014   LHU V1, 20(S8)
9D004D10  A443002A   SH V1, 42(V0)
3258:                
3259:                            memcpy((void*)&MyTCB.remote, (void*)remote, sizeof(NODE_INFO));
9D004D14  3C02A000   LUI V0, -24576
9D004D18  244475B4   ADDIU A0, V0, 30132
9D004D1C  8FC5002C   LW A1, 44(S8)
9D004D20  2406000A   ADDIU A2, ZERO, 10
9D004D24  0F406788   JAL 0x9D019E20
9D004D28  00000000   NOP
3260:                            MyTCB.remotePort.Val = h->SourcePort;
9D004D2C  8FC20028   LW V0, 40(S8)
9D004D30  94430000   LHU V1, 0(V0)
9D004D34  3C02A000   LUI V0, -24576
9D004D38  2442759C   ADDIU V0, V0, 30108
9D004D3C  A4430010   SH V1, 16(V0)
3261:                            MyTCB.localPort.Val = h->DestPort;
9D004D40  8FC20028   LW V0, 40(S8)
9D004D44  94430002   LHU V1, 2(V0)
9D004D48  3C02A000   LUI V0, -24576
9D004D4C  2442759C   ADDIU V0, V0, 30108
9D004D50  A4430012   SH V1, 18(V0)
3262:                            MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D004D54  93828014   LBU V0, -32748(GP)
9D004D58  3C04A000   LUI A0, -24576
9D004D5C  00021100   SLL V0, V0, 4
9D004D60  00021880   SLL V1, V0, 2
9D004D64  00621823   SUBU V1, V1, V0
9D004D68  2482753C   ADDIU V0, A0, 30012
9D004D6C  00621021   ADDU V0, V1, V0
9D004D70  8C430000   LW V1, 0(V0)
9D004D74  3C02A000   LUI V0, -24576
9D004D78  2442759C   ADDIU V0, V0, 30108
9D004D7C  AC43000C   SW V1, 12(V0)
3263:                
3264:                            // All done, and we have a match
3265:                            return true;
9D004D80  24020001   ADDIU V0, ZERO, 1
9D004D84  0B401426   J 0x9D005098
9D004D88  00000000   NOP
3266:                        }
3267:                    }
3268:                
3269:                    // No available sockets are listening on this port.  (Or, for
3270:                    // SSL requests, perhaps no SSL sessions were available.  However,
3271:                    // there may be a server socket which is currently busy but
3272:                    // could handle this packet, so we should check.
3273:                    #if TCP_SYN_QUEUE_MAX_ENTRIES
3274:                    {
3275:                        uint16_t wQueueInsertPos;
3276:                
3277:                        // See if this is a SYN packet
3278:                        if(!h->Flags.bits.flagSYN)
9D004D8C  8FC20028   LW V0, 40(S8)
9D004D90  8C42000C   LW V0, 12(V0)
9D004D94  30420200   ANDI V0, V0, 512
9D004D98  14400004   BNE V0, ZERO, 0x9D004DAC
9D004D9C  00000000   NOP
3279:                            return false;
9D004DA0  00001021   ADDU V0, ZERO, ZERO
9D004DA4  0B401426   J 0x9D005098
9D004DA8  00000000   NOP
3280:                
3281:                        // See if there is space in our SYN queue
3282:                        if(SYNQueue[TCP_SYN_QUEUE_MAX_ENTRIES-1].wDestPort)
9D004DAC  3C02A000   LUI V0, -24576
9D004DB0  244275C8   ADDIU V0, V0, 30152
9D004DB4  94420038   LHU V0, 56(V0)
9D004DB8  10400004   BEQ V0, ZERO, 0x9D004DCC
9D004DBC  00000000   NOP
3283:                            return false;
9D004DC0  00001021   ADDU V0, ZERO, ZERO
9D004DC4  0B401426   J 0x9D005098
9D004DC8  00000000   NOP
3284:                
3285:                        // See if we have this SYN already in our SYN queue.
3286:                        // If not already in the queue, find out where we
3287:                        // should insert this SYN to the queue
3288:                        for(wQueueInsertPos = 0; wQueueInsertPos < TCP_SYN_QUEUE_MAX_ENTRIES; wQueueInsertPos++)
9D004DCC  A7C00012   SH ZERO, 18(S8)
9D004DD0  0B4013C0   J 0x9D004F00
9D004DD4  00000000   NOP
9D004EF4  97C20012   LHU V0, 18(S8)
9D004EF8  24420001   ADDIU V0, V0, 1
9D004EFC  A7C20012   SH V0, 18(S8)
9D004F00  97C20012   LHU V0, 18(S8)
9D004F04  2C420003   SLTIU V0, V0, 3
9D004F08  1440FFB3   BNE V0, ZERO, 0x9D004DD8
9D004F0C  00000000   NOP
9D004F10  0B4013C7   J 0x9D004F1C
9D004F14  00000000   NOP
3289:                        {
3290:                            // Exit loop if we found a free record
3291:                            if(SYNQueue[wQueueInsertPos].wDestPort == 0u)
9D004DD8  97C20012   LHU V0, 18(S8)
9D004DDC  3C03A000   LUI V1, -24576
9D004DE0  00021080   SLL V0, V0, 2
9D004DE4  00022080   SLL A0, V0, 2
9D004DE8  00441021   ADDU V0, V0, A0
9D004DEC  246375C8   ADDIU V1, V1, 30152
9D004DF0  00431021   ADDU V0, V0, V1
9D004DF4  94420010   LHU V0, 16(V0)
9D004DF8  10400047   BEQ V0, ZERO, 0x9D004F18
9D004DFC  00000000   NOP
3292:                                break;
9D004F18  00000000   NOP
3293:                
3294:                            // Check if this SYN packet is already in the SYN queue
3295:                            if(SYNQueue[wQueueInsertPos].wDestPort != h->DestPort)
9D004E00  97C20012   LHU V0, 18(S8)
9D004E04  3C03A000   LUI V1, -24576
9D004E08  00021080   SLL V0, V0, 2
9D004E0C  00022080   SLL A0, V0, 2
9D004E10  00441021   ADDU V0, V0, A0
9D004E14  246375C8   ADDIU V1, V1, 30152
9D004E18  00431021   ADDU V0, V0, V1
9D004E1C  94430010   LHU V1, 16(V0)
9D004E20  8FC20028   LW V0, 40(S8)
9D004E24  94420002   LHU V0, 2(V0)
9D004E28  1462002B   BNE V1, V0, 0x9D004ED8
9D004E2C  00000000   NOP
3296:                                continue;
9D004ED8  00000000   NOP
9D004EDC  0B4013BD   J 0x9D004EF4
9D004EE0  00000000   NOP
3297:                            if(SYNQueue[wQueueInsertPos].wSourcePort != h->SourcePort)
9D004E30  97C20012   LHU V0, 18(S8)
9D004E34  3C03A000   LUI V1, -24576
9D004E38  00021080   SLL V0, V0, 2
9D004E3C  00022080   SLL A0, V0, 2
9D004E40  00441021   ADDU V0, V0, A0
9D004E44  246375C8   ADDIU V1, V1, 30152
9D004E48  00431021   ADDU V0, V0, V1
9D004E4C  9443000A   LHU V1, 10(V0)
9D004E50  8FC20028   LW V0, 40(S8)
9D004E54  94420000   LHU V0, 0(V0)
9D004E58  14620022   BNE V1, V0, 0x9D004EE4
9D004E5C  00000000   NOP
3298:                                continue;
9D004EE4  00000000   NOP
9D004EE8  0B4013BD   J 0x9D004EF4
9D004EEC  00000000   NOP
3299:                            if(SYNQueue[wQueueInsertPos].niSourceAddress.IPAddr.Val != remote->IPAddr.Val)
9D004E60  97C20012   LHU V0, 18(S8)
9D004E64  3C03A000   LUI V1, -24576
9D004E68  00021080   SLL V0, V0, 2
9D004E6C  00022080   SLL A0, V0, 2
9D004E70  00441021   ADDU V0, V0, A0
9D004E74  246375C8   ADDIU V1, V1, 30152
9D004E78  00431021   ADDU V0, V0, V1
9D004E7C  8C430000   LW V1, 0(V0)
9D004E80  8FC2002C   LW V0, 44(S8)
9D004E84  88440003   LWL A0, 3(V0)
9D004E88  00802821   ADDU A1, A0, ZERO
9D004E8C  98450000   LWR A1, 0(V0)
9D004E90  00A01021   ADDU V0, A1, ZERO
9D004E94  14620016   BNE V1, V0, 0x9D004EF0
9D004E98  00000000   NOP
3300:                                continue;
9D004EF0  00000000   NOP
3301:                
3302:                            // SYN matches SYN queue entry.  Update timestamp and do nothing.
3303:                            SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9D004E9C  97D00012   LHU S0, 18(S8)
9D004EA0  0F405C62   JAL TickGetDiv256
9D004EA4  00000000   NOP
9D004EA8  3043FFFF   ANDI V1, V0, -1
9D004EAC  3C04A000   LUI A0, -24576
9D004EB0  02001021   ADDU V0, S0, ZERO
9D004EB4  00021080   SLL V0, V0, 2
9D004EB8  00022880   SLL A1, V0, 2
9D004EBC  00451021   ADDU V0, V0, A1
9D004EC0  248475C8   ADDIU A0, A0, 30152
9D004EC4  00441021   ADDU V0, V0, A0
9D004EC8  A4430012   SH V1, 18(V0)
3304:                            return false;
9D004ECC  00001021   ADDU V0, ZERO, ZERO
9D004ED0  0B401426   J 0x9D005098
9D004ED4  00000000   NOP
3305:                        }
3306:                
3307:                        // Check to see if we have any server sockets which
3308:                        // are currently connected, but could handle this SYN
3309:                        // request at a later time if the client disconnects.
3310:                        for(hTCP = 0; hTCP < TCP_SOCKET_COUNT; hTCP++)
9D004F1C  A3C00010   SB ZERO, 16(S8)
9D004F20  0B401421   J 0x9D005084
9D004F24  00000000   NOP
9D005078  93C20010   LBU V0, 16(S8)
9D00507C  24420001   ADDIU V0, V0, 1
9D005080  A3C20010   SB V0, 16(S8)
9D005084  93C20010   LBU V0, 16(S8)
9D005088  2C420002   SLTIU V0, V0, 2
9D00508C  1440FFA6   BNE V0, ZERO, 0x9D004F28
9D005090  00000000   NOP
3311:                        {
3312:                            SyncTCBStub(hTCP);
9D004F28  93C20010   LBU V0, 16(S8)
9D004F2C  A3828014   SB V0, -32748(GP)
3313:                            if(!MyTCBStub.Flags.bServer)
9D004F30  93828014   LBU V0, -32748(GP)
9D004F34  3C04A000   LUI A0, -24576
9D004F38  00021100   SLL V0, V0, 4
9D004F3C  00021880   SLL V1, V0, 2
9D004F40  00621823   SUBU V1, V1, V0
9D004F44  2482753C   ADDIU V0, A0, 30012
9D004F48  00621021   ADDU V0, V1, V0
9D004F4C  8C420028   LW V0, 40(V0)
9D004F50  7C4200C0   EXT V0, V0, 3, 1
9D004F54  304200FF   ANDI V0, V0, 255
9D004F58  10400043   BEQ V0, ZERO, 0x9D005068
9D004F5C  00000000   NOP
3314:                                continue;
9D005068  00000000   NOP
9D00506C  0B40141E   J 0x9D005078
9D005070  00000000   NOP
3315:                
3316:                            SyncTCB();
9D004F60  0F400000   JAL 0x9D000000
9D004F64  00000000   NOP
3317:                            #if defined(STACK_USE_SSL_SERVER)
3318:                            if((MyTCB.localPort.Val != h->DestPort) && (MyTCB.localSSLPort.Val != h->DestPort))
3319:                            #else
3320:                            if(MyTCB.localPort.Val != h->DestPort)
9D004F68  3C02A000   LUI V0, -24576
9D004F6C  2442759C   ADDIU V0, V0, 30108
9D004F70  94430012   LHU V1, 18(V0)
9D004F74  8FC20028   LW V0, 40(S8)
9D004F78  94420002   LHU V0, 2(V0)
9D004F7C  1462003D   BNE V1, V0, 0x9D005074
9D004F80  00000000   NOP
3321:                            #endif
3322:                                continue;
9D005074  00000000   NOP
3323:                
3324:                            // Generate the SYN queue entry
3325:                            memcpy((void*)&SYNQueue[wQueueInsertPos].niSourceAddress, (void*)remote, sizeof(NODE_INFO));
9D004F84  97C20012   LHU V0, 18(S8)
9D004F88  00021080   SLL V0, V0, 2
9D004F8C  00021880   SLL V1, V0, 2
9D004F90  00431021   ADDU V0, V0, V1
9D004F94  3C03A000   LUI V1, -24576
9D004F98  246375C8   ADDIU V1, V1, 30152
9D004F9C  00431021   ADDU V0, V0, V1
9D004FA0  00402021   ADDU A0, V0, ZERO
9D004FA4  8FC5002C   LW A1, 44(S8)
9D004FA8  2406000A   ADDIU A2, ZERO, 10
9D004FAC  0F406788   JAL 0x9D019E20
9D004FB0  00000000   NOP
3326:                            SYNQueue[wQueueInsertPos].wSourcePort = h->SourcePort;
9D004FB4  97C20012   LHU V0, 18(S8)
9D004FB8  8FC30028   LW V1, 40(S8)
9D004FBC  94630000   LHU V1, 0(V1)
9D004FC0  3C04A000   LUI A0, -24576
9D004FC4  00021080   SLL V0, V0, 2
9D004FC8  00022880   SLL A1, V0, 2
9D004FCC  00451021   ADDU V0, V0, A1
9D004FD0  248475C8   ADDIU A0, A0, 30152
9D004FD4  00441021   ADDU V0, V0, A0
9D004FD8  A443000A   SH V1, 10(V0)
3327:                            SYNQueue[wQueueInsertPos].dwSourceSEQ = h->SeqNumber;
9D004FDC  97C20012   LHU V0, 18(S8)
9D004FE0  8FC30028   LW V1, 40(S8)
9D004FE4  8C630004   LW V1, 4(V1)
9D004FE8  3C04A000   LUI A0, -24576
9D004FEC  248475C8   ADDIU A0, A0, 30152
9D004FF0  00021080   SLL V0, V0, 2
9D004FF4  00022880   SLL A1, V0, 2
9D004FF8  00451021   ADDU V0, V0, A1
9D004FFC  00821021   ADDU V0, A0, V0
9D005000  AC43000C   SW V1, 12(V0)
3328:                            SYNQueue[wQueueInsertPos].wDestPort = h->DestPort;
9D005004  97C20012   LHU V0, 18(S8)
9D005008  8FC30028   LW V1, 40(S8)
9D00500C  94630002   LHU V1, 2(V1)
9D005010  3C04A000   LUI A0, -24576
9D005014  00021080   SLL V0, V0, 2
9D005018  00022880   SLL A1, V0, 2
9D00501C  00451021   ADDU V0, V0, A1
9D005020  248475C8   ADDIU A0, A0, 30152
9D005024  00441021   ADDU V0, V0, A0
9D005028  A4430010   SH V1, 16(V0)
3329:                            SYNQueue[wQueueInsertPos].wTimestamp = TickGetDiv256();
9D00502C  97D00012   LHU S0, 18(S8)
9D005030  0F405C62   JAL TickGetDiv256
9D005034  00000000   NOP
9D005038  3043FFFF   ANDI V1, V0, -1
9D00503C  3C04A000   LUI A0, -24576
9D005040  02001021   ADDU V0, S0, ZERO
9D005044  00021080   SLL V0, V0, 2
9D005048  00022880   SLL A1, V0, 2
9D00504C  00451021   ADDU V0, V0, A1
9D005050  248475C8   ADDIU A0, A0, 30152
9D005054  00441021   ADDU V0, V0, A0
9D005058  A4430012   SH V1, 18(V0)
3330:                
3331:                            return false;
9D00505C  00001021   ADDU V0, ZERO, ZERO
9D005060  0B401426   J 0x9D005098
9D005064  00000000   NOP
3332:                        }
3333:                    }
3334:                    #endif
3335:                
3336:                    return false;
9D005094  00001021   ADDU V0, ZERO, ZERO
3337:                
3338:                }
9D005098  03C0E821   ADDU SP, S8, ZERO
9D00509C  8FBF0024   LW RA, 36(SP)
9D0050A0  8FBE0020   LW S8, 32(SP)
9D0050A4  8FB0001C   LW S0, 28(SP)
9D0050A8  27BD0028   ADDIU SP, SP, 40
9D0050AC  03E00008   JR RA
9D0050B0  00000000   NOP
3339:                
3340:                
3341:                
3342:                /*****************************************************************************
3343:                  Function:
3344:                    static void SwapTCPHeader(TCP_HEADER* header)
3345:                
3346:                  Summary:
3347:                    Swaps endian-ness of a TCP header.
3348:                
3349:                  Description:
3350:                    This function swaps the endian-ness of a given TCP header for comparison.
3351:                
3352:                  Precondition:
3353:                    None
3354:                
3355:                  Parameters:
3356:                    header - The TCP header that is to be swapped
3357:                
3358:                  Returns:
3359:                    None
3360:                  ***************************************************************************/
3361:                static void SwapTCPHeader(TCP_HEADER* header)
3362:                {
9D0050B4  27BDFFE8   ADDIU SP, SP, -24
9D0050B8  AFBF0014   SW RA, 20(SP)
9D0050BC  AFBE0010   SW S8, 16(SP)
9D0050C0  03A0F021   ADDU S8, SP, ZERO
9D0050C4  AFC40018   SW A0, 24(S8)
3363:                    header->SourcePort      = swaps(header->SourcePort);
9D0050C8  8FC20018   LW V0, 24(S8)
9D0050CC  94420000   LHU V0, 0(V0)
9D0050D0  00402021   ADDU A0, V0, ZERO
9D0050D4  0F403F50   JAL swaps
9D0050D8  00000000   NOP
9D0050DC  00401821   ADDU V1, V0, ZERO
9D0050E0  8FC20018   LW V0, 24(S8)
9D0050E4  A4430000   SH V1, 0(V0)
3364:                    header->DestPort        = swaps(header->DestPort);
9D0050E8  8FC20018   LW V0, 24(S8)
9D0050EC  94420002   LHU V0, 2(V0)
9D0050F0  00402021   ADDU A0, V0, ZERO
9D0050F4  0F403F50   JAL swaps
9D0050F8  00000000   NOP
9D0050FC  00401821   ADDU V1, V0, ZERO
9D005100  8FC20018   LW V0, 24(S8)
9D005104  A4430002   SH V1, 2(V0)
3365:                    header->SeqNumber       = swapl(header->SeqNumber);
9D005108  8FC20018   LW V0, 24(S8)
9D00510C  8C420004   LW V0, 4(V0)
9D005110  00402021   ADDU A0, V0, ZERO
9D005114  0F403F63   JAL swapl
9D005118  00000000   NOP
9D00511C  00401821   ADDU V1, V0, ZERO
9D005120  8FC20018   LW V0, 24(S8)
9D005124  AC430004   SW V1, 4(V0)
3366:                    header->AckNumber       = swapl(header->AckNumber);
9D005128  8FC20018   LW V0, 24(S8)
9D00512C  8C420008   LW V0, 8(V0)
9D005130  00402021   ADDU A0, V0, ZERO
9D005134  0F403F63   JAL swapl
9D005138  00000000   NOP
9D00513C  00401821   ADDU V1, V0, ZERO
9D005140  8FC20018   LW V0, 24(S8)
9D005144  AC430008   SW V1, 8(V0)
3367:                    header->Window          = swaps(header->Window);
9D005148  8FC20018   LW V0, 24(S8)
9D00514C  9442000E   LHU V0, 14(V0)
9D005150  00402021   ADDU A0, V0, ZERO
9D005154  0F403F50   JAL swaps
9D005158  00000000   NOP
9D00515C  00401821   ADDU V1, V0, ZERO
9D005160  8FC20018   LW V0, 24(S8)
9D005164  A443000E   SH V1, 14(V0)
3368:                    header->Checksum        = swaps(header->Checksum);
9D005168  8FC20018   LW V0, 24(S8)
9D00516C  94420010   LHU V0, 16(V0)
9D005170  00402021   ADDU A0, V0, ZERO
9D005174  0F403F50   JAL swaps
9D005178  00000000   NOP
9D00517C  00401821   ADDU V1, V0, ZERO
9D005180  8FC20018   LW V0, 24(S8)
9D005184  A4430010   SH V1, 16(V0)
3369:                    header->UrgentPointer   = swaps(header->UrgentPointer);
9D005188  8FC20018   LW V0, 24(S8)
9D00518C  94420012   LHU V0, 18(V0)
9D005190  00402021   ADDU A0, V0, ZERO
9D005194  0F403F50   JAL swaps
9D005198  00000000   NOP
9D00519C  00401821   ADDU V1, V0, ZERO
9D0051A0  8FC20018   LW V0, 24(S8)
9D0051A4  A4430012   SH V1, 18(V0)
3370:                }
9D0051A8  03C0E821   ADDU SP, S8, ZERO
9D0051AC  8FBF0014   LW RA, 20(SP)
9D0051B0  8FBE0010   LW S8, 16(SP)
9D0051B4  27BD0018   ADDIU SP, SP, 24
9D0051B8  03E00008   JR RA
9D0051BC  00000000   NOP
3371:                
3372:                
3373:                
3374:                /*****************************************************************************
3375:                  Function:
3376:                    static void CloseSocket(void)
3377:                
3378:                  Summary:
3379:                    Closes a TCP socket.
3380:                
3381:                  Description:
3382:                    This function closes a TCP socket.  All socket state information is
3383:                    reset, and any buffered bytes are discarded.  The socket is no longer
3384:                    accessible by the application after this point.
3385:                
3386:                  Precondition:
3387:                    The TCPStub corresponding to the socket to be closed is synced.
3388:                
3389:                  Parameters:
3390:                    None
3391:                
3392:                  Returns:
3393:                    None
3394:                  ***************************************************************************/
3395:                static void CloseSocket(void)
3396:                {
9D0051C0  27BDFFE0   ADDIU SP, SP, -32
9D0051C4  AFBF001C   SW RA, 28(SP)
9D0051C8  AFBE0018   SW S8, 24(SP)
9D0051CC  AFB00014   SW S0, 20(SP)
9D0051D0  03A0F021   ADDU S8, SP, ZERO
3397:                    SyncTCB();
9D0051D4  0F400000   JAL 0x9D000000
9D0051D8  00000000   NOP
3398:                
3399:                    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
9D0051DC  93828014   LBU V0, -32748(GP)
9D0051E0  3C03A000   LUI V1, -24576
9D0051E4  2463759C   ADDIU V1, V1, 30108
9D0051E8  94640012   LHU A0, 18(V1)
9D0051EC  3C05A000   LUI A1, -24576
9D0051F0  00021100   SLL V0, V0, 4
9D0051F4  00021880   SLL V1, V0, 2
9D0051F8  00621823   SUBU V1, V1, V0
9D0051FC  24A2753C   ADDIU V0, A1, 30012
9D005200  00621021   ADDU V0, V1, V0
9D005204  A444002A   SH A0, 42(V0)
3400:                    MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D005208  93828014   LBU V0, -32748(GP)
9D00520C  00402821   ADDU A1, V0, ZERO
9D005210  93828014   LBU V0, -32748(GP)
9D005214  3C04A000   LUI A0, -24576
9D005218  00021100   SLL V0, V0, 4
9D00521C  00021880   SLL V1, V0, 2
9D005220  00621823   SUBU V1, V1, V0
9D005224  2482753C   ADDIU V0, A0, 30012
9D005228  00621021   ADDU V0, V1, V0
9D00522C  8C430000   LW V1, 0(V0)
9D005230  3C02A000   LUI V0, -24576
9D005234  2444753C   ADDIU A0, V0, 30012
9D005238  00A01021   ADDU V0, A1, ZERO
9D00523C  00021100   SLL V0, V0, 4
9D005240  00022880   SLL A1, V0, 2
9D005244  00A21023   SUBU V0, A1, V0
9D005248  00821021   ADDU V0, A0, V0
9D00524C  AC43000C   SW V1, 12(V0)
3401:                    MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9D005250  93828014   LBU V0, -32748(GP)
9D005254  00403021   ADDU A2, V0, ZERO
9D005258  93828014   LBU V0, -32748(GP)
9D00525C  3C04A000   LUI A0, -24576
9D005260  00021100   SLL V0, V0, 4
9D005264  00021880   SLL V1, V0, 2
9D005268  00621823   SUBU V1, V1, V0
9D00526C  2482753C   ADDIU V0, A0, 30012
9D005270  00621021   ADDU V0, V1, V0
9D005274  8C440000   LW A0, 0(V0)
9D005278  3C05A000   LUI A1, -24576
9D00527C  00C01021   ADDU V0, A2, ZERO
9D005280  00021100   SLL V0, V0, 4
9D005284  00021880   SLL V1, V0, 2
9D005288  00621823   SUBU V1, V1, V0
9D00528C  24A2753C   ADDIU V0, A1, 30012
9D005290  00621021   ADDU V0, V1, V0
9D005294  AC440010   SW A0, 16(V0)
3402:                    MyTCBStub.rxHead = MyTCBStub.bufferRxStart;
9D005298  93828014   LBU V0, -32748(GP)
9D00529C  00402821   ADDU A1, V0, ZERO
9D0052A0  93828014   LBU V0, -32748(GP)
9D0052A4  3C03A000   LUI V1, -24576
9D0052A8  2463753C   ADDIU V1, V1, 30012
9D0052AC  00021100   SLL V0, V0, 4
9D0052B0  00022080   SLL A0, V0, 2
9D0052B4  00821023   SUBU V0, A0, V0
9D0052B8  00621021   ADDU V0, V1, V0
9D0052BC  8C430004   LW V1, 4(V0)
9D0052C0  3C02A000   LUI V0, -24576
9D0052C4  2444753C   ADDIU A0, V0, 30012
9D0052C8  00A01021   ADDU V0, A1, ZERO
9D0052CC  00021100   SLL V0, V0, 4
9D0052D0  00022880   SLL A1, V0, 2
9D0052D4  00A21023   SUBU V0, A1, V0
9D0052D8  00821021   ADDU V0, A0, V0
9D0052DC  AC430014   SW V1, 20(V0)
3403:                    MyTCBStub.rxTail = MyTCBStub.bufferRxStart;
9D0052E0  93828014   LBU V0, -32748(GP)
9D0052E4  00401821   ADDU V1, V0, ZERO
9D0052E8  93828014   LBU V0, -32748(GP)
9D0052EC  3C04A000   LUI A0, -24576
9D0052F0  2484753C   ADDIU A0, A0, 30012
9D0052F4  00021100   SLL V0, V0, 4
9D0052F8  00022880   SLL A1, V0, 2
9D0052FC  00A21023   SUBU V0, A1, V0
9D005300  00821021   ADDU V0, A0, V0
9D005304  8C440004   LW A0, 4(V0)
9D005308  3C05A000   LUI A1, -24576
9D00530C  00601021   ADDU V0, V1, ZERO
9D005310  00021100   SLL V0, V0, 4
9D005314  00021880   SLL V1, V0, 2
9D005318  00621823   SUBU V1, V1, V0
9D00531C  24A2753C   ADDIU V0, A1, 30012
9D005320  00621021   ADDU V0, V1, V0
9D005324  AC440018   SW A0, 24(V0)
3404:                    MyTCBStub.smState = MyTCBStub.Flags.bServer ? TCP_LISTEN : TCP_CLOSED;
9D005328  93828014   LBU V0, -32748(GP)
9D00532C  00402821   ADDU A1, V0, ZERO
9D005330  93828014   LBU V0, -32748(GP)
9D005334  3C04A000   LUI A0, -24576
9D005338  00021100   SLL V0, V0, 4
9D00533C  00021880   SLL V1, V0, 2
9D005340  00621823   SUBU V1, V1, V0
9D005344  2482753C   ADDIU V0, A0, 30012
9D005348  00621021   ADDU V0, V1, V0
9D00534C  8C420028   LW V0, 40(V0)
9D005350  7C4200C0   EXT V0, V0, 3, 1
9D005354  304200FF   ANDI V0, V0, 255
9D005358  10400004   BEQ V0, ZERO, 0x9D00536C
9D00535C  00000000   NOP
9D005360  24030004   ADDIU V1, ZERO, 4
9D005364  0B4014DC   J 0x9D005370
9D005368  00000000   NOP
9D00536C  2403000D   ADDIU V1, ZERO, 13
9D005370  3C02A000   LUI V0, -24576
9D005374  2444753C   ADDIU A0, V0, 30012
9D005378  00A01021   ADDU V0, A1, ZERO
9D00537C  00021100   SLL V0, V0, 4
9D005380  00022880   SLL A1, V0, 2
9D005384  00A21023   SUBU V0, A1, V0
9D005388  00821021   ADDU V0, A0, V0
9D00538C  AC430024   SW V1, 36(V0)
3405:                    MyTCBStub.Flags.vUnackedKeepalives = 0;
9D005390  93828014   LBU V0, -32748(GP)
9D005394  3C04A000   LUI A0, -24576
9D005398  00021100   SLL V0, V0, 4
9D00539C  00021880   SLL V1, V0, 2
9D0053A0  00621823   SUBU V1, V1, V0
9D0053A4  2482753C   ADDIU V0, A0, 30012
9D0053A8  00621821   ADDU V1, V1, V0
9D0053AC  8C620028   LW V0, 40(V1)
9D0053B0  7C021004   INS V0, ZERO, 0, 3
9D0053B4  AC620028   SW V0, 40(V1)
3406:                    MyTCBStub.Flags.bTimerEnabled = 0;
9D0053B8  93828014   LBU V0, -32748(GP)
9D0053BC  3C04A000   LUI A0, -24576
9D0053C0  00021100   SLL V0, V0, 4
9D0053C4  00021880   SLL V1, V0, 2
9D0053C8  00621823   SUBU V1, V1, V0
9D0053CC  2482753C   ADDIU V0, A0, 30012
9D0053D0  00621821   ADDU V1, V1, V0
9D0053D4  8C620028   LW V0, 40(V1)
9D0053D8  7C022104   INS V0, ZERO, 4, 1
9D0053DC  AC620028   SW V0, 40(V1)
3407:                    MyTCBStub.Flags.bTimer2Enabled = 0;
9D0053E0  93828014   LBU V0, -32748(GP)
9D0053E4  3C04A000   LUI A0, -24576
9D0053E8  00021100   SLL V0, V0, 4
9D0053EC  00021880   SLL V1, V0, 2
9D0053F0  00621823   SUBU V1, V1, V0
9D0053F4  2482753C   ADDIU V0, A0, 30012
9D0053F8  00621821   ADDU V1, V1, V0
9D0053FC  8C620028   LW V0, 40(V1)
9D005400  7C022944   INS V0, ZERO, 5, 1
9D005404  AC620028   SW V0, 40(V1)
3408:                    MyTCBStub.Flags.bDelayedACKTimerEnabled = 0;
9D005408  93828014   LBU V0, -32748(GP)
9D00540C  3C04A000   LUI A0, -24576
9D005410  00021100   SLL V0, V0, 4
9D005414  00021880   SLL V1, V0, 2
9D005418  00621823   SUBU V1, V1, V0
9D00541C  2482753C   ADDIU V0, A0, 30012
9D005420  00621821   ADDU V1, V1, V0
9D005424  8C620028   LW V0, 40(V1)
9D005428  7C023184   INS V0, ZERO, 6, 1
9D00542C  AC620028   SW V0, 40(V1)
3409:                    MyTCBStub.Flags.bOneSegmentReceived = 0;
9D005430  93828014   LBU V0, -32748(GP)
9D005434  3C04A000   LUI A0, -24576
9D005438  00021100   SLL V0, V0, 4
9D00543C  00021880   SLL V1, V0, 2
9D005440  00621823   SUBU V1, V1, V0
9D005444  2482753C   ADDIU V0, A0, 30012
9D005448  00621821   ADDU V1, V1, V0
9D00544C  8C620028   LW V0, 40(V1)
9D005450  7C0239C4   INS V0, ZERO, 7, 1
9D005454  AC620028   SW V0, 40(V1)
3410:                    MyTCBStub.Flags.bHalfFullFlush = 0;
9D005458  93828014   LBU V0, -32748(GP)
9D00545C  3C04A000   LUI A0, -24576
9D005460  00021100   SLL V0, V0, 4
9D005464  00021880   SLL V1, V0, 2
9D005468  00621823   SUBU V1, V1, V0
9D00546C  2482753C   ADDIU V0, A0, 30012
9D005470  00621821   ADDU V1, V1, V0
9D005474  8C620028   LW V0, 40(V1)
9D005478  7C024204   INS V0, ZERO, 8, 1
9D00547C  AC620028   SW V0, 40(V1)
3411:                    MyTCBStub.Flags.bTXASAP = 0;
9D005480  93828014   LBU V0, -32748(GP)
9D005484  3C04A000   LUI A0, -24576
9D005488  00021100   SLL V0, V0, 4
9D00548C  00021880   SLL V1, V0, 2
9D005490  00621823   SUBU V1, V1, V0
9D005494  2482753C   ADDIU V0, A0, 30012
9D005498  00621821   ADDU V1, V1, V0
9D00549C  8C620028   LW V0, 40(V1)
9D0054A0  7C024A44   INS V0, ZERO, 9, 1
9D0054A4  AC620028   SW V0, 40(V1)
3412:                    MyTCBStub.Flags.bTXASAPWithoutTimerReset = 0;
9D0054A8  93828014   LBU V0, -32748(GP)
9D0054AC  3C04A000   LUI A0, -24576
9D0054B0  00021100   SLL V0, V0, 4
9D0054B4  00021880   SLL V1, V0, 2
9D0054B8  00621823   SUBU V1, V1, V0
9D0054BC  2482753C   ADDIU V0, A0, 30012
9D0054C0  00621821   ADDU V1, V1, V0
9D0054C4  8C620028   LW V0, 40(V1)
9D0054C8  7C025284   INS V0, ZERO, 10, 1
9D0054CC  AC620028   SW V0, 40(V1)
3413:                    MyTCBStub.Flags.bTXFIN = 0;
9D0054D0  93828014   LBU V0, -32748(GP)
9D0054D4  3C04A000   LUI A0, -24576
9D0054D8  00021100   SLL V0, V0, 4
9D0054DC  00021880   SLL V1, V0, 2
9D0054E0  00621823   SUBU V1, V1, V0
9D0054E4  2482753C   ADDIU V0, A0, 30012
9D0054E8  00621821   ADDU V1, V1, V0
9D0054EC  8C620028   LW V0, 40(V1)
9D0054F0  7C025AC4   INS V0, ZERO, 11, 1
9D0054F4  AC620028   SW V0, 40(V1)
3414:                    MyTCBStub.Flags.bSocketReset = 1;
9D0054F8  93828014   LBU V0, -32748(GP)
9D0054FC  3C04A000   LUI A0, -24576
9D005500  00021100   SLL V0, V0, 4
9D005504  00021880   SLL V1, V0, 2
9D005508  00621823   SUBU V1, V1, V0
9D00550C  2482753C   ADDIU V0, A0, 30012
9D005510  00621821   ADDU V1, V1, V0
9D005514  8C620028   LW V0, 40(V1)
9D005518  24040001   ADDIU A0, ZERO, 1
9D00551C  7C826304   INS V0, A0, 12, 1
9D005520  AC620028   SW V0, 40(V1)
3415:                
3416:                    #if defined(STACK_USE_SSL)
3417:                    // If SSL is active, then we need to close it
3418:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
3419:                    {
3420:                        SSLTerminate(MyTCBStub.sslStubID);
3421:                        MyTCBStub.sslStubID = SSL_INVALID_ID;
3422:                
3423:                        // Swap the SSL port and local port back to proper values
3424:                        MyTCBStub.remoteHash.Val = MyTCB.localSSLPort.Val;
3425:                        MyTCB.localSSLPort.Val = MyTCB.localPort.Val;
3426:                        MyTCB.localPort.Val = MyTCBStub.remoteHash.Val;
3427:                    }
3428:                
3429:                    // Reset the SSL buffer pointers
3430:                    MyTCBStub.sslRxHead = MyTCBStub.bufferRxStart;
3431:                    MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
3432:                    #endif
3433:                
3434:                    #if defined(STACK_USE_SSL_SERVER)
3435:                    MyTCBStub.sslTxHead = MyTCB.localSSLPort.Val;
3436:                    #endif
3437:                
3438:                    MyTCB.flags.bFINSent = 0;
9D005524  3C02A000   LUI V0, -24576
9D005528  2443759C   ADDIU V1, V0, 30108
9D00552C  8C620024   LW V0, 36(V1)
9D005530  7C028404   INS V0, ZERO, 16, 1
9D005534  AC620024   SW V0, 36(V1)
3439:                    MyTCB.flags.bSYNSent = 0;
9D005538  3C02A000   LUI V0, -24576
9D00553C  2443759C   ADDIU V1, V0, 30108
9D005540  8C620024   LW V0, 36(V1)
9D005544  7C028C44   INS V0, ZERO, 17, 1
9D005548  AC620024   SW V0, 36(V1)
3440:                    MyTCB.flags.bRXNoneACKed1 = 0;
9D00554C  3C02A000   LUI V0, -24576
9D005550  2443759C   ADDIU V1, V0, 30108
9D005554  8C620024   LW V0, 36(V1)
9D005558  7C029CC4   INS V0, ZERO, 19, 1
9D00555C  AC620024   SW V0, 36(V1)
3441:                    MyTCB.flags.bRXNoneACKed2 = 0;
9D005560  3C02A000   LUI V0, -24576
9D005564  2443759C   ADDIU V1, V0, 30108
9D005568  8C620024   LW V0, 36(V1)
9D00556C  7C02A504   INS V0, ZERO, 20, 1
9D005570  AC620024   SW V0, 36(V1)
3442:                    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D005574  93828014   LBU V0, -32748(GP)
9D005578  3C04A000   LUI A0, -24576
9D00557C  00021100   SLL V0, V0, 4
9D005580  00021880   SLL V1, V0, 2
9D005584  00621823   SUBU V1, V1, V0
9D005588  2482753C   ADDIU V0, A0, 30012
9D00558C  00621021   ADDU V0, V1, V0
9D005590  8C430000   LW V1, 0(V0)
9D005594  3C02A000   LUI V0, -24576
9D005598  2442759C   ADDIU V0, V0, 30108
9D00559C  AC43000C   SW V1, 12(V0)
3443:                    ((TCPIP_UINT32_VAL*)(&MyTCB.MySEQ))->w[0] = LFSRRand();
9D0055A0  3C02A000   LUI V0, -24576
9D0055A4  245075A0   ADDIU S0, V0, 30112
9D0055A8  0F403CAC   JAL LFSRRand
9D0055AC  00000000   NOP
9D0055B0  A6020000   SH V0, 0(S0)
3444:                    ((TCPIP_UINT32_VAL*)(&MyTCB.MySEQ))->w[1] = LFSRRand();
9D0055B4  3C02A000   LUI V0, -24576
9D0055B8  245075A0   ADDIU S0, V0, 30112
9D0055BC  0F403CAC   JAL LFSRRand
9D0055C0  00000000   NOP
9D0055C4  A6020002   SH V0, 2(S0)
3445:                    MyTCB.sHoleSize = -1;
9D0055C8  3C02A000   LUI V0, -24576
9D0055CC  2442759C   ADDIU V0, V0, 30108
9D0055D0  2403FFFF   ADDIU V1, ZERO, -1
9D0055D4  A4430024   SH V1, 36(V0)
3446:                    MyTCB.remoteWindow = 1;
9D0055D8  3C02A000   LUI V0, -24576
9D0055DC  2442759C   ADDIU V0, V0, 30108
9D0055E0  24030001   ADDIU V1, ZERO, 1
9D0055E4  A4430014   SH V1, 20(V0)
3447:                }
9D0055E8  03C0E821   ADDU SP, S8, ZERO
9D0055EC  8FBF001C   LW RA, 28(SP)
9D0055F0  8FBE0018   LW S8, 24(SP)
9D0055F4  8FB00014   LW S0, 20(SP)
9D0055F8  27BD0020   ADDIU SP, SP, 32
9D0055FC  03E00008   JR RA
9D005600  00000000   NOP
3448:                
3449:                
3450:                /*****************************************************************************
3451:                  Function:
3452:                    static uint16_t GetMaxSegSizeOption(void)
3453:                
3454:                  Summary:
3455:                    Obtains the Maximum Segment Size (MSS) TCP Option out of the TCP header
3456:                    for the current socket.
3457:                
3458:                  Description:
3459:                    Parses the current TCP packet header and extracts the Maximum Segment Size
3460:                    option.
3461:                
3462:                  Precondition:
3463:                    Must be called while a TCP packet is present and being processed via
3464:                    HandleTCPSeg() and only if the the TCP SYN flag is set.
3465:                
3466:                  Parameters:
3467:                    None
3468:                
3469:                  Returns:
3470:                    Maximum segment size option value.  If illegal or not present, a failsafe
3471:                    value of 536 is returned.  If the option is larger than the
3472:                    TCP_MAX_SEG_SIZE_TX upper limit, then TCP_MAX_SEG_SIZE_TX is returned.
3473:                
3474:                  Remarks:
3475:                    The internal MAC Read Pointer is moved but not restored.
3476:                  ***************************************************************************/
3477:                static uint16_t GetMaxSegSizeOption(void)
3478:                {
9D005604  27BDFFD8   ADDIU SP, SP, -40
9D005608  AFBF0024   SW RA, 36(SP)
9D00560C  AFBE0020   SW S8, 32(SP)
9D005610  AFB0001C   SW S0, 28(SP)
9D005614  03A0F021   ADDU S8, SP, ZERO
3479:                    uint8_t vOptionsBytes;
3480:                    uint8_t vOption;
3481:                    uint16_t wMSS;
3482:                
3483:                    // Find out how many options bytes are in this packet.
3484:                    IPSetRxBuffer(2+2+4+4); // Seek to data offset field, skipping Source port (2), Destination port (2), Sequence number (4), and Acknowledgement number (4)
9D005618  2404000C   ADDIU A0, ZERO, 12
9D00561C  0F406020   JAL IPSetRxBuffer
9D005620  00000000   NOP
3485:                    vOptionsBytes = MACGet();
9D005624  0F4046C4   JAL MACGet
9D005628  00000000   NOP
9D00562C  A3C20010   SB V0, 16(S8)
3486:                    vOptionsBytes = ((vOptionsBytes&0xF0)>>2) - sizeof(TCP_HEADER);
9D005630  93C20010   LBU V0, 16(S8)
9D005634  304200F0   ANDI V0, V0, 240
9D005638  00021083   SRA V0, V0, 2
9D00563C  304200FF   ANDI V0, V0, 255
9D005640  2442FFEC   ADDIU V0, V0, -20
9D005644  A3C20010   SB V0, 16(S8)
3487:                
3488:                    // Return minimum Maximum Segment Size value of 536 bytes if none are
3489:                    // present
3490:                    if(vOptionsBytes == 0u)
9D005648  93C20010   LBU V0, 16(S8)
9D00564C  14400004   BNE V0, ZERO, 0x9D005660
9D005650  00000000   NOP
3491:                        return 536;
9D005654  24020218   ADDIU V0, ZERO, 536
9D005658  0B4015FF   J 0x9D0057FC
9D00565C  00000000   NOP
3492:                
3493:                    // Seek to beginning of options
3494:                    MACGetArray(NULL, 7);
9D005660  00002021   ADDU A0, ZERO, ZERO
9D005664  24050007   ADDIU A1, ZERO, 7
9D005668  0F4046D1   JAL MACGetArray
9D00566C  00000000   NOP
3495:                
3496:                    // Search for the Maximum Segment Size option
3497:                    while(vOptionsBytes--)
9D005670  0B4015E7   J 0x9D00579C
9D005674  00000000   NOP
9D00579C  93C20010   LBU V0, 16(S8)
9D0057A0  0002102B   SLTU V0, ZERO, V0
9D0057A4  304200FF   ANDI V0, V0, 255
9D0057A8  93C30010   LBU V1, 16(S8)
9D0057AC  2463FFFF   ADDIU V1, V1, -1
9D0057B0  A3C30010   SB V1, 16(S8)
9D0057B4  1440FFB0   BNE V0, ZERO, 0x9D005678
9D0057B8  00000000   NOP
9D0057BC  0B4015FE   J 0x9D0057F8
9D0057C0  00000000   NOP
3498:                    {
3499:                        vOption = MACGet();
9D005678  0F4046C4   JAL MACGet
9D00567C  00000000   NOP
9D005680  A3C20011   SB V0, 17(S8)
3500:                
3501:                        if(vOption == 0u)   // End of Options list
9D005684  93C20011   LBU V0, 17(S8)
9D005688  1040004E   BEQ V0, ZERO, 0x9D0057C4
9D00568C  00000000   NOP
3502:                            break;
9D0057C4  00000000   NOP
9D0057C8  0B4015FE   J 0x9D0057F8
9D0057CC  00000000   NOP
3503:                
3504:                        if(vOption == 1u)   // NOP option
9D005690  93C30011   LBU V1, 17(S8)
9D005694  24020001   ADDIU V0, ZERO, 1
9D005698  1062003F   BEQ V1, V0, 0x9D005798
9D00569C  00000000   NOP
3505:                            continue;
9D005798  00000000   NOP
3506:                
3507:                        if(vOption == 2u)   // Maximum Segment Size option
9D0056A0  93C30011   LBU V1, 17(S8)
9D0056A4  24020002   ADDIU V0, ZERO, 2
9D0056A8  14620024   BNE V1, V0, 0x9D00573C
9D0056AC  00000000   NOP
3508:                        {
3509:                            if(vOptionsBytes < 3u)
9D0056B0  93C20010   LBU V0, 16(S8)
9D0056B4  2C420003   SLTIU V0, V0, 3
9D0056B8  14400045   BNE V0, ZERO, 0x9D0057D0
9D0056BC  00000000   NOP
3510:                                break;
9D0057D0  00000000   NOP
9D0057D4  0B4015FE   J 0x9D0057F8
9D0057D8  00000000   NOP
3511:                
3512:                            wMSS = 0;
9D0056C0  A7C00012   SH ZERO, 18(S8)
3513:                
3514:                            // Get option length
3515:                            vOption = MACGet();
9D0056C4  0F4046C4   JAL MACGet
9D0056C8  00000000   NOP
9D0056CC  A3C20011   SB V0, 17(S8)
3516:                            if(vOption == 4u)
9D0056D0  93C30011   LBU V1, 17(S8)
9D0056D4  24020004   ADDIU V0, ZERO, 4
9D0056D8  1462000A   BNE V1, V0, 0x9D005704
9D0056DC  00000000   NOP
3517:                            {// Retrieve MSS and swap value to little endian
3518:                                ((uint8_t*)&wMSS)[1] = MACGet();
9D0056E0  27C20012   ADDIU V0, S8, 18
9D0056E4  24500001   ADDIU S0, V0, 1
9D0056E8  0F4046C4   JAL MACGet
9D0056EC  00000000   NOP
9D0056F0  A2020000   SB V0, 0(S0)
3519:                                ((uint8_t*)&wMSS)[0] = MACGet();
9D0056F4  27D00012   ADDIU S0, S8, 18
9D0056F8  0F4046C4   JAL MACGet
9D0056FC  00000000   NOP
9D005700  A2020000   SB V0, 0(S0)
3520:                            }
3521:                
3522:                            if(wMSS < 536u)
9D005704  97C20012   LHU V0, 18(S8)
9D005708  2C420218   SLTIU V0, V0, 536
9D00570C  14400033   BNE V0, ZERO, 0x9D0057DC
9D005710  00000000   NOP
3523:                                break;
9D0057DC  00000000   NOP
9D0057E0  0B4015FE   J 0x9D0057F8
9D0057E4  00000000   NOP
3524:                            if(wMSS > TCP_MAX_SEG_SIZE_TX)
9D005714  97C20012   LHU V0, 18(S8)
9D005718  2C4205B5   SLTIU V0, V0, 1461
9D00571C  14400004   BNE V0, ZERO, 0x9D005730
9D005720  00000000   NOP
3525:                                return TCP_MAX_SEG_SIZE_TX;
9D005724  240205B4   ADDIU V0, ZERO, 1460
9D005728  0B4015FF   J 0x9D0057FC
9D00572C  00000000   NOP
3526:                            else
3527:                                return wMSS;
9D005730  97C20012   LHU V0, 18(S8)
9D005734  0B4015FF   J 0x9D0057FC
9D005738  00000000   NOP
3528:                        }
3529:                        else
3530:                        { // Assume this is a multi byte option and throw it way
3531:                            if(vOptionsBytes < 2u)
9D00573C  93C20010   LBU V0, 16(S8)
9D005740  2C420002   SLTIU V0, V0, 2
9D005744  14400028   BNE V0, ZERO, 0x9D0057E8
9D005748  00000000   NOP
3532:                                break;
9D0057E8  00000000   NOP
9D0057EC  0B4015FE   J 0x9D0057F8
9D0057F0  00000000   NOP
3533:                            vOption = MACGet();
9D00574C  0F4046C4   JAL MACGet
9D005750  00000000   NOP
9D005754  A3C20011   SB V0, 17(S8)
3534:                            if(vOptionsBytes < vOption)
9D005758  93C30010   LBU V1, 16(S8)
9D00575C  93C20011   LBU V0, 17(S8)
9D005760  0062102B   SLTU V0, V1, V0
9D005764  14400023   BNE V0, ZERO, 0x9D0057F4
9D005768  00000000   NOP
3535:                                break;
9D0057F4  00000000   NOP
3536:                            MACGetArray(NULL, vOption);
9D00576C  93C20011   LBU V0, 17(S8)
9D005770  00002021   ADDU A0, ZERO, ZERO
9D005774  00402821   ADDU A1, V0, ZERO
9D005778  0F4046D1   JAL MACGetArray
9D00577C  00000000   NOP
3537:                            vOptionsBytes -= vOption;
9D005780  93C30010   LBU V1, 16(S8)
9D005784  93C20011   LBU V0, 17(S8)
9D005788  00621023   SUBU V0, V1, V0
9D00578C  A3C20010   SB V0, 16(S8)
9D005790  0B4015E7   J 0x9D00579C
9D005794  00000000   NOP
3538:                        }
3539:                
3540:                    }
3541:                
3542:                    // Did not find MSS option, return worst case default
3543:                    return 536;
9D0057F8  24020218   ADDIU V0, ZERO, 536
3544:                }
9D0057FC  03C0E821   ADDU SP, S8, ZERO
9D005800  8FBF0024   LW RA, 36(SP)
9D005804  8FBE0020   LW S8, 32(SP)
9D005808  8FB0001C   LW S0, 28(SP)
9D00580C  27BD0028   ADDIU SP, SP, 40
9D005810  03E00008   JR RA
9D005814  00000000   NOP
3545:                
3546:                /*****************************************************************************
3547:                  Function:
3548:                    static void HandleTCPSeg(TCP_HEADER* h, uint16_t len)
3549:                
3550:                  Summary:
3551:                    Processes an incoming TCP segment.
3552:                
3553:                  Description:
3554:                    Once an incoming segment has been matched to a socket, this function
3555:                    performs the necessary processing with the data.  Depending on the
3556:                    segment and the state, this may include copying data to the TCP buffer,
3557:                    re-assembling out-of order packets, continuing an initialization or
3558:                    closing handshake, or closing the socket altogether.
3559:                
3560:                  Precondition:
3561:                    TCP is initialized and the current TCP stub is already synced.
3562:                
3563:                  Parameters:
3564:                    h - The TCP header for this packet
3565:                    len - The total buffer length of this segment
3566:                
3567:                  Returns:
3568:                    None
3569:                  ***************************************************************************/
3570:                static void HandleTCPSeg(TCP_HEADER* h, uint16_t len)
3571:                {
9D005818  27BDFFB8   ADDIU SP, SP, -72
9D00581C  AFBF0044   SW RA, 68(SP)
9D005820  AFBE0040   SW S8, 64(SP)
9D005824  AFB0003C   SW S0, 60(SP)
9D005828  03A0F021   ADDU S8, SP, ZERO
9D00582C  AFC40048   SW A0, 72(S8)
9D005830  00A01021   ADDU V0, A1, ZERO
9D005834  A7C2004C   SH V0, 76(S8)
3572:                    uint32_t dwTemp;
3573:                    PTR_BASE wTemp;
3574:                    int32_t lMissingBytes;
3575:                    uint16_t wMissingBytes;
3576:                    uint16_t wFreeSpace;
3577:                    uint8_t localHeaderFlags;
3578:                    uint32_t localAckNumber;
3579:                    uint32_t localSeqNumber;
3580:                    uint16_t wSegmentLength;
3581:                    bool bSegmentAcceptable;
3582:                    uint16_t wNewWindow;
3583:                
3584:                
3585:                    // Cache a few variables in local RAM.
3586:                    // PIC18s take a fair amount of code and execution time to
3587:                    // dereference pointers frequently.
3588:                    localHeaderFlags = h->Flags.byte;
9D005838  8FC20048   LW V0, 72(S8)
9D00583C  9042000D   LBU V0, 13(V0)
9D005840  A3C2002B   SB V0, 43(S8)
3589:                    localAckNumber = h->AckNumber;
9D005844  8FC20048   LW V0, 72(S8)
9D005848  8C420008   LW V0, 8(V0)
9D00584C  AFC20024   SW V0, 36(S8)
3590:                    localSeqNumber = h->SeqNumber;
9D005850  8FC20048   LW V0, 72(S8)
9D005854  8C420004   LW V0, 4(V0)
9D005858  AFC2002C   SW V0, 44(S8)
3591:                
3592:                    // We received a packet, reset the keep alive timer and count
3593:                    #if defined(TCP_KEEP_ALIVE_TIMEOUT)
3594:                        MyTCBStub.Flags.vUnackedKeepalives = 0;
9D00585C  93828014   LBU V0, -32748(GP)
9D005860  3C04A000   LUI A0, -24576
9D005864  00021100   SLL V0, V0, 4
9D005868  00021880   SLL V1, V0, 2
9D00586C  00621823   SUBU V1, V1, V0
9D005870  2482753C   ADDIU V0, A0, 30012
9D005874  00621821   ADDU V1, V1, V0
9D005878  8C620028   LW V0, 40(V1)
9D00587C  7C021004   INS V0, ZERO, 0, 3
9D005880  AC620028   SW V0, 40(V1)
3595:                        if(!MyTCBStub.Flags.bTimerEnabled)
9D005884  93828014   LBU V0, -32748(GP)
9D005888  3C04A000   LUI A0, -24576
9D00588C  00021100   SLL V0, V0, 4
9D005890  00021880   SLL V1, V0, 2
9D005894  00621823   SUBU V1, V1, V0
9D005898  2482753C   ADDIU V0, A0, 30012
9D00589C  00621021   ADDU V0, V1, V0
9D0058A0  8C420028   LW V0, 40(V0)
9D0058A4  7C420100   EXT V0, V0, 4, 1
9D0058A8  304200FF   ANDI V0, V0, 255
9D0058AC  14400011   BNE V0, ZERO, 0x9D0058F4
9D0058B0  00000000   NOP
3596:                            MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D0058B4  93828014   LBU V0, -32748(GP)
9D0058B8  00408021   ADDU S0, V0, ZERO
9D0058BC  0F405C42   JAL TickGet
9D0058C0  00000000   NOP
9D0058C4  00401821   ADDU V1, V0, ZERO
9D0058C8  3C02002F   LUI V0, 47
9D0058CC  3442AF08   ORI V0, V0, -20728
9D0058D0  00621821   ADDU V1, V1, V0
9D0058D4  3C02A000   LUI V0, -24576
9D0058D8  2444753C   ADDIU A0, V0, 30012
9D0058DC  02001021   ADDU V0, S0, ZERO
9D0058E0  00021100   SLL V0, V0, 4
9D0058E4  00022880   SLL A1, V0, 2
9D0058E8  00A21023   SUBU V0, A1, V0
9D0058EC  00821021   ADDU V0, A0, V0
9D0058F0  AC43001C   SW V1, 28(V0)
3597:                    #endif
3598:                
3599:                    // Handle TCP_LISTEN and TCP_SYN_SENT states
3600:                    // Both of these states will return, so code following this
3601:                    // state machine need not check explicitly for these two
3602:                    // states.
3603:                    switch(MyTCBStub.smState)
9D0058F4  93828014   LBU V0, -32748(GP)
9D0058F8  3C03A000   LUI V1, -24576
9D0058FC  2463753C   ADDIU V1, V1, 30012
9D005900  00021100   SLL V0, V0, 4
9D005904  00022080   SLL A0, V0, 2
9D005908  00821023   SUBU V0, A0, V0
9D00590C  00621021   ADDU V0, V1, V0
9D005910  8C420024   LW V0, 36(V0)
9D005914  24030004   ADDIU V1, ZERO, 4
9D005918  10430006   BEQ V0, V1, 0x9D005934
9D00591C  00000000   NOP
9D005920  24030005   ADDIU V1, ZERO, 5
9D005924  1043003D   BEQ V0, V1, 0x9D005A1C
9D005928  00000000   NOP
9D00592C  0B4016F7   J 0x9D005BDC
9D005930  00000000   NOP
3604:                    {
3605:                        case TCP_LISTEN:
3606:                            // First: check RST flag
3607:                            if(localHeaderFlags & RST)
9D005934  93C2002B   LBU V0, 43(S8)
9D005938  30420004   ANDI V0, V0, 4
9D00593C  10400005   BEQ V0, ZERO, 0x9D005954
9D005940  00000000   NOP
3608:                            {
3609:                                CloseSocket();  // Unbind remote IP address/port info
9D005944  0F401470   JAL 0x9D0051C0
9D005948  00000000   NOP
3610:                                return;
9D00594C  0B401EC9   J 0x9D007B24
9D005950  00000000   NOP
3611:                            }
3612:                
3613:                            // Second: check ACK flag, which would be invalid
3614:                            if(localHeaderFlags & ACK)
9D005954  93C2002B   LBU V0, 43(S8)
9D005958  30420010   ANDI V0, V0, 16
9D00595C  1040000D   BEQ V0, ZERO, 0x9D005994
9D005960  00000000   NOP
3615:                            {
3616:                                // Use a believable sequence number and reset the remote node
3617:                                MyTCB.MySEQ = localAckNumber;
9D005964  3C02A000   LUI V0, -24576
9D005968  2442759C   ADDIU V0, V0, 30108
9D00596C  8FC30024   LW V1, 36(S8)
9D005970  AC430004   SW V1, 4(V0)
3618:                                SendTCP(RST, 0);
9D005974  24040004   ADDIU A0, ZERO, 4
9D005978  00002821   ADDU A1, ZERO, ZERO
9D00597C  0F400F2C   JAL 0x9D003CB0
9D005980  00000000   NOP
3619:                                CloseSocket();  // Unbind remote IP address/port info
9D005984  0F401470   JAL 0x9D0051C0
9D005988  00000000   NOP
3620:                                return;
9D00598C  0B401EC9   J 0x9D007B24
9D005990  00000000   NOP
3621:                            }
3622:                
3623:                            // Third: check for SYN flag, which is what we're looking for
3624:                            if(localHeaderFlags & SYN)
9D005994  93C2002B   LBU V0, 43(S8)
9D005998  30420002   ANDI V0, V0, 2
9D00599C  1040001B   BEQ V0, ZERO, 0x9D005A0C
9D0059A0  00000000   NOP
3625:                            {
3626:                                // We now have a sequence number for the remote node
3627:                                MyTCB.RemoteSEQ = localSeqNumber + 1;
9D0059A4  8FC2002C   LW V0, 44(S8)
9D0059A8  24430001   ADDIU V1, V0, 1
9D0059AC  3C02A000   LUI V0, -24576
9D0059B0  2442759C   ADDIU V0, V0, 30108
9D0059B4  AC430008   SW V1, 8(V0)
3628:                
3629:                                // Get MSS option
3630:                                MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9D0059B8  0F401581   JAL 0x9D005604
9D0059BC  00000000   NOP
9D0059C0  00401821   ADDU V1, V0, ZERO
9D0059C4  3C02A000   LUI V0, -24576
9D0059C8  2442759C   ADDIU V0, V0, 30108
9D0059CC  A4430028   SH V1, 40(V0)
3631:                
3632:                                // Set Initial Send Sequence (ISS) number
3633:                                // Nothing to do on this step... ISS already set in CloseSocket()
3634:                
3635:                                // Respond with SYN + ACK
3636:                                SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9D0059D0  24040012   ADDIU A0, ZERO, 18
9D0059D4  24050001   ADDIU A1, ZERO, 1
9D0059D8  0F400F2C   JAL 0x9D003CB0
9D0059DC  00000000   NOP
3637:                                MyTCBStub.smState = TCP_SYN_RECEIVED;
9D0059E0  93828014   LBU V0, -32748(GP)
9D0059E4  3C03A000   LUI V1, -24576
9D0059E8  2463753C   ADDIU V1, V1, 30012
9D0059EC  00021100   SLL V0, V0, 4
9D0059F0  00022080   SLL A0, V0, 2
9D0059F4  00821023   SUBU V0, A0, V0
9D0059F8  00621021   ADDU V0, V1, V0
9D0059FC  24030006   ADDIU V1, ZERO, 6
9D005A00  AC430024   SW V1, 36(V0)
3638:                            }
3639:                            else
3640:                            {
3641:                                CloseSocket();  // Unbind remote IP address/port info
9D005A0C  0F401470   JAL 0x9D0051C0
9D005A10  00000000   NOP
3642:                            }
3643:                
3644:                            // Fourth: check for other text and control
3645:                            // Nothing to do since we don't support this
3646:                            return;
9D005A04  0B401EC9   J 0x9D007B24
9D005A08  00000000   NOP
9D005A14  0B401EC9   J 0x9D007B24
9D005A18  00000000   NOP
3647:                
3648:                        case TCP_SYN_SENT:
3649:                            // Second: check the RST bit
3650:                            // This is out of order because this stack has no API for
3651:                            // notifying the application that the connection seems to
3652:                            // be failing.  Instead, the application must time out and
3653:                            // the stack will just keep trying in the mean time.
3654:                            if(localHeaderFlags & RST)
9D005A1C  93C2002B   LBU V0, 43(S8)
9D005A20  30420004   ANDI V0, V0, 4
9D005A24  14400823   BNE V0, ZERO, 0x9D007AB4
9D005A28  00000000   NOP
3655:                                return;
9D007AB4  00000000   NOP
9D007AB8  0B401EC9   J 0x9D007B24
9D007ABC  00000000   NOP
3656:                
3657:                            // First: check ACK bit
3658:                            if(localHeaderFlags & ACK)
9D005A2C  93C2002B   LBU V0, 43(S8)
9D005A30  30420010   ANDI V0, V0, 16
9D005A34  10400019   BEQ V0, ZERO, 0x9D005A9C
9D005A38  00000000   NOP
3659:                            {
3660:                                if(localAckNumber != MyTCB.MySEQ)
9D005A3C  3C02A000   LUI V0, -24576
9D005A40  2442759C   ADDIU V0, V0, 30108
9D005A44  8C430004   LW V1, 4(V0)
9D005A48  8FC20024   LW V0, 36(S8)
9D005A4C  10620013   BEQ V1, V0, 0x9D005A9C
9D005A50  00000000   NOP
3661:                                {
3662:                                    // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ
3663:                                    // number for arivial of any other SYN+ACK packets
3664:                                    localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number
9D005A54  3C02A000   LUI V0, -24576
9D005A58  2442759C   ADDIU V0, V0, 30108
9D005A5C  8C420004   LW V0, 4(V0)
9D005A60  AFC2002C   SW V0, 44(S8)
3665:                                    MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK
9D005A64  3C02A000   LUI V0, -24576
9D005A68  2442759C   ADDIU V0, V0, 30108
9D005A6C  8FC30024   LW V1, 36(S8)
9D005A70  AC430004   SW V1, 4(V0)
3666:                                    SendTCP(RST, SENDTCP_RESET_TIMERS);     // Send the RST
9D005A74  24040004   ADDIU A0, ZERO, 4
9D005A78  24050001   ADDIU A1, ZERO, 1
9D005A7C  0F400F2C   JAL 0x9D003CB0
9D005A80  00000000   NOP
3667:                                    MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number
9D005A84  3C02A000   LUI V0, -24576
9D005A88  2442759C   ADDIU V0, V0, 30108
9D005A8C  8FC3002C   LW V1, 44(S8)
9D005A90  AC430004   SW V1, 4(V0)
3668:                                    return;
9D005A94  0B401EC9   J 0x9D007B24
9D005A98  00000000   NOP
3669:                                }
3670:                            }
3671:                
3672:                            // Third: check the security and precedence
3673:                            // No such feature in this stack.  We want to accept all connections.
3674:                
3675:                            // Fourth: check the SYN bit
3676:                            if(localHeaderFlags & SYN)
9D005A9C  93C2002B   LBU V0, 43(S8)
9D005AA0  30420002   ANDI V0, V0, 2
9D005AA4  10400806   BEQ V0, ZERO, 0x9D007AC0
9D005AA8  00000000   NOP
3677:                            {
3678:                                // We now have an initial sequence number and window size
3679:                                MyTCB.RemoteSEQ = localSeqNumber + 1;
9D005AAC  8FC2002C   LW V0, 44(S8)
9D005AB0  24430001   ADDIU V1, V0, 1
9D005AB4  3C02A000   LUI V0, -24576
9D005AB8  2442759C   ADDIU V0, V0, 30108
9D005ABC  AC430008   SW V1, 8(V0)
3680:                                MyTCB.remoteWindow = h->Window;
9D005AC0  8FC20048   LW V0, 72(S8)
9D005AC4  9443000E   LHU V1, 14(V0)
9D005AC8  3C02A000   LUI V0, -24576
9D005ACC  2442759C   ADDIU V0, V0, 30108
9D005AD0  A4430014   SH V1, 20(V0)
3681:                
3682:                                // Get MSS option
3683:                                MyTCB.wRemoteMSS = GetMaxSegSizeOption();
9D005AD4  0F401581   JAL 0x9D005604
9D005AD8  00000000   NOP
9D005ADC  00401821   ADDU V1, V0, ZERO
9D005AE0  3C02A000   LUI V0, -24576
9D005AE4  2442759C   ADDIU V0, V0, 30108
9D005AE8  A4430028   SH V1, 40(V0)
3684:                
3685:                                if(localHeaderFlags & ACK)
9D005AEC  93C2002B   LBU V0, 43(S8)
9D005AF0  30420010   ANDI V0, V0, 16
9D005AF4  1040002A   BEQ V0, ZERO, 0x9D005BA0
9D005AF8  00000000   NOP
3686:                                {
3687:                                    SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D005AFC  24040010   ADDIU A0, ZERO, 16
9D005B00  24050001   ADDIU A1, ZERO, 1
9D005B04  0F400F2C   JAL 0x9D003CB0
9D005B08  00000000   NOP
3688:                                    MyTCBStub.smState = TCP_ESTABLISHED;
9D005B0C  93828014   LBU V0, -32748(GP)
9D005B10  3C03A000   LUI V1, -24576
9D005B14  2463753C   ADDIU V1, V1, 30012
9D005B18  00021100   SLL V0, V0, 4
9D005B1C  00022080   SLL A0, V0, 2
9D005B20  00821023   SUBU V0, A0, V0
9D005B24  00621021   ADDU V0, V1, V0
9D005B28  24030007   ADDIU V1, ZERO, 7
9D005B2C  AC430024   SW V1, 36(V0)
3689:                                    // Set up keep-alive timer
3690:                                    #if defined(TCP_KEEP_ALIVE_TIMEOUT)
3691:                                        MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D005B30  93828014   LBU V0, -32748(GP)
9D005B34  00408021   ADDU S0, V0, ZERO
9D005B38  0F405C42   JAL TickGet
9D005B3C  00000000   NOP
9D005B40  00401821   ADDU V1, V0, ZERO
9D005B44  3C02002F   LUI V0, 47
9D005B48  3442AF08   ORI V0, V0, -20728
9D005B4C  00621821   ADDU V1, V1, V0
9D005B50  3C02A000   LUI V0, -24576
9D005B54  2444753C   ADDIU A0, V0, 30012
9D005B58  02001021   ADDU V0, S0, ZERO
9D005B5C  00021100   SLL V0, V0, 4
9D005B60  00022880   SLL A1, V0, 2
9D005B64  00A21023   SUBU V0, A1, V0
9D005B68  00821021   ADDU V0, A0, V0
9D005B6C  AC43001C   SW V1, 28(V0)
3692:                                    #endif
3693:                                    MyTCBStub.Flags.bTimerEnabled = 0;
9D005B70  93828014   LBU V0, -32748(GP)
9D005B74  3C04A000   LUI A0, -24576
9D005B78  00021100   SLL V0, V0, 4
9D005B7C  00021880   SLL V1, V0, 2
9D005B80  00621823   SUBU V1, V1, V0
9D005B84  2482753C   ADDIU V0, A0, 30012
9D005B88  00621821   ADDU V1, V1, V0
9D005B8C  8C620028   LW V0, 40(V1)
9D005B90  7C022104   INS V0, ZERO, 4, 1
9D005B94  AC620028   SW V0, 40(V1)
3694:                                }
3695:                                else
3696:                                {
3697:                                    SendTCP(SYN | ACK, SENDTCP_RESET_TIMERS);
9D005BA0  24040012   ADDIU A0, ZERO, 18
9D005BA4  24050001   ADDIU A1, ZERO, 1
9D005BA8  0F400F2C   JAL 0x9D003CB0
9D005BAC  00000000   NOP
3698:                                    MyTCBStub.smState = TCP_SYN_RECEIVED;
9D005BB0  93828014   LBU V0, -32748(GP)
9D005BB4  3C03A000   LUI V1, -24576
9D005BB8  2463753C   ADDIU V1, V1, 30012
9D005BBC  00021100   SLL V0, V0, 4
9D005BC0  00022080   SLL A0, V0, 2
9D005BC4  00821023   SUBU V0, A0, V0
9D005BC8  00621021   ADDU V0, V1, V0
9D005BCC  24030006   ADDIU V1, ZERO, 6
9D005BD0  AC430024   SW V1, 36(V0)
3699:                                }
3700:                            }
3701:                
3702:                            // Fifth: drop the segment if neither SYN or RST is set
3703:                            return;
9D005B98  0B401EC9   J 0x9D007B24
9D005B9C  00000000   NOP
9D005BD4  0B401EC9   J 0x9D007B24
9D005BD8  00000000   NOP
9D007AC0  00000000   NOP
9D007AC4  0B401EC9   J 0x9D007B24
9D007AC8  00000000   NOP
3704:                
3705:                        default:
3706:                            break;
3707:                    }
3708:                
3709:                    //
3710:                    // First: check the sequence number
3711:                    //
3712:                    wSegmentLength = len;
9D005BDC  97C2004C   LHU V0, 76(S8)
9D005BE0  A7C20028   SH V0, 40(S8)
3713:                    if(localHeaderFlags & FIN)
9D005BE4  93C2002B   LBU V0, 43(S8)
9D005BE8  30420001   ANDI V0, V0, 1
9D005BEC  304200FF   ANDI V0, V0, 255
9D005BF0  10400004   BEQ V0, ZERO, 0x9D005C04
9D005BF4  00000000   NOP
3714:                        wSegmentLength++;
9D005BF8  97C20028   LHU V0, 40(S8)
9D005BFC  24420001   ADDIU V0, V0, 1
9D005C00  A7C20028   SH V0, 40(S8)
3715:                    if(localHeaderFlags & SYN)
9D005C04  93C2002B   LBU V0, 43(S8)
9D005C08  30420002   ANDI V0, V0, 2
9D005C0C  10400004   BEQ V0, ZERO, 0x9D005C20
9D005C10  00000000   NOP
3716:                        wSegmentLength++;
9D005C14  97C20028   LHU V0, 40(S8)
9D005C18  24420001   ADDIU V0, V0, 1
9D005C1C  A7C20028   SH V0, 40(S8)
3717:                
3718:                    // Calculate the RX FIFO space
3719:                    if(MyTCBStub.rxHead >= MyTCBStub.rxTail)
9D005C20  93828014   LBU V0, -32748(GP)
9D005C24  3C03A000   LUI V1, -24576
9D005C28  2463753C   ADDIU V1, V1, 30012
9D005C2C  00021100   SLL V0, V0, 4
9D005C30  00022080   SLL A0, V0, 2
9D005C34  00821023   SUBU V0, A0, V0
9D005C38  00621021   ADDU V0, V1, V0
9D005C3C  8C440014   LW A0, 20(V0)
9D005C40  93828014   LBU V0, -32748(GP)
9D005C44  3C05A000   LUI A1, -24576
9D005C48  00021100   SLL V0, V0, 4
9D005C4C  00021880   SLL V1, V0, 2
9D005C50  00621823   SUBU V1, V1, V0
9D005C54  24A2753C   ADDIU V0, A1, 30012
9D005C58  00621021   ADDU V0, V1, V0
9D005C5C  8C420018   LW V0, 24(V0)
9D005C60  0082102B   SLTU V0, A0, V0
9D005C64  1440002D   BNE V0, ZERO, 0x9D005D1C
9D005C68  00000000   NOP
3720:                        wFreeSpace = (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart) - (MyTCBStub.rxHead - MyTCBStub.rxTail);
9D005C6C  93828014   LBU V0, -32748(GP)
9D005C70  3C04A000   LUI A0, -24576
9D005C74  00021100   SLL V0, V0, 4
9D005C78  00021880   SLL V1, V0, 2
9D005C7C  00621823   SUBU V1, V1, V0
9D005C80  2482753C   ADDIU V0, A0, 30012
9D005C84  00621021   ADDU V0, V1, V0
9D005C88  8C420008   LW V0, 8(V0)
9D005C8C  3043FFFF   ANDI V1, V0, -1
9D005C90  93828014   LBU V0, -32748(GP)
9D005C94  3C04A000   LUI A0, -24576
9D005C98  2484753C   ADDIU A0, A0, 30012
9D005C9C  00021100   SLL V0, V0, 4
9D005CA0  00022880   SLL A1, V0, 2
9D005CA4  00A21023   SUBU V0, A1, V0
9D005CA8  00821021   ADDU V0, A0, V0
9D005CAC  8C420004   LW V0, 4(V0)
9D005CB0  3042FFFF   ANDI V0, V0, -1
9D005CB4  00621023   SUBU V0, V1, V0
9D005CB8  3044FFFF   ANDI A0, V0, -1
9D005CBC  93828014   LBU V0, -32748(GP)
9D005CC0  3C05A000   LUI A1, -24576
9D005CC4  00021100   SLL V0, V0, 4
9D005CC8  00021880   SLL V1, V0, 2
9D005CCC  00621823   SUBU V1, V1, V0
9D005CD0  24A2753C   ADDIU V0, A1, 30012
9D005CD4  00621021   ADDU V0, V1, V0
9D005CD8  8C420018   LW V0, 24(V0)
9D005CDC  3043FFFF   ANDI V1, V0, -1
9D005CE0  93828014   LBU V0, -32748(GP)
9D005CE4  3C05A000   LUI A1, -24576
9D005CE8  24A5753C   ADDIU A1, A1, 30012
9D005CEC  00021100   SLL V0, V0, 4
9D005CF0  00023080   SLL A2, V0, 2
9D005CF4  00C21023   SUBU V0, A2, V0
9D005CF8  00A21021   ADDU V0, A1, V0
9D005CFC  8C420014   LW V0, 20(V0)
9D005D00  3042FFFF   ANDI V0, V0, -1
9D005D04  00621023   SUBU V0, V1, V0
9D005D08  3042FFFF   ANDI V0, V0, -1
9D005D0C  00821021   ADDU V0, A0, V0
9D005D10  A7C20020   SH V0, 32(S8)
9D005D14  0B40175D   J 0x9D005D74
9D005D18  00000000   NOP
3721:                    else
3722:                        wFreeSpace = MyTCBStub.rxTail - MyTCBStub.rxHead - 1;
9D005D1C  93828014   LBU V0, -32748(GP)
9D005D20  3C04A000   LUI A0, -24576
9D005D24  00021100   SLL V0, V0, 4
9D005D28  00021880   SLL V1, V0, 2
9D005D2C  00621823   SUBU V1, V1, V0
9D005D30  2482753C   ADDIU V0, A0, 30012
9D005D34  00621021   ADDU V0, V1, V0
9D005D38  8C420018   LW V0, 24(V0)
9D005D3C  3043FFFF   ANDI V1, V0, -1
9D005D40  93828014   LBU V0, -32748(GP)
9D005D44  3C04A000   LUI A0, -24576
9D005D48  2484753C   ADDIU A0, A0, 30012
9D005D4C  00021100   SLL V0, V0, 4
9D005D50  00022880   SLL A1, V0, 2
9D005D54  00A21023   SUBU V0, A1, V0
9D005D58  00821021   ADDU V0, A0, V0
9D005D5C  8C420014   LW V0, 20(V0)
9D005D60  3042FFFF   ANDI V0, V0, -1
9D005D64  00621023   SUBU V0, V1, V0
9D005D68  3042FFFF   ANDI V0, V0, -1
9D005D6C  2442FFFF   ADDIU V0, V0, -1
9D005D70  A7C20020   SH V0, 32(S8)
3723:                
3724:                    // Calculate the number of bytes ahead of our head pointer this segment skips
3725:                    lMissingBytes = localSeqNumber - MyTCB.RemoteSEQ;
9D005D74  3C02A000   LUI V0, -24576
9D005D78  2442759C   ADDIU V0, V0, 30108
9D005D7C  8C420008   LW V0, 8(V0)
9D005D80  8FC3002C   LW V1, 44(S8)
9D005D84  00621023   SUBU V0, V1, V0
9D005D88  AFC20030   SW V0, 48(S8)
3726:                    wMissingBytes = (uint16_t)lMissingBytes;
9D005D8C  8FC20030   LW V0, 48(S8)
9D005D90  A7C20034   SH V0, 52(S8)
3727:                
3728:                    // Run TCP acceptability tests to verify that this packet has a valid sequence number
3729:                    bSegmentAcceptable = false;
9D005D94  A3C0002A   SB ZERO, 42(S8)
3730:                    if(wSegmentLength)
9D005D98  97C20028   LHU V0, 40(S8)
9D005D9C  10400030   BEQ V0, ZERO, 0x9D005E60
9D005DA0  00000000   NOP
3731:                    {
3732:                        // Check to see if we have free space, and if so, if any of the data falls within the freespace
3733:                        if(wFreeSpace)
9D005DA4  97C20020   LHU V0, 32(S8)
9D005DA8  1040003E   BEQ V0, ZERO, 0x9D005EA4
9D005DAC  00000000   NOP
3734:                        {
3735:                            // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
3736:                            if((lMissingBytes >= (int32_t)0) && (wFreeSpace > (uint32_t)lMissingBytes))
9D005DB0  8FC20030   LW V0, 48(S8)
9D005DB4  0440000A   BLTZ V0, 0x9D005DE0
9D005DB8  00000000   NOP
9D005DBC  97C30020   LHU V1, 32(S8)
9D005DC0  8FC20030   LW V0, 48(S8)
9D005DC4  0043102B   SLTU V0, V0, V1
9D005DC8  10400005   BEQ V0, ZERO, 0x9D005DE0
9D005DCC  00000000   NOP
3737:                                bSegmentAcceptable = true;
9D005DD0  24020001   ADDIU V0, ZERO, 1
9D005DD4  A3C2002A   SB V0, 42(S8)
9D005DD8  0B401789   J 0x9D005E24
9D005DDC  00000000   NOP
3738:                            else
3739:                            {
3740:                                // RCV.NXT =< SEG.SEQ+SEG.LEN-1 < RCV.NXT+RCV.WND
3741:                                if((lMissingBytes + (int32_t)wSegmentLength > (int32_t)0) && (lMissingBytes <= (int32_t)(int16_t)(wFreeSpace - wSegmentLength)))
9D005DE0  97C30028   LHU V1, 40(S8)
9D005DE4  8FC20030   LW V0, 48(S8)
9D005DE8  00621021   ADDU V0, V1, V0
9D005DEC  1840000D   BLEZ V0, 0x9D005E24
9D005DF0  00000000   NOP
9D005DF4  97C30020   LHU V1, 32(S8)
9D005DF8  97C20028   LHU V0, 40(S8)
9D005DFC  00621023   SUBU V0, V1, V0
9D005E00  3042FFFF   ANDI V0, V0, -1
9D005E04  7C021620   SEH V0, V0
9D005E08  00401821   ADDU V1, V0, ZERO
9D005E0C  8FC20030   LW V0, 48(S8)
9D005E10  0062102A   SLT V0, V1, V0
9D005E14  14400003   BNE V0, ZERO, 0x9D005E24
9D005E18  00000000   NOP
3742:                                    bSegmentAcceptable = true;
9D005E1C  24020001   ADDIU V0, ZERO, 1
9D005E20  A3C2002A   SB V0, 42(S8)
3743:                            }
3744:                
3745:                            if((lMissingBytes < (int32_t)wFreeSpace) && ((int16_t)wMissingBytes + (int16_t)wSegmentLength > (int16_t)0))
9D005E24  97C30020   LHU V1, 32(S8)
9D005E28  8FC20030   LW V0, 48(S8)
9D005E2C  0043102A   SLT V0, V0, V1
9D005E30  1040001C   BEQ V0, ZERO, 0x9D005EA4
9D005E34  00000000   NOP
9D005E38  87C20034   LH V0, 52(S8)
9D005E3C  00401821   ADDU V1, V0, ZERO
9D005E40  87C20028   LH V0, 40(S8)
9D005E44  00621021   ADDU V0, V1, V0
9D005E48  18400016   BLEZ V0, 0x9D005EA4
9D005E4C  00000000   NOP
3746:                                bSegmentAcceptable = true;
9D005E50  24020001   ADDIU V0, ZERO, 1
9D005E54  A3C2002A   SB V0, 42(S8)
9D005E58  0B4017A9   J 0x9D005EA4
9D005E5C  00000000   NOP
3747:                        }
3748:                        // Segments with data are not acceptable if we have no free space
3749:                    }
3750:                    else
3751:                    {
3752:                        // Zero length packets are acceptable if they fall within our free space window
3753:                        // SEG.SEQ = RCV.NXT
3754:                        if(lMissingBytes == 0)
9D005E60  8FC20030   LW V0, 48(S8)
9D005E64  14400005   BNE V0, ZERO, 0x9D005E7C
9D005E68  00000000   NOP
3755:                        {
3756:                            bSegmentAcceptable = true;
9D005E6C  24020001   ADDIU V0, ZERO, 1
9D005E70  A3C2002A   SB V0, 42(S8)
9D005E74  0B4017A9   J 0x9D005EA4
9D005E78  00000000   NOP
3757:                        }
3758:                        else
3759:                        {
3760:                            // RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND
3761:                            if((lMissingBytes >= (int32_t)0) && (wFreeSpace > (uint32_t)lMissingBytes))
9D005E7C  8FC20030   LW V0, 48(S8)
9D005E80  04400008   BLTZ V0, 0x9D005EA4
9D005E84  00000000   NOP
9D005E88  97C30020   LHU V1, 32(S8)
9D005E8C  8FC20030   LW V0, 48(S8)
9D005E90  0043102B   SLTU V0, V0, V1
9D005E94  10400003   BEQ V0, ZERO, 0x9D005EA4
9D005E98  00000000   NOP
3762:                                bSegmentAcceptable = true;
9D005E9C  24020001   ADDIU V0, ZERO, 1
9D005EA0  A3C2002A   SB V0, 42(S8)
3763:                        }
3764:                    }
3765:                
3766:                    if(!bSegmentAcceptable)
9D005EA4  93C2002A   LBU V0, 42(S8)
9D005EA8  38420001   XORI V0, V0, 1
9D005EAC  304200FF   ANDI V0, V0, 255
9D005EB0  1040000B   BEQ V0, ZERO, 0x9D005EE0
9D005EB4  00000000   NOP
3767:                    {
3768:                        // Unacceptable segment, drop it and respond appropriately
3769:                        if(!(localHeaderFlags & RST))
9D005EB8  93C2002B   LBU V0, 43(S8)
9D005EBC  30420004   ANDI V0, V0, 4
9D005EC0  14400702   BNE V0, ZERO, 0x9D007ACC
9D005EC4  00000000   NOP
3770:                            SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D005EC8  24040010   ADDIU A0, ZERO, 16
9D005ECC  24050001   ADDIU A1, ZERO, 1
9D005ED0  0F400F2C   JAL 0x9D003CB0
9D005ED4  00000000   NOP
3771:                        return;
9D005ED8  0B401EC9   J 0x9D007B24
9D005EDC  00000000   NOP
9D007ACC  00000000   NOP
9D007AD0  0B401EC9   J 0x9D007B24
9D007AD4  00000000   NOP
3772:                    }
3773:                
3774:                
3775:                    //
3776:                    // Second: check the RST bit
3777:                    //
3778:                    //
3779:                    // Fourth: check the SYN bit
3780:                    //
3781:                    // Note, that since the third step is not implemented, we can
3782:                    // combine this second and fourth step into a single operation.
3783:                    if(localHeaderFlags & (RST | SYN))
9D005EE0  93C2002B   LBU V0, 43(S8)
9D005EE4  30420006   ANDI V0, V0, 6
9D005EE8  10400005   BEQ V0, ZERO, 0x9D005F00
9D005EEC  00000000   NOP
3784:                    {
3785:                        CloseSocket();
9D005EF0  0F401470   JAL 0x9D0051C0
9D005EF4  00000000   NOP
3786:                        return;
9D005EF8  0B401EC9   J 0x9D007B24
9D005EFC  00000000   NOP
3787:                    }
3788:                
3789:                    //
3790:                    // Third: check the security and precedence
3791:                    //
3792:                    // Feature not supported.  Let's process this segment.
3793:                
3794:                    //
3795:                    // Fifth: check the ACK bit
3796:                    //
3797:                    if(!(localHeaderFlags & ACK))
9D005F00  93C2002B   LBU V0, 43(S8)
9D005F04  30420010   ANDI V0, V0, 16
9D005F08  104006F3   BEQ V0, ZERO, 0x9D007AD8
9D005F0C  00000000   NOP
3798:                        return;
9D007AD8  00000000   NOP
9D007ADC  0B401EC9   J 0x9D007B24
9D007AE0  00000000   NOP
3799:                
3800:                    switch(MyTCBStub.smState)
9D005F10  93828014   LBU V0, -32748(GP)
9D005F14  3C03A000   LUI V1, -24576
9D005F18  2463753C   ADDIU V1, V1, 30012
9D005F1C  00021100   SLL V0, V0, 4
9D005F20  00022080   SLL A0, V0, 2
9D005F24  00821023   SUBU V0, A0, V0
9D005F28  00621021   ADDU V0, V1, V0
9D005F2C  8C420024   LW V0, 36(V0)
9D005F30  2C43000C   SLTIU V1, V0, 12
9D005F34  10600009   BEQ V1, ZERO, 0x9D005F5C
9D005F38  00000000   NOP
9D005F3C  2C430007   SLTIU V1, V0, 7
9D005F40  1060002C   BEQ V1, ZERO, 0x9D005FF4
9D005F44  00000000   NOP
9D005F48  24030006   ADDIU V1, ZERO, 6
9D005F4C  10430008   BEQ V0, V1, 0x9D005F70
9D005F50  00000000   NOP
9D005F5C  2403000C   ADDIU V1, ZERO, 12
9D005F60  1043032A   BEQ V0, V1, 0x9D006C0C
9D005F64  00000000   NOP
3801:                    {
3802:                        case TCP_SYN_RECEIVED:
3803:                            if(localAckNumber != MyTCB.MySEQ)
9D005F70  3C02A000   LUI V0, -24576
9D005F74  2442759C   ADDIU V0, V0, 30108
9D005F78  8C430004   LW V1, 4(V0)
9D005F7C  8FC20024   LW V0, 36(S8)
9D005F80  10620013   BEQ V1, V0, 0x9D005FD0
9D005F84  00000000   NOP
3804:                            {
3805:                                // Send a RST packet with SEQ = SEG.ACK, but retain our SEQ
3806:                                // number for arivial of any other correct packets
3807:                                localSeqNumber = MyTCB.MySEQ;   // Save our original SEQ number
9D005F88  3C02A000   LUI V0, -24576
9D005F8C  2442759C   ADDIU V0, V0, 30108
9D005F90  8C420004   LW V0, 4(V0)
9D005F94  AFC2002C   SW V0, 44(S8)
3808:                                MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK
9D005F98  3C02A000   LUI V0, -24576
9D005F9C  2442759C   ADDIU V0, V0, 30108
9D005FA0  8FC30024   LW V1, 36(S8)
9D005FA4  AC430004   SW V1, 4(V0)
3809:                                SendTCP(RST, SENDTCP_RESET_TIMERS);     // Send the RST
9D005FA8  24040004   ADDIU A0, ZERO, 4
9D005FAC  24050001   ADDIU A1, ZERO, 1
9D005FB0  0F400F2C   JAL 0x9D003CB0
9D005FB4  00000000   NOP
3810:                                MyTCB.MySEQ = localSeqNumber;   // Restore original SEQ number
9D005FB8  3C02A000   LUI V0, -24576
9D005FBC  2442759C   ADDIU V0, V0, 30108
9D005FC0  8FC3002C   LW V1, 44(S8)
9D005FC4  AC430004   SW V1, 4(V0)
3811:                                return;
9D005FC8  0B401EC9   J 0x9D007B24
9D005FCC  00000000   NOP
3812:                            }
3813:                            MyTCBStub.smState = TCP_ESTABLISHED;
9D005FD0  93828014   LBU V0, -32748(GP)
9D005FD4  3C03A000   LUI V1, -24576
9D005FD8  2463753C   ADDIU V1, V1, 30012
9D005FDC  00021100   SLL V0, V0, 4
9D005FE0  00022080   SLL A0, V0, 2
9D005FE4  00821023   SUBU V0, A0, V0
9D005FE8  00621021   ADDU V0, V1, V0
9D005FEC  24030007   ADDIU V1, ZERO, 7
9D005FF0  AC430024   SW V1, 36(V0)
3814:                            // No break
3815:                
3816:                        case TCP_ESTABLISHED:
3817:                        case TCP_FIN_WAIT_1:
3818:                        case TCP_FIN_WAIT_2:
3819:                        case TCP_CLOSE_WAIT:
3820:                        case TCP_CLOSING:
3821:                            // Calculate what the highest possible SEQ number in our TX FIFO is
3822:                            wTemp = MyTCBStub.txHead - MyTCB.txUnackedTail;
9D005FF4  93828014   LBU V0, -32748(GP)
9D005FF8  3C03A000   LUI V1, -24576
9D005FFC  2463753C   ADDIU V1, V1, 30012
9D006000  00021100   SLL V0, V0, 4
9D006004  00022080   SLL A0, V0, 2
9D006008  00821023   SUBU V0, A0, V0
9D00600C  00621021   ADDU V0, V1, V0
9D006010  8C43000C   LW V1, 12(V0)
9D006014  3C02A000   LUI V0, -24576
9D006018  2442759C   ADDIU V0, V0, 30108
9D00601C  8C42000C   LW V0, 12(V0)
9D006020  00621023   SUBU V0, V1, V0
9D006024  AFC2001C   SW V0, 28(S8)
3823:                            if((int16_t)wTemp < (int16_t)0)
9D006028  8FC2001C   LW V0, 28(S8)
9D00602C  7C021620   SEH V0, V0
9D006030  04410015   BGEZ V0, 0x9D006088
9D006034  00000000   NOP
3824:                                wTemp += MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D006038  93828014   LBU V0, -32748(GP)
9D00603C  3C03A000   LUI V1, -24576
9D006040  2463753C   ADDIU V1, V1, 30012
9D006044  00021100   SLL V0, V0, 4
9D006048  00022080   SLL A0, V0, 2
9D00604C  00821023   SUBU V0, A0, V0
9D006050  00621021   ADDU V0, V1, V0
9D006054  8C440004   LW A0, 4(V0)
9D006058  93828014   LBU V0, -32748(GP)
9D00605C  3C05A000   LUI A1, -24576
9D006060  00021100   SLL V0, V0, 4
9D006064  00021880   SLL V1, V0, 2
9D006068  00621823   SUBU V1, V1, V0
9D00606C  24A2753C   ADDIU V0, A1, 30012
9D006070  00621021   ADDU V0, V1, V0
9D006074  8C420000   LW V0, 0(V0)
9D006078  00821023   SUBU V0, A0, V0
9D00607C  8FC3001C   LW V1, 28(S8)
9D006080  00621021   ADDU V0, V1, V0
9D006084  AFC2001C   SW V0, 28(S8)
3825:                            dwTemp = MyTCB.MySEQ + (uint32_t)wTemp;
9D006088  3C02A000   LUI V0, -24576
9D00608C  2442759C   ADDIU V0, V0, 30108
9D006090  8C430004   LW V1, 4(V0)
9D006094  8FC2001C   LW V0, 28(S8)
9D006098  00621021   ADDU V0, V1, V0
9D00609C  AFC20018   SW V0, 24(S8)
3826:                
3827:                            // Drop the packet if it ACKs something we haven't sent
3828:                            dwTemp = (int32_t)localAckNumber - (int32_t)dwTemp;
9D0060A0  8FC30024   LW V1, 36(S8)
9D0060A4  8FC20018   LW V0, 24(S8)
9D0060A8  00621023   SUBU V0, V1, V0
9D0060AC  AFC20018   SW V0, 24(S8)
3829:                            if((int32_t)dwTemp > 0)
9D0060B0  8FC20018   LW V0, 24(S8)
9D0060B4  18400015   BLEZ V0, 0x9D00610C
9D0060B8  00000000   NOP
3830:                            {   // acknowledged more than we've sent??
3831:                                if(!MyTCB.flags.bFINSent || dwTemp != 1)
9D0060BC  3C02A000   LUI V0, -24576
9D0060C0  2442759C   ADDIU V0, V0, 30108
9D0060C4  8C430024   LW V1, 36(V0)
9D0060C8  3C020001   LUI V0, 1
9D0060CC  00621024   AND V0, V1, V0
9D0060D0  10400005   BEQ V0, ZERO, 0x9D0060E8
9D0060D4  00000000   NOP
9D0060D8  8FC30018   LW V1, 24(S8)
9D0060DC  24020001   ADDIU V0, ZERO, 1
9D0060E0  10620007   BEQ V1, V0, 0x9D006100
9D0060E4  00000000   NOP
3832:                                {
3833:                                    SendTCP(ACK, 0);
9D0060E8  24040010   ADDIU A0, ZERO, 16
9D0060EC  00002821   ADDU A1, ZERO, ZERO
9D0060F0  0F400F2C   JAL 0x9D003CB0
9D0060F4  00000000   NOP
3834:                                    return;
9D0060F8  0B401EC9   J 0x9D007B24
9D0060FC  00000000   NOP
3835:                                }
3836:                                else
3837:                                {
3838:                                    localAckNumber--;   // since we don't count the FIN anyway
9D006100  8FC20024   LW V0, 36(S8)
9D006104  2442FFFF   ADDIU V0, V0, -1
9D006108  AFC20024   SW V0, 36(S8)
3839:                                }
3840:                            }
3841:                
3842:                            // Throw away all ACKnowledged TX data:
3843:                            // Calculate what the last acknowledged sequence number was (ignoring any FINs we sent)
3844:                            dwTemp = MyTCB.MySEQ - (int32_t)(int16_t)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9D00610C  3C02A000   LUI V0, -24576
9D006110  2442759C   ADDIU V0, V0, 30108
9D006114  8C440004   LW A0, 4(V0)
9D006118  3C02A000   LUI V0, -24576
9D00611C  2442759C   ADDIU V0, V0, 30108
9D006120  8C42000C   LW V0, 12(V0)
9D006124  3045FFFF   ANDI A1, V0, -1
9D006128  93828014   LBU V0, -32748(GP)
9D00612C  3C06A000   LUI A2, -24576
9D006130  00021100   SLL V0, V0, 4
9D006134  00021880   SLL V1, V0, 2
9D006138  00621823   SUBU V1, V1, V0
9D00613C  24C2753C   ADDIU V0, A2, 30012
9D006140  00621021   ADDU V0, V1, V0
9D006144  8C420010   LW V0, 16(V0)
9D006148  3042FFFF   ANDI V0, V0, -1
9D00614C  00A21023   SUBU V0, A1, V0
9D006150  3042FFFF   ANDI V0, V0, -1
9D006154  7C021620   SEH V0, V0
9D006158  00821023   SUBU V0, A0, V0
9D00615C  AFC20018   SW V0, 24(S8)
3845:                            if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D006160  3C02A000   LUI V0, -24576
9D006164  2442759C   ADDIU V0, V0, 30108
9D006168  8C44000C   LW A0, 12(V0)
9D00616C  93828014   LBU V0, -32748(GP)
9D006170  3C05A000   LUI A1, -24576
9D006174  00021100   SLL V0, V0, 4
9D006178  00021880   SLL V1, V0, 2
9D00617C  00621823   SUBU V1, V1, V0
9D006180  24A2753C   ADDIU V0, A1, 30012
9D006184  00621021   ADDU V0, V1, V0
9D006188  8C420010   LW V0, 16(V0)
9D00618C  0082102B   SLTU V0, A0, V0
9D006190  10400015   BEQ V0, ZERO, 0x9D0061E8
9D006194  00000000   NOP
3846:                                dwTemp -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D006198  93828014   LBU V0, -32748(GP)
9D00619C  3C04A000   LUI A0, -24576
9D0061A0  00021100   SLL V0, V0, 4
9D0061A4  00021880   SLL V1, V0, 2
9D0061A8  00621823   SUBU V1, V1, V0
9D0061AC  2482753C   ADDIU V0, A0, 30012
9D0061B0  00621021   ADDU V0, V1, V0
9D0061B4  8C430000   LW V1, 0(V0)
9D0061B8  93828014   LBU V0, -32748(GP)
9D0061BC  3C04A000   LUI A0, -24576
9D0061C0  2484753C   ADDIU A0, A0, 30012
9D0061C4  00021100   SLL V0, V0, 4
9D0061C8  00022880   SLL A1, V0, 2
9D0061CC  00A21023   SUBU V0, A1, V0
9D0061D0  00821021   ADDU V0, A0, V0
9D0061D4  8C420004   LW V0, 4(V0)
9D0061D8  00621023   SUBU V0, V1, V0
9D0061DC  8FC30018   LW V1, 24(S8)
9D0061E0  00621021   ADDU V0, V1, V0
9D0061E4  AFC20018   SW V0, 24(S8)
3847:                
3848:                            // Calcluate how many bytes were ACKed with this packet
3849:                            dwTemp = localAckNumber - dwTemp;
9D0061E8  8FC30024   LW V1, 36(S8)
9D0061EC  8FC20018   LW V0, 24(S8)
9D0061F0  00621023   SUBU V0, V1, V0
9D0061F4  AFC20018   SW V0, 24(S8)
3850:                            if(((int32_t)(dwTemp) > (int32_t)0) && (dwTemp <= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart))
9D0061F8  8FC20018   LW V0, 24(S8)
9D0061FC  18400119   BLEZ V0, 0x9D006664
9D006200  00000000   NOP
9D006204  93828014   LBU V0, -32748(GP)
9D006208  3C03A000   LUI V1, -24576
9D00620C  2463753C   ADDIU V1, V1, 30012
9D006210  00021100   SLL V0, V0, 4
9D006214  00022080   SLL A0, V0, 2
9D006218  00821023   SUBU V0, A0, V0
9D00621C  00621021   ADDU V0, V1, V0
9D006220  8C440004   LW A0, 4(V0)
9D006224  93828014   LBU V0, -32748(GP)
9D006228  3C05A000   LUI A1, -24576
9D00622C  00021100   SLL V0, V0, 4
9D006230  00021880   SLL V1, V0, 2
9D006234  00621823   SUBU V1, V1, V0
9D006238  24A2753C   ADDIU V0, A1, 30012
9D00623C  00621021   ADDU V0, V1, V0
9D006240  8C420000   LW V0, 0(V0)
9D006244  00821823   SUBU V1, A0, V0
9D006248  8FC20018   LW V0, 24(S8)
9D00624C  0062102B   SLTU V0, V1, V0
9D006250  14400104   BNE V0, ZERO, 0x9D006664
9D006254  00000000   NOP
3851:                            {
3852:                                MyTCB.flags.bRXNoneACKed1 = 0;
9D006258  3C02A000   LUI V0, -24576
9D00625C  2443759C   ADDIU V1, V0, 30108
9D006260  8C620024   LW V0, 36(V1)
9D006264  7C029CC4   INS V0, ZERO, 19, 1
9D006268  AC620024   SW V0, 36(V1)
3853:                                MyTCB.flags.bRXNoneACKed2 = 0;
9D00626C  3C02A000   LUI V0, -24576
9D006270  2443759C   ADDIU V1, V0, 30108
9D006274  8C620024   LW V0, 36(V1)
9D006278  7C02A504   INS V0, ZERO, 20, 1
9D00627C  AC620024   SW V0, 36(V1)
3854:                                MyTCBStub.Flags.bHalfFullFlush = false;
9D006280  93828014   LBU V0, -32748(GP)
9D006284  3C04A000   LUI A0, -24576
9D006288  00021100   SLL V0, V0, 4
9D00628C  00021880   SLL V1, V0, 2
9D006290  00621823   SUBU V1, V1, V0
9D006294  2482753C   ADDIU V0, A0, 30012
9D006298  00621821   ADDU V1, V1, V0
9D00629C  8C620028   LW V0, 40(V1)
9D0062A0  7C024204   INS V0, ZERO, 8, 1
9D0062A4  AC620028   SW V0, 40(V1)
3855:                
3856:                                // Bytes ACKed, free up the TX FIFO space
3857:                                wTemp = MyTCBStub.txTail;
9D0062A8  93828014   LBU V0, -32748(GP)
9D0062AC  3C04A000   LUI A0, -24576
9D0062B0  00021100   SLL V0, V0, 4
9D0062B4  00021880   SLL V1, V0, 2
9D0062B8  00621823   SUBU V1, V1, V0
9D0062BC  2482753C   ADDIU V0, A0, 30012
9D0062C0  00621021   ADDU V0, V1, V0
9D0062C4  8C420010   LW V0, 16(V0)
9D0062C8  AFC2001C   SW V0, 28(S8)
3858:                                MyTCBStub.txTail += dwTemp;
9D0062CC  93828014   LBU V0, -32748(GP)
9D0062D0  00403021   ADDU A2, V0, ZERO
9D0062D4  93828014   LBU V0, -32748(GP)
9D0062D8  3C04A000   LUI A0, -24576
9D0062DC  00021100   SLL V0, V0, 4
9D0062E0  00021880   SLL V1, V0, 2
9D0062E4  00621823   SUBU V1, V1, V0
9D0062E8  2482753C   ADDIU V0, A0, 30012
9D0062EC  00621021   ADDU V0, V1, V0
9D0062F0  8C430010   LW V1, 16(V0)
9D0062F4  8FC20018   LW V0, 24(S8)
9D0062F8  00622021   ADDU A0, V1, V0
9D0062FC  3C05A000   LUI A1, -24576
9D006300  00C01021   ADDU V0, A2, ZERO
9D006304  00021100   SLL V0, V0, 4
9D006308  00021880   SLL V1, V0, 2
9D00630C  00621823   SUBU V1, V1, V0
9D006310  24A2753C   ADDIU V0, A1, 30012
9D006314  00621021   ADDU V0, V1, V0
9D006318  AC440010   SW A0, 16(V0)
3859:                                if(MyTCB.txUnackedTail >= wTemp)
9D00631C  3C02A000   LUI V0, -24576
9D006320  2442759C   ADDIU V0, V0, 30108
9D006324  8C43000C   LW V1, 12(V0)
9D006328  8FC2001C   LW V0, 28(S8)
9D00632C  0062102B   SLTU V0, V1, V0
9D006330  1440002F   BNE V0, ZERO, 0x9D0063F0
9D006334  00000000   NOP
3860:                                {
3861:                                    if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D006338  3C02A000   LUI V0, -24576
9D00633C  2442759C   ADDIU V0, V0, 30108
9D006340  8C44000C   LW A0, 12(V0)
9D006344  93828014   LBU V0, -32748(GP)
9D006348  3C05A000   LUI A1, -24576
9D00634C  00021100   SLL V0, V0, 4
9D006350  00021880   SLL V1, V0, 2
9D006354  00621823   SUBU V1, V1, V0
9D006358  24A2753C   ADDIU V0, A1, 30012
9D00635C  00621021   ADDU V0, V1, V0
9D006360  8C420010   LW V0, 16(V0)
9D006364  0082102B   SLTU V0, A0, V0
9D006368  1040005F   BEQ V0, ZERO, 0x9D0064E8
9D00636C  00000000   NOP
3862:                                    {
3863:                                        MyTCB.MySEQ += MyTCBStub.txTail - MyTCB.txUnackedTail;
9D006370  3C02A000   LUI V0, -24576
9D006374  2442759C   ADDIU V0, V0, 30108
9D006378  8C440004   LW A0, 4(V0)
9D00637C  93828014   LBU V0, -32748(GP)
9D006380  3C05A000   LUI A1, -24576
9D006384  00021100   SLL V0, V0, 4
9D006388  00021880   SLL V1, V0, 2
9D00638C  00621823   SUBU V1, V1, V0
9D006390  24A2753C   ADDIU V0, A1, 30012
9D006394  00621021   ADDU V0, V1, V0
9D006398  8C430010   LW V1, 16(V0)
9D00639C  3C02A000   LUI V0, -24576
9D0063A0  2442759C   ADDIU V0, V0, 30108
9D0063A4  8C42000C   LW V0, 12(V0)
9D0063A8  00621023   SUBU V0, V1, V0
9D0063AC  00821821   ADDU V1, A0, V0
9D0063B0  3C02A000   LUI V0, -24576
9D0063B4  2442759C   ADDIU V0, V0, 30108
9D0063B8  AC430004   SW V1, 4(V0)
3864:                                        MyTCB.txUnackedTail = MyTCBStub.txTail;
9D0063BC  93828014   LBU V0, -32748(GP)
9D0063C0  3C04A000   LUI A0, -24576
9D0063C4  00021100   SLL V0, V0, 4
9D0063C8  00021880   SLL V1, V0, 2
9D0063CC  00621823   SUBU V1, V1, V0
9D0063D0  2482753C   ADDIU V0, A0, 30012
9D0063D4  00621021   ADDU V0, V1, V0
9D0063D8  8C430010   LW V1, 16(V0)
9D0063DC  3C02A000   LUI V0, -24576
9D0063E0  2442759C   ADDIU V0, V0, 30108
9D0063E4  AC43000C   SW V1, 12(V0)
9D0063E8  0B40193A   J 0x9D0064E8
9D0063EC  00000000   NOP
3865:                                    }
3866:                                }
3867:                                else
3868:                                {
3869:                                    wTemp = MyTCB.txUnackedTail + (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9D0063F0  3C02A000   LUI V0, -24576
9D0063F4  2442759C   ADDIU V0, V0, 30108
9D0063F8  8C44000C   LW A0, 12(V0)
9D0063FC  93828014   LBU V0, -32748(GP)
9D006400  3C03A000   LUI V1, -24576
9D006404  2463753C   ADDIU V1, V1, 30012
9D006408  00021100   SLL V0, V0, 4
9D00640C  00022880   SLL A1, V0, 2
9D006410  00A21023   SUBU V0, A1, V0
9D006414  00621021   ADDU V0, V1, V0
9D006418  8C450004   LW A1, 4(V0)
9D00641C  93828014   LBU V0, -32748(GP)
9D006420  3C06A000   LUI A2, -24576
9D006424  00021100   SLL V0, V0, 4
9D006428  00021880   SLL V1, V0, 2
9D00642C  00621823   SUBU V1, V1, V0
9D006430  24C2753C   ADDIU V0, A2, 30012
9D006434  00621021   ADDU V0, V1, V0
9D006438  8C420000   LW V0, 0(V0)
9D00643C  00A21023   SUBU V0, A1, V0
9D006440  00821021   ADDU V0, A0, V0
9D006444  AFC2001C   SW V0, 28(S8)
3870:                                    if(wTemp < MyTCBStub.txTail)
9D006448  93828014   LBU V0, -32748(GP)
9D00644C  3C04A000   LUI A0, -24576
9D006450  00021100   SLL V0, V0, 4
9D006454  00021880   SLL V1, V0, 2
9D006458  00621823   SUBU V1, V1, V0
9D00645C  2482753C   ADDIU V0, A0, 30012
9D006460  00621021   ADDU V0, V1, V0
9D006464  8C430010   LW V1, 16(V0)
9D006468  8FC2001C   LW V0, 28(S8)
9D00646C  0043102B   SLTU V0, V0, V1
9D006470  1040001D   BEQ V0, ZERO, 0x9D0064E8
9D006474  00000000   NOP
3871:                                    {
3872:                                        MyTCB.MySEQ += MyTCBStub.txTail - wTemp;
9D006478  3C02A000   LUI V0, -24576
9D00647C  2442759C   ADDIU V0, V0, 30108
9D006480  8C440004   LW A0, 4(V0)
9D006484  93828014   LBU V0, -32748(GP)
9D006488  3C05A000   LUI A1, -24576
9D00648C  00021100   SLL V0, V0, 4
9D006490  00021880   SLL V1, V0, 2
9D006494  00621823   SUBU V1, V1, V0
9D006498  24A2753C   ADDIU V0, A1, 30012
9D00649C  00621021   ADDU V0, V1, V0
9D0064A0  8C430010   LW V1, 16(V0)
9D0064A4  8FC2001C   LW V0, 28(S8)
9D0064A8  00621023   SUBU V0, V1, V0
9D0064AC  00821821   ADDU V1, A0, V0
9D0064B0  3C02A000   LUI V0, -24576
9D0064B4  2442759C   ADDIU V0, V0, 30108
9D0064B8  AC430004   SW V1, 4(V0)
3873:                                        MyTCB.txUnackedTail = MyTCBStub.txTail;
9D0064BC  93828014   LBU V0, -32748(GP)
9D0064C0  3C04A000   LUI A0, -24576
9D0064C4  00021100   SLL V0, V0, 4
9D0064C8  00021880   SLL V1, V0, 2
9D0064CC  00621823   SUBU V1, V1, V0
9D0064D0  2482753C   ADDIU V0, A0, 30012
9D0064D4  00621021   ADDU V0, V1, V0
9D0064D8  8C430010   LW V1, 16(V0)
9D0064DC  3C02A000   LUI V0, -24576
9D0064E0  2442759C   ADDIU V0, V0, 30108
9D0064E4  AC43000C   SW V1, 12(V0)
3874:                                    }
3875:                                }
3876:                                if(MyTCBStub.txTail >= MyTCBStub.bufferRxStart)
9D0064E8  93828014   LBU V0, -32748(GP)
9D0064EC  3C04A000   LUI A0, -24576
9D0064F0  00021100   SLL V0, V0, 4
9D0064F4  00021880   SLL V1, V0, 2
9D0064F8  00621823   SUBU V1, V1, V0
9D0064FC  2482753C   ADDIU V0, A0, 30012
9D006500  00621021   ADDU V0, V1, V0
9D006504  8C430010   LW V1, 16(V0)
9D006508  93828014   LBU V0, -32748(GP)
9D00650C  3C04A000   LUI A0, -24576
9D006510  2484753C   ADDIU A0, A0, 30012
9D006514  00021100   SLL V0, V0, 4
9D006518  00022880   SLL A1, V0, 2
9D00651C  00A21023   SUBU V0, A1, V0
9D006520  00821021   ADDU V0, A0, V0
9D006524  8C420004   LW V0, 4(V0)
9D006528  0062102B   SLTU V0, V1, V0
9D00652C  14400025   BNE V0, ZERO, 0x9D0065C4
9D006530  00000000   NOP
3877:                                    MyTCBStub.txTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D006534  93828014   LBU V0, -32748(GP)
9D006538  00403021   ADDU A2, V0, ZERO
9D00653C  93828014   LBU V0, -32748(GP)
9D006540  3C04A000   LUI A0, -24576
9D006544  00021100   SLL V0, V0, 4
9D006548  00021880   SLL V1, V0, 2
9D00654C  00621823   SUBU V1, V1, V0
9D006550  2482753C   ADDIU V0, A0, 30012
9D006554  00621021   ADDU V0, V1, V0
9D006558  8C440010   LW A0, 16(V0)
9D00655C  93828014   LBU V0, -32748(GP)
9D006560  3C05A000   LUI A1, -24576
9D006564  00021100   SLL V0, V0, 4
9D006568  00021880   SLL V1, V0, 2
9D00656C  00621823   SUBU V1, V1, V0
9D006570  24A2753C   ADDIU V0, A1, 30012
9D006574  00621021   ADDU V0, V1, V0
9D006578  8C430000   LW V1, 0(V0)
9D00657C  93828014   LBU V0, -32748(GP)
9D006580  3C05A000   LUI A1, -24576
9D006584  24A5753C   ADDIU A1, A1, 30012
9D006588  00021100   SLL V0, V0, 4
9D00658C  00023880   SLL A3, V0, 2
9D006590  00E21023   SUBU V0, A3, V0
9D006594  00A21021   ADDU V0, A1, V0
9D006598  8C420004   LW V0, 4(V0)
9D00659C  00621023   SUBU V0, V1, V0
9D0065A0  00822021   ADDU A0, A0, V0
9D0065A4  3C05A000   LUI A1, -24576
9D0065A8  00C01021   ADDU V0, A2, ZERO
9D0065AC  00021100   SLL V0, V0, 4
9D0065B0  00021880   SLL V1, V0, 2
9D0065B4  00621823   SUBU V1, V1, V0
9D0065B8  24A2753C   ADDIU V0, A1, 30012
9D0065BC  00621021   ADDU V0, V1, V0
9D0065C0  AC440010   SW A0, 16(V0)
3878:                                if(MyTCB.txUnackedTail >= MyTCBStub.bufferRxStart)
9D0065C4  3C02A000   LUI V0, -24576
9D0065C8  2442759C   ADDIU V0, V0, 30108
9D0065CC  8C43000C   LW V1, 12(V0)
9D0065D0  93828014   LBU V0, -32748(GP)
9D0065D4  3C04A000   LUI A0, -24576
9D0065D8  2484753C   ADDIU A0, A0, 30012
9D0065DC  00021100   SLL V0, V0, 4
9D0065E0  00022880   SLL A1, V0, 2
9D0065E4  00A21023   SUBU V0, A1, V0
9D0065E8  00821021   ADDU V0, A0, V0
9D0065EC  8C420004   LW V0, 4(V0)
9D0065F0  0062102B   SLTU V0, V1, V0
9D0065F4  14400099   BNE V0, ZERO, 0x9D00685C
9D0065F8  00000000   NOP
9D00665C  0B401A17   J 0x9D00685C
9D006660  00000000   NOP
3879:                                    MyTCB.txUnackedTail -= MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart;
9D0065FC  3C02A000   LUI V0, -24576
9D006600  2442759C   ADDIU V0, V0, 30108
9D006604  8C44000C   LW A0, 12(V0)
9D006608  93828014   LBU V0, -32748(GP)
9D00660C  3C05A000   LUI A1, -24576
9D006610  00021100   SLL V0, V0, 4
9D006614  00021880   SLL V1, V0, 2
9D006618  00621823   SUBU V1, V1, V0
9D00661C  24A2753C   ADDIU V0, A1, 30012
9D006620  00621021   ADDU V0, V1, V0
9D006624  8C430000   LW V1, 0(V0)
9D006628  93828014   LBU V0, -32748(GP)
9D00662C  3C05A000   LUI A1, -24576
9D006630  24A5753C   ADDIU A1, A1, 30012
9D006634  00021100   SLL V0, V0, 4
9D006638  00023080   SLL A2, V0, 2
9D00663C  00C21023   SUBU V0, A2, V0
9D006640  00A21021   ADDU V0, A1, V0
9D006644  8C420004   LW V0, 4(V0)
9D006648  00621023   SUBU V0, V1, V0
9D00664C  00821821   ADDU V1, A0, V0
9D006650  3C02A000   LUI V0, -24576
9D006654  2442759C   ADDIU V0, V0, 30108
9D006658  AC43000C   SW V1, 12(V0)
3880:                            }
3881:                            else
3882:                            {
3883:                                // See if we have outstanding TX data that is waiting for an ACK
3884:                                if(MyTCBStub.txTail != MyTCB.txUnackedTail)
9D006664  93828014   LBU V0, -32748(GP)
9D006668  3C04A000   LUI A0, -24576
9D00666C  00021100   SLL V0, V0, 4
9D006670  00021880   SLL V1, V0, 2
9D006674  00621823   SUBU V1, V1, V0
9D006678  2482753C   ADDIU V0, A0, 30012
9D00667C  00621021   ADDU V0, V1, V0
9D006680  8C430010   LW V1, 16(V0)
9D006684  3C02A000   LUI V0, -24576
9D006688  2442759C   ADDIU V0, V0, 30108
9D00668C  8C42000C   LW V0, 12(V0)
9D006690  10620072   BEQ V1, V0, 0x9D00685C
9D006694  00000000   NOP
3885:                                {
3886:                                    if(MyTCB.flags.bRXNoneACKed1)
9D006698  3C02A000   LUI V0, -24576
9D00669C  2442759C   ADDIU V0, V0, 30108
9D0066A0  8C430024   LW V1, 36(V0)
9D0066A4  3C020008   LUI V0, 8
9D0066A8  00621024   AND V0, V1, V0
9D0066AC  10400065   BEQ V0, ZERO, 0x9D006844
9D0066B0  00000000   NOP
3887:                                    {
3888:                                        if(MyTCB.flags.bRXNoneACKed2)
9D0066B4  3C02A000   LUI V0, -24576
9D0066B8  2442759C   ADDIU V0, V0, 30108
9D0066BC  8C430024   LW V1, 36(V0)
9D0066C0  3C020010   LUI V0, 16
9D0066C4  00621024   AND V0, V1, V0
9D0066C8  10400058   BEQ V0, ZERO, 0x9D00682C
9D0066CC  00000000   NOP
3889:                                        {
3890:                                            // Set up to perform a fast retransmission
3891:                                            // Roll back unacknowledged TX tail pointer to cause retransmit to occur
3892:                                            MyTCB.MySEQ -= (int32_t)(int16_t)(MyTCB.txUnackedTail - MyTCBStub.txTail);
9D0066D0  3C02A000   LUI V0, -24576
9D0066D4  2442759C   ADDIU V0, V0, 30108
9D0066D8  8C440004   LW A0, 4(V0)
9D0066DC  3C02A000   LUI V0, -24576
9D0066E0  2442759C   ADDIU V0, V0, 30108
9D0066E4  8C42000C   LW V0, 12(V0)
9D0066E8  3045FFFF   ANDI A1, V0, -1
9D0066EC  93828014   LBU V0, -32748(GP)
9D0066F0  3C06A000   LUI A2, -24576
9D0066F4  00021100   SLL V0, V0, 4
9D0066F8  00021880   SLL V1, V0, 2
9D0066FC  00621823   SUBU V1, V1, V0
9D006700  24C2753C   ADDIU V0, A2, 30012
9D006704  00621021   ADDU V0, V1, V0
9D006708  8C420010   LW V0, 16(V0)
9D00670C  3042FFFF   ANDI V0, V0, -1
9D006710  00A21023   SUBU V0, A1, V0
9D006714  3042FFFF   ANDI V0, V0, -1
9D006718  7C021620   SEH V0, V0
9D00671C  00821823   SUBU V1, A0, V0
9D006720  3C02A000   LUI V0, -24576
9D006724  2442759C   ADDIU V0, V0, 30108
9D006728  AC430004   SW V1, 4(V0)
3893:                                            if(MyTCB.txUnackedTail < MyTCBStub.txTail)
9D00672C  3C02A000   LUI V0, -24576
9D006730  2442759C   ADDIU V0, V0, 30108
9D006734  8C44000C   LW A0, 12(V0)
9D006738  93828014   LBU V0, -32748(GP)
9D00673C  3C05A000   LUI A1, -24576
9D006740  00021100   SLL V0, V0, 4
9D006744  00021880   SLL V1, V0, 2
9D006748  00621823   SUBU V1, V1, V0
9D00674C  24A2753C   ADDIU V0, A1, 30012
9D006750  00621021   ADDU V0, V1, V0
9D006754  8C420010   LW V0, 16(V0)
9D006758  0082102B   SLTU V0, A0, V0
9D00675C  1040001D   BEQ V0, ZERO, 0x9D0067D4
9D006760  00000000   NOP
3894:                                                MyTCB.MySEQ -= (int32_t)(int16_t)(MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart);
9D006764  3C02A000   LUI V0, -24576
9D006768  2442759C   ADDIU V0, V0, 30108
9D00676C  8C440004   LW A0, 4(V0)
9D006770  93828014   LBU V0, -32748(GP)
9D006774  3C03A000   LUI V1, -24576
9D006778  2463753C   ADDIU V1, V1, 30012
9D00677C  00021100   SLL V0, V0, 4
9D006780  00022880   SLL A1, V0, 2
9D006784  00A21023   SUBU V0, A1, V0
9D006788  00621021   ADDU V0, V1, V0
9D00678C  8C420004   LW V0, 4(V0)
9D006790  3045FFFF   ANDI A1, V0, -1
9D006794  93828014   LBU V0, -32748(GP)
9D006798  3C06A000   LUI A2, -24576
9D00679C  00021100   SLL V0, V0, 4
9D0067A0  00021880   SLL V1, V0, 2
9D0067A4  00621823   SUBU V1, V1, V0
9D0067A8  24C2753C   ADDIU V0, A2, 30012
9D0067AC  00621021   ADDU V0, V1, V0
9D0067B0  8C420000   LW V0, 0(V0)
9D0067B4  3042FFFF   ANDI V0, V0, -1
9D0067B8  00A21023   SUBU V0, A1, V0
9D0067BC  3042FFFF   ANDI V0, V0, -1
9D0067C0  7C021620   SEH V0, V0
9D0067C4  00821823   SUBU V1, A0, V0
9D0067C8  3C02A000   LUI V0, -24576
9D0067CC  2442759C   ADDIU V0, V0, 30108
9D0067D0  AC430004   SW V1, 4(V0)
3895:                                            MyTCB.txUnackedTail = MyTCBStub.txTail;
9D0067D4  93828014   LBU V0, -32748(GP)
9D0067D8  3C04A000   LUI A0, -24576
9D0067DC  00021100   SLL V0, V0, 4
9D0067E0  00021880   SLL V1, V0, 2
9D0067E4  00621823   SUBU V1, V1, V0
9D0067E8  2482753C   ADDIU V0, A0, 30012
9D0067EC  00621021   ADDU V0, V1, V0
9D0067F0  8C430010   LW V1, 16(V0)
9D0067F4  3C02A000   LUI V0, -24576
9D0067F8  2442759C   ADDIU V0, V0, 30108
9D0067FC  AC43000C   SW V1, 12(V0)
3896:                                            MyTCBStub.Flags.bTXASAPWithoutTimerReset = 1;
9D006800  93828014   LBU V0, -32748(GP)
9D006804  3C04A000   LUI A0, -24576
9D006808  00021100   SLL V0, V0, 4
9D00680C  00021880   SLL V1, V0, 2
9D006810  00621823   SUBU V1, V1, V0
9D006814  2482753C   ADDIU V0, A0, 30012
9D006818  00621821   ADDU V1, V1, V0
9D00681C  8C620028   LW V0, 40(V1)
9D006820  24040001   ADDIU A0, ZERO, 1
9D006824  7C825284   INS V0, A0, 10, 1
9D006828  AC620028   SW V0, 40(V1)
3897:                                        }
3898:                                        MyTCB.flags.bRXNoneACKed2 = 1;
9D00682C  3C02A000   LUI V0, -24576
9D006830  2443759C   ADDIU V1, V0, 30108
9D006834  8C620024   LW V0, 36(V1)
9D006838  24040001   ADDIU A0, ZERO, 1
9D00683C  7C82A504   INS V0, A0, 20, 1
9D006840  AC620024   SW V0, 36(V1)
3899:                                    }
3900:                                    MyTCB.flags.bRXNoneACKed1 = 1;
9D006844  3C02A000   LUI V0, -24576
9D006848  2443759C   ADDIU V1, V0, 30108
9D00684C  8C620024   LW V0, 36(V1)
9D006850  24040001   ADDIU A0, ZERO, 1
9D006854  7C829CC4   INS V0, A0, 19, 1
9D006858  AC620024   SW V0, 36(V1)
3901:                                }
3902:                            }
3903:                
3904:                            // No need to keep our retransmit timer going if we have nothing that needs ACKing anymore
3905:                            if(MyTCBStub.txTail == MyTCBStub.txHead)
9D00685C  93828014   LBU V0, -32748(GP)
9D006860  3C04A000   LUI A0, -24576
9D006864  00021100   SLL V0, V0, 4
9D006868  00021880   SLL V1, V0, 2
9D00686C  00621823   SUBU V1, V1, V0
9D006870  2482753C   ADDIU V0, A0, 30012
9D006874  00621021   ADDU V0, V1, V0
9D006878  8C430010   LW V1, 16(V0)
9D00687C  93828014   LBU V0, -32748(GP)
9D006880  3C04A000   LUI A0, -24576
9D006884  2484753C   ADDIU A0, A0, 30012
9D006888  00021100   SLL V0, V0, 4
9D00688C  00022880   SLL A1, V0, 2
9D006890  00A21023   SUBU V0, A1, V0
9D006894  00821021   ADDU V0, A0, V0
9D006898  8C42000C   LW V0, 12(V0)
9D00689C  1462004A   BNE V1, V0, 0x9D0069C8
9D0068A0  00000000   NOP
3906:                            {
3907:                                // Make sure there isn't a "FIN byte in our TX FIFO"
3908:                                if(MyTCBStub.Flags.bTXFIN == 0u)
9D0068A4  93828014   LBU V0, -32748(GP)
9D0068A8  3C04A000   LUI A0, -24576
9D0068AC  00021100   SLL V0, V0, 4
9D0068B0  00021880   SLL V1, V0, 2
9D0068B4  00621823   SUBU V1, V1, V0
9D0068B8  2482753C   ADDIU V0, A0, 30012
9D0068BC  00621021   ADDU V0, V1, V0
9D0068C0  8C420028   LW V0, 40(V0)
9D0068C4  7C4202C0   EXT V0, V0, 11, 1
9D0068C8  304200FF   ANDI V0, V0, 255
9D0068CC  1440001D   BNE V0, ZERO, 0x9D006944
9D0068D0  00000000   NOP
3909:                                {
3910:                                    // Convert retransmission timer to keep-alive timer
3911:                                    #if defined(TCP_KEEP_ALIVE_TIMEOUT)
3912:                                        MyTCBStub.eventTime = TickGet() + TCP_KEEP_ALIVE_TIMEOUT;
9D0068D4  93828014   LBU V0, -32748(GP)
9D0068D8  00408021   ADDU S0, V0, ZERO
9D0068DC  0F405C42   JAL TickGet
9D0068E0  00000000   NOP
9D0068E4  00401821   ADDU V1, V0, ZERO
9D0068E8  3C02002F   LUI V0, 47
9D0068EC  3442AF08   ORI V0, V0, -20728
9D0068F0  00621821   ADDU V1, V1, V0
9D0068F4  3C02A000   LUI V0, -24576
9D0068F8  2444753C   ADDIU A0, V0, 30012
9D0068FC  02001021   ADDU V0, S0, ZERO
9D006900  00021100   SLL V0, V0, 4
9D006904  00022880   SLL A1, V0, 2
9D006908  00A21023   SUBU V0, A1, V0
9D00690C  00821021   ADDU V0, A0, V0
9D006910  AC43001C   SW V1, 28(V0)
3913:                                    #endif
3914:                                    MyTCBStub.Flags.bTimerEnabled = 0;
9D006914  93828014   LBU V0, -32748(GP)
9D006918  3C04A000   LUI A0, -24576
9D00691C  00021100   SLL V0, V0, 4
9D006920  00021880   SLL V1, V0, 2
9D006924  00621823   SUBU V1, V1, V0
9D006928  2482753C   ADDIU V0, A0, 30012
9D00692C  00621821   ADDU V1, V1, V0
9D006930  8C620028   LW V0, 40(V1)
9D006934  7C022104   INS V0, ZERO, 4, 1
9D006938  AC620028   SW V0, 40(V1)
9D00693C  0B401A72   J 0x9D0069C8
9D006940  00000000   NOP
3915:                                }
3916:                                else
3917:                                {
3918:                                    // "Throw away" FIN byte from our TX FIFO if it has been ACKed
3919:                                    if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9D006944  3C02A000   LUI V0, -24576
9D006948  2442759C   ADDIU V0, V0, 30108
9D00694C  8C430004   LW V1, 4(V0)
9D006950  8FC20024   LW V0, 36(S8)
9D006954  1462001C   BNE V1, V0, 0x9D0069C8
9D006958  00000000   NOP
9D00695C  3C02A000   LUI V0, -24576
9D006960  2442759C   ADDIU V0, V0, 30108
9D006964  8C430024   LW V1, 36(V0)
9D006968  3C020001   LUI V0, 1
9D00696C  00621024   AND V0, V1, V0
9D006970  10400015   BEQ V0, ZERO, 0x9D0069C8
9D006974  00000000   NOP
3920:                                    {
3921:                                        MyTCBStub.Flags.bTimerEnabled = 0;
9D006978  93828014   LBU V0, -32748(GP)
9D00697C  3C04A000   LUI A0, -24576
9D006980  00021100   SLL V0, V0, 4
9D006984  00021880   SLL V1, V0, 2
9D006988  00621823   SUBU V1, V1, V0
9D00698C  2482753C   ADDIU V0, A0, 30012
9D006990  00621821   ADDU V1, V1, V0
9D006994  8C620028   LW V0, 40(V1)
9D006998  7C022104   INS V0, ZERO, 4, 1
9D00699C  AC620028   SW V0, 40(V1)
3922:                                        MyTCBStub.Flags.bTXFIN = 0;
9D0069A0  93828014   LBU V0, -32748(GP)
9D0069A4  3C04A000   LUI A0, -24576
9D0069A8  00021100   SLL V0, V0, 4
9D0069AC  00021880   SLL V1, V0, 2
9D0069B0  00621823   SUBU V1, V1, V0
9D0069B4  2482753C   ADDIU V0, A0, 30012
9D0069B8  00621821   ADDU V1, V1, V0
9D0069BC  8C620028   LW V0, 40(V1)
9D0069C0  7C025AC4   INS V0, ZERO, 11, 1
9D0069C4  AC620028   SW V0, 40(V1)
3923:                                    }
3924:                                }
3925:                            }
3926:                
3927:                            // The window size advirtised in this packet is adjusted to account
3928:                            // for any bytes that we have transmitted but haven't been ACKed yet
3929:                            // by this segment.
3930:                            wNewWindow = h->Window - ((uint16_t)(MyTCB.MySEQ - localAckNumber));
9D0069C8  8FC20048   LW V0, 72(S8)
9D0069CC  9443000E   LHU V1, 14(V0)
9D0069D0  8FC20024   LW V0, 36(S8)
9D0069D4  3044FFFF   ANDI A0, V0, -1
9D0069D8  3C02A000   LUI V0, -24576
9D0069DC  2442759C   ADDIU V0, V0, 30108
9D0069E0  8C420004   LW V0, 4(V0)
9D0069E4  3042FFFF   ANDI V0, V0, -1
9D0069E8  00821023   SUBU V0, A0, V0
9D0069EC  3042FFFF   ANDI V0, V0, -1
9D0069F0  00621021   ADDU V0, V1, V0
9D0069F4  A7C20036   SH V0, 54(S8)
3931:                
3932:                            // Update the local stored copy of the RemoteWindow.
3933:                            // If previously we had a zero window, and now we don't, then
3934:                            // immediately send whatever was pending.
3935:                            if((MyTCB.remoteWindow == 0u) && wNewWindow)
9D0069F8  3C02A000   LUI V0, -24576
9D0069FC  2442759C   ADDIU V0, V0, 30108
9D006A00  94420014   LHU V0, 20(V0)
9D006A04  1440000F   BNE V0, ZERO, 0x9D006A44
9D006A08  00000000   NOP
9D006A0C  97C20036   LHU V0, 54(S8)
9D006A10  1040000C   BEQ V0, ZERO, 0x9D006A44
9D006A14  00000000   NOP
3936:                                MyTCBStub.Flags.bTXASAP = 1;
9D006A18  93828014   LBU V0, -32748(GP)
9D006A1C  3C04A000   LUI A0, -24576
9D006A20  00021100   SLL V0, V0, 4
9D006A24  00021880   SLL V1, V0, 2
9D006A28  00621823   SUBU V1, V1, V0
9D006A2C  2482753C   ADDIU V0, A0, 30012
9D006A30  00621821   ADDU V1, V1, V0
9D006A34  8C620028   LW V0, 40(V1)
9D006A38  24040001   ADDIU A0, ZERO, 1
9D006A3C  7C824A44   INS V0, A0, 9, 1
9D006A40  AC620028   SW V0, 40(V1)
3937:                            MyTCB.remoteWindow = wNewWindow;
9D006A44  3C02A000   LUI V0, -24576
9D006A48  2442759C   ADDIU V0, V0, 30108
9D006A4C  97C30036   LHU V1, 54(S8)
9D006A50  A4430014   SH V1, 20(V0)
3938:                
3939:                            // A couple of states must do all of the TCP_ESTABLISHED stuff, but also a little more
3940:                            if(MyTCBStub.smState == TCP_FIN_WAIT_1)
9D006A54  93828014   LBU V0, -32748(GP)
9D006A58  3C03A000   LUI V1, -24576
9D006A5C  2463753C   ADDIU V1, V1, 30012
9D006A60  00021100   SLL V0, V0, 4
9D006A64  00022080   SLL A0, V0, 2
9D006A68  00821023   SUBU V0, A0, V0
9D006A6C  00621021   ADDU V0, V1, V0
9D006A70  8C430024   LW V1, 36(V0)
9D006A74  24020008   ADDIU V0, ZERO, 8
9D006A78  14620034   BNE V1, V0, 0x9D006B4C
9D006A7C  00000000   NOP
3941:                            {
3942:                                // Check to see if our FIN has been ACKnowledged
3943:                                if((MyTCB.MySEQ == localAckNumber) && MyTCB.flags.bFINSent)
9D006A80  3C02A000   LUI V0, -24576
9D006A84  2442759C   ADDIU V0, V0, 30108
9D006A88  8C430004   LW V1, 4(V0)
9D006A8C  8FC20024   LW V0, 36(S8)
9D006A90  14620069   BNE V1, V0, 0x9D006C38
9D006A94  00000000   NOP
9D006A98  3C02A000   LUI V0, -24576
9D006A9C  2442759C   ADDIU V0, V0, 30108
9D006AA0  8C430024   LW V1, 36(V0)
9D006AA4  3C020001   LUI V0, 1
9D006AA8  00621024   AND V0, V1, V0
9D006AAC  10400065   BEQ V0, ZERO, 0x9D006C44
9D006AB0  00000000   NOP
3944:                                {
3945:                                    // Reset our timer for forced closure if the remote node
3946:                                    // doesn't send us a FIN in a timely manner.
3947:                                    MyTCBStub.eventTime = TickGet() + TCP_FIN_WAIT_2_TIMEOUT;
9D006AB4  93828014   LBU V0, -32748(GP)
9D006AB8  00408021   ADDU S0, V0, ZERO
9D006ABC  0F405C42   JAL TickGet
9D006AC0  00000000   NOP
9D006AC4  00401821   ADDU V1, V0, ZERO
9D006AC8  3C020017   LUI V0, 23
9D006ACC  3442D784   ORI V0, V0, -10364
9D006AD0  00621821   ADDU V1, V1, V0
9D006AD4  3C02A000   LUI V0, -24576
9D006AD8  2444753C   ADDIU A0, V0, 30012
9D006ADC  02001021   ADDU V0, S0, ZERO
9D006AE0  00021100   SLL V0, V0, 4
9D006AE4  00022880   SLL A1, V0, 2
9D006AE8  00A21023   SUBU V0, A1, V0
9D006AEC  00821021   ADDU V0, A0, V0
9D006AF0  AC43001C   SW V1, 28(V0)
3948:                                    MyTCBStub.Flags.bTimerEnabled = 1;
9D006AF4  93828014   LBU V0, -32748(GP)
9D006AF8  3C04A000   LUI A0, -24576
9D006AFC  00021100   SLL V0, V0, 4
9D006B00  00021880   SLL V1, V0, 2
9D006B04  00621823   SUBU V1, V1, V0
9D006B08  2482753C   ADDIU V0, A0, 30012
9D006B0C  00621821   ADDU V1, V1, V0
9D006B10  8C620028   LW V0, 40(V1)
9D006B14  24040001   ADDIU A0, ZERO, 1
9D006B18  7C822104   INS V0, A0, 4, 1
9D006B1C  AC620028   SW V0, 40(V1)
3949:                                    MyTCBStub.smState = TCP_FIN_WAIT_2;
9D006B20  93828014   LBU V0, -32748(GP)
9D006B24  3C03A000   LUI V1, -24576
9D006B28  2463753C   ADDIU V1, V1, 30012
9D006B2C  00021100   SLL V0, V0, 4
9D006B30  00022080   SLL A0, V0, 2
9D006B34  00821023   SUBU V0, A0, V0
9D006B38  00621021   ADDU V0, V1, V0
9D006B3C  24030009   ADDIU V1, ZERO, 9
9D006B40  AC430024   SW V1, 36(V0)
3950:                                }
3951:                            }
3952:                            else if(MyTCBStub.smState == TCP_FIN_WAIT_2)
9D006B4C  93828014   LBU V0, -32748(GP)
9D006B50  3C03A000   LUI V1, -24576
9D006B54  2463753C   ADDIU V1, V1, 30012
9D006B58  00021100   SLL V0, V0, 4
9D006B5C  00022080   SLL A0, V0, 2
9D006B60  00821023   SUBU V0, A0, V0
9D006B64  00621021   ADDU V0, V1, V0
9D006B68  8C430024   LW V1, 36(V0)
9D006B6C  24020009   ADDIU V0, ZERO, 9
9D006B70  14620011   BNE V1, V0, 0x9D006BB8
9D006B74  00000000   NOP
3953:                            {
3954:                                // RFC noncompliance:
3955:                                // The remote node should not keep sending us data
3956:                                // indefinitely after we send a FIN to it.
3957:                                // However, some bad stacks may still keep sending
3958:                                // us data indefinitely after ACKing our FIN.  To
3959:                                // prevent this from locking up our socket, let's
3960:                                // send a RST right now and close forcefully on
3961:                                // our side.
3962:                                if(!(localHeaderFlags & FIN))
9D006B78  93C2002B   LBU V0, 43(S8)
9D006B7C  30420001   ANDI V0, V0, 1
9D006B80  14400033   BNE V0, ZERO, 0x9D006C50
9D006B84  00000000   NOP
3963:                                {
3964:                                    MyTCB.MySEQ = localAckNumber;   // Set SEQ = SEG.ACK
9D006B88  3C02A000   LUI V0, -24576
9D006B8C  2442759C   ADDIU V0, V0, 30108
9D006B90  8FC30024   LW V1, 36(S8)
9D006B94  AC430004   SW V1, 4(V0)
3965:                                    SendTCP(RST | ACK, 0);
9D006B98  24040014   ADDIU A0, ZERO, 20
9D006B9C  00002821   ADDU A1, ZERO, ZERO
9D006BA0  0F400F2C   JAL 0x9D003CB0
9D006BA4  00000000   NOP
3966:                                    CloseSocket();
9D006BA8  0F401470   JAL 0x9D0051C0
9D006BAC  00000000   NOP
3967:                                    return;
9D006BB0  0B401EC9   J 0x9D007B24
9D006BB4  00000000   NOP
3968:                                }
3969:                            }
3970:                            else if(MyTCBStub.smState == TCP_CLOSING)
9D006BB8  93828014   LBU V0, -32748(GP)
9D006BBC  3C03A000   LUI V1, -24576
9D006BC0  2463753C   ADDIU V1, V1, 30012
9D006BC4  00021100   SLL V0, V0, 4
9D006BC8  00022080   SLL A0, V0, 2
9D006BCC  00821023   SUBU V0, A0, V0
9D006BD0  00621021   ADDU V0, V1, V0
9D006BD4  8C430024   LW V1, 36(V0)
9D006BD8  2402000A   ADDIU V0, ZERO, 10
9D006BDC  1462001F   BNE V1, V0, 0x9D006C5C
9D006BE0  00000000   NOP
3971:                            {
3972:                                // Check to see if our FIN has been ACKnowledged
3973:                                if(MyTCB.MySEQ == localAckNumber)
9D006BE4  3C02A000   LUI V0, -24576
9D006BE8  2442759C   ADDIU V0, V0, 30108
9D006BEC  8C430004   LW V1, 4(V0)
9D006BF0  8FC20024   LW V0, 36(S8)
9D006BF4  146203BB   BNE V1, V0, 0x9D007AE4
9D006BF8  00000000   NOP
3974:                                {
3975:                                    // RFC not recommended: We should be going to
3976:                                    // the TCP_TIME_WAIT state right here and
3977:                                    // starting a 2MSL timer, but since we have so
3978:                                    // few precious sockets, we can't afford to
3979:                                    // leave a socket waiting around doing nothing
3980:                                    // for a long time.  If the remote node does
3981:                                    // not recieve this ACK, it'll have to figure
3982:                                    // out on it's own that the connection is now
3983:                                    // closed.
3984:                                    CloseSocket();
9D006BFC  0F401470   JAL 0x9D0051C0
9D006C00  00000000   NOP
3985:                                }
3986:                
3987:                                return;
9D006C04  0B401EC9   J 0x9D007B24
9D006C08  00000000   NOP
9D007AE4  00000000   NOP
9D007AE8  0B401EC9   J 0x9D007B24
9D007AEC  00000000   NOP
3988:                            }
3989:                
3990:                            break;
9D006B44  0B401B18   J 0x9D006C60
9D006B48  00000000   NOP
9D006C38  00000000   NOP
9D006C3C  0B401B18   J 0x9D006C60
9D006C40  00000000   NOP
9D006C44  00000000   NOP
9D006C48  0B401B18   J 0x9D006C60
9D006C4C  00000000   NOP
9D006C50  00000000   NOP
9D006C54  0B401B18   J 0x9D006C60
9D006C58  00000000   NOP
9D006C5C  00000000   NOP
3991:                
3992:                        case TCP_LAST_ACK:
3993:                            // Check to see if our FIN has been ACKnowledged
3994:                            if(MyTCB.MySEQ + 1 == localAckNumber)
9D006C0C  3C02A000   LUI V0, -24576
9D006C10  2442759C   ADDIU V0, V0, 30108
9D006C14  8C420004   LW V0, 4(V0)
9D006C18  24430001   ADDIU V1, V0, 1
9D006C1C  8FC20024   LW V0, 36(S8)
9D006C20  146203B3   BNE V1, V0, 0x9D007AF0
9D006C24  00000000   NOP
3995:                                CloseSocket();
9D006C28  0F401470   JAL 0x9D0051C0
9D006C2C  00000000   NOP
3996:                            return;
9D006C30  0B401EC9   J 0x9D007B24
9D006C34  00000000   NOP
9D007AF0  00000000   NOP
9D007AF4  0B401EC9   J 0x9D007B24
9D007AF8  00000000   NOP
3997:                
3998:                //      case TCP_TIME_WAIT:
3999:                //          // Nothing is supposed to arrive here.  If it does, reset the quiet timer.
4000:                //          SendTCP(ACK, SENDTCP_RESET_TIMERS);
4001:                //          return;
4002:                
4003:                        default:
4004:                            break;
9D005F54  0B401B18   J 0x9D006C60
9D005F58  00000000   NOP
9D005F68  0B401B18   J 0x9D006C60
9D005F6C  00000000   NOP
4005:                    }
4006:                
4007:                    //
4008:                    // Sixth: Check the URG bit
4009:                    //
4010:                    // Urgent packets are not supported in this stack, so we
4011:                    // will throw them away instead
4012:                    if(localHeaderFlags & URG)
9D006C60  93C2002B   LBU V0, 43(S8)
9D006C64  30420020   ANDI V0, V0, 32
9D006C68  144003A4   BNE V0, ZERO, 0x9D007AFC
9D006C6C  00000000   NOP
4013:                        return;
9D007AFC  00000000   NOP
9D007B00  0B401EC9   J 0x9D007B24
9D007B04  00000000   NOP
4014:                
4015:                    //
4016:                    // Seventh: Process the segment text
4017:                    //
4018:                    // Throw data away if in a state that doesn't accept data
4019:                    if(MyTCBStub.smState == TCP_CLOSE_WAIT)
9D006C70  93828014   LBU V0, -32748(GP)
9D006C74  3C03A000   LUI V1, -24576
9D006C78  2463753C   ADDIU V1, V1, 30012
9D006C7C  00021100   SLL V0, V0, 4
9D006C80  00022080   SLL A0, V0, 2
9D006C84  00821023   SUBU V0, A0, V0
9D006C88  00621021   ADDU V0, V1, V0
9D006C8C  8C430024   LW V1, 36(V0)
9D006C90  2402000B   ADDIU V0, ZERO, 11
9D006C94  1062039C   BEQ V1, V0, 0x9D007B08
9D006C98  00000000   NOP
4020:                        return;
9D007B08  00000000   NOP
9D007B0C  0B401EC9   J 0x9D007B24
9D007B10  00000000   NOP
4021:                    if(MyTCBStub.smState == TCP_CLOSING)
9D006C9C  93828014   LBU V0, -32748(GP)
9D006CA0  3C03A000   LUI V1, -24576
9D006CA4  2463753C   ADDIU V1, V1, 30012
9D006CA8  00021100   SLL V0, V0, 4
9D006CAC  00022080   SLL A0, V0, 2
9D006CB0  00821023   SUBU V0, A0, V0
9D006CB4  00621021   ADDU V0, V1, V0
9D006CB8  8C430024   LW V1, 36(V0)
9D006CBC  2402000A   ADDIU V0, ZERO, 10
9D006CC0  10620394   BEQ V1, V0, 0x9D007B14
9D006CC4  00000000   NOP
4022:                        return;
9D007B14  00000000   NOP
9D007B18  0B401EC9   J 0x9D007B24
9D007B1C  00000000   NOP
4023:                    if(MyTCBStub.smState == TCP_LAST_ACK)
9D006CC8  93828014   LBU V0, -32748(GP)
9D006CCC  3C03A000   LUI V1, -24576
9D006CD0  2463753C   ADDIU V1, V1, 30012
9D006CD4  00021100   SLL V0, V0, 4
9D006CD8  00022080   SLL A0, V0, 2
9D006CDC  00821023   SUBU V0, A0, V0
9D006CE0  00621021   ADDU V0, V1, V0
9D006CE4  8C430024   LW V1, 36(V0)
9D006CE8  2402000C   ADDIU V0, ZERO, 12
9D006CEC  1062038C   BEQ V1, V0, 0x9D007B20
9D006CF0  00000000   NOP
4024:                        return;
9D007B20  00000000   NOP
4025:                //  if(MyTCBStub.smState == TCP_TIME_WAIT)
4026:                //      return;
4027:                
4028:                    // Copy any valid segment data into our RX FIFO, if any
4029:                    if(len)
9D006CF4  97C2004C   LHU V0, 76(S8)
9D006CF8  10400289   BEQ V0, ZERO, 0x9D007720
9D006CFC  00000000   NOP
4030:                    {
4031:                        // See if there are bytes we must skip
4032:                        if((int16_t)wMissingBytes <= 0)
9D006D00  87C20034   LH V0, 52(S8)
9D006D04  1C400141   BGTZ V0, 0x9D00720C
9D006D08  00000000   NOP
4033:                        {
4034:                            // Position packet read pointer to start of useful data area.
4035:                            IPSetRxBuffer((h->DataOffset.Val << 2) - wMissingBytes);
9D006D0C  8FC20048   LW V0, 72(S8)
9D006D10  8C42000C   LW V0, 12(V0)
9D006D14  7C421900   EXT V0, V0, 4, 4
9D006D18  304200FF   ANDI V0, V0, 255
9D006D1C  00021080   SLL V0, V0, 2
9D006D20  3043FFFF   ANDI V1, V0, -1
9D006D24  97C20034   LHU V0, 52(S8)
9D006D28  00621023   SUBU V0, V1, V0
9D006D2C  3042FFFF   ANDI V0, V0, -1
9D006D30  00402021   ADDU A0, V0, ZERO
9D006D34  0F406020   JAL IPSetRxBuffer
9D006D38  00000000   NOP
4036:                            len += wMissingBytes;
9D006D3C  97C3004C   LHU V1, 76(S8)
9D006D40  97C20034   LHU V0, 52(S8)
9D006D44  00621021   ADDU V0, V1, V0
9D006D48  A7C2004C   SH V0, 76(S8)
4037:                
4038:                            // Truncate packets that would overflow our TCP RX FIFO
4039:                            // and request a retransmit by sending a duplicate ACK
4040:                            if(len > wFreeSpace)
9D006D4C  97C3004C   LHU V1, 76(S8)
9D006D50  97C20020   LHU V0, 32(S8)
9D006D54  0043102B   SLTU V0, V0, V1
9D006D58  10400003   BEQ V0, ZERO, 0x9D006D68
9D006D5C  00000000   NOP
4041:                                len = wFreeSpace;
9D006D60  97C20020   LHU V0, 32(S8)
9D006D64  A7C2004C   SH V0, 76(S8)
4042:                
4043:                            MyTCB.RemoteSEQ += (uint32_t)len;
9D006D68  3C02A000   LUI V0, -24576
9D006D6C  2442759C   ADDIU V0, V0, 30108
9D006D70  8C430008   LW V1, 8(V0)
9D006D74  97C2004C   LHU V0, 76(S8)
9D006D78  00621821   ADDU V1, V1, V0
9D006D7C  3C02A000   LUI V0, -24576
9D006D80  2442759C   ADDIU V0, V0, 30108
9D006D84  AC430008   SW V1, 8(V0)
4044:                
4045:                            // Copy the application data from the packet into the socket RX FIFO
4046:                            // See if we need a two part copy (spans bufferEnd->bufferRxStart)
4047:                            if(MyTCBStub.rxHead + len > MyTCBStub.bufferEnd)
9D006D88  93828014   LBU V0, -32748(GP)
9D006D8C  3C03A000   LUI V1, -24576
9D006D90  2463753C   ADDIU V1, V1, 30012
9D006D94  00021100   SLL V0, V0, 4
9D006D98  00022080   SLL A0, V0, 2
9D006D9C  00821023   SUBU V0, A0, V0
9D006DA0  00621021   ADDU V0, V1, V0
9D006DA4  8C430014   LW V1, 20(V0)
9D006DA8  97C2004C   LHU V0, 76(S8)
9D006DAC  00622021   ADDU A0, V1, V0
9D006DB0  93828014   LBU V0, -32748(GP)
9D006DB4  3C05A000   LUI A1, -24576
9D006DB8  00021100   SLL V0, V0, 4
9D006DBC  00021880   SLL V1, V0, 2
9D006DC0  00621823   SUBU V1, V1, V0
9D006DC4  24A2753C   ADDIU V0, A1, 30012
9D006DC8  00621021   ADDU V0, V1, V0
9D006DCC  8C420008   LW V0, 8(V0)
9D006DD0  0044102B   SLTU V0, V0, A0
9D006DD4  1040005F   BEQ V0, ZERO, 0x9D006F54
9D006DD8  00000000   NOP
4048:                            {
4049:                                wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1;
9D006DDC  93828014   LBU V0, -32748(GP)
9D006DE0  3C04A000   LUI A0, -24576
9D006DE4  00021100   SLL V0, V0, 4
9D006DE8  00021880   SLL V1, V0, 2
9D006DEC  00621823   SUBU V1, V1, V0
9D006DF0  2482753C   ADDIU V0, A0, 30012
9D006DF4  00621021   ADDU V0, V1, V0
9D006DF8  8C430008   LW V1, 8(V0)
9D006DFC  93828014   LBU V0, -32748(GP)
9D006E00  3C04A000   LUI A0, -24576
9D006E04  2484753C   ADDIU A0, A0, 30012
9D006E08  00021100   SLL V0, V0, 4
9D006E0C  00022880   SLL A1, V0, 2
9D006E10  00A21023   SUBU V0, A1, V0
9D006E14  00821021   ADDU V0, A0, V0
9D006E18  8C420014   LW V0, 20(V0)
9D006E1C  00621023   SUBU V0, V1, V0
9D006E20  24420001   ADDIU V0, V0, 1
9D006E24  AFC2001C   SW V0, 28(S8)
4050:                                TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9D006E28  93828014   LBU V0, -32748(GP)
9D006E2C  3C03A000   LUI V1, -24576
9D006E30  2463753C   ADDIU V1, V1, 30012
9D006E34  00021100   SLL V0, V0, 4
9D006E38  00022080   SLL A0, V0, 2
9D006E3C  00821023   SUBU V0, A0, V0
9D006E40  00621021   ADDU V0, V1, V0
9D006E44  8C440014   LW A0, 20(V0)
9D006E48  93828014   LBU V0, -32748(GP)
9D006E4C  3C05A000   LUI A1, -24576
9D006E50  00021100   SLL V0, V0, 4
9D006E54  00021880   SLL V1, V0, 2
9D006E58  00621823   SUBU V1, V1, V0
9D006E5C  24A2753C   ADDIU V0, A1, 30012
9D006E60  00621021   ADDU V0, V1, V0
9D006E64  9042002C   LBU V0, 44(V0)
9D006E68  8FC3001C   LW V1, 28(S8)
9D006E6C  3063FFFF   ANDI V1, V1, -1
9D006E70  AFA30010   SW V1, 16(SP)
9D006E74  00402821   ADDU A1, V0, ZERO
9D006E78  2406FFFF   ADDIU A2, ZERO, -1
9D006E7C  00003821   ADDU A3, ZERO, ZERO
9D006E80  0F4020A8   JAL 0x9D0082A0
9D006E84  00000000   NOP
4051:                                TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9D006E88  93828014   LBU V0, -32748(GP)
9D006E8C  3C03A000   LUI V1, -24576
9D006E90  2463753C   ADDIU V1, V1, 30012
9D006E94  00021100   SLL V0, V0, 4
9D006E98  00022080   SLL A0, V0, 2
9D006E9C  00821023   SUBU V0, A0, V0
9D006EA0  00621021   ADDU V0, V1, V0
9D006EA4  8C440004   LW A0, 4(V0)
9D006EA8  93828014   LBU V0, -32748(GP)
9D006EAC  3C05A000   LUI A1, -24576
9D006EB0  00021100   SLL V0, V0, 4
9D006EB4  00021880   SLL V1, V0, 2
9D006EB8  00621823   SUBU V1, V1, V0
9D006EBC  24A2753C   ADDIU V0, A1, 30012
9D006EC0  00621021   ADDU V0, V1, V0
9D006EC4  9042002C   LBU V0, 44(V0)
9D006EC8  8FC3001C   LW V1, 28(S8)
9D006ECC  3063FFFF   ANDI V1, V1, -1
9D006ED0  97C5004C   LHU A1, 76(S8)
9D006ED4  00A31823   SUBU V1, A1, V1
9D006ED8  3063FFFF   ANDI V1, V1, -1
9D006EDC  AFA30010   SW V1, 16(SP)
9D006EE0  00402821   ADDU A1, V0, ZERO
9D006EE4  2406FFFF   ADDIU A2, ZERO, -1
9D006EE8  00003821   ADDU A3, ZERO, ZERO
9D006EEC  0F4020A8   JAL 0x9D0082A0
9D006EF0  00000000   NOP
4052:                                MyTCBStub.rxHead = MyTCBStub.bufferRxStart + (len - wTemp);
9D006EF4  93828014   LBU V0, -32748(GP)
9D006EF8  00402821   ADDU A1, V0, ZERO
9D006EFC  93828014   LBU V0, -32748(GP)
9D006F00  3C03A000   LUI V1, -24576
9D006F04  2463753C   ADDIU V1, V1, 30012
9D006F08  00021100   SLL V0, V0, 4
9D006F0C  00022080   SLL A0, V0, 2
9D006F10  00821023   SUBU V0, A0, V0
9D006F14  00621021   ADDU V0, V1, V0
9D006F18  8C430004   LW V1, 4(V0)
9D006F1C  97C4004C   LHU A0, 76(S8)
9D006F20  8FC2001C   LW V0, 28(S8)
9D006F24  00821023   SUBU V0, A0, V0
9D006F28  00621821   ADDU V1, V1, V0
9D006F2C  3C02A000   LUI V0, -24576
9D006F30  2444753C   ADDIU A0, V0, 30012
9D006F34  00A01021   ADDU V0, A1, ZERO
9D006F38  00021100   SLL V0, V0, 4
9D006F3C  00022880   SLL A1, V0, 2
9D006F40  00A21023   SUBU V0, A1, V0
9D006F44  00821021   ADDU V0, A0, V0
9D006F48  AC430014   SW V1, 20(V0)
9D006F4C  0B401C00   J 0x9D007000
9D006F50  00000000   NOP
4053:                            }
4054:                            else
4055:                            {
4056:                                TCPRAMCopy(MyTCBStub.rxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D006F54  93828014   LBU V0, -32748(GP)
9D006F58  3C03A000   LUI V1, -24576
9D006F5C  2463753C   ADDIU V1, V1, 30012
9D006F60  00021100   SLL V0, V0, 4
9D006F64  00022080   SLL A0, V0, 2
9D006F68  00821023   SUBU V0, A0, V0
9D006F6C  00621021   ADDU V0, V1, V0
9D006F70  8C440014   LW A0, 20(V0)
9D006F74  93828014   LBU V0, -32748(GP)
9D006F78  3C05A000   LUI A1, -24576
9D006F7C  00021100   SLL V0, V0, 4
9D006F80  00021880   SLL V1, V0, 2
9D006F84  00621823   SUBU V1, V1, V0
9D006F88  24A2753C   ADDIU V0, A1, 30012
9D006F8C  00621021   ADDU V0, V1, V0
9D006F90  9042002C   LBU V0, 44(V0)
9D006F94  97C3004C   LHU V1, 76(S8)
9D006F98  AFA30010   SW V1, 16(SP)
9D006F9C  00402821   ADDU A1, V0, ZERO
9D006FA0  2406FFFF   ADDIU A2, ZERO, -1
9D006FA4  00003821   ADDU A3, ZERO, ZERO
9D006FA8  0F4020A8   JAL 0x9D0082A0
9D006FAC  00000000   NOP
4057:                                MyTCBStub.rxHead += len;
9D006FB0  93828014   LBU V0, -32748(GP)
9D006FB4  00402821   ADDU A1, V0, ZERO
9D006FB8  93828014   LBU V0, -32748(GP)
9D006FBC  3C03A000   LUI V1, -24576
9D006FC0  2463753C   ADDIU V1, V1, 30012
9D006FC4  00021100   SLL V0, V0, 4
9D006FC8  00022080   SLL A0, V0, 2
9D006FCC  00821023   SUBU V0, A0, V0
9D006FD0  00621021   ADDU V0, V1, V0
9D006FD4  8C430014   LW V1, 20(V0)
9D006FD8  97C2004C   LHU V0, 76(S8)
9D006FDC  00621821   ADDU V1, V1, V0
9D006FE0  3C02A000   LUI V0, -24576
9D006FE4  2444753C   ADDIU A0, V0, 30012
9D006FE8  00A01021   ADDU V0, A1, ZERO
9D006FEC  00021100   SLL V0, V0, 4
9D006FF0  00022880   SLL A1, V0, 2
9D006FF4  00A21023   SUBU V0, A1, V0
9D006FF8  00821021   ADDU V0, A0, V0
9D006FFC  AC430014   SW V1, 20(V0)
4058:                            }
4059:                
4060:                            // See if we have a hole and other data waiting already in the RX FIFO
4061:                            if(MyTCB.sHoleSize != -1)
9D007000  3C02A000   LUI V0, -24576
9D007004  2442759C   ADDIU V0, V0, 30108
9D007008  84430024   LH V1, 36(V0)
9D00700C  2402FFFF   ADDIU V0, ZERO, -1
9D007010  106201C3   BEQ V1, V0, 0x9D007720
9D007014  00000000   NOP
4062:                            {
4063:                                MyTCB.sHoleSize -= len;
9D007018  3C02A000   LUI V0, -24576
9D00701C  2442759C   ADDIU V0, V0, 30108
9D007020  84420024   LH V0, 36(V0)
9D007024  3043FFFF   ANDI V1, V0, -1
9D007028  97C2004C   LHU V0, 76(S8)
9D00702C  00621023   SUBU V0, V1, V0
9D007030  3042FFFF   ANDI V0, V0, -1
9D007034  7C021E20   SEH V1, V0
9D007038  3C02A000   LUI V0, -24576
9D00703C  2442759C   ADDIU V0, V0, 30108
9D007040  A4430024   SH V1, 36(V0)
4064:                                wTemp = MyTCB.wFutureDataSize + MyTCB.sHoleSize;
9D007044  3C02A000   LUI V0, -24576
9D007048  2442759C   ADDIU V0, V0, 30108
9D00704C  94420016   LHU V0, 22(V0)
9D007050  00401821   ADDU V1, V0, ZERO
9D007054  3C02A000   LUI V0, -24576
9D007058  2442759C   ADDIU V0, V0, 30108
9D00705C  84420024   LH V0, 36(V0)
9D007060  00621021   ADDU V0, V1, V0
9D007064  AFC2001C   SW V0, 28(S8)
4065:                
4066:                                // See if we just closed up a hole, and if so, advance head pointer
4067:                                if((int16_t)wTemp < (int16_t)0)
9D007068  8FC2001C   LW V0, 28(S8)
9D00706C  7C021620   SEH V0, V0
9D007070  04410007   BGEZ V0, 0x9D007090
9D007074  00000000   NOP
4068:                                {
4069:                                    MyTCB.sHoleSize = -1;
9D007078  3C02A000   LUI V0, -24576
9D00707C  2442759C   ADDIU V0, V0, 30108
9D007080  2403FFFF   ADDIU V1, ZERO, -1
9D007084  A4430024   SH V1, 36(V0)
9D007088  0B401DC8   J 0x9D007720
9D00708C  00000000   NOP
4070:                                }
4071:                                else if(MyTCB.sHoleSize <= 0)
9D007090  3C02A000   LUI V0, -24576
9D007094  2442759C   ADDIU V0, V0, 30108
9D007098  84420024   LH V0, 36(V0)
9D00709C  1C4001A0   BGTZ V0, 0x9D007720
9D0070A0  00000000   NOP
4072:                                {
4073:                                    MyTCB.RemoteSEQ += wTemp;
9D0070A4  3C02A000   LUI V0, -24576
9D0070A8  2442759C   ADDIU V0, V0, 30108
9D0070AC  8C430008   LW V1, 8(V0)
9D0070B0  8FC2001C   LW V0, 28(S8)
9D0070B4  00621821   ADDU V1, V1, V0
9D0070B8  3C02A000   LUI V0, -24576
9D0070BC  2442759C   ADDIU V0, V0, 30108
9D0070C0  AC430008   SW V1, 8(V0)
4074:                                    MyTCBStub.rxHead += wTemp;
9D0070C4  93828014   LBU V0, -32748(GP)
9D0070C8  00402821   ADDU A1, V0, ZERO
9D0070CC  93828014   LBU V0, -32748(GP)
9D0070D0  3C03A000   LUI V1, -24576
9D0070D4  2463753C   ADDIU V1, V1, 30012
9D0070D8  00021100   SLL V0, V0, 4
9D0070DC  00022080   SLL A0, V0, 2
9D0070E0  00821023   SUBU V0, A0, V0
9D0070E4  00621021   ADDU V0, V1, V0
9D0070E8  8C430014   LW V1, 20(V0)
9D0070EC  8FC2001C   LW V0, 28(S8)
9D0070F0  00621821   ADDU V1, V1, V0
9D0070F4  3C02A000   LUI V0, -24576
9D0070F8  2444753C   ADDIU A0, V0, 30012
9D0070FC  00A01021   ADDU V0, A1, ZERO
9D007100  00021100   SLL V0, V0, 4
9D007104  00022880   SLL A1, V0, 2
9D007108  00A21023   SUBU V0, A1, V0
9D00710C  00821021   ADDU V0, A0, V0
9D007110  AC430014   SW V1, 20(V0)
4075:                                    if(MyTCBStub.rxHead > MyTCBStub.bufferEnd)
9D007114  93828014   LBU V0, -32748(GP)
9D007118  3C03A000   LUI V1, -24576
9D00711C  2463753C   ADDIU V1, V1, 30012
9D007120  00021100   SLL V0, V0, 4
9D007124  00022080   SLL A0, V0, 2
9D007128  00821023   SUBU V0, A0, V0
9D00712C  00621021   ADDU V0, V1, V0
9D007130  8C440014   LW A0, 20(V0)
9D007134  93828014   LBU V0, -32748(GP)
9D007138  3C05A000   LUI A1, -24576
9D00713C  00021100   SLL V0, V0, 4
9D007140  00021880   SLL V1, V0, 2
9D007144  00621823   SUBU V1, V1, V0
9D007148  24A2753C   ADDIU V0, A1, 30012
9D00714C  00621021   ADDU V0, V1, V0
9D007150  8C420008   LW V0, 8(V0)
9D007154  0044102B   SLTU V0, V0, A0
9D007158  10400026   BEQ V0, ZERO, 0x9D0071F4
9D00715C  00000000   NOP
4076:                                        MyTCBStub.rxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D007160  93828014   LBU V0, -32748(GP)
9D007164  00402821   ADDU A1, V0, ZERO
9D007168  93828014   LBU V0, -32748(GP)
9D00716C  3C03A000   LUI V1, -24576
9D007170  2463753C   ADDIU V1, V1, 30012
9D007174  00021100   SLL V0, V0, 4
9D007178  00022080   SLL A0, V0, 2
9D00717C  00821023   SUBU V0, A0, V0
9D007180  00621021   ADDU V0, V1, V0
9D007184  8C440014   LW A0, 20(V0)
9D007188  93828014   LBU V0, -32748(GP)
9D00718C  3C06A000   LUI A2, -24576
9D007190  00021100   SLL V0, V0, 4
9D007194  00021880   SLL V1, V0, 2
9D007198  00621823   SUBU V1, V1, V0
9D00719C  24C2753C   ADDIU V0, A2, 30012
9D0071A0  00621021   ADDU V0, V1, V0
9D0071A4  8C430008   LW V1, 8(V0)
9D0071A8  93828014   LBU V0, -32748(GP)
9D0071AC  3C06A000   LUI A2, -24576
9D0071B0  24C6753C   ADDIU A2, A2, 30012
9D0071B4  00021100   SLL V0, V0, 4
9D0071B8  00023880   SLL A3, V0, 2
9D0071BC  00E21023   SUBU V0, A3, V0
9D0071C0  00C21021   ADDU V0, A2, V0
9D0071C4  8C420004   LW V0, 4(V0)
9D0071C8  00621023   SUBU V0, V1, V0
9D0071CC  00021027   NOR V0, ZERO, V0
9D0071D0  00821821   ADDU V1, A0, V0
9D0071D4  3C02A000   LUI V0, -24576
9D0071D8  2444753C   ADDIU A0, V0, 30012
9D0071DC  00A01021   ADDU V0, A1, ZERO
9D0071E0  00021100   SLL V0, V0, 4
9D0071E4  00022880   SLL A1, V0, 2
9D0071E8  00A21023   SUBU V0, A1, V0
9D0071EC  00821021   ADDU V0, A0, V0
9D0071F0  AC430014   SW V1, 20(V0)
4077:                                    MyTCB.sHoleSize = -1;
9D0071F4  3C02A000   LUI V0, -24576
9D0071F8  2442759C   ADDIU V0, V0, 30108
9D0071FC  2403FFFF   ADDIU V1, ZERO, -1
9D007200  A4430024   SH V1, 36(V0)
9D007204  0B401DC8   J 0x9D007720
9D007208  00000000   NOP
4078:                                }
4079:                            }
4080:                        } // This packet is out of order or we lost a packet, see if we can generate a hole to accomodate it
4081:                        else if((int16_t)wMissingBytes > 0)
9D00720C  87C20034   LH V0, 52(S8)
9D007210  18400143   BLEZ V0, 0x9D007720
9D007214  00000000   NOP
4082:                        {
4083:                            // Truncate packets that would overflow our TCP RX FIFO
4084:                            if(len + wMissingBytes > wFreeSpace)
9D007218  97C3004C   LHU V1, 76(S8)
9D00721C  97C20034   LHU V0, 52(S8)
9D007220  00621821   ADDU V1, V1, V0
9D007224  97C20020   LHU V0, 32(S8)
9D007228  0043102A   SLT V0, V0, V1
9D00722C  10400005   BEQ V0, ZERO, 0x9D007244
9D007230  00000000   NOP
4085:                                len = wFreeSpace - wMissingBytes;
9D007234  97C30020   LHU V1, 32(S8)
9D007238  97C20034   LHU V0, 52(S8)
9D00723C  00621023   SUBU V0, V1, V0
9D007240  A7C2004C   SH V0, 76(S8)
4086:                
4087:                            // Position packet read pointer to start of useful data area.
4088:                            IPSetRxBuffer(h->DataOffset.Val << 2);
9D007244  8FC20048   LW V0, 72(S8)
9D007248  8C42000C   LW V0, 12(V0)
9D00724C  7C421900   EXT V0, V0, 4, 4
9D007250  304200FF   ANDI V0, V0, 255
9D007254  00021080   SLL V0, V0, 2
9D007258  3042FFFF   ANDI V0, V0, -1
9D00725C  00402021   ADDU A0, V0, ZERO
9D007260  0F406020   JAL IPSetRxBuffer
9D007264  00000000   NOP
4089:                
4090:                            // See if we need a two part copy (spans bufferEnd->bufferRxStart)
4091:                            if(MyTCBStub.rxHead + wMissingBytes + len > MyTCBStub.bufferEnd)
9D007268  93828014   LBU V0, -32748(GP)
9D00726C  3C03A000   LUI V1, -24576
9D007270  2463753C   ADDIU V1, V1, 30012
9D007274  00021100   SLL V0, V0, 4
9D007278  00022080   SLL A0, V0, 2
9D00727C  00821023   SUBU V0, A0, V0
9D007280  00621021   ADDU V0, V1, V0
9D007284  8C430014   LW V1, 20(V0)
9D007288  97C20034   LHU V0, 52(S8)
9D00728C  00621821   ADDU V1, V1, V0
9D007290  97C2004C   LHU V0, 76(S8)
9D007294  00622021   ADDU A0, V1, V0
9D007298  93828014   LBU V0, -32748(GP)
9D00729C  3C05A000   LUI A1, -24576
9D0072A0  00021100   SLL V0, V0, 4
9D0072A4  00021880   SLL V1, V0, 2
9D0072A8  00621823   SUBU V1, V1, V0
9D0072AC  24A2753C   ADDIU V0, A1, 30012
9D0072B0  00621021   ADDU V0, V1, V0
9D0072B4  8C420008   LW V0, 8(V0)
9D0072B8  0044102B   SLTU V0, V0, A0
9D0072BC  10400080   BEQ V0, ZERO, 0x9D0074C0
9D0072C0  00000000   NOP
4092:                            {
4093:                                // Calculate number of data bytes to copy before wraparound
4094:                                wTemp = MyTCBStub.bufferEnd - MyTCBStub.rxHead + 1 - wMissingBytes;
9D0072C4  93828014   LBU V0, -32748(GP)
9D0072C8  3C04A000   LUI A0, -24576
9D0072CC  00021100   SLL V0, V0, 4
9D0072D0  00021880   SLL V1, V0, 2
9D0072D4  00621823   SUBU V1, V1, V0
9D0072D8  2482753C   ADDIU V0, A0, 30012
9D0072DC  00621021   ADDU V0, V1, V0
9D0072E0  8C430008   LW V1, 8(V0)
9D0072E4  93828014   LBU V0, -32748(GP)
9D0072E8  3C04A000   LUI A0, -24576
9D0072EC  2484753C   ADDIU A0, A0, 30012
9D0072F0  00021100   SLL V0, V0, 4
9D0072F4  00022880   SLL A1, V0, 2
9D0072F8  00A21023   SUBU V0, A1, V0
9D0072FC  00821021   ADDU V0, A0, V0
9D007300  8C420014   LW V0, 20(V0)
9D007304  00621823   SUBU V1, V1, V0
9D007308  97C20034   LHU V0, 52(S8)
9D00730C  00021023   SUBU V0, ZERO, V0
9D007310  00621021   ADDU V0, V1, V0
9D007314  24420001   ADDIU V0, V0, 1
9D007318  AFC2001C   SW V0, 28(S8)
4095:                                if((int16_t)wTemp >= 0)
9D00731C  8FC2001C   LW V0, 28(S8)
9D007320  7C021620   SEH V0, V0
9D007324  04400038   BLTZ V0, 0x9D007408
9D007328  00000000   NOP
4096:                                {
4097:                                    TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, wTemp);
9D00732C  93828014   LBU V0, -32748(GP)
9D007330  3C03A000   LUI V1, -24576
9D007334  2463753C   ADDIU V1, V1, 30012
9D007338  00021100   SLL V0, V0, 4
9D00733C  00022080   SLL A0, V0, 2
9D007340  00821023   SUBU V0, A0, V0
9D007344  00621021   ADDU V0, V1, V0
9D007348  8C430014   LW V1, 20(V0)
9D00734C  97C20034   LHU V0, 52(S8)
9D007350  00622021   ADDU A0, V1, V0
9D007354  93828014   LBU V0, -32748(GP)
9D007358  3C05A000   LUI A1, -24576
9D00735C  00021100   SLL V0, V0, 4
9D007360  00021880   SLL V1, V0, 2
9D007364  00621823   SUBU V1, V1, V0
9D007368  24A2753C   ADDIU V0, A1, 30012
9D00736C  00621021   ADDU V0, V1, V0
9D007370  9042002C   LBU V0, 44(V0)
9D007374  8FC3001C   LW V1, 28(S8)
9D007378  3063FFFF   ANDI V1, V1, -1
9D00737C  AFA30010   SW V1, 16(SP)
9D007380  00402821   ADDU A1, V0, ZERO
9D007384  2406FFFF   ADDIU A2, ZERO, -1
9D007388  00003821   ADDU A3, ZERO, ZERO
9D00738C  0F4020A8   JAL 0x9D0082A0
9D007390  00000000   NOP
4098:                                    TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len - wTemp);
9D007394  93828014   LBU V0, -32748(GP)
9D007398  3C03A000   LUI V1, -24576
9D00739C  2463753C   ADDIU V1, V1, 30012
9D0073A0  00021100   SLL V0, V0, 4
9D0073A4  00022080   SLL A0, V0, 2
9D0073A8  00821023   SUBU V0, A0, V0
9D0073AC  00621021   ADDU V0, V1, V0
9D0073B0  8C440004   LW A0, 4(V0)
9D0073B4  93828014   LBU V0, -32748(GP)
9D0073B8  3C05A000   LUI A1, -24576
9D0073BC  00021100   SLL V0, V0, 4
9D0073C0  00021880   SLL V1, V0, 2
9D0073C4  00621823   SUBU V1, V1, V0
9D0073C8  24A2753C   ADDIU V0, A1, 30012
9D0073CC  00621021   ADDU V0, V1, V0
9D0073D0  9042002C   LBU V0, 44(V0)
9D0073D4  8FC3001C   LW V1, 28(S8)
9D0073D8  3063FFFF   ANDI V1, V1, -1
9D0073DC  97C5004C   LHU A1, 76(S8)
9D0073E0  00A31823   SUBU V1, A1, V1
9D0073E4  3063FFFF   ANDI V1, V1, -1
9D0073E8  AFA30010   SW V1, 16(SP)
9D0073EC  00402821   ADDU A1, V0, ZERO
9D0073F0  2406FFFF   ADDIU A2, ZERO, -1
9D0073F4  00003821   ADDU A3, ZERO, ZERO
9D0073F8  0F4020A8   JAL 0x9D0082A0
9D0073FC  00000000   NOP
9D007400  0B401D49   J 0x9D007524
9D007404  00000000   NOP
4099:                                }
4100:                                else
4101:                                {
4102:                                    TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes - (MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1), MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D007408  93828014   LBU V0, -32748(GP)
9D00740C  3C03A000   LUI V1, -24576
9D007410  2463753C   ADDIU V1, V1, 30012
9D007414  00021100   SLL V0, V0, 4
9D007418  00022080   SLL A0, V0, 2
9D00741C  00821023   SUBU V0, A0, V0
9D007420  00621021   ADDU V0, V1, V0
9D007424  8C430014   LW V1, 20(V0)
9D007428  97C20034   LHU V0, 52(S8)
9D00742C  00622021   ADDU A0, V1, V0
9D007430  93828014   LBU V0, -32748(GP)
9D007434  3C05A000   LUI A1, -24576
9D007438  00021100   SLL V0, V0, 4
9D00743C  00021880   SLL V1, V0, 2
9D007440  00621823   SUBU V1, V1, V0
9D007444  24A2753C   ADDIU V0, A1, 30012
9D007448  00621021   ADDU V0, V1, V0
9D00744C  8C430008   LW V1, 8(V0)
9D007450  93828014   LBU V0, -32748(GP)
9D007454  3C05A000   LUI A1, -24576
9D007458  24A5753C   ADDIU A1, A1, 30012
9D00745C  00021100   SLL V0, V0, 4
9D007460  00023080   SLL A2, V0, 2
9D007464  00C21023   SUBU V0, A2, V0
9D007468  00A21021   ADDU V0, A1, V0
9D00746C  8C420004   LW V0, 4(V0)
9D007470  00621023   SUBU V0, V1, V0
9D007474  00021027   NOR V0, ZERO, V0
9D007478  00822021   ADDU A0, A0, V0
9D00747C  93828014   LBU V0, -32748(GP)
9D007480  3C05A000   LUI A1, -24576
9D007484  00021100   SLL V0, V0, 4
9D007488  00021880   SLL V1, V0, 2
9D00748C  00621823   SUBU V1, V1, V0
9D007490  24A2753C   ADDIU V0, A1, 30012
9D007494  00621021   ADDU V0, V1, V0
9D007498  9042002C   LBU V0, 44(V0)
9D00749C  97C3004C   LHU V1, 76(S8)
9D0074A0  AFA30010   SW V1, 16(SP)
9D0074A4  00402821   ADDU A1, V0, ZERO
9D0074A8  2406FFFF   ADDIU A2, ZERO, -1
9D0074AC  00003821   ADDU A3, ZERO, ZERO
9D0074B0  0F4020A8   JAL 0x9D0082A0
9D0074B4  00000000   NOP
9D0074B8  0B401D49   J 0x9D007524
9D0074BC  00000000   NOP
4103:                                }
4104:                            }
4105:                            else
4106:                            {
4107:                                TCPRAMCopy(MyTCBStub.rxHead + wMissingBytes, MyTCBStub.vMemoryMedium, (PTR_BASE)-1, TCP_ETH_RAM, len);
9D0074C0  93828014   LBU V0, -32748(GP)
9D0074C4  3C03A000   LUI V1, -24576
9D0074C8  2463753C   ADDIU V1, V1, 30012
9D0074CC  00021100   SLL V0, V0, 4
9D0074D0  00022080   SLL A0, V0, 2
9D0074D4  00821023   SUBU V0, A0, V0
9D0074D8  00621021   ADDU V0, V1, V0
9D0074DC  8C430014   LW V1, 20(V0)
9D0074E0  97C20034   LHU V0, 52(S8)
9D0074E4  00622021   ADDU A0, V1, V0
9D0074E8  93828014   LBU V0, -32748(GP)
9D0074EC  3C05A000   LUI A1, -24576
9D0074F0  00021100   SLL V0, V0, 4
9D0074F4  00021880   SLL V1, V0, 2
9D0074F8  00621823   SUBU V1, V1, V0
9D0074FC  24A2753C   ADDIU V0, A1, 30012
9D007500  00621021   ADDU V0, V1, V0
9D007504  9042002C   LBU V0, 44(V0)
9D007508  97C3004C   LHU V1, 76(S8)
9D00750C  AFA30010   SW V1, 16(SP)
9D007510  00402821   ADDU A1, V0, ZERO
9D007514  2406FFFF   ADDIU A2, ZERO, -1
9D007518  00003821   ADDU A3, ZERO, ZERO
9D00751C  0F4020A8   JAL 0x9D0082A0
9D007520  00000000   NOP
4108:                            }
4109:                
4110:                            // Record the hole is here
4111:                            if(MyTCB.sHoleSize == -1)
9D007524  3C02A000   LUI V0, -24576
9D007528  2442759C   ADDIU V0, V0, 30108
9D00752C  84430024   LH V1, 36(V0)
9D007530  2402FFFF   ADDIU V0, ZERO, -1
9D007534  1462000B   BNE V1, V0, 0x9D007564
9D007538  00000000   NOP
4112:                            {
4113:                                MyTCB.sHoleSize = wMissingBytes;
9D00753C  87C30034   LH V1, 52(S8)
9D007540  3C02A000   LUI V0, -24576
9D007544  2442759C   ADDIU V0, V0, 30108
9D007548  A4430024   SH V1, 36(V0)
4114:                                MyTCB.wFutureDataSize = len;
9D00754C  3C02A000   LUI V0, -24576
9D007550  2442759C   ADDIU V0, V0, 30108
9D007554  97C3004C   LHU V1, 76(S8)
9D007558  A4430016   SH V1, 22(V0)
9D00755C  0B401DC8   J 0x9D007720
9D007560  00000000   NOP
4115:                            }
4116:                            else
4117:                            {
4118:                                // We already have a hole, see if we can shrink the hole
4119:                                // or extend the future data size
4120:                                if(wMissingBytes < (uint16_t)MyTCB.sHoleSize)
9D007564  3C02A000   LUI V0, -24576
9D007568  2442759C   ADDIU V0, V0, 30108
9D00756C  84420024   LH V0, 36(V0)
9D007570  3042FFFF   ANDI V0, V0, -1
9D007574  97C30034   LHU V1, 52(S8)
9D007578  0062102B   SLTU V0, V1, V0
9D00757C  10400035   BEQ V0, ZERO, 0x9D007654
9D007580  00000000   NOP
4121:                                {
4122:                                    if((wMissingBytes + len > (uint16_t)MyTCB.sHoleSize + MyTCB.wFutureDataSize) || (wMissingBytes + len < (uint16_t)MyTCB.sHoleSize))
9D007584  97C30034   LHU V1, 52(S8)
9D007588  97C2004C   LHU V0, 76(S8)
9D00758C  00621821   ADDU V1, V1, V0
9D007590  3C02A000   LUI V0, -24576
9D007594  2442759C   ADDIU V0, V0, 30108
9D007598  84420024   LH V0, 36(V0)
9D00759C  3042FFFF   ANDI V0, V0, -1
9D0075A0  00402021   ADDU A0, V0, ZERO
9D0075A4  3C02A000   LUI V0, -24576
9D0075A8  2442759C   ADDIU V0, V0, 30108
9D0075AC  94420016   LHU V0, 22(V0)
9D0075B0  00821021   ADDU V0, A0, V0
9D0075B4  0043102A   SLT V0, V0, V1
9D0075B8  1440000B   BNE V0, ZERO, 0x9D0075E8
9D0075BC  00000000   NOP
9D0075C0  97C30034   LHU V1, 52(S8)
9D0075C4  97C2004C   LHU V0, 76(S8)
9D0075C8  00621821   ADDU V1, V1, V0
9D0075CC  3C02A000   LUI V0, -24576
9D0075D0  2442759C   ADDIU V0, V0, 30108
9D0075D4  84420024   LH V0, 36(V0)
9D0075D8  3042FFFF   ANDI V0, V0, -1
9D0075DC  0062102A   SLT V0, V1, V0
9D0075E0  10400007   BEQ V0, ZERO, 0x9D007600
9D0075E4  00000000   NOP
4123:                                        MyTCB.wFutureDataSize = len;
9D0075E8  3C02A000   LUI V0, -24576
9D0075EC  2442759C   ADDIU V0, V0, 30108
9D0075F0  97C3004C   LHU V1, 76(S8)
9D0075F4  A4430016   SH V1, 22(V0)
9D0075F8  0B401D8F   J 0x9D00763C
9D0075FC  00000000   NOP
4124:                                    else
4125:                                        MyTCB.wFutureDataSize = (uint16_t)MyTCB.sHoleSize + MyTCB.wFutureDataSize - wMissingBytes;
9D007600  3C02A000   LUI V0, -24576
9D007604  2442759C   ADDIU V0, V0, 30108
9D007608  84420024   LH V0, 36(V0)
9D00760C  3043FFFF   ANDI V1, V0, -1
9D007610  3C02A000   LUI V0, -24576
9D007614  2442759C   ADDIU V0, V0, 30108
9D007618  94420016   LHU V0, 22(V0)
9D00761C  00621021   ADDU V0, V1, V0
9D007620  3043FFFF   ANDI V1, V0, -1
9D007624  97C20034   LHU V0, 52(S8)
9D007628  00621023   SUBU V0, V1, V0
9D00762C  3043FFFF   ANDI V1, V0, -1
9D007630  3C02A000   LUI V0, -24576
9D007634  2442759C   ADDIU V0, V0, 30108
9D007638  A4430016   SH V1, 22(V0)
4126:                                    MyTCB.sHoleSize = wMissingBytes;
9D00763C  87C30034   LH V1, 52(S8)
9D007640  3C02A000   LUI V0, -24576
9D007644  2442759C   ADDIU V0, V0, 30108
9D007648  A4430024   SH V1, 36(V0)
9D00764C  0B401DC8   J 0x9D007720
9D007650  00000000   NOP
4127:                                }
4128:                                else if(wMissingBytes + len > (uint16_t)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9D007654  97C30034   LHU V1, 52(S8)
9D007658  97C2004C   LHU V0, 76(S8)
9D00765C  00621821   ADDU V1, V1, V0
9D007660  3C02A000   LUI V0, -24576
9D007664  2442759C   ADDIU V0, V0, 30108
9D007668  84420024   LH V0, 36(V0)
9D00766C  3042FFFF   ANDI V0, V0, -1
9D007670  00402021   ADDU A0, V0, ZERO
9D007674  3C02A000   LUI V0, -24576
9D007678  2442759C   ADDIU V0, V0, 30108
9D00767C  94420016   LHU V0, 22(V0)
9D007680  00821021   ADDU V0, A0, V0
9D007684  0043102A   SLT V0, V0, V1
9D007688  10400025   BEQ V0, ZERO, 0x9D007720
9D00768C  00000000   NOP
4129:                                {
4130:                                    // Make sure that there isn't a second hole between
4131:                                    // our future data and this TCP segment's future data
4132:                                    if(wMissingBytes <= (uint16_t)MyTCB.sHoleSize + MyTCB.wFutureDataSize)
9D007690  97C30034   LHU V1, 52(S8)
9D007694  3C02A000   LUI V0, -24576
9D007698  2442759C   ADDIU V0, V0, 30108
9D00769C  84420024   LH V0, 36(V0)
9D0076A0  3042FFFF   ANDI V0, V0, -1
9D0076A4  00402021   ADDU A0, V0, ZERO
9D0076A8  3C02A000   LUI V0, -24576
9D0076AC  2442759C   ADDIU V0, V0, 30108
9D0076B0  94420016   LHU V0, 22(V0)
9D0076B4  00821021   ADDU V0, A0, V0
9D0076B8  0043102A   SLT V0, V0, V1
9D0076BC  14400018   BNE V0, ZERO, 0x9D007720
9D0076C0  00000000   NOP
4133:                                        MyTCB.wFutureDataSize += wMissingBytes + len - (uint16_t)MyTCB.sHoleSize - MyTCB.wFutureDataSize;
9D0076C4  3C02A000   LUI V0, -24576
9D0076C8  2442759C   ADDIU V0, V0, 30108
9D0076CC  94430016   LHU V1, 22(V0)
9D0076D0  97C40034   LHU A0, 52(S8)
9D0076D4  97C2004C   LHU V0, 76(S8)
9D0076D8  00821021   ADDU V0, A0, V0
9D0076DC  3044FFFF   ANDI A0, V0, -1
9D0076E0  3C02A000   LUI V0, -24576
9D0076E4  2442759C   ADDIU V0, V0, 30108
9D0076E8  84420024   LH V0, 36(V0)
9D0076EC  3042FFFF   ANDI V0, V0, -1
9D0076F0  00821023   SUBU V0, A0, V0
9D0076F4  3044FFFF   ANDI A0, V0, -1
9D0076F8  3C02A000   LUI V0, -24576
9D0076FC  2442759C   ADDIU V0, V0, 30108
9D007700  94420016   LHU V0, 22(V0)
9D007704  00821023   SUBU V0, A0, V0
9D007708  3042FFFF   ANDI V0, V0, -1
9D00770C  00621021   ADDU V0, V1, V0
9D007710  3043FFFF   ANDI V1, V0, -1
9D007714  3C02A000   LUI V0, -24576
9D007718  2442759C   ADDIU V0, V0, 30108
9D00771C  A4430016   SH V1, 22(V0)
4134:                                }
4135:                
4136:                            }
4137:                        }
4138:                    }
4139:                
4140:                    // Send back an ACK of the data (+SYN | FIN) we just received,
4141:                    // if any.  To minimize bandwidth waste, we are implementing
4142:                    // the delayed acknowledgement algorithm here, only sending
4143:                    // back an immediate ACK if this is the second segment received.
4144:                    // Otherwise, a 200ms timer will cause the ACK to be transmitted.
4145:                    if(wSegmentLength)
9D007720  97C20028   LHU V0, 40(S8)
9D007724  10400063   BEQ V0, ZERO, 0x9D0078B4
9D007728  00000000   NOP
4146:                    {
4147:                        // For non-established sockets, let's delete all data in
4148:                        // the RX buffer immediately after receiving it.  This is
4149:                        // not really how TCP was intended to operate since a
4150:                        // socket cannot receive any response after it sends a FIN,
4151:                        // but our TCP application API doesn't readily accomodate
4152:                        // receiving data after calling TCPDisconnect(), which
4153:                        // invalidates the application TCP handle.  By deleting all
4154:                        // data, we'll ensure that the RX window is nonzero and
4155:                        // the remote node will be able to send us a FIN response,
4156:                        // which needs an RX window of at least 1.
4157:                        if(MyTCBStub.smState != TCP_ESTABLISHED)
9D00772C  93828014   LBU V0, -32748(GP)
9D007730  3C03A000   LUI V1, -24576
9D007734  2463753C   ADDIU V1, V1, 30012
9D007738  00021100   SLL V0, V0, 4
9D00773C  00022080   SLL A0, V0, 2
9D007740  00821023   SUBU V0, A0, V0
9D007744  00621021   ADDU V0, V1, V0
9D007748  8C430024   LW V1, 36(V0)
9D00774C  24020007   ADDIU V0, ZERO, 7
9D007750  10620013   BEQ V1, V0, 0x9D0077A0
9D007754  00000000   NOP
4158:                            MyTCBStub.rxTail = MyTCBStub.rxHead;
9D007758  93828014   LBU V0, -32748(GP)
9D00775C  00401821   ADDU V1, V0, ZERO
9D007760  93828014   LBU V0, -32748(GP)
9D007764  3C04A000   LUI A0, -24576
9D007768  2484753C   ADDIU A0, A0, 30012
9D00776C  00021100   SLL V0, V0, 4
9D007770  00022880   SLL A1, V0, 2
9D007774  00A21023   SUBU V0, A1, V0
9D007778  00821021   ADDU V0, A0, V0
9D00777C  8C440014   LW A0, 20(V0)
9D007780  3C05A000   LUI A1, -24576
9D007784  00601021   ADDU V0, V1, ZERO
9D007788  00021100   SLL V0, V0, 4
9D00778C  00021880   SLL V1, V0, 2
9D007790  00621823   SUBU V1, V1, V0
9D007794  24A2753C   ADDIU V0, A1, 30012
9D007798  00621021   ADDU V0, V1, V0
9D00779C  AC440018   SW A0, 24(V0)
4159:                
4160:                        if(MyTCBStub.Flags.bOneSegmentReceived)
9D0077A0  93828014   LBU V0, -32748(GP)
9D0077A4  3C04A000   LUI A0, -24576
9D0077A8  00021100   SLL V0, V0, 4
9D0077AC  00021880   SLL V1, V0, 2
9D0077B0  00621823   SUBU V1, V1, V0
9D0077B4  2482753C   ADDIU V0, A0, 30012
9D0077B8  00621021   ADDU V0, V1, V0
9D0077BC  8C420028   LW V0, 40(V0)
9D0077C0  7C4201C0   EXT V0, V0, 7, 1
9D0077C4  304200FF   ANDI V0, V0, 255
9D0077C8  10400009   BEQ V0, ZERO, 0x9D0077F0
9D0077CC  00000000   NOP
4161:                        {
4162:                            SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D0077D0  24040010   ADDIU A0, ZERO, 16
9D0077D4  24050001   ADDIU A1, ZERO, 1
9D0077D8  0F400F2C   JAL 0x9D003CB0
9D0077DC  00000000   NOP
4163:                            SyncTCB();
9D0077E0  0F400000   JAL 0x9D000000
9D0077E4  00000000   NOP
9D0077E8  0B401E2D   J 0x9D0078B4
9D0077EC  00000000   NOP
4164:                            // bOneSegmentReceived is cleared in SendTCP(), so no need here
4165:                        }
4166:                        else
4167:                        {
4168:                            MyTCBStub.Flags.bOneSegmentReceived = true;
9D0077F0  93828014   LBU V0, -32748(GP)
9D0077F4  3C04A000   LUI A0, -24576
9D0077F8  00021100   SLL V0, V0, 4
9D0077FC  00021880   SLL V1, V0, 2
9D007800  00621823   SUBU V1, V1, V0
9D007804  2482753C   ADDIU V0, A0, 30012
9D007808  00621821   ADDU V1, V1, V0
9D00780C  8C620028   LW V0, 40(V1)
9D007810  24040001   ADDIU A0, ZERO, 1
9D007814  7C8239C4   INS V0, A0, 7, 1
9D007818  AC620028   SW V0, 40(V1)
4169:                
4170:                            // Do not send an ACK immediately back.  Instead, we will
4171:                            // perform delayed acknowledgements.  To do this, we will
4172:                            // just start a timer
4173:                            if(!MyTCBStub.Flags.bDelayedACKTimerEnabled)
9D00781C  93828014   LBU V0, -32748(GP)
9D007820  3C04A000   LUI A0, -24576
9D007824  00021100   SLL V0, V0, 4
9D007828  00021880   SLL V1, V0, 2
9D00782C  00621823   SUBU V1, V1, V0
9D007830  2482753C   ADDIU V0, A0, 30012
9D007834  00621021   ADDU V0, V1, V0
9D007838  8C420028   LW V0, 40(V0)
9D00783C  7C420180   EXT V0, V0, 6, 1
9D007840  304200FF   ANDI V0, V0, 255
9D007844  1440001B   BNE V0, ZERO, 0x9D0078B4
9D007848  00000000   NOP
4174:                            {
4175:                                MyTCBStub.Flags.bDelayedACKTimerEnabled = 1;
9D00784C  93828014   LBU V0, -32748(GP)
9D007850  3C04A000   LUI A0, -24576
9D007854  00021100   SLL V0, V0, 4
9D007858  00021880   SLL V1, V0, 2
9D00785C  00621823   SUBU V1, V1, V0
9D007860  2482753C   ADDIU V0, A0, 30012
9D007864  00621821   ADDU V1, V1, V0
9D007868  8C620028   LW V0, 40(V1)
9D00786C  24040001   ADDIU A0, ZERO, 1
9D007870  7C823184   INS V0, A0, 6, 1
9D007874  AC620028   SW V0, 40(V1)
4176:                                MyTCBStub.OverlappedTimers.delayedACKTime = (uint16_t)TickGetDiv256() + (uint16_t)((TCP_DELAYED_ACK_TIMEOUT)>>8);
9D007878  93828014   LBU V0, -32748(GP)
9D00787C  00408021   ADDU S0, V0, ZERO
9D007880  0F405C62   JAL TickGetDiv256
9D007884  00000000   NOP
9D007888  3042FFFF   ANDI V0, V0, -1
9D00788C  2442007A   ADDIU V0, V0, 122
9D007890  3044FFFF   ANDI A0, V0, -1
9D007894  3C05A000   LUI A1, -24576
9D007898  02001021   ADDU V0, S0, ZERO
9D00789C  00021100   SLL V0, V0, 4
9D0078A0  00021880   SLL V1, V0, 2
9D0078A4  00621823   SUBU V1, V1, V0
9D0078A8  24A2753C   ADDIU V0, A1, 30012
9D0078AC  00621021   ADDU V0, V1, V0
9D0078B0  A4440022   SH A0, 34(V0)
4177:                            }
4178:                        }
4179:                    }
4180:                
4181:                    //
4182:                    // Eighth: check the FIN bit
4183:                    //
4184:                    if(localHeaderFlags & FIN)
9D0078B4  93C2002B   LBU V0, 43(S8)
9D0078B8  30420001   ANDI V0, V0, 1
9D0078BC  304200FF   ANDI V0, V0, 255
9D0078C0  10400098   BEQ V0, ZERO, 0x9D007B24
9D0078C4  00000000   NOP
4185:                    {
4186:                        // Note: Since we don't have a good means of storing "FIN bytes"
4187:                        // in our TCP RX FIFO, we must ensure that FINs are processed
4188:                        // in-order.
4189:                        if(MyTCB.RemoteSEQ + 1 == localSeqNumber + (uint32_t)wSegmentLength)
9D0078C8  3C02A000   LUI V0, -24576
9D0078CC  2442759C   ADDIU V0, V0, 30108
9D0078D0  8C420008   LW V0, 8(V0)
9D0078D4  24430001   ADDIU V1, V0, 1
9D0078D8  97C40028   LHU A0, 40(S8)
9D0078DC  8FC2002C   LW V0, 44(S8)
9D0078E0  00821021   ADDU V0, A0, V0
9D0078E4  1462008F   BNE V1, V0, 0x9D007B24
9D0078E8  00000000   NOP
4190:                        {
4191:                            // FINs are treated as one byte of data for ACK sequencing
4192:                            MyTCB.RemoteSEQ++;
9D0078EC  3C02A000   LUI V0, -24576
9D0078F0  2442759C   ADDIU V0, V0, 30108
9D0078F4  8C420008   LW V0, 8(V0)
9D0078F8  24430001   ADDIU V1, V0, 1
9D0078FC  3C02A000   LUI V0, -24576
9D007900  2442759C   ADDIU V0, V0, 30108
9D007904  AC430008   SW V1, 8(V0)
4193:                
4194:                            switch(MyTCBStub.smState)
9D007908  93828014   LBU V0, -32748(GP)
9D00790C  3C03A000   LUI V1, -24576
9D007910  2463753C   ADDIU V1, V1, 30012
9D007914  00021100   SLL V0, V0, 4
9D007918  00022080   SLL A0, V0, 2
9D00791C  00821023   SUBU V0, A0, V0
9D007920  00621021   ADDU V0, V1, V0
9D007924  8C420024   LW V0, 36(V0)
9D007928  24030007   ADDIU V1, ZERO, 7
9D00792C  10430020   BEQ V0, V1, 0x9D0079B0
9D007930  00000000   NOP
9D007934  2C430008   SLTIU V1, V0, 8
9D007938  10600006   BEQ V1, ZERO, 0x9D007954
9D00793C  00000000   NOP
9D007940  24030006   ADDIU V1, ZERO, 6
9D007944  1043000B   BEQ V0, V1, 0x9D007974
9D007948  00000000   NOP
9D007954  24030008   ADDIU V1, ZERO, 8
9D007958  1043002F   BEQ V0, V1, 0x9D007A18
9D00795C  00000000   NOP
9D007960  24030009   ADDIU V1, ZERO, 9
9D007964  10430045   BEQ V0, V1, 0x9D007A7C
9D007968  00000000   NOP
4195:                            {
4196:                                case TCP_SYN_RECEIVED:
4197:                                    // RFC in exact: Our API has no need for the user
4198:                                    // to explicitly close a socket that never really
4199:                                    // got opened fully in the first place, so just
4200:                                    // transmit a FIN automatically and jump to
4201:                                    // TCP_LAST_ACK
4202:                                    MyTCBStub.smState = TCP_LAST_ACK;
9D007974  93828014   LBU V0, -32748(GP)
9D007978  3C03A000   LUI V1, -24576
9D00797C  2463753C   ADDIU V1, V1, 30012
9D007980  00021100   SLL V0, V0, 4
9D007984  00022080   SLL A0, V0, 2
9D007988  00821023   SUBU V0, A0, V0
9D00798C  00621021   ADDU V0, V1, V0
9D007990  2403000C   ADDIU V1, ZERO, 12
9D007994  AC430024   SW V1, 36(V0)
4203:                                    SendTCP(FIN | ACK, SENDTCP_RESET_TIMERS);
9D007998  24040011   ADDIU A0, ZERO, 17
9D00799C  24050001   ADDIU A1, ZERO, 1
9D0079A0  0F400F2C   JAL 0x9D003CB0
9D0079A4  00000000   NOP
4204:                                    return;
9D0079A8  0B401EC9   J 0x9D007B24
9D0079AC  00000000   NOP
4205:                
4206:                                case TCP_ESTABLISHED:
4207:                                    // Go to TCP_CLOSE_WAIT state
4208:                                    MyTCBStub.smState = TCP_CLOSE_WAIT;
9D0079B0  93828014   LBU V0, -32748(GP)
9D0079B4  3C03A000   LUI V1, -24576
9D0079B8  2463753C   ADDIU V1, V1, 30012
9D0079BC  00021100   SLL V0, V0, 4
9D0079C0  00022080   SLL A0, V0, 2
9D0079C4  00821023   SUBU V0, A0, V0
9D0079C8  00621021   ADDU V0, V1, V0
9D0079CC  2403000B   ADDIU V1, ZERO, 11
9D0079D0  AC430024   SW V1, 36(V0)
4209:                
4210:                                    // For legacy applications that don't call
4211:                                    // TCPDisconnect() as needed and expect the TCP/IP
4212:                                    // Stack to automatically close sockets when the
4213:                                    // remote node sends a FIN, let's start a timer so
4214:                                    // that we will eventually close the socket automatically
4215:                                    MyTCBStub.OverlappedTimers.closeWaitTime = (uint16_t)TickGetDiv256() + (uint16_t)((TCP_CLOSE_WAIT_TIMEOUT)>>8);
9D0079D4  93828014   LBU V0, -32748(GP)
9D0079D8  00408021   ADDU S0, V0, ZERO
9D0079DC  0F405C62   JAL TickGetDiv256
9D0079E0  00000000   NOP
9D0079E4  3042FFFF   ANDI V0, V0, -1
9D0079E8  244200F4   ADDIU V0, V0, 244
9D0079EC  3044FFFF   ANDI A0, V0, -1
9D0079F0  3C05A000   LUI A1, -24576
9D0079F4  02001021   ADDU V0, S0, ZERO
9D0079F8  00021100   SLL V0, V0, 4
9D0079FC  00021880   SLL V1, V0, 2
9D007A00  00621823   SUBU V1, V1, V0
9D007A04  24A2753C   ADDIU V0, A1, 30012
9D007A08  00621021   ADDU V0, V1, V0
9D007A0C  A4440022   SH A0, 34(V0)
4216:                                    break;
9D007A10  0B401EA7   J 0x9D007A9C
9D007A14  00000000   NOP
4217:                
4218:                                case TCP_FIN_WAIT_1:
4219:                                    if(MyTCB.MySEQ == localAckNumber)
9D007A18  3C02A000   LUI V0, -24576
9D007A1C  2442759C   ADDIU V0, V0, 30108
9D007A20  8C430004   LW V1, 4(V0)
9D007A24  8FC20024   LW V0, 36(S8)
9D007A28  14620009   BNE V1, V0, 0x9D007A50
9D007A2C  00000000   NOP
4220:                                    {
4221:                                        // RFC not recommended: We should be going to
4222:                                        // the TCP_TIME_WAIT state right here and
4223:                                        // starting a 2MSL timer, but since we have so
4224:                                        // few precious sockets, we can't afford to
4225:                                        // leave a socket waiting around doing nothing
4226:                                        // for a long time.  If the remote node does
4227:                                        // not recieve this ACK, it'll have to figure
4228:                                        // out on it's own that the connection is now
4229:                                        // closed.
4230:                                        SendTCP(ACK, 0);
9D007A30  24040010   ADDIU A0, ZERO, 16
9D007A34  00002821   ADDU A1, ZERO, ZERO
9D007A38  0F400F2C   JAL 0x9D003CB0
9D007A3C  00000000   NOP
4231:                                        CloseSocket();
9D007A40  0F401470   JAL 0x9D0051C0
9D007A44  00000000   NOP
4232:                                        return;
9D007A48  0B401EC9   J 0x9D007B24
9D007A4C  00000000   NOP
4233:                                    }
4234:                                    else
4235:                                    {
4236:                                        MyTCBStub.smState = TCP_CLOSING;
9D007A50  93828014   LBU V0, -32748(GP)
9D007A54  3C03A000   LUI V1, -24576
9D007A58  2463753C   ADDIU V1, V1, 30012
9D007A5C  00021100   SLL V0, V0, 4
9D007A60  00022080   SLL A0, V0, 2
9D007A64  00821023   SUBU V0, A0, V0
9D007A68  00621021   ADDU V0, V1, V0
9D007A6C  2403000A   ADDIU V1, ZERO, 10
9D007A70  AC430024   SW V1, 36(V0)
4237:                                    }
4238:                                    break;
9D007A74  0B401EA7   J 0x9D007A9C
9D007A78  00000000   NOP
4239:                
4240:                                case TCP_FIN_WAIT_2:
4241:                                    // RFC not recommended: We should be going to
4242:                                    // the TCP_TIME_WAIT state right here and
4243:                                    // starting a 2MSL timer, but since we have so
4244:                                    // few precious sockets, we can't afford to
4245:                                    // leave a socket waiting around doing nothing
4246:                                    // for a long time.  If the remote node does
4247:                                    // not recieve this ACK, it'll have to figure
4248:                                    // out on it's own that the connection is now
4249:                                    // closed.
4250:                                    SendTCP(ACK, 0);
9D007A7C  24040010   ADDIU A0, ZERO, 16
9D007A80  00002821   ADDU A1, ZERO, ZERO
9D007A84  0F400F2C   JAL 0x9D003CB0
9D007A88  00000000   NOP
4251:                                    CloseSocket();
9D007A8C  0F401470   JAL 0x9D0051C0
9D007A90  00000000   NOP
4252:                                    return;
9D007A94  0B401EC9   J 0x9D007B24
9D007A98  00000000   NOP
4253:                
4254:                                default:
4255:                                    break;
9D00794C  0B401EA7   J 0x9D007A9C
9D007950  00000000   NOP
9D00796C  0B401EA7   J 0x9D007A9C
9D007970  00000000   NOP
4256:                            }
4257:                
4258:                            // Acknowledge receipt of FIN
4259:                            SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D007A9C  24040010   ADDIU A0, ZERO, 16
9D007AA0  24050001   ADDIU A1, ZERO, 1
9D007AA4  0F400F2C   JAL 0x9D003CB0
9D007AA8  00000000   NOP
9D007AAC  0B401EC9   J 0x9D007B24
9D007AB0  00000000   NOP
4260:                        }
4261:                    }
4262:                }
9D007B24  03C0E821   ADDU SP, S8, ZERO
9D007B28  8FBF0044   LW RA, 68(SP)
9D007B2C  8FBE0040   LW S8, 64(SP)
9D007B30  8FB0003C   LW S0, 60(SP)
9D007B34  27BD0048   ADDIU SP, SP, 72
9D007B38  03E00008   JR RA
9D007B3C  00000000   NOP
4263:                
4264:                /****************************************************************************
4265:                  Section:
4266:                    Buffer Management Functions
4267:                  ***************************************************************************/
4268:                
4269:                /*****************************************************************************
4270:                  Function:
4271:                    bool TCPAdjustFIFOSize(TCP_SOCKET hTCP, uint16_t wMinRXSize,
4272:                                            uint16_t wMinTXSize, uint8_t vFlags)
4273:                
4274:                  Summary:
4275:                    Adjusts the relative sizes of the RX and TX buffers.
4276:                
4277:                  Description:
4278:                    This function can be used to adjust the relative sizes of the RX and
4279:                    TX FIFO depending on the immediate needs of an application.  Since a
4280:                    larger FIFO can allow more data to be sent in a given packet, adjusting
4281:                    the relative sizes on the fly can allow for optimal transmission speed
4282:                    for one-sided application protocols.  For example, HTTP typically
4283:                    begins by receiving large amounts of data from the client, then switches
4284:                    to serving large amounts of data back.  Adjusting the FIFO at these
4285:                    points can increase performance substantially.  Once the FIFO is
4286:                    adjusted, a window update is sent.
4287:                
4288:                    If neither or both of TCP_ADJUST_GIVE_REST_TO_TX and
4289:                    TCP_ADJUST_GIVE_REST_TO_RX are set, the function distributes the
4290:                    remaining space equally.
4291:                
4292:                    Received data can be preserved as long as the buffer is expanding and
4293:                    has not wrapped.
4294:                
4295:                  Precondition:
4296:                    TCP is initialized.
4297:                
4298:                  Parameters:
4299:                    hTCP        - The socket to be adjusted
4300:                    wMinRXSize  - Minimum number of byte for the RX FIFO
4301:                    wMinTXSize  - Minimum number of bytes for the RX FIFO
4302:                    vFlags      - Any combination of TCP_ADJUST_GIVE_REST_TO_RX,
4303:                                  TCP_ADJUST_GIVE_REST_TO_TX, TCP_ADJUST_PRESERVE_RX.
4304:                                  TCP_ADJUST_PRESERVE_TX is not currently supported.
4305:                
4306:                  Return Values:
4307:                    true - The FIFOs were adjusted successfully
4308:                    false - Minimum RX, Minimum TX, or flags couldn't be accommodated and
4309:                            therefore the socket was left unchanged.
4310:                
4311:                  Side Effects:
4312:                    Any unacknowledged or untransmitted data in the TX FIFO is always
4313:                    deleted.
4314:                
4315:                  Remarks:
4316:                    At least one byte must always be allocated to the RX buffer so that
4317:                    a FIN can be received.  The function automatically corrects for this.
4318:                  ***************************************************************************/
4319:                bool TCPAdjustFIFOSize(TCP_SOCKET hTCP, uint16_t wMinRXSize, uint16_t wMinTXSize, uint8_t vFlags)
4320:                {
9D007B40  27BDFFD0   ADDIU SP, SP, -48
9D007B44  AFBF002C   SW RA, 44(SP)
9D007B48  AFBE0028   SW S8, 40(SP)
9D007B4C  03A0F021   ADDU S8, SP, ZERO
9D007B50  00804021   ADDU T0, A0, ZERO
9D007B54  00A02021   ADDU A0, A1, ZERO
9D007B58  00C01821   ADDU V1, A2, ZERO
9D007B5C  00E01021   ADDU V0, A3, ZERO
9D007B60  A3C80030   SB T0, 48(S8)
9D007B64  A7C40034   SH A0, 52(S8)
9D007B68  A7C30038   SH V1, 56(S8)
9D007B6C  A3C2003C   SB V0, 60(S8)
4321:                    PTR_BASE ptrTemp, ptrHead;
4322:                    uint16_t wTXAllocation;
4323:                
4324:                    if(hTCP >= TCP_SOCKET_COUNT)
9D007B70  93C20030   LBU V0, 48(S8)
9D007B74  2C420002   SLTIU V0, V0, 2
9D007B78  14400004   BNE V0, ZERO, 0x9D007B8C
9D007B7C  00000000   NOP
4325:                    {
4326:                        return false;
9D007B80  00001021   ADDU V0, ZERO, ZERO
9D007B84  0B4020A2   J 0x9D008288
9D007B88  00000000   NOP
4327:                    }
4328:                
4329:                    // Load up info on this socket
4330:                    SyncTCBStub(hTCP);
9D007B8C  93C20030   LBU V0, 48(S8)
9D007B90  A3828014   SB V0, -32748(GP)
4331:                
4332:                    // RX has to be at least 1 byte to receive SYN and FIN bytes
4333:                    // from the remote node, even if they aren't stored in the RX FIFO
4334:                    if(wMinRXSize == 0u)
9D007B94  97C20034   LHU V0, 52(S8)
9D007B98  14400003   BNE V0, ZERO, 0x9D007BA8
9D007B9C  00000000   NOP
4335:                        wMinRXSize = 1;
9D007BA0  24020001   ADDIU V0, ZERO, 1
9D007BA4  A7C20034   SH V0, 52(S8)
4336:                
4337:                    // SSL connections need to be able to send or receive at least
4338:                    // a full Alert record, MAC, and FIN
4339:                    #if defined(STACK_USE_SSL)
4340:                    if(TCPIsSSL(hTCP) && wMinRXSize < 25u)
4341:                        wMinRXSize = 25;
4342:                    if(TCPIsSSL(hTCP) && wMinTXSize < 25u)
4343:                        wMinTXSize = 25;
4344:                    #endif
4345:                
4346:                    // Make sure space is available for minimums
4347:                    ptrTemp = MyTCBStub.bufferEnd - MyTCBStub.bufferTxStart - 1;
9D007BA8  93828014   LBU V0, -32748(GP)
9D007BAC  3C04A000   LUI A0, -24576
9D007BB0  00021100   SLL V0, V0, 4
9D007BB4  00021880   SLL V1, V0, 2
9D007BB8  00621823   SUBU V1, V1, V0
9D007BBC  2482753C   ADDIU V0, A0, 30012
9D007BC0  00621021   ADDU V0, V1, V0
9D007BC4  8C440008   LW A0, 8(V0)
9D007BC8  93828014   LBU V0, -32748(GP)
9D007BCC  3C05A000   LUI A1, -24576
9D007BD0  00021100   SLL V0, V0, 4
9D007BD4  00021880   SLL V1, V0, 2
9D007BD8  00621823   SUBU V1, V1, V0
9D007BDC  24A2753C   ADDIU V0, A1, 30012
9D007BE0  00621021   ADDU V0, V1, V0
9D007BE4  8C420000   LW V0, 0(V0)
9D007BE8  00821023   SUBU V0, A0, V0
9D007BEC  2442FFFF   ADDIU V0, V0, -1
9D007BF0  AFC20020   SW V0, 32(S8)
4348:                    if(wMinRXSize + wMinTXSize > ptrTemp)
9D007BF4  97C30034   LHU V1, 52(S8)
9D007BF8  97C20038   LHU V0, 56(S8)
9D007BFC  00621021   ADDU V0, V1, V0
9D007C00  00401821   ADDU V1, V0, ZERO
9D007C04  8FC20020   LW V0, 32(S8)
9D007C08  0043102B   SLTU V0, V0, V1
9D007C0C  10400004   BEQ V0, ZERO, 0x9D007C20
9D007C10  00000000   NOP
4349:                        return false;
9D007C14  00001021   ADDU V0, ZERO, ZERO
9D007C18  0B4020A2   J 0x9D008288
9D007C1C  00000000   NOP
4350:                
4351:                    SyncTCB();
9D007C20  0F400000   JAL 0x9D000000
9D007C24  00000000   NOP
4352:                
4353:                    // Set both allocation flags if none set
4354:                    if(!(vFlags & (TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX)))
9D007C28  93C2003C   LBU V0, 60(S8)
9D007C2C  30420003   ANDI V0, V0, 3
9D007C30  14400004   BNE V0, ZERO, 0x9D007C44
9D007C34  00000000   NOP
4355:                        vFlags |= TCP_ADJUST_GIVE_REST_TO_TX | TCP_ADJUST_GIVE_REST_TO_RX;
9D007C38  93C2003C   LBU V0, 60(S8)
9D007C3C  34420003   ORI V0, V0, 3
9D007C40  A3C2003C   SB V0, 60(S8)
4356:                
4357:                
4358:                    // Allocate minimums
4359:                    wTXAllocation = wMinTXSize;
9D007C44  97C20038   LHU V0, 56(S8)
9D007C48  A7C2001C   SH V0, 28(S8)
4360:                    ptrTemp -= wMinRXSize + wMinTXSize;
9D007C4C  97C30034   LHU V1, 52(S8)
9D007C50  97C20038   LHU V0, 56(S8)
9D007C54  00621021   ADDU V0, V1, V0
9D007C58  8FC30020   LW V1, 32(S8)
9D007C5C  00621023   SUBU V0, V1, V0
9D007C60  AFC20020   SW V0, 32(S8)
4361:                
4362:                    // Allocate extra
4363:                    if(vFlags & TCP_ADJUST_GIVE_REST_TO_TX)
9D007C64  93C2003C   LBU V0, 60(S8)
9D007C68  30420002   ANDI V0, V0, 2
9D007C6C  10400013   BEQ V0, ZERO, 0x9D007CBC
9D007C70  00000000   NOP
4364:                    {
4365:                        if(vFlags & TCP_ADJUST_GIVE_REST_TO_RX)
9D007C74  93C2003C   LBU V0, 60(S8)
9D007C78  30420001   ANDI V0, V0, 1
9D007C7C  304200FF   ANDI V0, V0, 255
9D007C80  10400009   BEQ V0, ZERO, 0x9D007CA8
9D007C84  00000000   NOP
4366:                        {
4367:                            // Do a 50%/50% split with any odd byte always going to the RX FIFO
4368:                            wTXAllocation += ptrTemp>>1;
9D007C88  8FC20020   LW V0, 32(S8)
9D007C8C  00021042   SRL V0, V0, 1
9D007C90  3043FFFF   ANDI V1, V0, -1
9D007C94  97C2001C   LHU V0, 28(S8)
9D007C98  00621021   ADDU V0, V1, V0
9D007C9C  A7C2001C   SH V0, 28(S8)
9D007CA0  0B401F2F   J 0x9D007CBC
9D007CA4  00000000   NOP
4369:                        }
4370:                        else
4371:                        {
4372:                            wTXAllocation += ptrTemp;
9D007CA8  8FC20020   LW V0, 32(S8)
9D007CAC  3043FFFF   ANDI V1, V0, -1
9D007CB0  97C2001C   LHU V0, 28(S8)
9D007CB4  00621021   ADDU V0, V1, V0
9D007CB8  A7C2001C   SH V0, 28(S8)
4373:                        }
4374:                    }
4375:                
4376:                    // Calculate new bufferRxStart pointer
4377:                    ptrTemp = MyTCBStub.bufferTxStart + wTXAllocation + 1;
9D007CBC  93828014   LBU V0, -32748(GP)
9D007CC0  3C04A000   LUI A0, -24576
9D007CC4  00021100   SLL V0, V0, 4
9D007CC8  00021880   SLL V1, V0, 2
9D007CCC  00621823   SUBU V1, V1, V0
9D007CD0  2482753C   ADDIU V0, A0, 30012
9D007CD4  00621021   ADDU V0, V1, V0
9D007CD8  8C430000   LW V1, 0(V0)
9D007CDC  97C2001C   LHU V0, 28(S8)
9D007CE0  00621021   ADDU V0, V1, V0
9D007CE4  24420001   ADDIU V0, V0, 1
9D007CE8  AFC20020   SW V0, 32(S8)
4378:                
4379:                    // Find the head pointer to use
4380:                    ptrHead = MyTCBStub.rxHead;
9D007CEC  93828014   LBU V0, -32748(GP)
9D007CF0  3C03A000   LUI V1, -24576
9D007CF4  2463753C   ADDIU V1, V1, 30012
9D007CF8  00021100   SLL V0, V0, 4
9D007CFC  00022080   SLL A0, V0, 2
9D007D00  00821023   SUBU V0, A0, V0
9D007D04  00621021   ADDU V0, V1, V0
9D007D08  8C420014   LW V0, 20(V0)
9D007D0C  AFC20018   SW V0, 24(S8)
4381:                    #if defined(STACK_USE_SSL)
4382:                    if(TCPIsSSL(hTCP))
4383:                        ptrHead = MyTCBStub.sslRxHead;
4384:                    #endif
4385:                
4386:                    // If there's out-of-order data pending, adjust the head pointer to compensate
4387:                    if(MyTCB.sHoleSize != -1)
9D007D10  3C02A000   LUI V0, -24576
9D007D14  2442759C   ADDIU V0, V0, 30108
9D007D18  84430024   LH V1, 36(V0)
9D007D1C  2402FFFF   ADDIU V0, ZERO, -1
9D007D20  1062002D   BEQ V1, V0, 0x9D007DD8
9D007D24  00000000   NOP
4388:                    {
4389:                        ptrHead += MyTCB.sHoleSize + MyTCB.wFutureDataSize;
9D007D28  3C02A000   LUI V0, -24576
9D007D2C  2442759C   ADDIU V0, V0, 30108
9D007D30  84420024   LH V0, 36(V0)
9D007D34  00401821   ADDU V1, V0, ZERO
9D007D38  3C02A000   LUI V0, -24576
9D007D3C  2442759C   ADDIU V0, V0, 30108
9D007D40  94420016   LHU V0, 22(V0)
9D007D44  00621021   ADDU V0, V1, V0
9D007D48  8FC30018   LW V1, 24(S8)
9D007D4C  00621021   ADDU V0, V1, V0
9D007D50  AFC20018   SW V0, 24(S8)
4390:                        if(ptrHead > MyTCBStub.bufferEnd)
9D007D54  93828014   LBU V0, -32748(GP)
9D007D58  3C04A000   LUI A0, -24576
9D007D5C  00021100   SLL V0, V0, 4
9D007D60  00021880   SLL V1, V0, 2
9D007D64  00621823   SUBU V1, V1, V0
9D007D68  2482753C   ADDIU V0, A0, 30012
9D007D6C  00621021   ADDU V0, V1, V0
9D007D70  8C430008   LW V1, 8(V0)
9D007D74  8FC20018   LW V0, 24(S8)
9D007D78  0062102B   SLTU V0, V1, V0
9D007D7C  10400016   BEQ V0, ZERO, 0x9D007DD8
9D007D80  00000000   NOP
4391:                            ptrHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
9D007D84  93828014   LBU V0, -32748(GP)
9D007D88  3C04A000   LUI A0, -24576
9D007D8C  00021100   SLL V0, V0, 4
9D007D90  00021880   SLL V1, V0, 2
9D007D94  00621823   SUBU V1, V1, V0
9D007D98  2482753C   ADDIU V0, A0, 30012
9D007D9C  00621021   ADDU V0, V1, V0
9D007DA0  8C430008   LW V1, 8(V0)
9D007DA4  93828014   LBU V0, -32748(GP)
9D007DA8  3C04A000   LUI A0, -24576
9D007DAC  2484753C   ADDIU A0, A0, 30012
9D007DB0  00021100   SLL V0, V0, 4
9D007DB4  00022880   SLL A1, V0, 2
9D007DB8  00A21023   SUBU V0, A1, V0
9D007DBC  00821021   ADDU V0, A0, V0
9D007DC0  8C420004   LW V0, 4(V0)
9D007DC4  00621023   SUBU V0, V1, V0
9D007DC8  00021027   NOR V0, ZERO, V0
9D007DCC  8FC30018   LW V1, 24(S8)
9D007DD0  00621021   ADDU V0, V1, V0
9D007DD4  AFC20018   SW V0, 24(S8)
4392:                    }
4393:                
4394:                    // Determine if resizing will lose any RX data
4395:                    if(MyTCBStub.rxTail < ptrHead)
9D007DD8  93828014   LBU V0, -32748(GP)
9D007DDC  3C04A000   LUI A0, -24576
9D007DE0  00021100   SLL V0, V0, 4
9D007DE4  00021880   SLL V1, V0, 2
9D007DE8  00621823   SUBU V1, V1, V0
9D007DEC  2482753C   ADDIU V0, A0, 30012
9D007DF0  00621021   ADDU V0, V1, V0
9D007DF4  8C430018   LW V1, 24(V0)
9D007DF8  8FC20018   LW V0, 24(S8)
9D007DFC  0062102B   SLTU V0, V1, V0
9D007E00  10400028   BEQ V0, ZERO, 0x9D007EA4
9D007E04  00000000   NOP
4396:                    {
4397:                        if(ptrTemp > MyTCBStub.rxTail)
9D007E08  93828014   LBU V0, -32748(GP)
9D007E0C  3C04A000   LUI A0, -24576
9D007E10  00021100   SLL V0, V0, 4
9D007E14  00021880   SLL V1, V0, 2
9D007E18  00621823   SUBU V1, V1, V0
9D007E1C  2482753C   ADDIU V0, A0, 30012
9D007E20  00621021   ADDU V0, V1, V0
9D007E24  8C430018   LW V1, 24(V0)
9D007E28  8FC20020   LW V0, 32(S8)
9D007E2C  0062102B   SLTU V0, V1, V0
9D007E30  10400061   BEQ V0, ZERO, 0x9D007FB8
9D007E34  00000000   NOP
4398:                        {
4399:                            if(vFlags & TCP_ADJUST_PRESERVE_RX)
9D007E38  93C2003C   LBU V0, 60(S8)
9D007E3C  30420004   ANDI V0, V0, 4
9D007E40  10400004   BEQ V0, ZERO, 0x9D007E54
9D007E44  00000000   NOP
4400:                                return false;
9D007E48  00001021   ADDU V0, ZERO, ZERO
9D007E4C  0B4020A2   J 0x9D008288
9D007E50  00000000   NOP
4401:                            else
4402:                            {
4403:                                MyTCBStub.rxTail = ptrTemp;
9D007E54  93828014   LBU V0, -32748(GP)
9D007E58  3C04A000   LUI A0, -24576
9D007E5C  00021100   SLL V0, V0, 4
9D007E60  00021880   SLL V1, V0, 2
9D007E64  00621823   SUBU V1, V1, V0
9D007E68  2482753C   ADDIU V0, A0, 30012
9D007E6C  00621021   ADDU V0, V1, V0
9D007E70  8FC30020   LW V1, 32(S8)
9D007E74  AC430018   SW V1, 24(V0)
4404:                                MyTCBStub.rxHead = ptrTemp;
9D007E78  93828014   LBU V0, -32748(GP)
9D007E7C  3C03A000   LUI V1, -24576
9D007E80  2463753C   ADDIU V1, V1, 30012
9D007E84  00021100   SLL V0, V0, 4
9D007E88  00022080   SLL A0, V0, 2
9D007E8C  00821023   SUBU V0, A0, V0
9D007E90  00621021   ADDU V0, V1, V0
9D007E94  8FC30020   LW V1, 32(S8)
9D007E98  AC430014   SW V1, 20(V0)
9D007E9C  0B401FEE   J 0x9D007FB8
9D007EA0  00000000   NOP
4405:                
4406:                                #if defined(STACK_USE_SSL)
4407:                                MyTCBStub.sslRxHead = ptrTemp;
4408:                                #endif
4409:                            }
4410:                        }
4411:                    }
4412:                    else if(MyTCBStub.rxTail > ptrHead)
9D007EA4  93828014   LBU V0, -32748(GP)
9D007EA8  3C04A000   LUI A0, -24576
9D007EAC  00021100   SLL V0, V0, 4
9D007EB0  00021880   SLL V1, V0, 2
9D007EB4  00621823   SUBU V1, V1, V0
9D007EB8  2482753C   ADDIU V0, A0, 30012
9D007EBC  00621021   ADDU V0, V1, V0
9D007EC0  8C430018   LW V1, 24(V0)
9D007EC4  8FC20018   LW V0, 24(S8)
9D007EC8  0043102B   SLTU V0, V0, V1
9D007ECC  10400028   BEQ V0, ZERO, 0x9D007F70
9D007ED0  00000000   NOP
4413:                    {
4414:                        if(ptrTemp > MyTCBStub.bufferRxStart)
9D007ED4  93828014   LBU V0, -32748(GP)
9D007ED8  3C03A000   LUI V1, -24576
9D007EDC  2463753C   ADDIU V1, V1, 30012
9D007EE0  00021100   SLL V0, V0, 4
9D007EE4  00022080   SLL A0, V0, 2
9D007EE8  00821023   SUBU V0, A0, V0
9D007EEC  00621021   ADDU V0, V1, V0
9D007EF0  8C430004   LW V1, 4(V0)
9D007EF4  8FC20020   LW V0, 32(S8)
9D007EF8  0062102B   SLTU V0, V1, V0
9D007EFC  1040002E   BEQ V0, ZERO, 0x9D007FB8
9D007F00  00000000   NOP
4415:                        {
4416:                            if(vFlags & TCP_ADJUST_PRESERVE_RX)
9D007F04  93C2003C   LBU V0, 60(S8)
9D007F08  30420004   ANDI V0, V0, 4
9D007F0C  10400004   BEQ V0, ZERO, 0x9D007F20
9D007F10  00000000   NOP
4417:                                return false;
9D007F14  00001021   ADDU V0, ZERO, ZERO
9D007F18  0B4020A2   J 0x9D008288
9D007F1C  00000000   NOP
4418:                            else
4419:                            {
4420:                                MyTCBStub.rxTail = ptrTemp;
9D007F20  93828014   LBU V0, -32748(GP)
9D007F24  3C04A000   LUI A0, -24576
9D007F28  00021100   SLL V0, V0, 4
9D007F2C  00021880   SLL V1, V0, 2
9D007F30  00621823   SUBU V1, V1, V0
9D007F34  2482753C   ADDIU V0, A0, 30012
9D007F38  00621021   ADDU V0, V1, V0
9D007F3C  8FC30020   LW V1, 32(S8)
9D007F40  AC430018   SW V1, 24(V0)
4421:                                MyTCBStub.rxHead = ptrTemp;
9D007F44  93828014   LBU V0, -32748(GP)
9D007F48  3C03A000   LUI V1, -24576
9D007F4C  2463753C   ADDIU V1, V1, 30012
9D007F50  00021100   SLL V0, V0, 4
9D007F54  00022080   SLL A0, V0, 2
9D007F58  00821023   SUBU V0, A0, V0
9D007F5C  00621021   ADDU V0, V1, V0
9D007F60  8FC30020   LW V1, 32(S8)
9D007F64  AC430014   SW V1, 20(V0)
9D007F68  0B401FEE   J 0x9D007FB8
9D007F6C  00000000   NOP
4422:                
4423:                                #if defined(STACK_USE_SSL)
4424:                                MyTCBStub.sslRxHead = ptrTemp;
4425:                                #endif
4426:                            }
4427:                        }
4428:                    }
4429:                    else
4430:                    {
4431:                        // No data to preserve, but we may need to move
4432:                        // the pointers to stay in the RX space
4433:                        MyTCBStub.rxTail = ptrTemp;
9D007F70  93828014   LBU V0, -32748(GP)
9D007F74  3C04A000   LUI A0, -24576
9D007F78  00021100   SLL V0, V0, 4
9D007F7C  00021880   SLL V1, V0, 2
9D007F80  00621823   SUBU V1, V1, V0
9D007F84  2482753C   ADDIU V0, A0, 30012
9D007F88  00621021   ADDU V0, V1, V0
9D007F8C  8FC30020   LW V1, 32(S8)
9D007F90  AC430018   SW V1, 24(V0)
4434:                        MyTCBStub.rxHead = ptrTemp;
9D007F94  93828014   LBU V0, -32748(GP)
9D007F98  3C03A000   LUI V1, -24576
9D007F9C  2463753C   ADDIU V1, V1, 30012
9D007FA0  00021100   SLL V0, V0, 4
9D007FA4  00022080   SLL A0, V0, 2
9D007FA8  00821023   SUBU V0, A0, V0
9D007FAC  00621021   ADDU V0, V1, V0
9D007FB0  8FC30020   LW V1, 32(S8)
9D007FB4  AC430014   SW V1, 20(V0)
4435:                
4436:                        #if defined(STACK_USE_SSL)
4437:                        MyTCBStub.sslRxHead = ptrTemp;
4438:                        #endif
4439:                    }
4440:                
4441:                    // If we need to preserve data that wrapped in the ring, we must copy
4442:                    if(ptrHead < MyTCBStub.rxTail && (vFlags & TCP_ADJUST_PRESERVE_RX))
9D007FB8  93828014   LBU V0, -32748(GP)
9D007FBC  3C04A000   LUI A0, -24576
9D007FC0  00021100   SLL V0, V0, 4
9D007FC4  00021880   SLL V1, V0, 2
9D007FC8  00621823   SUBU V1, V1, V0
9D007FCC  2482753C   ADDIU V0, A0, 30012
9D007FD0  00621021   ADDU V0, V1, V0
9D007FD4  8C430018   LW V1, 24(V0)
9D007FD8  8FC20018   LW V0, 24(S8)
9D007FDC  0043102B   SLTU V0, V0, V1
9D007FE0  10400061   BEQ V0, ZERO, 0x9D008168
9D007FE4  00000000   NOP
9D007FE8  93C2003C   LBU V0, 60(S8)
9D007FEC  30420004   ANDI V0, V0, 4
9D007FF0  1040005D   BEQ V0, ZERO, 0x9D008168
9D007FF4  00000000   NOP
4443:                    {
4444:                        TCPRAMCopy(ptrTemp, MyTCBStub.vMemoryMedium,
9D007FF8  93828014   LBU V0, -32748(GP)
9D007FFC  3C04A000   LUI A0, -24576
9D008000  00021100   SLL V0, V0, 4
9D008004  00021880   SLL V1, V0, 2
9D008008  00621823   SUBU V1, V1, V0
9D00800C  2482753C   ADDIU V0, A0, 30012
9D008010  00621021   ADDU V0, V1, V0
9D008014  9042002C   LBU V0, 44(V0)
9D008018  00402821   ADDU A1, V0, ZERO
9D00801C  93828014   LBU V0, -32748(GP)
9D008020  3C03A000   LUI V1, -24576
9D008024  2463753C   ADDIU V1, V1, 30012
9D008028  00021100   SLL V0, V0, 4
9D00802C  00022080   SLL A0, V0, 2
9D008030  00821023   SUBU V0, A0, V0
9D008034  00621021   ADDU V0, V1, V0
9D008038  8C460004   LW A2, 4(V0)
9D00805C  00401821   ADDU V1, V0, ZERO
9D008060  8FC20018   LW V0, 24(S8)
9D008064  3044FFFF   ANDI A0, V0, -1
9D008088  3042FFFF   ANDI V0, V0, -1
9D00808C  00821023   SUBU V0, A0, V0
9D008090  3042FFFF   ANDI V0, V0, -1
9D008094  AFA20010   SW V0, 16(SP)
9D008098  8FC40020   LW A0, 32(S8)
9D00809C  00603821   ADDU A3, V1, ZERO
9D0080A0  0F4020A8   JAL 0x9D0082A0
9D0080A4  00000000   NOP
4445:                            MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium,
9D00803C  93828014   LBU V0, -32748(GP)
9D008040  3C04A000   LUI A0, -24576
9D008044  00021100   SLL V0, V0, 4
9D008048  00021880   SLL V1, V0, 2
9D00804C  00621823   SUBU V1, V1, V0
9D008050  2482753C   ADDIU V0, A0, 30012
9D008054  00621021   ADDU V0, V1, V0
9D008058  9042002C   LBU V0, 44(V0)
4446:                            ptrHead - MyTCBStub.bufferRxStart);
9D008068  93828014   LBU V0, -32748(GP)
9D00806C  3C07A000   LUI A3, -24576
9D008070  24E7753C   ADDIU A3, A3, 30012
9D008074  00021100   SLL V0, V0, 4
9D008078  00024080   SLL T0, V0, 2
9D00807C  01021023   SUBU V0, T0, V0
9D008080  00E21021   ADDU V0, A3, V0
9D008084  8C420004   LW V0, 4(V0)
4447:                
4448:                        // Move the pointers if they were in front of the tail
4449:                        #if defined(STACK_USE_SSL)
4450:                        if(TCPIsSSL(hTCP) && MyTCBStub.sslRxHead < MyTCBStub.rxTail)
4451:                            MyTCBStub.sslRxHead -= MyTCBStub.bufferRxStart - ptrTemp;
4452:                        #endif
4453:                        if(MyTCBStub.rxHead < MyTCBStub.rxTail)
9D0080A8  93828014   LBU V0, -32748(GP)
9D0080AC  3C03A000   LUI V1, -24576
9D0080B0  2463753C   ADDIU V1, V1, 30012
9D0080B4  00021100   SLL V0, V0, 4
9D0080B8  00022080   SLL A0, V0, 2
9D0080BC  00821023   SUBU V0, A0, V0
9D0080C0  00621021   ADDU V0, V1, V0
9D0080C4  8C440014   LW A0, 20(V0)
9D0080C8  93828014   LBU V0, -32748(GP)
9D0080CC  3C05A000   LUI A1, -24576
9D0080D0  00021100   SLL V0, V0, 4
9D0080D4  00021880   SLL V1, V0, 2
9D0080D8  00621823   SUBU V1, V1, V0
9D0080DC  24A2753C   ADDIU V0, A1, 30012
9D0080E0  00621021   ADDU V0, V1, V0
9D0080E4  8C420018   LW V0, 24(V0)
9D0080E8  0082102B   SLTU V0, A0, V0
9D0080EC  1040001E   BEQ V0, ZERO, 0x9D008168
9D0080F0  00000000   NOP
4454:                            MyTCBStub.rxHead -= MyTCBStub.bufferRxStart - ptrTemp;
9D0080F4  93828014   LBU V0, -32748(GP)
9D0080F8  00402821   ADDU A1, V0, ZERO
9D0080FC  93828014   LBU V0, -32748(GP)
9D008100  3C03A000   LUI V1, -24576
9D008104  2463753C   ADDIU V1, V1, 30012
9D008108  00021100   SLL V0, V0, 4
9D00810C  00022080   SLL A0, V0, 2
9D008110  00821023   SUBU V0, A0, V0
9D008114  00621021   ADDU V0, V1, V0
9D008118  8C430014   LW V1, 20(V0)
9D00811C  93828014   LBU V0, -32748(GP)
9D008120  3C04A000   LUI A0, -24576
9D008124  2484753C   ADDIU A0, A0, 30012
9D008128  00021100   SLL V0, V0, 4
9D00812C  00023080   SLL A2, V0, 2
9D008130  00C21023   SUBU V0, A2, V0
9D008134  00821021   ADDU V0, A0, V0
9D008138  8C420004   LW V0, 4(V0)
9D00813C  8FC40020   LW A0, 32(S8)
9D008140  00821023   SUBU V0, A0, V0
9D008144  00621821   ADDU V1, V1, V0
9D008148  3C02A000   LUI V0, -24576
9D00814C  2444753C   ADDIU A0, V0, 30012
9D008150  00A01021   ADDU V0, A1, ZERO
9D008154  00021100   SLL V0, V0, 4
9D008158  00022880   SLL A1, V0, 2
9D00815C  00A21023   SUBU V0, A1, V0
9D008160  00821021   ADDU V0, A0, V0
9D008164  AC430014   SW V1, 20(V0)
4455:                    }
4456:                
4457:                    // Move the RX buffer pointer - it's the one that divides the two
4458:                    MyTCBStub.bufferRxStart = ptrTemp;
9D008168  93828014   LBU V0, -32748(GP)
9D00816C  3C03A000   LUI V1, -24576
9D008170  2463753C   ADDIU V1, V1, 30012
9D008174  00021100   SLL V0, V0, 4
9D008178  00022080   SLL A0, V0, 2
9D00817C  00821023   SUBU V0, A0, V0
9D008180  00621021   ADDU V0, V1, V0
9D008184  8FC30020   LW V1, 32(S8)
9D008188  AC430004   SW V1, 4(V0)
4459:                
4460:                    // Empty the TX buffer
4461:                    MyTCB.txUnackedTail = MyTCBStub.bufferTxStart;
9D00818C  93828014   LBU V0, -32748(GP)
9D008190  3C04A000   LUI A0, -24576
9D008194  00021100   SLL V0, V0, 4
9D008198  00021880   SLL V1, V0, 2
9D00819C  00621823   SUBU V1, V1, V0
9D0081A0  2482753C   ADDIU V0, A0, 30012
9D0081A4  00621021   ADDU V0, V1, V0
9D0081A8  8C430000   LW V1, 0(V0)
9D0081AC  3C02A000   LUI V0, -24576
9D0081B0  2442759C   ADDIU V0, V0, 30108
9D0081B4  AC43000C   SW V1, 12(V0)
4462:                    MyTCBStub.txTail = MyTCBStub.bufferTxStart;
9D0081B8  93828014   LBU V0, -32748(GP)
9D0081BC  00403021   ADDU A2, V0, ZERO
9D0081C0  93828014   LBU V0, -32748(GP)
9D0081C4  3C04A000   LUI A0, -24576
9D0081C8  00021100   SLL V0, V0, 4
9D0081CC  00021880   SLL V1, V0, 2
9D0081D0  00621823   SUBU V1, V1, V0
9D0081D4  2482753C   ADDIU V0, A0, 30012
9D0081D8  00621021   ADDU V0, V1, V0
9D0081DC  8C440000   LW A0, 0(V0)
9D0081E0  3C05A000   LUI A1, -24576
9D0081E4  00C01021   ADDU V0, A2, ZERO
9D0081E8  00021100   SLL V0, V0, 4
9D0081EC  00021880   SLL V1, V0, 2
9D0081F0  00621823   SUBU V1, V1, V0
9D0081F4  24A2753C   ADDIU V0, A1, 30012
9D0081F8  00621021   ADDU V0, V1, V0
9D0081FC  AC440010   SW A0, 16(V0)
4463:                    MyTCBStub.txHead = MyTCBStub.bufferTxStart;
9D008200  93828014   LBU V0, -32748(GP)
9D008204  00402821   ADDU A1, V0, ZERO
9D008208  93828014   LBU V0, -32748(GP)
9D00820C  3C04A000   LUI A0, -24576
9D008210  00021100   SLL V0, V0, 4
9D008214  00021880   SLL V1, V0, 2
9D008218  00621823   SUBU V1, V1, V0
9D00821C  2482753C   ADDIU V0, A0, 30012
9D008220  00621021   ADDU V0, V1, V0
9D008224  8C430000   LW V1, 0(V0)
9D008228  3C02A000   LUI V0, -24576
9D00822C  2444753C   ADDIU A0, V0, 30012
9D008230  00A01021   ADDU V0, A1, ZERO
9D008234  00021100   SLL V0, V0, 4
9D008238  00022880   SLL A1, V0, 2
9D00823C  00A21023   SUBU V0, A1, V0
9D008240  00821021   ADDU V0, A0, V0
9D008244  AC43000C   SW V1, 12(V0)
4464:                
4465:                    #if defined(STACK_USE_SSL)
4466:                    if(TCPIsSSL(hTCP))
4467:                        MyTCBStub.sslTxHead = MyTCBStub.txHead + 5;
4468:                    #endif
4469:                
4470:                    // Send a window update to notify remote node of change
4471:                    if(MyTCBStub.smState == TCP_ESTABLISHED)
9D008248  93828014   LBU V0, -32748(GP)
9D00824C  3C03A000   LUI V1, -24576
9D008250  2463753C   ADDIU V1, V1, 30012
9D008254  00021100   SLL V0, V0, 4
9D008258  00022080   SLL A0, V0, 2
9D00825C  00821023   SUBU V0, A0, V0
9D008260  00621021   ADDU V0, V1, V0
9D008264  8C430024   LW V1, 36(V0)
9D008268  24020007   ADDIU V0, ZERO, 7
9D00826C  14620005   BNE V1, V0, 0x9D008284
9D008270  00000000   NOP
4472:                        SendTCP(ACK, SENDTCP_RESET_TIMERS);
9D008274  24040010   ADDIU A0, ZERO, 16
9D008278  24050001   ADDIU A1, ZERO, 1
9D00827C  0F400F2C   JAL 0x9D003CB0
9D008280  00000000   NOP
4473:                
4474:                    return true;
9D008284  24020001   ADDIU V0, ZERO, 1
4475:                
4476:                }
9D008288  03C0E821   ADDU SP, S8, ZERO
9D00828C  8FBF002C   LW RA, 44(SP)
9D008290  8FBE0028   LW S8, 40(SP)
9D008294  27BD0030   ADDIU SP, SP, 48
9D008298  03E00008   JR RA
9D00829C  00000000   NOP
4477:                
4478:                /*****************************************************************************
4479:                  Function:
4480:                    static void TCPRAMCopy(PTR_BASE ptrDest, uint8_t vDestType, PTR_BASE ptrSource,
4481:                                            uint8_t vSourceType, uint16_t wLength)
4482:                
4483:                  Summary:
4484:                    Copies data to/from various memory mediums.
4485:                
4486:                  Description:
4487:                    This function copies data between memory mediums (PIC RAM, SPI
4488:                    RAM, and Ethernet buffer RAM).
4489:                
4490:                  Precondition:
4491:                    TCP is initialized.
4492:                
4493:                  Parameters:
4494:                    ptrDest     - Address to write to
4495:                    vDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
4496:                    ptrSource   - Address to copy from
4497:                    vSourceType - Source medium (TCP_PIC_RAM, TCP_ETH_RAM, or TCP_SPI_RAM)
4498:                    wLength     - Number of bytes to copy
4499:                
4500:                  Returns:
4501:                    None
4502:                
4503:                  Remarks:
4504:                    Copying to a destination region that overlaps with the source address
4505:                    is supported only if the destination start address is at a lower memory
4506:                    address (closer to 0x0000) than the source pointer.  However, if they do
4507:                    overlap there must be at least 4 bytes of non-overlap to ensure correct
4508:                    results due to hardware DMA requirements.
4509:                  ***************************************************************************/
4510:                static void TCPRAMCopy(PTR_BASE ptrDest, uint8_t vDestType, PTR_BASE ptrSource, uint8_t vSourceType, uint16_t wLength)
4511:                {
9D0082A0  27BDFFE0   ADDIU SP, SP, -32
9D0082A4  AFBF001C   SW RA, 28(SP)
9D0082A8  AFBE0018   SW S8, 24(SP)
9D0082AC  03A0F021   ADDU S8, SP, ZERO
9D0082B0  AFC40020   SW A0, 32(S8)
9D0082B4  00A02021   ADDU A0, A1, ZERO
9D0082B8  AFC60028   SW A2, 40(S8)
9D0082BC  00E01821   ADDU V1, A3, ZERO
9D0082C0  8FC20030   LW V0, 48(S8)
9D0082C4  A3C40024   SB A0, 36(S8)
9D0082C8  A3C3002C   SB V1, 44(S8)
9D0082CC  A7C20010   SH V0, 16(S8)
4512:                    #if defined(SPIRAM_CS_TRIS)
4513:                    uint8_t vBuffer[16];
4514:                    uint16_t w;
4515:                    #endif
4516:                
4517:                    switch(vSourceType)
9D0082D0  93C2002C   LBU V0, 44(S8)
9D0082D4  10400023   BEQ V0, ZERO, 0x9D008364
9D0082D8  00000000   NOP
9D0082DC  24030001   ADDIU V1, ZERO, 1
9D0082E0  1443004A   BNE V0, V1, 0x9D00840C
9D0082E4  00000000   NOP
4518:                    {
4519:                        case TCP_PIC_RAM:
4520:                            switch(vDestType)
9D0082E8  93C20024   LBU V0, 36(S8)
9D0082EC  1040000D   BEQ V0, ZERO, 0x9D008324
9D0082F0  00000000   NOP
9D0082F4  24030001   ADDIU V1, ZERO, 1
9D0082F8  14430040   BNE V0, V1, 0x9D0083FC
9D0082FC  00000000   NOP
4521:                            {
4522:                                case TCP_PIC_RAM:
4523:                                    memcpy((void*)(uint8_t*)ptrDest, (void*)(uint8_t*)ptrSource, wLength);
9D008300  8FC40020   LW A0, 32(S8)
9D008304  8FC30028   LW V1, 40(S8)
9D008308  97C20010   LHU V0, 16(S8)
9D00830C  00602821   ADDU A1, V1, ZERO
9D008310  00403021   ADDU A2, V0, ZERO
9D008314  0F406788   JAL 0x9D019E20
9D008318  00000000   NOP
4524:                                    break;
9D00831C  0B4020D7   J 0x9D00835C
9D008320  00000000   NOP
4525:                
4526:                                case TCP_ETH_RAM:
4527:                                    if(ptrDest!=(PTR_BASE)-1)
9D008324  8FC30020   LW V1, 32(S8)
9D008328  2402FFFF   ADDIU V0, ZERO, -1
9D00832C  10620004   BEQ V1, V0, 0x9D008340
9D008330  00000000   NOP
4528:                                        MACSetWritePtr(ptrDest);
9D008334  8FC40020   LW A0, 32(S8)
9D008338  0F40452C   JAL MACSetWritePtr
9D00833C  00000000   NOP
4529:                                    MACPutArray((uint8_t*)ptrSource, wLength);
9D008340  8FC30028   LW V1, 40(S8)
9D008344  97C20010   LHU V0, 16(S8)
9D008348  00602021   ADDU A0, V1, ZERO
9D00834C  00402821   ADDU A1, V0, ZERO
9D008350  0F4045BD   JAL MACPutArray
9D008354  00000000   NOP
4530:                                    break;
9D008358  00000000   NOP
4531:                
4532:                                #if defined(SPIRAM_CS_TRIS)
4533:                                case TCP_SPI_RAM:
4534:                                    SPIRAMPutArray(ptrDest, (uint8_t*)ptrSource, wLength);
4535:                                    break;
4536:                                #endif
4537:                            }
4538:                            break;
9D00835C  0B402103   J 0x9D00840C
9D008360  00000000   NOP
9D0083FC  00000000   NOP
9D008400  0B402103   J 0x9D00840C
9D008404  00000000   NOP
4539:                
4540:                        case TCP_ETH_RAM:
4541:                            switch(vDestType)
9D008364  93C20024   LBU V0, 36(S8)
9D008368  10400013   BEQ V0, ZERO, 0x9D0083B8
9D00836C  00000000   NOP
9D008370  24030001   ADDIU V1, ZERO, 1
9D008374  14430024   BNE V0, V1, 0x9D008408
9D008378  00000000   NOP
4542:                            {
4543:                                case TCP_PIC_RAM:
4544:                                    if(ptrSource!=(PTR_BASE)-1)
9D00837C  8FC30028   LW V1, 40(S8)
9D008380  2402FFFF   ADDIU V0, ZERO, -1
9D008384  10620004   BEQ V1, V0, 0x9D008398
9D008388  00000000   NOP
4545:                                        MACSetReadPtr(ptrSource);
9D00838C  8FC40028   LW A0, 40(S8)
9D008390  0F4046B6   JAL MACSetReadPtr
9D008394  00000000   NOP
4546:                                    MACGetArray((uint8_t*)ptrDest, wLength);
9D008398  8FC30020   LW V1, 32(S8)
9D00839C  97C20010   LHU V0, 16(S8)
9D0083A0  00602021   ADDU A0, V1, ZERO
9D0083A4  00402821   ADDU A1, V0, ZERO
9D0083A8  0F4046D1   JAL MACGetArray
9D0083AC  00000000   NOP
4547:                                    break;
9D0083B0  0B4020FC   J 0x9D0083F0
9D0083B4  00000000   NOP
4548:                
4549:                                case TCP_ETH_RAM:
4550:                                    MACMemCopyAsync(ptrDest, ptrSource, wLength);
9D0083B8  97C20010   LHU V0, 16(S8)
9D0083BC  8FC40020   LW A0, 32(S8)
9D0083C0  8FC50028   LW A1, 40(S8)
9D0083C4  00403021   ADDU A2, V0, ZERO
9D0083C8  0F404701   JAL MACMemCopyAsync
9D0083CC  00000000   NOP
4551:                                    while(!MACIsMemCopyDone());
9D0083D0  00000000   NOP
9D0083D4  0F40472A   JAL MACIsMemCopyDone
9D0083D8  00000000   NOP
9D0083DC  38420001   XORI V0, V0, 1
9D0083E0  304200FF   ANDI V0, V0, 255
9D0083E4  1440FFFB   BNE V0, ZERO, 0x9D0083D4
9D0083E8  00000000   NOP
4552:                                    break;
9D0083EC  00000000   NOP
4553:                
4554:                                #if defined(SPIRAM_CS_TRIS)
4555:                                case TCP_SPI_RAM:
4556:                                    if(ptrSource!=(PTR_BASE)-1)
4557:                                        MACSetReadPtr(ptrSource);
4558:                                    w = sizeof(vBuffer);
4559:                                    while(wLength)
4560:                                    {
4561:                                        if(w > wLength)
4562:                                            w = wLength;
4563:                
4564:                                        // Read and write a chunk
4565:                                        MACGetArray(vBuffer, w);
4566:                                        SPIRAMPutArray(ptrDest, vBuffer, w);
4567:                                        ptrDest += w;
4568:                                        wLength -= w;
4569:                                    }
4570:                                    break;
4571:                                #endif
4572:                            }
4573:                            break;
9D0083F0  00000000   NOP
9D0083F4  0B402103   J 0x9D00840C
9D0083F8  00000000   NOP
9D008408  00000000   NOP
4574:                
4575:                        #if defined(SPIRAM_CS_TRIS)
4576:                        case TCP_SPI_RAM:
4577:                            switch(vDestType)
4578:                            {
4579:                                case TCP_PIC_RAM:
4580:                                    SPIRAMGetArray(ptrSource, (uint8_t*)ptrDest, wLength);
4581:                                    break;
4582:                
4583:                                case TCP_ETH_RAM:
4584:                                    if(ptrDest!=(PTR_BASE)-1)
4585:                                        MACSetWritePtr(ptrDest);
4586:                                    w = sizeof(vBuffer);
4587:                                    while(wLength)
4588:                                    {
4589:                                        if(w > wLength)
4590:                                            w = wLength;
4591:                
4592:                                        // Read and write a chunk
4593:                                        SPIRAMGetArray(ptrSource, vBuffer, w);
4594:                                        ptrSource += w;
4595:                                        MACPutArray(vBuffer, w);
4596:                                        wLength -= w;
4597:                                    }
4598:                                    break;
4599:                
4600:                                case TCP_SPI_RAM:
4601:                                    // Copy all of the data over in chunks
4602:                                    w = sizeof(vBuffer);
4603:                                    while(wLength)
4604:                                    {
4605:                                        if(w > wLength)
4606:                                            w = wLength;
4607:                
4608:                                        SPIRAMGetArray(ptrSource, vBuffer, w);
4609:                                        SPIRAMPutArray(ptrDest, vBuffer, w);
4610:                                        ptrSource += w;
4611:                                        ptrDest += w;
4612:                                        wLength -= w;
4613:                                    }
4614:                                    break;
4615:                            }
4616:                            break;
4617:                        #endif
4618:                    }
4619:                }
9D00840C  03C0E821   ADDU SP, S8, ZERO
9D008410  8FBF001C   LW RA, 28(SP)
9D008414  8FBE0018   LW S8, 24(SP)
9D008418  27BD0020   ADDIU SP, SP, 32
9D00841C  03E00008   JR RA
9D008420  00000000   NOP
4620:                
4621:                /*****************************************************************************
4622:                  Function:
4623:                    static void TCPRAMCopyROM(PTR_BASE wDest, uint8_t wDestType, ROM uint8_t* wSource,
4624:                                                uint16_t wLength)
4625:                
4626:                  Summary:
4627:                    Copies data to/from various memory mediums.
4628:                
4629:                  Description:
4630:                    This function copies data between memory mediums (PIC RAM, SPI
4631:                    RAM, and Ethernet buffer RAM).  This function is to be used when
4632:                    copying from ROM.
4633:                
4634:                  Precondition:
4635:                    TCP is initialized.
4636:                
4637:                  Parameters:
4638:                    wDest       - Address to write to
4639:                    wDestType   - Destination meidum (TCP_PIC_RAM, TCP_ETH_RAM, TCP_SPI_RAM)
4640:                    wSource     - Address to copy from
4641:                    wLength     - Number of bytes to copy
4642:                
4643:                  Returns:
4644:                    None
4645:                
4646:                  Remarks:
4647:                    Copying to a destination region that overlaps with the source address
4648:                    is supported only if the destination start address is at a lower memory
4649:                    address (closer to 0x0000) than the source pointer.
4650:                
4651:                    This function is aliased to TCPRAMCopy on non-PIC18 platforms.
4652:                  ***************************************************************************/
4653:                #if defined(__XC8)
4654:                static void TCPRAMCopyROM(PTR_BASE wDest, uint8_t wDestType, ROM uint8_t* wSource, uint16_t wLength)
4655:                {
4656:                    uint8_t vBuffer[16];
4657:                    uint16_t w;
4658:                
4659:                    switch(wDestType)
4660:                    {
4661:                        case TCP_PIC_RAM:
4662:                            memcpypgm2ram((void*)(uint8_t*)wDest, (ROM void*)wSource, wLength);
4663:                            break;
4664:                
4665:                        case TCP_ETH_RAM:
4666:                            if(wDest!=(PTR_BASE)-1)
4667:                                MACSetWritePtr(wDest);
4668:                            w = sizeof(vBuffer);
4669:                            while(wLength)
4670:                            {
4671:                                if(w > wLength)
4672:                                    w = wLength;
4673:                
4674:                                // Read and write a chunk
4675:                                memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
4676:                                MACPutArray(vBuffer, w);
4677:                                wSource += w;
4678:                                wLength -= w;
4679:                            }
4680:                            break;
4681:                
4682:                        #if defined(SPIRAM_CS_TRIS)
4683:                        case TCP_SPI_RAM:
4684:                            w = sizeof(vBuffer);
4685:                            while(wLength)
4686:                            {
4687:                                if(w > wLength)
4688:                                    w = wLength;
4689:                
4690:                                // Read and write a chunk
4691:                                memcpypgm2ram(vBuffer, (ROM void*)wSource, w);
4692:                                SPIRAMPutArray(wDest, vBuffer, w);
4693:                                wDest += w;
4694:                                wSource += w;
4695:                                wLength -= w;
4696:                            }
4697:                            break;
4698:                        #endif
4699:                    }
4700:                }
4701:                #endif
4702:                
4703:                /****************************************************************************
4704:                  Section:
4705:                    SSL Functions
4706:                  ***************************************************************************/
4707:                
4708:                /*****************************************************************************
4709:                  Function:
4710:                    bool TCPStartSSLClient(TCP_SOCKET hTCP, uint8_t* host)
4711:                
4712:                  Summary:
4713:                    Begins an SSL client session.
4714:                
4715:                  Description:
4716:                    This function escalates the current connection to an SSL secured
4717:                    connection by initiating an SSL client handshake.
4718:                
4719:                  Precondition:
4720:                    TCP is initialized and hTCP is already connected.
4721:                
4722:                  Parameters:
4723:                    hTCP        - TCP connection to secure
4724:                    host        - Expected host name on certificate (currently ignored)
4725:                
4726:                  Return Values:
4727:                    true        - an SSL connection was initiated
4728:                    false       - Insufficient SSL resources (stubs) were available
4729:                
4730:                  Remarks:
4731:                    The host parameter is currently ignored and is not validated.
4732:                  ***************************************************************************/
4733:                #if defined(STACK_USE_SSL_CLIENT)
4734:                bool TCPStartSSLClient(TCP_SOCKET hTCP, uint8_t* host)
4735:                {
4736:                    uint8_t i;
4737:                
4738:                    if(hTCP >= TCP_SOCKET_COUNT)
4739:                    {
4740:                        return false;
4741:                    }
4742:                
4743:                    SyncTCBStub(hTCP);
4744:                
4745:                    // Make sure SSL is not established already
4746:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4747:                        return false;
4748:                
4749:                    // Try to start the session
4750:                    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
4751:                
4752:                    // Make sure a session stub was obtained
4753:                    if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4754:                        return false;
4755:                
4756:                    // Mark connection as handshaking and return
4757:                    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
4758:                    MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4759:                    MyTCBStub.sslTxHead = MyTCBStub.txHead;
4760:                    MyTCBStub.Flags.bSSLHandshaking = 1;
4761:                    for(i = 0; i < 5u; i++)
4762:                    {// Skip first 5 bytes in TX for the record header
4763:                        if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4764:                            MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4765:                    }
4766:                    return true;
4767:                }
4768:                #endif // SSL Client
4769:                
4770:                /*****************************************************************************
4771:                  Function:
4772:                    bool TCPStartSSLClientEx(TCP_SOCKET hTCP, uint8_t* host, uint8_t * buffer, uint8_t suppDataType)
4773:                
4774:                  Summary:
4775:                    Begins an SSL client session.
4776:                
4777:                  Description:
4778:                    This function escalates the current connection to an SSL secured
4779:                    connection by initiating an SSL client handshake.
4780:                
4781:                  Precondition:
4782:                    TCP is initialized and hTCP is already connected.
4783:                
4784:                  Parameters:
4785:                    hTCP            - TCP connection to secure
4786:                    host            - Expected host name on certificate (currently ignored)
4787:                    buffer          - Buffer for supplementary data return
4788:                    suppDataType    - Type of supplementary data to copy
4789:                
4790:                  Return Values:
4791:                    true        - an SSL connection was initiated
4792:                    false       - Insufficient SSL resources (stubs) were available
4793:                
4794:                  Remarks:
4795:                    The host parameter is currently ignored and is not validated.
4796:                  ***************************************************************************/
4797:                #if defined(STACK_USE_SSL_CLIENT)
4798:                bool TCPStartSSLClientEx(TCP_SOCKET hTCP, uint8_t* host, void * buffer, uint8_t suppDataType)
4799:                {
4800:                    uint8_t i;
4801:                
4802:                    if(hTCP >= TCP_SOCKET_COUNT)
4803:                    {
4804:                        return false;
4805:                    }
4806:                
4807:                    SyncTCBStub(hTCP);
4808:                
4809:                    // Make sure SSL is not established already
4810:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4811:                        return false;
4812:                
4813:                    // Try to start the session
4814:                    MyTCBStub.sslStubID = SSLStartSession(hTCP, buffer, suppDataType);
4815:                
4816:                    // Make sure a session stub was obtained
4817:                    if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4818:                        return false;
4819:                
4820:                    // Mark connection as handshaking and return
4821:                    MyTCBStub.sslReqMessage = SSL_CLIENT_HELLO;
4822:                    MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4823:                    MyTCBStub.sslTxHead = MyTCBStub.txHead;
4824:                    MyTCBStub.Flags.bSSLHandshaking = 1;
4825:                    for(i = 0; i < 5u; i++)
4826:                    {// Skip first 5 bytes in TX for the record header
4827:                        if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4828:                            MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4829:                    }
4830:                    return true;
4831:                }
4832:                #endif // SSL Client
4833:                
4834:                /*****************************************************************************
4835:                  Function:
4836:                    bool TCPStartSSLServer(TCP_SOCKET hTCP)
4837:                
4838:                  Summary:
4839:                    Begins an SSL server session.
4840:                
4841:                  Description:
4842:                    This function sets up an SSL server session when a new connection is
4843:                    established on an SSL port.
4844:                
4845:                  Precondition:
4846:                    TCP is initialized and hTCP is already connected.
4847:                
4848:                  Parameters:
4849:                    hTCP        - TCP connection to secure
4850:                
4851:                  Return Values:
4852:                    true        - an SSL connection was initiated
4853:                    false       - Insufficient SSL resources (stubs) were available
4854:                  ***************************************************************************/
4855:                #if defined(STACK_USE_SSL_SERVER)
4856:                bool TCPStartSSLServer(TCP_SOCKET hTCP)
4857:                {
4858:                    uint8_t i;
4859:                
4860:                    if(hTCP >= TCP_SOCKET_COUNT)
4861:                    {
4862:                        return false;
4863:                    }
4864:                
4865:                    SyncTCBStub(hTCP);
4866:                    SyncTCB();
4867:                
4868:                    // Make sure SSL is not established already
4869:                    if(MyTCBStub.sslStubID != SSL_INVALID_ID)
4870:                        return true;
4871:                
4872:                    // Try to start the session
4873:                    MyTCBStub.sslStubID = SSLStartSession(hTCP, NULL, 0);
4874:                
4875:                    // Make sure a session stub was obtained
4876:                    if(MyTCBStub.sslStubID == SSL_INVALID_ID)
4877:                        return false;
4878:                
4879:                    // Swap the localPort and localSSLPort
4880:                    MyTCBStub.remoteHash.Val = MyTCB.localPort.Val;
4881:                    MyTCB.localPort.Val = MyTCB.localSSLPort.Val;
4882:                    MyTCB.localSSLPort.Val = MyTCBStub.remoteHash.Val;
4883:                
4884:                    // Mark connection as handshaking and return
4885:                    MyTCBStub.sslReqMessage = SSL_NO_MESSAGE;
4886:                    MyTCBStub.sslRxHead = MyTCBStub.rxHead;
4887:                    MyTCBStub.sslTxHead = MyTCBStub.txHead;
4888:                    MyTCBStub.Flags.bSSLHandshaking = 1;
4889:                    for(i = 0; i < 5u; i++)
4890:                    {// Skip first 5 bytes in TX for the record header
4891:                        if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
4892:                            MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
4893:                    }
4894:                    return true;
4895:                }
4896:                #endif // SSL Client
4897:                
4898:                /*****************************************************************************
4899:                  Function:
4900:                    bool TCPAddSSLListener(TCP_SOCKET hTCP, uint16_t port)
4901:                
4902:                  Summary:
4903:                    Listens for SSL connection on a specific port.
4904:                
4905:                  Description:
4906:                    This function adds an additional listening port to a TCP connection.
4907:                    Connections made on this alternate port will be secured via SSL.
4908:                
4909:                  Precondition:
4910:                    TCP is initialized and hTCP is listening.
4911:                
4912:                  Parameters:
4913:                    hTCP        - TCP connection to secure
4914:                    port        - SSL port to listen on
4915:                
4916:                  Return Values:
4917:                    true        - SSL port was added.
4918:                    false       - The socket was not a listening socket.
4919:                  ***************************************************************************/
4920:                #if defined(STACK_USE_SSL_SERVER)
4921:                bool TCPAddSSLListener(TCP_SOCKET hTCP, uint16_t port)
4922:                {
4923:                    if(hTCP >= TCP_SOCKET_COUNT)
4924:                    {
4925:                        return false;
4926:                    }
4927:                
4928:                    SyncTCBStub(hTCP);
4929:                
4930:                    if(MyTCBStub.smState != TCP_LISTEN)
4931:                        return false;
4932:                
4933:                    SyncTCB();
4934:                
4935:                    MyTCB.localSSLPort.Val = port;
4936:                    MyTCBStub.sslTxHead = port;
4937:                
4938:                    return true;
4939:                }
4940:                #endif // SSL Server
4941:                
4942:                /*****************************************************************************
4943:                  Function:
4944:                    bool TCPRequestSSLMessage(TCP_SOCKET hTCP, uint8_t msg)
4945:                
4946:                  Summary:
4947:                    Requests an SSL message to be transmitted.
4948:                
4949:                  Description:
4950:                    This function is called to request that a specific SSL message be
4951:                    transmitted.  This message should only be called by the SSL module.
4952:                
4953:                  Precondition:
4954:                    TCP is initialized.
4955:                
4956:                  Parameters:
4957:                    hTCP        - TCP connection to use
4958:                    msg         - One of the SSL_MESSAGE types to transmit.
4959:                
4960:                  Return Values:
4961:                    true        - The message was requested.
4962:                    false       - Another message is already pending transmission.
4963:                  ***************************************************************************/
4964:                #if defined(STACK_USE_SSL)
4965:                bool TCPRequestSSLMessage(TCP_SOCKET hTCP, uint8_t msg)
4966:                {
4967:                    if(hTCP >= TCP_SOCKET_COUNT)
4968:                    {
4969:                        return false;
4970:                    }
4971:                
4972:                    SyncTCBStub(hTCP);
4973:                
4974:                    if(msg == SSL_NO_MESSAGE || MyTCBStub.sslReqMessage == SSL_NO_MESSAGE)
4975:                    {
4976:                        MyTCBStub.sslReqMessage = msg;
4977:                        return true;
4978:                    }
4979:                
4980:                    return false;
4981:                }
4982:                #endif // SSL
4983:                
4984:                /*****************************************************************************
4985:                  Function:
4986:                    bool TCPSSLIsHandshaking(TCP_SOCKET hTCP)
4987:                
4988:                  Summary:
4989:                    Determines if an SSL session is still handshaking.
4990:                
4991:                  Description:
4992:                    Call this function after calling TCPStartSSLClient until false is
4993:                    returned.  Then your application may continue with its normal data
4994:                    transfer (which is now secured).
4995:                
4996:                  Precondition:
4997:                    TCP is initialized and hTCP is connected.
4998:                
4999:                  Parameters:
5000:                    hTCP        - TCP connection to check
5001:                
5002:                  Return Values:
5003:                    true        - SSL handshake is still progressing
5004:                    false       - SSL handshake has completed
5005:                  ***************************************************************************/
5006:                #if defined(STACK_USE_SSL)
5007:                bool TCPSSLIsHandshaking(TCP_SOCKET hTCP)
5008:                {
5009:                    if(hTCP >= TCP_SOCKET_COUNT)
5010:                    {
5011:                        return false;
5012:                    }
5013:                
5014:                    SyncTCBStub(hTCP);
5015:                    return MyTCBStub.Flags.bSSLHandshaking;
5016:                }
5017:                #endif // SSL
5018:                
5019:                /*****************************************************************************
5020:                  Function:
5021:                    bool TCPIsSSL(TCP_SOCKET hTCP)
5022:                
5023:                  Summary:
5024:                    Determines if a TCP connection is secured with SSL.
5025:                
5026:                  Description:
5027:                    Call this function to determine whether or not a TCP connection is
5028:                    secured with SSL.
5029:                
5030:                  Precondition:
5031:                    TCP is initialized and hTCP is connected.
5032:                
5033:                  Parameters:
5034:                    hTCP        - TCP connection to check
5035:                
5036:                  Return Values:
5037:                    true        - Connection is secured via SSL
5038:                    false       - Connection is not secured
5039:                  ***************************************************************************/
5040:                #if defined(STACK_USE_SSL)
5041:                bool TCPIsSSL(TCP_SOCKET hTCP)
5042:                {
5043:                    if(hTCP >= TCP_SOCKET_COUNT)
5044:                    {
5045:                        return false;
5046:                    }
5047:                
5048:                    SyncTCBStub(hTCP);
5049:                
5050:                    if(MyTCBStub.sslStubID == SSL_INVALID_ID)
5051:                        return false;
5052:                
5053:                    return true;
5054:                }
5055:                #endif // SSL
5056:                
5057:                /*****************************************************************************
5058:                  Function:
5059:                    void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
5060:                
5061:                  Summary:
5062:                    Clears the SSL handshake flag.
5063:                
5064:                  Description:
5065:                    This function clears the flag indicating that an SSL handshake is
5066:                    complete.
5067:                
5068:                  Precondition:
5069:                    TCP is initialized and hTCP is connected.
5070:                
5071:                  Parameters:
5072:                    hTCP        - TCP connection to set
5073:                
5074:                  Returns:
5075:                    None
5076:                
5077:                  Remarks:
5078:                    This function should never be called by an application.  It is used
5079:                    only by the SSL module itself.
5080:                  ***************************************************************************/
5081:                #if defined(STACK_USE_SSL)
5082:                void TCPSSLHandshakeComplete(TCP_SOCKET hTCP)
5083:                {
5084:                    if(hTCP >= TCP_SOCKET_COUNT)
5085:                    {
5086:                        return;
5087:                    }
5088:                
5089:                    SyncTCBStub(hTCP);
5090:                    MyTCBStub.Flags.bSSLHandshaking = 0;
5091:                }
5092:                #endif // SSL
5093:                
5094:                /*****************************************************************************
5095:                  Function:
5096:                    void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, uint16_t len)
5097:                
5098:                  Summary:
5099:                    Decrypts and MACs data arriving via SSL.
5100:                
5101:                  Description:
5102:                    This function decrypts data in the TCP buffer and calculates the MAC over
5103:                    the data.  All data is left in the exact same location in the TCP buffer.
5104:                    It is called to help process incoming SSL records.
5105:                
5106:                  Precondition:
5107:                    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
5108:                
5109:                  Parameters:
5110:                    hTCP        - TCP connection to decrypt in
5111:                    ctx         - ARCFOUR encryption context to use
5112:                    len         - Number of bytes to crypt
5113:                    inPlace     - true to write back in place, false to write at end of
5114:                                    currently visible data.
5115:                
5116:                  Returns:
5117:                    None
5118:                
5119:                  Remarks:
5120:                    This function should never be called by an application.  It is used
5121:                    only by the SSL module itself.
5122:                  ***************************************************************************/
5123:                #if defined(STACK_USE_SSL)
5124:                void TCPSSLDecryptMAC(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, uint16_t len)
5125:                {
5126:                    PTR_BASE wSrc, wDest, wBlockLen, wTemp;
5127:                    uint8_t buffer[32];
5128:                
5129:                    if(hTCP >= TCP_SOCKET_COUNT)
5130:                    {
5131:                        return;
5132:                    }
5133:                
5134:                    // Set up the pointers
5135:                    SyncTCBStub(hTCP);
5136:                    wSrc = MyTCBStub.rxTail;
5137:                    wDest = wSrc;
5138:                
5139:                    // Handle 32 bytes at a time
5140:                    while(len)
5141:                    {
5142:                        // Determine how many bytes we can read
5143:                        wBlockLen = sizeof(buffer);
5144:                        if(wBlockLen > len) // Don't do more than we should
5145:                            wBlockLen = len;
5146:                
5147:                        // Read those bytes to a buffer
5148:                        if(wSrc + wBlockLen > MyTCBStub.bufferEnd)
5149:                        {// Two part read
5150:                            wTemp = MyTCBStub.bufferEnd - wSrc + 1;
5151:                            TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wTemp);
5152:                            TCPRAMCopy((PTR_BASE)buffer+wTemp, TCP_PIC_RAM, MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, wBlockLen - wTemp);
5153:                            wSrc = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
5154:                        }
5155:                        else
5156:                        {
5157:                            TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, wSrc, MyTCBStub.vMemoryMedium, wBlockLen);
5158:                            wSrc += wBlockLen;
5159:                        }
5160:                
5161:                        // Decrypt and hash
5162:                        ARCFOURCrypt(ctx, buffer, wBlockLen);
5163:                        SSLMACAdd(buffer, wBlockLen);
5164:                
5165:                        // Write decrypted bytes back
5166:                        if(wDest + wBlockLen > MyTCBStub.bufferEnd)
5167:                        {// Two part write
5168:                            wTemp = MyTCBStub.bufferEnd - wDest + 1;
5169:                            TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wTemp);
5170:                            TCPRAMCopy(MyTCBStub.bufferRxStart, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer+wTemp, TCP_PIC_RAM, wBlockLen - wTemp);
5171:                            wDest = MyTCBStub.bufferRxStart + wBlockLen - wTemp;
5172:                        }
5173:                        else
5174:                        {
5175:                            TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, wBlockLen);
5176:                            wDest += wBlockLen;
5177:                        }
5178:                
5179:                        // Update the length remaining
5180:                        len -= wBlockLen;
5181:                    }
5182:                }
5183:                #endif // SSL
5184:                
5185:                /*****************************************************************************
5186:                  Function:
5187:                    void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx,
5188:                                                    uint8_t* MACSecret, uint16_t len)
5189:                
5190:                  Summary:
5191:                    Encrypts and MACs data in place in the TCP TX buffer.
5192:                
5193:                  Description:
5194:                    This function encrypts data in the TCP buffer while calcuating a MAC.
5195:                    When encryption is finished, the MAC is appended to the buffer and
5196:                    the record will be ready to transmit.
5197:                
5198:                  Precondition:
5199:                    TCP is initialized, hTCP is connected, and ctx's Sbox is loaded.
5200:                
5201:                  Parameters:
5202:                    hTCP        - TCP connection to encrypt in
5203:                    ctx         - ARCFOUR encryption context to use
5204:                    MACSecret   - MAC encryption secret to use
5205:                    len         - Number of bytes to crypt
5206:                
5207:                  Returns:
5208:                    None
5209:                
5210:                  Remarks:
5211:                    This function should never be called by an application.  It is used
5212:                    only by the SSL module itself.
5213:                  ***************************************************************************/
5214:                #if defined(STACK_USE_SSL)
5215:                void TCPSSLInPlaceMACEncrypt(TCP_SOCKET hTCP, ARCFOUR_CTX* ctx, uint8_t* MACSecret, uint16_t len)
5216:                {
5217:                    PTR_BASE pos;
5218:                    uint16_t blockLen;
5219:                    uint8_t buffer[32];
5220:                
5221:                    if(hTCP >= TCP_SOCKET_COUNT)
5222:                    {
5223:                        return;
5224:                    }
5225:                
5226:                    // Set up the pointers
5227:                    SyncTCBStub(hTCP);
5228:                    pos = MyTCBStub.txHead;
5229:                    for(blockLen = 0; blockLen < 5u; blockLen++)
5230:                    {// Skips first 5 bytes for the header
5231:                        if(++pos >= MyTCBStub.bufferRxStart)
5232:                            pos = MyTCBStub.bufferTxStart;
5233:                    }
5234:                
5235:                    // Handle 32 bytes at a time
5236:                    while(len)
5237:                    {
5238:                        // Determine how many bytes we can read
5239:                        blockLen = sizeof(buffer);
5240:                        if(blockLen > len) // Don't do more than we should
5241:                            blockLen = len;
5242:                        if(blockLen > MyTCBStub.bufferRxStart - pos) // Don't pass the end
5243:                            blockLen = MyTCBStub.bufferRxStart - pos;
5244:                
5245:                        // Read those bytes to a buffer
5246:                        TCPRAMCopy((PTR_BASE)buffer, TCP_PIC_RAM, pos, MyTCBStub.vMemoryMedium, blockLen);
5247:                
5248:                        // Hash and encrypt
5249:                        SSLMACAdd(buffer, blockLen);
5250:                        ARCFOURCrypt(ctx, buffer, blockLen);
5251:                
5252:                        // Put them back
5253:                        TCPRAMCopy(pos, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
5254:                
5255:                        // Update the pointers
5256:                        pos += blockLen;
5257:                        len -= blockLen;
5258:                        if(pos >= MyTCBStub.bufferRxStart)
5259:                            pos = MyTCBStub.bufferTxStart;
5260:                    }
5261:                
5262:                    // Calculate and add the MAC
5263:                    SSLMACCalc(MACSecret, buffer);
5264:                    ARCFOURCrypt(ctx, buffer, 16);
5265:                
5266:                    // Write the MAC to the TX FIFO
5267:                    // Can't use TCPPutArray here because TCPIsPutReady() saves 16 bytes for the MAC
5268:                    // TCPPut* functions use this to prevent writing too much data.  Therefore, the
5269:                    // functionality is duplicated here.
5270:                
5271:                    len = 16;
5272:                    blockLen = 0;
5273:                    // See if we need a two part put
5274:                    if(MyTCBStub.sslTxHead + len >= MyTCBStub.bufferRxStart)
5275:                    {
5276:                        blockLen = MyTCBStub.bufferRxStart-MyTCBStub.sslTxHead;
5277:                        TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)buffer, TCP_PIC_RAM, blockLen);
5278:                        len -= blockLen;
5279:                        MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
5280:                    }
5281:                
5282:                    TCPRAMCopy(MyTCBStub.sslTxHead, MyTCBStub.vMemoryMedium, (PTR_BASE)&buffer[blockLen], TCP_PIC_RAM, len);
5283:                    MyTCBStub.sslTxHead += len;
5284:                
5285:                }
5286:                #endif // SSL
5287:                
5288:                /*****************************************************************************
5289:                  Function:
5290:                    void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, uint8_t* hdr, bool recDone)
5291:                
5292:                  Summary:
5293:                    Writes an SSL record header and sends an SSL record.
5294:                
5295:                  Description:
5296:                    This function writes an SSL record header to the pending TCP SSL data,
5297:                    then indicates that the data is ready to be sent by moving the txHead
5298:                    pointer.
5299:                
5300:                    If the record is complete, set recDone to true.  The sslTxHead
5301:                    pointer will be moved forward 5 bytes to leave space for a future
5302:                    record header.  If the record is only partially sent, use false and
5303:                    to leave the pointer where it is so that more data can be added
5304:                    to the record.  Partial records can only be used for the
5305:                    SERVER_CERTIFICATE handshake message.
5306:                
5307:                  Precondition:
5308:                    TCP is initialized, and hTCP is connected with an active SSL session.
5309:                
5310:                  Parameters:
5311:                    hTCP        - TCP connection to write the header and transmit with
5312:                    hdr         - Record header (5 bytes) to send or NULL to just
5313:                                  move the pointerctx
5314:                    recDone     - true if the record is done, false otherwise
5315:                
5316:                  Returns:
5317:                    None
5318:                
5319:                  Remarks:
5320:                    This function should never be called by an application.  It is used
5321:                    only by the SSL module itself.
5322:                  ***************************************************************************/
5323:                #if defined(STACK_USE_SSL)
5324:                void TCPSSLPutRecordHeader(TCP_SOCKET hTCP, uint8_t* hdr, bool recDone)
5325:                {
5326:                    uint8_t i;
5327:                
5328:                    if(hTCP >= TCP_SOCKET_COUNT)
5329:                    {
5330:                        return;
5331:                    }
5332:                
5333:                    // Set up the pointers
5334:                    SyncTCBStub(hTCP);
5335:                
5336:                    // Write the header if needed
5337:                    if(hdr)
5338:                    {// This is a new record, so insert the header
5339:                        for(i = 0; i < 5u; i++)
5340:                        {
5341:                            TCPRAMCopy(MyTCBStub.txHead, MyTCBStub.vMemoryMedium, (PTR_BASE)hdr+i, TCP_PIC_RAM, sizeof(uint8_t));
5342:                            if(++MyTCBStub.txHead >= MyTCBStub.bufferRxStart)
5343:                                MyTCBStub.txHead = MyTCBStub.bufferTxStart;
5344:                        }
5345:                    }
5346:                
5347:                    // Move the txHead pointer to indicate what data is ready
5348:                    // Also, flush just the header, then all the data.  This shotguns two
5349:                    // packets down the line, therefore causing immediate ACKs by the
5350:                    // remote node.  Reconnect handshakes are as much as 60% faster now.
5351:                    TCPFlush(hTCP);
5352:                    MyTCBStub.txHead = MyTCBStub.sslTxHead;
5353:                    TCPFlush(hTCP);
5354:                
5355:                    // If this record is done, move the sslTxHead forward
5356:                    // to accomodate the next record header
5357:                    if(recDone)
5358:                    {
5359:                        for(i = 0; i < 5u; i++)
5360:                        {// Skip first 5 bytes in TX for the record header
5361:                            if(++MyTCBStub.sslTxHead >= MyTCBStub.bufferRxStart)
5362:                                MyTCBStub.sslTxHead = MyTCBStub.bufferTxStart;
5363:                        }
5364:                    }
5365:                }
5366:                #endif // SSL
5367:                
5368:                /*****************************************************************************
5369:                  Function:
5370:                    uint16_t TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
5371:                
5372:                  Summary:
5373:                    Determines how many bytes are pending for a future SSL record.
5374:                
5375:                  Description:
5376:                    This function determines how many bytes are pending for a future SSL
5377:                    record.
5378:                
5379:                  Precondition:
5380:                    TCP is initialized, and hTCP is connected with an active SSL connection.
5381:                
5382:                  Parameters:
5383:                    hTCP        - TCP connection to check
5384:                
5385:                  Returns:
5386:                     Pending TX size
5387:                  ***************************************************************************/
5388:                #if defined(STACK_USE_SSL)
5389:                uint16_t TCPSSLGetPendingTxSize(TCP_SOCKET hTCP)
5390:                {
5391:                    if(hTCP >= TCP_SOCKET_COUNT)
5392:                    {
5393:                        return 0;
5394:                    }
5395:                
5396:                    SyncTCBStub(hTCP);
5397:                
5398:                    // Non-SSL connections have no pending SSL data
5399:                    //if(MyTCBStub.sslStubID == SSL_INVALID_ID)
5400:                    //  return 0;
5401:                
5402:                    // Determine how many bytes are waiting to be written in this record
5403:                    if(MyTCBStub.sslTxHead > MyTCBStub.txHead)
5404:                        return MyTCBStub.sslTxHead - MyTCBStub.txHead - 5;
5405:                    else
5406:                        return (MyTCBStub.bufferRxStart - MyTCBStub.bufferTxStart - 1) - (MyTCBStub.txHead - MyTCBStub.sslTxHead - 1) - 5;
5407:                }
5408:                #endif
5409:                
5410:                
5411:                /*****************************************************************************
5412:                  Function:
5413:                    void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
5414:                
5415:                  Summary:
5416:                    Hands newly arrive TCP data to the SSL module for processing.
5417:                
5418:                  Description:
5419:                    This function processes incoming TCP data as an SSL record and
5420:                    performs any necessary repositioning and decrypting.
5421:                
5422:                  Precondition:
5423:                    TCP is initialized, and hTCP is connected with an active SSL session.
5424:                
5425:                  Parameters:
5426:                    hTCP        - TCP connection to handle incoming data on
5427:                
5428:                  Returns:
5429:                    None
5430:                
5431:                  Remarks:
5432:                    This function should never be called by an application.  It is used
5433:                    only by the SSL module itself.
5434:                  ***************************************************************************/
5435:                #if defined(STACK_USE_SSL)
5436:                void TCPSSLHandleIncoming(TCP_SOCKET hTCP)
5437:                {
5438:                    PTR_BASE prevRxTail, nextRxHead, startRxTail, wSrc, wDest;
5439:                    uint16_t wToMove, wLen, wSSLBytesThatPoofed, wDecryptedBytes;
5440:                
5441:                    if(hTCP >= TCP_SOCKET_COUNT)
5442:                    {
5443:                        return;
5444:                    }
5445:                
5446:                    // Sync the stub
5447:                    SyncTCBStub(hTCP);
5448:                
5449:                    // If new data is waiting
5450:                    if(MyTCBStub.sslRxHead != MyTCBStub.rxHead)
5451:                    {
5452:                        // Reconfigure pointers for SSL use
5453:                        prevRxTail = MyTCBStub.rxTail;
5454:                        nextRxHead = MyTCBStub.rxHead;
5455:                        MyTCBStub.rxTail = MyTCBStub.rxHead;
5456:                        MyTCBStub.rxHead = MyTCBStub.sslRxHead;
5457:                
5458:                        do
5459:                        {
5460:                            startRxTail = MyTCBStub.rxTail;
5461:                
5462:                            // Handle incoming data.  This function performs deframing of the
5463:                            // SSL records, decryption, and MAC verification.
5464:                            wSSLBytesThatPoofed = TCPIsGetReady(hTCP);
5465:                            wDecryptedBytes = SSLRxRecord(hTCP, MyTCBStub.sslStubID);
5466:                            wSSLBytesThatPoofed -= TCPIsGetReady(hTCP);
5467:                
5468:                            // Now need to move data to fill the SSL header/MAC/padding hole,
5469:                            // if there is one
5470:                            if(wSSLBytesThatPoofed)
5471:                            {
5472:                                // Sync the TCP so we can see if there is a TCP hole
5473:                                SyncTCB();
5474:                
5475:                                // Calculate how big the SSL hole is
5476:                                if(MyTCB.sHoleSize == -1)
5477:                                {// Just need to move pending SSL data
5478:                                    wToMove = TCPIsGetReady(hTCP);
5479:                                }
5480:                                else
5481:                                {// A TCP hole exists, so move all data
5482:                                    wToMove = TCPIsGetReady(hTCP) + MyTCB.sHoleSize + MyTCB.wFutureDataSize;
5483:                                }
5484:                
5485:                                // Start with the destination as the startRxTail and source as current rxTail
5486:                                wDest = startRxTail;
5487:                                wSrc = MyTCBStub.rxTail;
5488:                
5489:                                // If data exists between the end of the buffer and
5490:                                // the destination, then move it forward
5491:                                if(wSrc > wDest)
5492:                                {
5493:                                    wLen = MyTCBStub.bufferEnd - wSrc + 1;
5494:                                    if(wLen > wToMove)
5495:                                        wLen = wToMove;
5496:                                    TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,
5497:                                               wSrc, MyTCBStub.vMemoryMedium, wLen);
5498:                                    wDest += wLen;
5499:                                    wSrc = MyTCBStub.bufferRxStart;
5500:                                    wToMove -= wLen;
5501:                                }
5502:                
5503:                                // If data remains to be moved, fill in to end of buffer
5504:                                if(wToMove)
5505:                                {
5506:                                    wLen = MyTCBStub.bufferEnd - wDest + 1;
5507:                                    if(wLen > wToMove)
5508:                                        wLen = wToMove;
5509:                                    TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,
5510:                                               wSrc, MyTCBStub.vMemoryMedium, wLen);
5511:                                    wDest = MyTCBStub.bufferRxStart;
5512:                                    wSrc += wLen;
5513:                                    wToMove -= wLen;
5514:                                }
5515:                
5516:                                // If data still remains, copy from from front + len to front
5517:                                if(wToMove)
5518:                                {
5519:                                    TCPRAMCopy(wDest, MyTCBStub.vMemoryMedium,
5520:                                               wSrc, MyTCBStub.vMemoryMedium, wToMove);
5521:                                }
5522:                
5523:                                // Since bytes poofed, we need to move the head pointers
5524:                                // backwards by an equal amount.
5525:                                MyTCBStub.rxHead -= wSSLBytesThatPoofed;
5526:                                if(MyTCBStub.rxHead < MyTCBStub.bufferRxStart)
5527:                                    MyTCBStub.rxHead += MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5528:                                MyTCBStub.sslRxHead = MyTCBStub.rxHead;
5529:                            }
5530:                
5531:                            // Move tail pointer forward by the number of decrypted bytes ready
5532:                            // for the application (but not poofed bytes)
5533:                            MyTCBStub.rxTail = startRxTail + wDecryptedBytes;
5534:                            if(MyTCBStub.rxTail > MyTCBStub.bufferEnd)
5535:                                MyTCBStub.rxTail -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5536:                            nextRxHead += wDecryptedBytes;
5537:                
5538:                            // Loop until SSLRxRecord() runs out of data and stops doing
5539:                            // anything
5540:                        } while(wSSLBytesThatPoofed || (startRxTail != MyTCBStub.rxTail));
5541:                
5542:                        // Restore TCP buffer pointers to point to the decrypted application data
5543:                        // only
5544:                        if(nextRxHead > MyTCBStub.bufferEnd)
5545:                            nextRxHead -= MyTCBStub.bufferEnd - MyTCBStub.bufferRxStart + 1;
5546:                        MyTCBStub.rxTail = prevRxTail;
5547:                        MyTCBStub.rxHead = nextRxHead;
5548:                    }
5549:                }
5550:                #endif
5551:                
5552:                
5553:                #endif //#if defined(STACK_USE_TCP)
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/stack_task.c  ---------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       stack_task.c
7:                   
8:                     Summary:
9:                       -Handles internal RX packet pre-processing prior to dispatching
10:                       to upper application layers.
11:                      -Reference: AN833
12:                  
13:                    Description:
14:                      TCP/IP Stack Manager
15:                      Module for Microchip TCP/IP Stack
16:                  
17:                   *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #define __STACKTSK_C_
45:                  
46:                  #include "tcpip/tcpip.h"
47:                  
48:                  #if defined( WF_CS_TRIS )
49:                      #if defined( WF_CONFIG_CONSOLE )
50:                          #include "drv_wifi_console.h"
51:                      #endif
52:                      #if defined( STACK_USE_EZ_CONFIG ) || defined( EZ_CONFIG_SCAN )
53:                          #include "driver/wifi/mrf24w/src/drv_wifi_easy_config.h"
54:                      #endif
55:                      #include "driver/wifi/mrf24w/drv_wifi_api.h"
56:                  #endif
57:                  
58:                  // Stack FSM states.
59:                  typedef enum
60:                  {
61:                      SM_STACK_IDLE,
62:                      SM_STACK_MAC,
63:                      SM_STACK_IP,
64:                      SM_STACK_ARP,
65:                      SM_STACK_TCP,
66:                      SM_STACK_UDP
67:                  } SM_STACK;
68:                  
69:                  static SM_STACK smStack;
70:                  
71:                  NODE_INFO remoteNode;
72:                  
73:                  #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT)
74:                      bool g_DhcpRenew = false;
75:                      extern void SetDhcpProgressState(void);
76:                      uint32_t g_DhcpRetryTimer = 0;
77:                  #endif
78:                  
79:                  /*********************************************************************
80:                   * Function:        void StackInit(void)
81:                   *
82:                   * PreCondition:    None
83:                   *
84:                   * Input:           None
85:                   *
86:                   * Output:          Stack and its componets are initialized
87:                   *
88:                   * Side Effects:    None
89:                   *
90:                   * Note:            This function must be called before any of the
91:                   *                  stack or its component routines are used.
92:                   *
93:                   ********************************************************************/
94:                  void StackInit(void)
95:                  {
9D01815C  27BDFFE8   ADDIU SP, SP, -24
9D018160  AFBF0014   SW RA, 20(SP)
9D018164  AFBE0010   SW S8, 16(SP)
9D018168  03A0F021   ADDU S8, SP, ZERO
96:                      static bool once = false;
97:                      smStack = SM_STACK_IDLE;
9D01816C  AF808034   SW ZERO, -32716(GP)
98:                  
99:                  #if defined(STACK_USE_IP_GLEANING) || defined(STACK_USE_DHCP_CLIENT)
100:                     /*
101:                      * If DHCP or IP Gleaning is enabled,
102:                      * startup in Config Mode.
103:                      */
104:                     AppConfig.Flags.bInConfigMode = true;
105:                 #endif
106:                 
107:                 #if defined (WF_CS_TRIS) && defined (STACK_USE_DHCP_CLIENT)
108:                     g_DhcpRenew = false;
109:                     g_DhcpRetryTimer = 0;
110:                 #endif
111:                 
112:                     if (!once) {
9D018170  93828038   LBU V0, -32712(GP)
9D018174  38420001   XORI V0, V0, 1
9D018178  304200FF   ANDI V0, V0, 255
9D01817C  10400008   BEQ V0, ZERO, 0x9D0181A0
9D018180  00000000   NOP
113:                         // Seed the LFSRRand() function
114:                         LFSRSeedRand(GenerateRandomDWORD());
9D018184  0F403CCA   JAL GenerateRandomDWORD
9D018188  00000000   NOP
9D01818C  00402021   ADDU A0, V0, ZERO
9D018190  0F403C8B   JAL LFSRSeedRand
9D018194  00000000   NOP
115:                         once = true;
9D018198  24020001   ADDIU V0, ZERO, 1
9D01819C  A3828038   SB V0, -32712(GP)
116:                     }
117:                 
118:                     MACInit();
9D0181A0  0F40441C   JAL MACInit
9D0181A4  00000000   NOP
119:                 
120:                 #if defined(WF_CS_TRIS) && defined(STACK_USE_EZ_CONFIG) && !defined(__XC8)
121:                     WFEasyConfigInit();
122:                 #endif
123:                 
124:                     ARPInit();
9D0181A8  0F4052D7   JAL ARPInit
9D0181AC  00000000   NOP
125:                 
126:                 #if defined(STACK_USE_ANNOUNCE)
127:                     AnnounceInit();
128:                 #endif
129:                 
130:                 #if defined(STACK_USE_UDP)
131:                     UDPInit();
9D0181B0  0F403854   JAL UDPInit
9D0181B4  00000000   NOP
132:                 #endif
133:                 
134:                 #if defined(STACK_USE_TCP)
135:                     TCPInit();
9D0181B8  0F40004B   JAL TCPInit
9D0181BC  00000000   NOP
136:                 #endif
137:                 
138:                 #if defined(STACK_USE_BERKELEY_API)
139:                     BerkeleySocketInit();
140:                 #endif
141:                 
142:                 #if defined(STACK_USE_HTTP2_SERVER)
143:                     HTTPInit();
9D0181C0  0F402150   JAL HTTPInit
9D0181C4  00000000   NOP
144:                 #endif
145:                 
146:                 #if defined(STACK_USE_RSA)
147:                     RSAInit();
148:                 #endif
149:                 
150:                 #if defined(STACK_USE_SSL)
151:                     SSLInit();
152:                 #endif
153:                 
154:                 #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2)
155:                     FTPInit();
156:                 #endif
157:                 
158:                 #if defined(STACK_USE_DHCP_CLIENT)
159:                     DHCPInit(0);
160:                 
161:                     if(!AppConfig.Flags.bIsDHCPEnabled)
162:                     {
163:                         DHCPDisable(0);
164:                     }
165:                 #endif
166:                 
167:                 #if defined(STACK_USE_AUTO_IP)
168:                     AutoIPInit(0);
169:                 #endif
170:                 
171:                 #if defined(STACK_USE_DYNAMICDNS_CLIENT)
172:                     DDNSInit();
173:                 #endif
174:                 
175:                 #if defined(STACK_USE_RANDOM)
176:                     RandomInit();
177:                 #endif
178:                 
179:                 #if defined(STACK_USE_NBNS)
180:                     NBNSInit();
181:                 #endif
182:                 }
9D0181C8  03C0E821   ADDU SP, S8, ZERO
9D0181CC  8FBF0014   LW RA, 20(SP)
9D0181D0  8FBE0010   LW S8, 16(SP)
9D0181D4  27BD0018   ADDIU SP, SP, 24
9D0181D8  03E00008   JR RA
9D0181DC  00000000   NOP
183:                 
184:                 /*********************************************************************
185:                  * Function:        void StackTask(void)
186:                  *
187:                  * PreCondition:    StackInit() is already called.
188:                  *
189:                  * Input:           None
190:                  *
191:                  * Output:          Stack FSM is executed.
192:                  *
193:                  * Side Effects:    None
194:                  *
195:                  * Note:            This FSM checks for new incoming packets,
196:                  *                  and routes it to appropriate stack components.
197:                  *                  It also performs timed operations.
198:                  *
199:                  *                  This function must be called periodically to
200:                  *                  ensure timely responses.
201:                  *
202:                  ********************************************************************/
203:                 void StackTask(void)
204:                 {
9D0181E0  27BDFFD8   ADDIU SP, SP, -40
9D0181E4  AFBF0024   SW RA, 36(SP)
9D0181E8  AFBE0020   SW S8, 32(SP)
9D0181EC  03A0F021   ADDU S8, SP, ZERO
205:                     uint16_t dataCount;
206:                     IP_ADDR tempLocalIP;
207:                     uint8_t cFrameType;
208:                     uint8_t cIPFrameType;
209:                 
210:                     #if defined( WF_CS_TRIS )
211:                         // This task performs low-level MAC processing specific to the MRF24W
212:                         MACProcess();
213:                 
214:                         #if defined( STACK_USE_EZ_CONFIG ) && !defined(__XC8)
215:                             WFEasyConfigMgr();
216:                         #endif
217:                 
218:                         #if defined(STACK_USE_DHCP_CLIENT)
219:                             // Normally, an application would not include DHCP module
220:                             // if it is not enabled. But in case some one wants to disable
221:                             // DHCP module at run-time, remember to not clear our IP
222:                             // address if link is removed.
223:                             if(AppConfig.Flags.bIsDHCPEnabled)
224:                             {
225:                                 if(g_DhcpRenew == true)
226:                                 {
227:                                     g_DhcpRenew = false;
228:                                     AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
229:                                     AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
230:                                     AppConfig.Flags.bInConfigMode = true;
231:                                     DHCPInit(0);
232:                                     g_DhcpRetryTimer = (uint32_t)TickGet();
233:                                 } else {
234:                                     if (g_DhcpRetryTimer && TickGet() - g_DhcpRetryTimer >= TICKS_PER_SECOND * 8) {
235:                                         DHCPInit(0);
236:                                         g_DhcpRetryTimer = (uint32_t)TickGet();
237:                                     }
238:                                 }
239:                 
240:                                 // DHCP must be called all the time even after IP configuration is
241:                                 // discovered.
242:                                 // DHCP has to account lease expiration time and renew the configuration
243:                                 // time.
244:                                 DHCPTask();
245:                 
246:                                 if (DHCPIsBound(0)) {
247:                                     AppConfig.Flags.bInConfigMode = false;
248:                                     g_DhcpRetryTimer = 0;
249:                                 }
250:                             }
251:                         #endif // STACK_USE_DHCP_CLIENT
252:                 
253:                     #endif // WF_CS_TRIS
254:                 
255:                     #if defined(STACK_USE_DHCP_CLIENT) && !defined(WF_CS_TRIS)
256:                     // Normally, an application would not include  DHCP module
257:                     // if it is not enabled. But in case some one wants to disable
258:                     // DHCP module at run-time, remember to not clear our IP
259:                     // address if link is removed.
260:                     if(AppConfig.Flags.bIsDHCPEnabled)
261:                     {
262:                         static bool bLastLinkState = false;
263:                         bool bCurrentLinkState;
264:                 
265:                         bCurrentLinkState = MACIsLinked();
266:                         if(bCurrentLinkState != bLastLinkState)
267:                         {
268:                             bLastLinkState = bCurrentLinkState;
269:                             if(!bCurrentLinkState)
270:                             {
271:                                 AppConfig.MyIPAddr.Val = AppConfig.DefaultIPAddr.Val;
272:                                 AppConfig.MyMask.Val = AppConfig.DefaultMask.Val;
273:                                 AppConfig.Flags.bInConfigMode = true;
274:                                 DHCPInit(0);
275:                             }
276:                         }
277:                 
278:                         // DHCP must be called all the time even after IP configuration is
279:                         // discovered.
280:                         // DHCP has to account lease expiration time and renew the configuration
281:                         // time.
282:                         DHCPTask();
283:                 
284:                         if(DHCPIsBound(0))
285:                             AppConfig.Flags.bInConfigMode = false;
286:                     }
287:                     #endif
288:                 
289:                     #if defined (STACK_USE_AUTO_IP)
290:                     AutoIPTasks();
291:                     #endif
292:                 
293:                     #if defined(STACK_USE_TCP)
294:                     // Perform all TCP time related tasks (retransmit, send acknowledge, close connection, etc)
295:                     TCPTick();
9D0181F0  0F400B0F   JAL TCPTick
9D0181F4  00000000   NOP
296:                     #endif
297:                 
298:                     #if defined(STACK_USE_UDP)
299:                     UDPTask();
9D0181F8  0F4038EB   JAL UDPTask
9D0181FC  00000000   NOP
9D018200  0B406083   J 0x9D01820C
9D018204  00000000   NOP
300:                     #endif
301:                 
302:                     // Process as many incomming packets as we can
303:                     while(1)
304:                     {
305:                         //if using the random module, generate entropy
306:                         #if defined(STACK_USE_RANDOM)
307:                             RandomAdd(remoteNode.MACAddr.v[5]);
308:                         #endif
309:                 
310:                         // We are about to fetch a new packet, make sure that the
311:                         // UDP module knows that any old RX data it has laying
312:                         // around will now be gone.
313:                         #if defined(STACK_USE_UDP)
314:                             UDPDiscard();
9D01820C  0F403BA5   JAL UDPDiscard
9D018210  00000000   NOP
315:                         #endif
316:                 
317:                         // Fetch a packet (throws old one away, if not thrown away
318:                         // yet)
319:                         if(!MACGetHeader(&remoteNode.MACAddr, &cFrameType))
9D018214  27C20018   ADDIU V0, S8, 24
9D018218  3C03A000   LUI V1, -24576
9D01821C  24640380   ADDIU A0, V1, 896
9D018220  00402821   ADDU A1, V0, ZERO
9D018224  0F404642   JAL MACGetHeader
9D018228  00000000   NOP
9D01822C  38420001   XORI V0, V0, 1
9D018230  304200FF   ANDI V0, V0, 255
9D018234  14400069   BNE V0, ZERO, 0x9D0183DC
9D018238  00000000   NOP
320:                             break;
9D0183DC  00000000   NOP
9D0183E0  0B4060FB   J 0x9D0183EC
9D0183E4  00000000   NOP
321:                 
322:                         // When using a WiFi module, filter out all incoming packets that have
323:                         // the same source MAC address as our own MAC address.  This is to
324:                         // prevent receiving and passing our own broadcast packets up to other
325:                         // layers and avoid, for example, having our own gratuitous ARPs get
326:                         // answered by ourself.
327:                         #if defined(WF_CS_TRIS)
328:                             if(memcmp((void*)&remoteNode.MACAddr, (void*)&AppConfig.MyMACAddr, 6) == 0u)
329:                                 continue;
330:                         #endif  /* defined(WF_CS_TRIS) */
331:                 
332:                         // Dispatch the packet to the appropriate handler
333:                         switch(cFrameType)
9D01823C  93C20018   LBU V0, 24(S8)
9D018240  10400008   BEQ V0, ZERO, 0x9D018264
9D018244  00000000   NOP
9D018248  24030006   ADDIU V1, ZERO, 6
9D01824C  1443FFEE   BNE V0, V1, 0x9D018208
9D018250  00000000   NOP
334:                         {
335:                             case MAC_ARP:
336:                                 ARPProcess();
9D018254  0F4052FA   JAL ARPProcess
9D018258  00000000   NOP
337:                                 break;
9D01825C  0B4060F5   J 0x9D0183D4
9D018260  00000000   NOP
338:                 
339:                             case MAC_IP:
340:                                 if(!IPGetHeader(&tempLocalIP, &remoteNode, &cIPFrameType, &dataCount))
9D018264  27C30014   ADDIU V1, S8, 20
9D018268  27C20019   ADDIU V0, S8, 25
9D01826C  00602021   ADDU A0, V1, ZERO
9D018270  3C03A000   LUI V1, -24576
9D018274  2465037C   ADDIU A1, V1, 892
9D018278  00403021   ADDU A2, V0, ZERO
9D01827C  27C20010   ADDIU V0, S8, 16
9D018280  00403821   ADDU A3, V0, ZERO
9D018284  0F405F85   JAL IPGetHeader
9D018288  00000000   NOP
9D01828C  38420001   XORI V0, V0, 1
9D018290  304200FF   ANDI V0, V0, 255
9D018294  10400003   BEQ V0, ZERO, 0x9D0182A4
9D018298  00000000   NOP
341:                                     break;
9D01829C  0B4060F5   J 0x9D0183D4
9D0182A0  00000000   NOP
342:                 
343:                                 #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
344:                                 if(cIPFrameType == IP_PROT_ICMP)
9D0182A4  93C30019   LBU V1, 25(S8)
9D0182A8  24020001   ADDIU V0, ZERO, 1
9D0182AC  1462002C   BNE V1, V0, 0x9D018360
9D0182B0  00000000   NOP
345:                                 {
346:                                     #if defined(STACK_USE_IP_GLEANING)
347:                                     if(AppConfig.Flags.bInConfigMode && AppConfig.Flags.bIsDHCPEnabled)
348:                                     {
349:                                         // According to "IP Gleaning" procedure,
350:                                         // when we receive an ICMP packet with a valid
351:                                         // IP address while we are still in configuration
352:                                         // mode, accept that address as ours and conclude
353:                                         // configuration mode.
354:                                         if(tempLocalIP.Val != 0xffffffff)
355:                                         {
356:                                             AppConfig.Flags.bInConfigMode = false;
357:                                             AppConfig.MyIPAddr = tempLocalIP;
358:                                         }
359:                                     }
360:                                     #endif
361:                 
362:                                     // Process this ICMP packet if it the destination IP address matches our address or one of the broadcast IP addressees
363:                                     if( (tempLocalIP.Val == AppConfig.MyIPAddr.Val) ||
9D0182B4  8FC30014   LW V1, 20(S8)
9D0182B8  3C02A000   LUI V0, -24576
9D0182BC  244408D8   ADDIU A0, V0, 2264
9D0182C0  88840003   LWL A0, 3(A0)
9D0182C4  00802821   ADDU A1, A0, ZERO
9D0182C8  984508D8   LWR A1, 2264(V0)
9D0182CC  00A01021   ADDU V0, A1, ZERO
9D0182D0  1062001B   BEQ V1, V0, 0x9D018340
9D0182D4  00000000   NOP
9D0182DC  2402FFFF   ADDIU V0, ZERO, -1
9D0182E0  10620017   BEQ V1, V0, 0x9D018340
9D0182E4  00000000   NOP
364:                                         (tempLocalIP.Val == 0xFFFFFFFF) ||
9D0182D8  8FC30014   LW V1, 20(S8)
9D018338  14620007   BNE V1, V0, 0x9D018358
9D01833C  00000000   NOP
365:                 #if defined(STACK_USE_ZEROCONF_LINK_LOCAL) || defined(STACK_USE_ZEROCONF_MDNS_SD)
366:                                         (tempLocalIP.Val == 0xFB0000E0) ||
367:                 #endif
368:                                         (tempLocalIP.Val == ((AppConfig.MyIPAddr.Val & AppConfig.MyMask.Val) | ~AppConfig.MyMask.Val)))
9D0182E8  8FC30014   LW V1, 20(S8)
9D0182EC  3C02A000   LUI V0, -24576
9D0182F0  244408D8   ADDIU A0, V0, 2264
9D0182F4  88840003   LWL A0, 3(A0)
9D0182F8  984408D8   LWR A0, 2264(V0)
9D0182FC  3C02A000   LUI V0, -24576
9D018300  244208D8   ADDIU V0, V0, 2264
9D018304  88450007   LWL A1, 7(V0)
9D018308  00A03021   ADDU A2, A1, ZERO
9D01830C  98460004   LWR A2, 4(V0)
9D018310  00C01021   ADDU V0, A2, ZERO
9D018314  00822024   AND A0, A0, V0
9D018318  3C02A000   LUI V0, -24576
9D01831C  244208D8   ADDIU V0, V0, 2264
9D018320  88450007   LWL A1, 7(V0)
9D018324  00A03021   ADDU A2, A1, ZERO
9D018328  98460004   LWR A2, 4(V0)
9D01832C  00C01021   ADDU V0, A2, ZERO
9D018330  00021027   NOR V0, ZERO, V0
9D018334  00821025   OR V0, A0, V0
369:                                     {
370:                                         ICMPProcess(&remoteNode, dataCount);
9D018340  97C20010   LHU V0, 16(S8)
9D018344  3C03A000   LUI V1, -24576
9D018348  2464037C   ADDIU A0, V1, 892
9D01834C  00402821   ADDU A1, V0, ZERO
9D018350  0F406668   JAL ICMPProcess
9D018354  00000000   NOP
371:                                     }
372:                 
373:                                     break;
9D018358  0B4060F5   J 0x9D0183D4
9D01835C  00000000   NOP
374:                                 }
375:                                 #endif
376:                 
377:                                 #if defined(STACK_USE_TCP)
378:                                 if(cIPFrameType == IP_PROT_TCP)
9D018360  93C30019   LBU V1, 25(S8)
9D018364  24020006   ADDIU V0, ZERO, 6
9D018368  1462000B   BNE V1, V0, 0x9D018398
9D01836C  00000000   NOP
379:                                 {
380:                                     TCPProcess(&remoteNode, &tempLocalIP, dataCount);
9D018370  97C20010   LHU V0, 16(S8)
9D018374  27C30014   ADDIU V1, S8, 20
9D018378  3C04A000   LUI A0, -24576
9D01837C  2484037C   ADDIU A0, A0, 892
9D018380  00602821   ADDU A1, V1, ZERO
9D018384  00403021   ADDU A2, V0, ZERO
9D018388  0F400ECB   JAL TCPProcess
9D01838C  00000000   NOP
381:                                     break;
9D018390  0B4060F5   J 0x9D0183D4
9D018394  00000000   NOP
382:                                 }
383:                                 #endif
384:                 
385:                                 #if defined(STACK_USE_UDP)
386:                                 if(cIPFrameType == IP_PROT_UDP)
9D018398  93C30019   LBU V1, 25(S8)
9D01839C  24020011   ADDIU V0, ZERO, 17
9D0183A0  1462000B   BNE V1, V0, 0x9D0183D0
9D0183A4  00000000   NOP
387:                                 {
388:                                     // Stop processing packets if we came upon a UDP frame with application data in it
389:                                     if(UDPProcess(&remoteNode, &tempLocalIP, dataCount))
9D0183A8  97C20010   LHU V0, 16(S8)
9D0183AC  27C30014   ADDIU V1, S8, 20
9D0183B0  3C04A000   LUI A0, -24576
9D0183B4  2484037C   ADDIU A0, A0, 892
9D0183B8  00602821   ADDU A1, V1, ZERO
9D0183BC  00403021   ADDU A2, V0, ZERO
9D0183C0  0F403BBD   JAL UDPProcess
9D0183C4  00000000   NOP
9D0183C8  14400007   BNE V0, ZERO, 0x9D0183E8
9D0183CC  00000000   NOP
390:                                         return;
9D0183E8  00000000   NOP
391:                                 }
392:                                 #endif
393:                 
394:                                 break;
9D0183D0  00000000   NOP
395:                         }
396:                     }
9D018208  00000000   NOP
9D0183D4  0B406083   J 0x9D01820C
9D0183D8  00000000   NOP
397:                 }
9D0183EC  03C0E821   ADDU SP, S8, ZERO
9D0183F0  8FBF0024   LW RA, 36(SP)
9D0183F4  8FBE0020   LW S8, 32(SP)
9D0183F8  27BD0028   ADDIU SP, SP, 40
9D0183FC  03E00008   JR RA
9D018400  00000000   NOP
398:                 
399:                 /*********************************************************************
400:                  * Function:        void StackApplications(void)
401:                  *
402:                  * PreCondition:    StackInit() is already called.
403:                  *
404:                  * Input:           None
405:                  *
406:                  * Output:          Calls all loaded application modules.
407:                  *
408:                  * Side Effects:    None
409:                  *
410:                  * Note:            This function must be called periodically to
411:                  *                  ensure timely responses.
412:                  *
413:                  ********************************************************************/
414:                 void StackApplications(void)
415:                 {
9D018404  27BDFFE8   ADDIU SP, SP, -24
9D018408  AFBF0014   SW RA, 20(SP)
9D01840C  AFBE0010   SW S8, 16(SP)
9D018410  03A0F021   ADDU S8, SP, ZERO
416:                     #if defined(STACK_USE_HTTP2_SERVER)
417:                     HTTPServer();
9D018414  0F40219E   JAL HTTPServer
9D018418  00000000   NOP
418:                     #endif
419:                 
420:                     #if defined(STACK_USE_FTP_SERVER) && defined(STACK_USE_MPFS2)
421:                     FTPServer();
422:                     #endif
423:                 
424:                     #if defined(STACK_USE_ANNOUNCE)
425:                     DiscoveryTask();
426:                     #endif
427:                 
428:                     #if defined(STACK_USE_NBNS)
429:                     NBNSTask();
430:                     #endif
431:                 
432:                     #if defined(STACK_USE_DHCP_SERVER)
433:                     DHCPServerTask();
434:                     #endif
435:                 
436:                     #if defined(STACK_USE_DNS_SERVER)
437:                     DNSServerTask();
438:                     #endif
439:                 
440:                     #if defined (STACK_USE_DYNAMICDNS_CLIENT)
441:                     DDNSTask();
442:                     #endif
443:                 
444:                     #if defined(STACK_USE_TELNET_SERVER)
445:                     TelnetTask();
446:                     #endif
447:                 
448:                     #if defined(STACK_USE_REBOOT_SERVER)
449:                     RebootTask();
450:                     #endif
451:                 
452:                     #if defined(STACK_USE_SNTP_CLIENT)
453:                     SNTPClient();
454:                     #endif
455:                 
456:                     #if defined(STACK_USE_UDP_PERFORMANCE_TEST)
457:                     UDPPerformanceTask();
458:                     #endif
459:                 
460:                     #if defined(STACK_USE_TCP_PERFORMANCE_TEST)
461:                     TCPPerformanceTask();
462:                     #endif
463:                 
464:                     #if defined(STACK_USE_SMTP_CLIENT)
465:                     SMTPTask();
466:                     #endif
467:                 
468:                     #if defined(STACK_USE_UART2TCP_BRIDGE)
469:                     UART2TCPBridgeTask();
470:                     #endif
471:                 }
9D01841C  03C0E821   ADDU SP, S8, ZERO
9D018420  8FBF0014   LW RA, 20(SP)
9D018424  8FBE0010   LW S8, 16(SP)
9D018428  27BD0018   ADDIU SP, SP, 24
9D01842C  03E00008   JR RA
9D018430  00000000   NOP
472:                 
473:                 #if defined(WF_CS_TRIS) && defined(STACK_USE_DHCP_CLIENT)
474:                 void RenewDhcp(void)
475:                 {
476:                     g_DhcpRenew = true;
477:                     SetDhcpProgressState();
478:                 }
479:                 
480:                 #endif
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/mpfs2.c  --------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       mpfs2.c
7:                   
8:                     Summary:
9:                       Module for Microchip TCP/IP Stack
10:                      -Provides single API for accessing web pages and other files
11:                       from internal program memory or an external serial EEPROM memory
12:                      -Reference: AN833
13:                  
14:                    Description:
15:                      Microchip File System (MPFS) File Access API
16:                  
17:                   *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #define __MPFS2_C_
45:                  
46:                  #include "tcpip/tcpip.h"
47:                  
48:                  #if defined(STACK_USE_MPFS2)
49:                  
50:                  //Supports long file names to 64 characters
51:                  #define MAX_FILE_NAME_LEN   (64u)
52:                  
53:                  /*
54:                   * MPFS Structure:
55:                   *     [M][P][F][S]
56:                   *     [uint8_t Ver Hi][uint8_t Ver Lo][uint16_t Number of Files]
57:                   *     [Name Hash 0][Name Hash 1]...[Name Hash N]
58:                   *     [File Record 0][File Record 1]...[File Record N]
59:                   *     [String 0][String 1]...[String N]
60:                   *     [File Data 0][File Data 1]...[File Data N]
61:                   *
62:                   * Name Hash (2 bytes):
63:                   *     hash = 0
64:                   *     for each(byte in name)
65:                   *         hash += byte
66:                   *         hash <<= 1
67:                   *
68:                   *     Technically this means the hash only includes the
69:                   *     final 15 characters of a name.
70:                   *
71:                   * File Record Structure (22 bytes):
72:                   *     [uint32_t String Ptr][uint32_t Data Ptr]
73:                   *     [uint32_t Len][uint32_t Timestamp][uint32_t Microtime]
74:                   *     [uint16_t Flags]
75:                   *
76:                   *     Pointers are absolute addresses within the MPFS image.
77:                   *     Timestamp is the UNIX timestamp
78:                   *     Microtime is currently unimplemented
79:                   *
80:                   * String Structure (1 to 64 bytes):
81:                   *     ["path/to/file.ext"][0x00]
82:                   *
83:                   * File Data Structure (arbitrary length):
84:                   *      [File Data]
85:                   *
86:                   * Unlike previous versions, there are no delimiters.
87:                   *
88:                   * Name hash is calculated as follows:
89:                   *      hash = 0
90:                   *      for each(byte in name)
91:                   *          hash += byte, hash <<= 1
92:                   *
93:                   * When a file has an index, that index file has no file name,
94:                   * but is accessible as the file immediately following in the image.
95:                   *
96:                   * Current version is 2.1
97:                   */
98:                  
99:                  /****************************************************************************
100:                   Section:
101:                     Module-Only Globals and Functions
102:                   ***************************************************************************/
103:                 
104:                 // Track the MPFS File Handles
105:                 // MPFSStubs[0] is reserved for internal use (FAT access)
106:                 static MPFS_STUB MPFSStubs[MAX_MPFS_HANDLES+1];
107:                 
108:                 // Allows the MPFS to be locked, preventing access during updates
109:                 static bool isMPFSLocked;
110:                 
111:                 // FAT record cache
112:                 static MPFS_FAT_RECORD fatCache;
113:                 
114:                 // ID of currently loaded fatCache
115:                 static uint16_t fatCacheID;
116:                 
117:                 // Number of files in this MPFS image
118:                 static uint16_t numFiles;
119:                 
120:                 
121:                 static void _LoadFATRecord(uint16_t fatID);
122:                 static void _Validate(void);
123:                 
124:                 /****************************************************************************
125:                   Section:
126:                     EEPROM vs Flash Storage Settings
127:                   ***************************************************************************/
128:                 
129:                 #if defined(MPFS_USE_EEPROM)
130:                 
131:                     // Beginning address of MPFS Image
132:                     #define MPFS_HEAD       MPFS_RESERVE_BLOCK
133:                 
134:                     // Track the last read address to prevent unnecessary
135:                     // data overhead to switch locations.
136:                     MPFS_PTR lastRead;
137:                 
138:                 
139:                 #elif defined(MPFS_USE_SPI_FLASH)
140:                 
141:                     // Beginning address of MPFS Image
142:                     #define MPFS_HEAD       MPFS_RESERVE_BLOCK
143:                 
144:                 #else
145:                 
146:                     // An address where MPFS data starts in program memory.
147:                     #if defined(__XC8) || defined(__XC32)
148:                         extern ROM uint8_t MPFS_Start[];
149:                         #define MPFS_HEAD       ((uint32_t)(&MPFS_Start[0]))
150:                     #else
151:                         extern uint32_t MPFS_Start;
152:                         #define MPFS_HEAD       MPFS_Start;
153:                     #endif
154:                 
155:                 #endif
156:                 
157:                 /****************************************************************************
158:                   Section:
159:                     Stack-Level Functions
160:                   ***************************************************************************/
161:                 
162:                 /*****************************************************************************
163:                   Function:
164:                     void MPFSInit(void)
165:                 
166:                   Summary:
167:                     Initializes the MPFS module.
168:                 
169:                   Description:
170:                     Sets all MPFS handles to closed, and initializes access to the EEPROM
171:                     if necessary.
172:                 
173:                   Precondition:
174:                     None
175:                 
176:                   Parameters:
177:                     None
178:                 
179:                   Returns:
180:                     None
181:                 
182:                   Remarks:
183:                     This function is called only one during lifetime of the application.
184:                   ***************************************************************************/
185:                 void MPFSInit(void)
186:                 {
9D00CA8C  27BDFFE0   ADDIU SP, SP, -32
9D00CA90  AFBF001C   SW RA, 28(SP)
9D00CA94  AFBE0018   SW S8, 24(SP)
9D00CA98  03A0F021   ADDU S8, SP, ZERO
187:                     uint8_t i;
188:                 
189:                     for(i = 1; i <= MAX_MPFS_HANDLES; i++)
9D00CA9C  24020001   ADDIU V0, ZERO, 1
9D00CAA0  A3C20010   SB V0, 16(S8)
9D00CAA4  0B4032B7   J 0x9D00CADC
9D00CAA8  00000000   NOP
9D00CAD0  93C20010   LBU V0, 16(S8)
9D00CAD4  24420001   ADDIU V0, V0, 1
9D00CAD8  A3C20010   SB V0, 16(S8)
9D00CADC  93C20010   LBU V0, 16(S8)
9D00CAE0  2C420008   SLTIU V0, V0, 8
9D00CAE4  1440FFF1   BNE V0, ZERO, 0x9D00CAAC
9D00CAE8  00000000   NOP
190:                     {
191:                         MPFSStubs[i].addr = MPFS_INVALID;
9D00CAAC  93C20010   LBU V0, 16(S8)
9D00CAB0  3C04A001   LUI A0, -24575
9D00CAB4  00021080   SLL V0, V0, 2
9D00CAB8  00021880   SLL V1, V0, 2
9D00CABC  00621823   SUBU V1, V1, V0
9D00CAC0  248287C0   ADDIU V0, A0, -30784
9D00CAC4  00621021   ADDU V0, V1, V0
9D00CAC8  2403FFFF   ADDIU V1, ZERO, -1
9D00CACC  AC430000   SW V1, 0(V0)
192:                     }
193:                 
194:                     #if defined(MPFS_USE_EEPROM)
195:                     // Initialize the EEPROM access routines.
196:                     XEEInit();
197:                     lastRead = MPFS_INVALID;
198:                     #endif
199:                 
200:                     #if defined(MPFS_USE_SPI_FLASH)
201:                     // Initialize SPI Flash access routines.
202:                     SPIFlashInit();
203:                     #endif
204:                 
205:                     // Validate the image and load numFiles
206:                     _Validate();
9D00CAEC  0F403829   JAL 0x9D00E0A4
9D00CAF0  00000000   NOP
207:                 
208:                     isMPFSLocked = false;
9D00CAF4  A380809C   SB ZERO, -32612(GP)
209:                 
210:                 }
9D00CAF8  03C0E821   ADDU SP, S8, ZERO
9D00CAFC  8FBF001C   LW RA, 28(SP)
9D00CB00  8FBE0018   LW S8, 24(SP)
9D00CB04  27BD0020   ADDIU SP, SP, 32
9D00CB08  03E00008   JR RA
9D00CB0C  00000000   NOP
211:                 
212:                 /****************************************************************************
213:                   Section:
214:                     Handle Management Functions
215:                   ***************************************************************************/
216:                 
217:                 /*****************************************************************************
218:                   Function:
219:                     MPFS_HANDLE MPFSOpen(uint8_t* cFile)
220:                 
221:                   Description:
222:                     Opens a file in the MPFS2 file system.
223:                 
224:                   Precondition:
225:                     MPFSInit has been called
226:                 
227:                   Parameters:
228:                     cFile - a null terminated file name to open
229:                 
230:                   Returns:
231:                     An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
232:                     if the file could not be found or no free handles exist.
233:                   ***************************************************************************/
234:                 MPFS_HANDLE MPFSOpen(uint8_t* cFile)
235:                 {
9D00CB10  27BDFFC8   ADDIU SP, SP, -56
9D00CB14  AFBF0034   SW RA, 52(SP)
9D00CB18  AFBE0030   SW S8, 48(SP)
9D00CB1C  03A0F021   ADDU S8, SP, ZERO
9D00CB20  AFC40038   SW A0, 56(S8)
236:                     MPFS_HANDLE hMPFS;
237:                     uint16_t nameHash, i;
238:                     uint16_t hashCache[8];
239:                     uint8_t *ptr, c;
240:                 
241:                     // Initialize c to avoid "may be used uninitialized" compiler warning
242:                     c = 0;
9D00CB24  A3C0002C   SB ZERO, 44(S8)
243:                 
244:                     // Make sure MPFS is unlocked and we got a filename
245:                     if(*cFile == '\0' || isMPFSLocked == true)
9D00CB28  8FC20038   LW V0, 56(S8)
9D00CB2C  90420000   LBU V0, 0(V0)
9D00CB30  10400004   BEQ V0, ZERO, 0x9D00CB44
9D00CB34  00000000   NOP
9D00CB38  9382809C   LBU V0, -32612(GP)
9D00CB3C  10400004   BEQ V0, ZERO, 0x9D00CB50
9D00CB40  00000000   NOP
246:                         return MPFS_INVALID_HANDLE;
9D00CB44  240200FF   ADDIU V0, ZERO, 255
9D00CB48  0B403384   J 0x9D00CE10
9D00CB4C  00000000   NOP
247:                 
248:                     // Calculate the name hash to speed up searching
249:                     for(nameHash = 0, ptr = cFile; *ptr != '\0'; ptr++)
9D00CB50  A7C00012   SH ZERO, 18(S8)
9D00CB54  8FC20038   LW V0, 56(S8)
9D00CB58  AFC20018   SW V0, 24(S8)
9D00CB5C  0B4032E5   J 0x9D00CB94
9D00CB60  00000000   NOP
9D00CB88  8FC20018   LW V0, 24(S8)
9D00CB8C  24420001   ADDIU V0, V0, 1
9D00CB90  AFC20018   SW V0, 24(S8)
9D00CB94  8FC20018   LW V0, 24(S8)
9D00CB98  90420000   LBU V0, 0(V0)
9D00CB9C  1440FFF1   BNE V0, ZERO, 0x9D00CB64
9D00CBA0  00000000   NOP
250:                     {
251:                         nameHash += *ptr;
9D00CB64  8FC20018   LW V0, 24(S8)
9D00CB68  90420000   LBU V0, 0(V0)
9D00CB6C  00401821   ADDU V1, V0, ZERO
9D00CB70  97C20012   LHU V0, 18(S8)
9D00CB74  00621021   ADDU V0, V1, V0
9D00CB78  A7C20012   SH V0, 18(S8)
252:                         nameHash <<= 1;
9D00CB7C  97C20012   LHU V0, 18(S8)
9D00CB80  00021040   SLL V0, V0, 1
9D00CB84  A7C20012   SH V0, 18(S8)
253:                     }
254:                 
255:                     // Find a free file handle to use
256:                     for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
9D00CBA4  24020001   ADDIU V0, ZERO, 1
9D00CBA8  A3C20010   SB V0, 16(S8)
9D00CBAC  0B4032FB   J 0x9D00CBEC
9D00CBB0  00000000   NOP
9D00CBE0  93C20010   LBU V0, 16(S8)
9D00CBE4  24420001   ADDIU V0, V0, 1
9D00CBE8  A3C20010   SB V0, 16(S8)
9D00CBEC  93C20010   LBU V0, 16(S8)
9D00CBF0  2C420008   SLTIU V0, V0, 8
9D00CBF4  1440FFEF   BNE V0, ZERO, 0x9D00CBB4
9D00CBF8  00000000   NOP
9D00CBFC  0B403302   J 0x9D00CC08
9D00CC00  00000000   NOP
257:                         if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00CBB4  93C20010   LBU V0, 16(S8)
9D00CBB8  3C04A001   LUI A0, -24575
9D00CBBC  00021080   SLL V0, V0, 2
9D00CBC0  00021880   SLL V1, V0, 2
9D00CBC4  00621823   SUBU V1, V1, V0
9D00CBC8  248287C0   ADDIU V0, A0, -30784
9D00CBCC  00621021   ADDU V0, V1, V0
9D00CBD0  8C430000   LW V1, 0(V0)
9D00CBD4  2402FFFF   ADDIU V0, ZERO, -1
9D00CBD8  1062000A   BEQ V1, V0, 0x9D00CC04
9D00CBDC  00000000   NOP
258:                             break;
9D00CC04  00000000   NOP
259:                     if(hMPFS == MAX_MPFS_HANDLES)
9D00CC08  93C30010   LBU V1, 16(S8)
9D00CC0C  24020007   ADDIU V0, ZERO, 7
9D00CC10  14620004   BNE V1, V0, 0x9D00CC24
9D00CC14  00000000   NOP
260:                         return MPFS_INVALID_HANDLE;
9D00CC18  240200FF   ADDIU V0, ZERO, 255
9D00CC1C  0B403384   J 0x9D00CE10
9D00CC20  00000000   NOP
261:                 
262:                     // Read in hashes, and check remainder on a match.  Store 8 in cache for performance
263:                     for(i = 0; i < numFiles; i++)
9D00CC24  A7C00014   SH ZERO, 20(S8)
9D00CC28  0B40337E   J 0x9D00CDF8
9D00CC2C  00000000   NOP
9D00CDEC  97C20014   LHU V0, 20(S8)
9D00CDF0  24420001   ADDIU V0, V0, 1
9D00CDF4  A7C20014   SH V0, 20(S8)
9D00CDF8  978280A0   LHU V0, -32608(GP)
9D00CDFC  97C30014   LHU V1, 20(S8)
9D00CE00  0062102B   SLTU V0, V1, V0
9D00CE04  1440FF8A   BNE V0, ZERO, 0x9D00CC30
9D00CE08  00000000   NOP
264:                     {
265:                         // For new block of 8, read in data
266:                         if((i & 0x07) == 0u)
9D00CC30  97C20014   LHU V0, 20(S8)
9D00CC34  30420007   ANDI V0, V0, 7
9D00CC38  14400011   BNE V0, ZERO, 0x9D00CC80
9D00CC3C  00000000   NOP
267:                         {
268:                             MPFSStubs[0].addr = 8 + i*2;
9D00CC40  97C20014   LHU V0, 20(S8)
9D00CC44  24420004   ADDIU V0, V0, 4
9D00CC48  00021040   SLL V0, V0, 1
9D00CC4C  00401821   ADDU V1, V0, ZERO
9D00CC50  3C02A001   LUI V0, -24575
9D00CC54  AC4387C0   SW V1, -30784(V0)
269:                             MPFSStubs[0].bytesRem = 16;
9D00CC58  3C02A001   LUI V0, -24575
9D00CC5C  244287C0   ADDIU V0, V0, -30784
9D00CC60  24030010   ADDIU V1, ZERO, 16
9D00CC64  AC430004   SW V1, 4(V0)
270:                             MPFSGetArray(0, (uint8_t*)hashCache, 16);
9D00CC68  27C2001C   ADDIU V0, S8, 28
9D00CC6C  00002021   ADDU A0, ZERO, ZERO
9D00CC70  00402821   ADDU A1, V0, ZERO
9D00CC74  24060010   ADDIU A2, ZERO, 16
9D00CC78  0F403488   JAL MPFSGetArray
9D00CC7C  00000000   NOP
271:                         }
272:                 
273:                         // If the hash matches, compare the full filename
274:                         if(hashCache[i&0x07] == nameHash)
9D00CC80  97C20014   LHU V0, 20(S8)
9D00CC84  30420007   ANDI V0, V0, 7
9D00CC88  00021040   SLL V0, V0, 1
9D00CC8C  27C30010   ADDIU V1, S8, 16
9D00CC90  00621021   ADDU V0, V1, V0
9D00CC94  9442000C   LHU V0, 12(V0)
9D00CC98  97C30012   LHU V1, 18(S8)
9D00CC9C  14620053   BNE V1, V0, 0x9D00CDEC
9D00CCA0  00000000   NOP
275:                         {
276:                             _LoadFATRecord(i);
9D00CCA4  97C20014   LHU V0, 20(S8)
9D00CCA8  00402021   ADDU A0, V0, ZERO
9D00CCAC  0F403642   JAL 0x9D00D908
9D00CCB0  00000000   NOP
277:                             MPFSStubs[0].addr = fatCache.string;
9D00CCB4  3C02A001   LUI V0, -24575
9D00CCB8  8C438820   LW V1, -30688(V0)
9D00CCBC  3C02A001   LUI V0, -24575
9D00CCC0  AC4387C0   SW V1, -30784(V0)
278:                             MPFSStubs[0].bytesRem = 255;
9D00CCC4  3C02A001   LUI V0, -24575
9D00CCC8  244287C0   ADDIU V0, V0, -30784
9D00CCCC  240300FF   ADDIU V1, ZERO, 255
9D00CCD0  AC430004   SW V1, 4(V0)
279:                 
280:                             // Loop over filename to perform comparison
281:                             for(ptr = cFile; *ptr != '\0'; ptr++)
9D00CCD4  8FC20038   LW V0, 56(S8)
9D00CCD8  AFC20018   SW V0, 24(S8)
9D00CCDC  0B403346   J 0x9D00CD18
9D00CCE0  00000000   NOP
9D00CD0C  8FC20018   LW V0, 24(S8)
9D00CD10  24420001   ADDIU V0, V0, 1
9D00CD14  AFC20018   SW V0, 24(S8)
9D00CD18  8FC20018   LW V0, 24(S8)
9D00CD1C  90420000   LBU V0, 0(V0)
9D00CD20  1440FFF0   BNE V0, ZERO, 0x9D00CCE4
9D00CD24  00000000   NOP
9D00CD28  0B40334D   J 0x9D00CD34
9D00CD2C  00000000   NOP
282:                             {
283:                                 MPFSGet(0, &c);
9D00CCE4  27C2002C   ADDIU V0, S8, 44
9D00CCE8  00002021   ADDU A0, ZERO, ZERO
9D00CCEC  00402821   ADDU A1, V0, ZERO
9D00CCF0  0F4033FF   JAL MPFSGet
9D00CCF4  00000000   NOP
284:                                 if(*ptr != c)
9D00CCF8  8FC20018   LW V0, 24(S8)
9D00CCFC  90430000   LBU V1, 0(V0)
9D00CD00  93C2002C   LBU V0, 44(S8)
9D00CD04  1462000A   BNE V1, V0, 0x9D00CD30
9D00CD08  00000000   NOP
285:                                     break;
9D00CD30  00000000   NOP
286:                             }
287:                 
288:                             MPFSGet(0, &c);
9D00CD34  27C2002C   ADDIU V0, S8, 44
9D00CD38  00002021   ADDU A0, ZERO, ZERO
9D00CD3C  00402821   ADDU A1, V0, ZERO
9D00CD40  0F4033FF   JAL MPFSGet
9D00CD44  00000000   NOP
289:                 
290:                             if(c == '\0' && *ptr == '\0')
9D00CD48  93C2002C   LBU V0, 44(S8)
9D00CD4C  14400027   BNE V0, ZERO, 0x9D00CDEC
9D00CD50  00000000   NOP
9D00CD54  8FC20018   LW V0, 24(S8)
9D00CD58  90420000   LBU V0, 0(V0)
9D00CD5C  14400023   BNE V0, ZERO, 0x9D00CDEC
9D00CD60  00000000   NOP
291:                             {// Filename matches, so return true
292:                                 MPFSStubs[hMPFS].addr = fatCache.data;
9D00CD64  93C20010   LBU V0, 16(S8)
9D00CD68  3C03A001   LUI V1, -24575
9D00CD6C  24638820   ADDIU V1, V1, -30688
9D00CD70  8C640004   LW A0, 4(V1)
9D00CD74  3C05A001   LUI A1, -24575
9D00CD78  00021080   SLL V0, V0, 2
9D00CD7C  00021880   SLL V1, V0, 2
9D00CD80  00621823   SUBU V1, V1, V0
9D00CD84  24A287C0   ADDIU V0, A1, -30784
9D00CD88  00621021   ADDU V0, V1, V0
9D00CD8C  AC440000   SW A0, 0(V0)
293:                                 MPFSStubs[hMPFS].bytesRem = fatCache.len;
9D00CD90  93C20010   LBU V0, 16(S8)
9D00CD94  3C03A001   LUI V1, -24575
9D00CD98  24638820   ADDIU V1, V1, -30688
9D00CD9C  8C630008   LW V1, 8(V1)
9D00CDA0  3C04A001   LUI A0, -24575
9D00CDA4  248487C0   ADDIU A0, A0, -30784
9D00CDA8  00021080   SLL V0, V0, 2
9D00CDAC  00022880   SLL A1, V0, 2
9D00CDB0  00A21023   SUBU V0, A1, V0
9D00CDB4  00821021   ADDU V0, A0, V0
9D00CDB8  AC430004   SW V1, 4(V0)
294:                                 MPFSStubs[hMPFS].fatID = i;
9D00CDBC  93C20010   LBU V0, 16(S8)
9D00CDC0  3C04A001   LUI A0, -24575
9D00CDC4  00021080   SLL V0, V0, 2
9D00CDC8  00021880   SLL V1, V0, 2
9D00CDCC  00621823   SUBU V1, V1, V0
9D00CDD0  248287C0   ADDIU V0, A0, -30784
9D00CDD4  00621021   ADDU V0, V1, V0
9D00CDD8  97C30014   LHU V1, 20(S8)
9D00CDDC  A4430008   SH V1, 8(V0)
295:                                 return hMPFS;
9D00CDE0  93C20010   LBU V0, 16(S8)
9D00CDE4  0B403384   J 0x9D00CE10
9D00CDE8  00000000   NOP
296:                             }
297:                         }
298:                     }
299:                 
300:                     // No file name matched, so return nothing
301:                     return MPFS_INVALID_HANDLE;
9D00CE0C  240200FF   ADDIU V0, ZERO, 255
302:                 }
9D00CE10  03C0E821   ADDU SP, S8, ZERO
9D00CE14  8FBF0034   LW RA, 52(SP)
9D00CE18  8FBE0030   LW S8, 48(SP)
9D00CE1C  27BD0038   ADDIU SP, SP, 56
9D00CE20  03E00008   JR RA
9D00CE24  00000000   NOP
303:                 
304:                 /*****************************************************************************
305:                   Function:
306:                     MPFS_HANDLE MPFSOpenROM(ROM uint8_t* cFile)
307:                 
308:                   Description:
309:                     Opens a file in the MPFS2 file system.
310:                 
311:                   Precondition:
312:                     None
313:                 
314:                   Parameters:
315:                     cFile - a null terminated file name to open
316:                 
317:                   Returns:
318:                     An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
319:                     if the file could not be found or no free handles exist.
320:                 
321:                   Remarks:
322:                     This function is aliased to MPFSOpen on non-PIC18 platforms.
323:                   ***************************************************************************/
324:                 #if defined(__XC8)
325:                 MPFS_HANDLE MPFSOpenROM(ROM uint8_t* cFile)
326:                 {
327:                     MPFS_HANDLE hMPFS;
328:                     uint16_t nameHash, i;
329:                     uint16_t hashCache[8];
330:                     ROM uint8_t *ptr;
331:                     uint8_t c;
332:                 
333:                     // Make sure MPFS is unlocked and we got a filename
334:                     if(*cFile == '\0' || isMPFSLocked == true)
335:                         return MPFS_INVALID_HANDLE;
336:                 
337:                     // Calculate the name hash to speed up searching
338:                     for(nameHash = 0, ptr = cFile; *ptr != '\0'; ptr++)
339:                     {
340:                         nameHash += *ptr;
341:                         nameHash <<= 1;
342:                     }
343:                 
344:                     // Find a free file handle to use
345:                     for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
346:                         if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
347:                             break;
348:                     if(hMPFS == MAX_MPFS_HANDLES)
349:                         return MPFS_INVALID_HANDLE;
350:                 
351:                     // Read in hashes, and check remainder on a match.  Store 8 in cache for performance
352:                     for(i = 0; i < numFiles; i++)
353:                     {
354:                         // For new block of 8, read in data
355:                         if((i & 0x07) == 0u)
356:                         {
357:                             MPFSStubs[0].addr = 8 + i*2;
358:                             MPFSStubs[0].bytesRem = 16;
359:                             MPFSGetArray(0, (uint8_t*)hashCache, 16);
360:                         }
361:                 
362:                         // If the hash matches, compare the full filename
363:                         if(hashCache[i&0x07] == nameHash)
364:                         {
365:                             _LoadFATRecord(i);
366:                             MPFSStubs[0].addr = fatCache.string;
367:                             MPFSStubs[0].bytesRem = 255;
368:                 
369:                             // Loop over filename to perform comparison
370:                             for(ptr = cFile; *ptr != '\0'; ptr++)
371:                             {
372:                                 MPFSGet(0, &c);
373:                                 if(*ptr != c)
374:                                     break;
375:                             }
376:                 
377:                             MPFSGet(0, &c);
378:                 
379:                             if(c == '\0' && *ptr == '\0')
380:                             {// Filename matches, so return true
381:                                 MPFSStubs[hMPFS].addr = fatCache.data;
382:                                 MPFSStubs[hMPFS].bytesRem = fatCache.len;
383:                                 MPFSStubs[hMPFS].fatID = i;
384:                                 return hMPFS;
385:                             }
386:                         }
387:                     }
388:                 
389:                     // No file name matched, so return nothing
390:                     return MPFS_INVALID_HANDLE;
391:                 }
392:                 #endif
393:                 
394:                 /*****************************************************************************
395:                   Function:
396:                     MPFS_HANDLE MPFSOpenID(uint16_t hFatID)
397:                 
398:                   Summary:
399:                     Quickly re-opens a file.
400:                 
401:                   Description:
402:                     Quickly re-opens a file in the MPFS2 file system.  Use this function
403:                     along with MPFSGetID() to quickly re-open a file without tying up
404:                     a permanent MPFSStub.
405:                 
406:                   Precondition:
407:                     None
408:                 
409:                   Parameters:
410:                     hFatID - the ID of a previous opened file in the FAT
411:                 
412:                   Returns:
413:                     An MPFS_HANDLE to the opened file if found, or MPFS_INVALID_HANDLE
414:                     if the file could not be found or no free handles exist.
415:                   ***************************************************************************/
416:                 MPFS_HANDLE MPFSOpenID(uint16_t hFatID)
417:                 {
9D00CE28  27BDFFE0   ADDIU SP, SP, -32
9D00CE2C  AFBF001C   SW RA, 28(SP)
9D00CE30  AFBE0018   SW S8, 24(SP)
9D00CE34  03A0F021   ADDU S8, SP, ZERO
9D00CE38  00801021   ADDU V0, A0, ZERO
9D00CE3C  A7C20020   SH V0, 32(S8)
418:                     MPFS_HANDLE hMPFS;
419:                 
420:                     // Make sure MPFS is unlocked and we got a valid id
421:                     if(isMPFSLocked == true || hFatID > numFiles)
9D00CE40  9382809C   LBU V0, -32612(GP)
9D00CE44  14400006   BNE V0, ZERO, 0x9D00CE60
9D00CE48  00000000   NOP
9D00CE4C  978280A0   LHU V0, -32608(GP)
9D00CE50  97C30020   LHU V1, 32(S8)
9D00CE54  0043102B   SLTU V0, V0, V1
9D00CE58  10400004   BEQ V0, ZERO, 0x9D00CE6C
9D00CE5C  00000000   NOP
422:                         return MPFS_INVALID_HANDLE;
9D00CE60  240200FF   ADDIU V0, ZERO, 255
9D00CE64  0B4033DF   J 0x9D00CF7C
9D00CE68  00000000   NOP
423:                 
424:                     // Find a free file handle to use
425:                     for(hMPFS = 1; hMPFS <= MAX_MPFS_HANDLES; hMPFS++)
9D00CE6C  24020001   ADDIU V0, ZERO, 1
9D00CE70  A3C20010   SB V0, 16(S8)
9D00CE74  0B4033AD   J 0x9D00CEB4
9D00CE78  00000000   NOP
9D00CEA8  93C20010   LBU V0, 16(S8)
9D00CEAC  24420001   ADDIU V0, V0, 1
9D00CEB0  A3C20010   SB V0, 16(S8)
9D00CEB4  93C20010   LBU V0, 16(S8)
9D00CEB8  2C420008   SLTIU V0, V0, 8
9D00CEBC  1440FFEF   BNE V0, ZERO, 0x9D00CE7C
9D00CEC0  00000000   NOP
9D00CEC4  0B4033B4   J 0x9D00CED0
9D00CEC8  00000000   NOP
426:                         if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00CE7C  93C20010   LBU V0, 16(S8)
9D00CE80  3C04A001   LUI A0, -24575
9D00CE84  00021080   SLL V0, V0, 2
9D00CE88  00021880   SLL V1, V0, 2
9D00CE8C  00621823   SUBU V1, V1, V0
9D00CE90  248287C0   ADDIU V0, A0, -30784
9D00CE94  00621021   ADDU V0, V1, V0
9D00CE98  8C430000   LW V1, 0(V0)
9D00CE9C  2402FFFF   ADDIU V0, ZERO, -1
9D00CEA0  1062000A   BEQ V1, V0, 0x9D00CECC
9D00CEA4  00000000   NOP
427:                             break;
9D00CECC  00000000   NOP
428:                     if(hMPFS == MAX_MPFS_HANDLES)
9D00CED0  93C30010   LBU V1, 16(S8)
9D00CED4  24020007   ADDIU V0, ZERO, 7
9D00CED8  14620004   BNE V1, V0, 0x9D00CEEC
9D00CEDC  00000000   NOP
429:                         return MPFS_INVALID_HANDLE;
9D00CEE0  240200FF   ADDIU V0, ZERO, 255
9D00CEE4  0B4033DF   J 0x9D00CF7C
9D00CEE8  00000000   NOP
430:                 
431:                     // Load the FAT record
432:                     _LoadFATRecord(hFatID);
9D00CEEC  97C20020   LHU V0, 32(S8)
9D00CEF0  00402021   ADDU A0, V0, ZERO
9D00CEF4  0F403642   JAL 0x9D00D908
9D00CEF8  00000000   NOP
433:                 
434:                     // Set up the file handle
435:                     MPFSStubs[hMPFS].fatID = hFatID;
9D00CEFC  93C20010   LBU V0, 16(S8)
9D00CF00  3C04A001   LUI A0, -24575
9D00CF04  00021080   SLL V0, V0, 2
9D00CF08  00021880   SLL V1, V0, 2
9D00CF0C  00621823   SUBU V1, V1, V0
9D00CF10  248287C0   ADDIU V0, A0, -30784
9D00CF14  00621021   ADDU V0, V1, V0
9D00CF18  97C30020   LHU V1, 32(S8)
9D00CF1C  A4430008   SH V1, 8(V0)
436:                     MPFSStubs[hMPFS].addr = fatCache.data;
9D00CF20  93C20010   LBU V0, 16(S8)
9D00CF24  3C03A001   LUI V1, -24575
9D00CF28  24638820   ADDIU V1, V1, -30688
9D00CF2C  8C640004   LW A0, 4(V1)
9D00CF30  3C05A001   LUI A1, -24575
9D00CF34  00021080   SLL V0, V0, 2
9D00CF38  00021880   SLL V1, V0, 2
9D00CF3C  00621823   SUBU V1, V1, V0
9D00CF40  24A287C0   ADDIU V0, A1, -30784
9D00CF44  00621021   ADDU V0, V1, V0
9D00CF48  AC440000   SW A0, 0(V0)
437:                     MPFSStubs[hMPFS].bytesRem = fatCache.len;
9D00CF4C  93C20010   LBU V0, 16(S8)
9D00CF50  3C03A001   LUI V1, -24575
9D00CF54  24638820   ADDIU V1, V1, -30688
9D00CF58  8C630008   LW V1, 8(V1)
9D00CF5C  3C04A001   LUI A0, -24575
9D00CF60  248487C0   ADDIU A0, A0, -30784
9D00CF64  00021080   SLL V0, V0, 2
9D00CF68  00022880   SLL A1, V0, 2
9D00CF6C  00A21023   SUBU V0, A1, V0
9D00CF70  00821021   ADDU V0, A0, V0
9D00CF74  AC430004   SW V1, 4(V0)
438:                 
439:                     return hMPFS;
9D00CF78  93C20010   LBU V0, 16(S8)
440:                 }
9D00CF7C  03C0E821   ADDU SP, S8, ZERO
9D00CF80  8FBF001C   LW RA, 28(SP)
9D00CF84  8FBE0018   LW S8, 24(SP)
9D00CF88  27BD0020   ADDIU SP, SP, 32
9D00CF8C  03E00008   JR RA
9D00CF90  00000000   NOP
441:                 
442:                 /*****************************************************************************
443:                   Function:
444:                     void MPFSClose(MPFS_HANDLE hMPFS)
445:                 
446:                   Summary:
447:                     Closes a file.
448:                 
449:                   Description:
450:                     Closes a file and releases its stub back to the pool of available
451:                     handles.
452:                 
453:                   Precondition:
454:                     None
455:                 
456:                   Parameters:
457:                     hMPFS - the file handle to be closed
458:                 
459:                   Returns:
460:                     None
461:                   ***************************************************************************/
462:                 void MPFSClose(MPFS_HANDLE hMPFS)
463:                 {
9D00CF94  27BDFFF8   ADDIU SP, SP, -8
9D00CF98  AFBE0004   SW S8, 4(SP)
9D00CF9C  03A0F021   ADDU S8, SP, ZERO
9D00CFA0  00801021   ADDU V0, A0, ZERO
9D00CFA4  A3C20008   SB V0, 8(S8)
464:                     if(hMPFS != 0u && hMPFS <= MAX_MPFS_HANDLES)
9D00CFA8  93C20008   LBU V0, 8(S8)
9D00CFAC  1040000E   BEQ V0, ZERO, 0x9D00CFE8
9D00CFB0  00000000   NOP
9D00CFB4  93C20008   LBU V0, 8(S8)
9D00CFB8  2C420008   SLTIU V0, V0, 8
9D00CFBC  1040000A   BEQ V0, ZERO, 0x9D00CFE8
9D00CFC0  00000000   NOP
465:                         MPFSStubs[hMPFS].addr = MPFS_INVALID;
9D00CFC4  93C20008   LBU V0, 8(S8)
9D00CFC8  3C04A001   LUI A0, -24575
9D00CFCC  00021080   SLL V0, V0, 2
9D00CFD0  00021880   SLL V1, V0, 2
9D00CFD4  00621823   SUBU V1, V1, V0
9D00CFD8  248287C0   ADDIU V0, A0, -30784
9D00CFDC  00621021   ADDU V0, V1, V0
9D00CFE0  2403FFFF   ADDIU V1, ZERO, -1
9D00CFE4  AC430000   SW V1, 0(V0)
466:                 }
9D00CFE8  03C0E821   ADDU SP, S8, ZERO
9D00CFEC  8FBE0004   LW S8, 4(SP)
9D00CFF0  27BD0008   ADDIU SP, SP, 8
9D00CFF4  03E00008   JR RA
9D00CFF8  00000000   NOP
467:                 
468:                 
469:                 /****************************************************************************
470:                   Section:
471:                     Data Reading Functions
472:                   ***************************************************************************/
473:                 
474:                 /*****************************************************************************
475:                   Function:
476:                     bool MPFSGet(MPFS_HANDLE hMPFS, uint8_t* c)
477:                 
478:                   Description:
479:                     Reads a byte from a file.
480:                 
481:                   Precondition:
482:                     The file handle referenced by hMPFS is already open.
483:                 
484:                   Parameters:
485:                     hMPFS - the file handle from which to read
486:                     c - Where to store the byte that was read
487:                 
488:                   Return Values:
489:                     true - The byte was successfully read
490:                     false - No byte was read because either the handle was invalid or
491:                             the end of the file has been reached.
492:                   ***************************************************************************/
493:                 bool MPFSGet(MPFS_HANDLE hMPFS, uint8_t* c)
494:                 {
9D00CFFC  27BDFFF0   ADDIU SP, SP, -16
9D00D000  AFBE000C   SW S8, 12(SP)
9D00D004  03A0F021   ADDU S8, SP, ZERO
9D00D008  00801021   ADDU V0, A0, ZERO
9D00D00C  AFC50014   SW A1, 20(S8)
9D00D010  A3C20010   SB V0, 16(S8)
495:                     // Make sure we're reading a valid address
496:                     if(hMPFS > MAX_MPFS_HANDLES)
9D00D014  93C20010   LBU V0, 16(S8)
9D00D018  2C420008   SLTIU V0, V0, 8
9D00D01C  14400004   BNE V0, ZERO, 0x9D00D030
9D00D020  00000000   NOP
497:                         return false;
9D00D024  00001021   ADDU V0, ZERO, ZERO
9D00D028  0B403483   J 0x9D00D20C
9D00D02C  00000000   NOP
498:                     if( MPFSStubs[hMPFS].addr == MPFS_INVALID ||
9D00D030  93C20010   LBU V0, 16(S8)
9D00D034  3C04A001   LUI A0, -24575
9D00D038  00021080   SLL V0, V0, 2
9D00D03C  00021880   SLL V1, V0, 2
9D00D040  00621823   SUBU V1, V1, V0
9D00D044  248287C0   ADDIU V0, A0, -30784
9D00D048  00621021   ADDU V0, V1, V0
9D00D04C  8C430000   LW V1, 0(V0)
9D00D050  2402FFFF   ADDIU V0, ZERO, -1
9D00D054  1062000B   BEQ V1, V0, 0x9D00D084
9D00D058  00000000   NOP
9D00D07C  14400004   BNE V0, ZERO, 0x9D00D090
9D00D080  00000000   NOP
499:                         MPFSStubs[hMPFS].bytesRem == 0u)
9D00D05C  93C20010   LBU V0, 16(S8)
9D00D060  3C03A001   LUI V1, -24575
9D00D064  246387C0   ADDIU V1, V1, -30784
9D00D068  00021080   SLL V0, V0, 2
9D00D06C  00022080   SLL A0, V0, 2
9D00D070  00821023   SUBU V0, A0, V0
9D00D074  00621021   ADDU V0, V1, V0
9D00D078  8C420004   LW V0, 4(V0)
500:                         return false;
9D00D084  00001021   ADDU V0, ZERO, ZERO
9D00D088  0B403483   J 0x9D00D20C
9D00D08C  00000000   NOP
501:                 
502:                     if(c == NULL)
9D00D090  8FC20014   LW V0, 20(S8)
9D00D094  14400028   BNE V0, ZERO, 0x9D00D138
9D00D098  00000000   NOP
503:                     {
504:                         MPFSStubs[hMPFS].addr++;
9D00D09C  93C40010   LBU A0, 16(S8)
9D00D0A0  3C05A001   LUI A1, -24575
9D00D0A4  00801021   ADDU V0, A0, ZERO
9D00D0A8  00021080   SLL V0, V0, 2
9D00D0AC  00021880   SLL V1, V0, 2
9D00D0B0  00621823   SUBU V1, V1, V0
9D00D0B4  24A287C0   ADDIU V0, A1, -30784
9D00D0B8  00621021   ADDU V0, V1, V0
9D00D0BC  8C420000   LW V0, 0(V0)
9D00D0C0  24450001   ADDIU A1, V0, 1
9D00D0C4  3C06A001   LUI A2, -24575
9D00D0C8  00801021   ADDU V0, A0, ZERO
9D00D0CC  00021080   SLL V0, V0, 2
9D00D0D0  00021880   SLL V1, V0, 2
9D00D0D4  00621823   SUBU V1, V1, V0
9D00D0D8  24C287C0   ADDIU V0, A2, -30784
9D00D0DC  00621021   ADDU V0, V1, V0
9D00D0E0  AC450000   SW A1, 0(V0)
505:                         MPFSStubs[hMPFS].bytesRem--;
9D00D0E4  93C30010   LBU V1, 16(S8)
9D00D0E8  3C02A001   LUI V0, -24575
9D00D0EC  244487C0   ADDIU A0, V0, -30784
9D00D0F0  00601021   ADDU V0, V1, ZERO
9D00D0F4  00021080   SLL V0, V0, 2
9D00D0F8  00022880   SLL A1, V0, 2
9D00D0FC  00A21023   SUBU V0, A1, V0
9D00D100  00821021   ADDU V0, A0, V0
9D00D104  8C420004   LW V0, 4(V0)
9D00D108  2444FFFF   ADDIU A0, V0, -1
9D00D10C  3C02A001   LUI V0, -24575
9D00D110  244587C0   ADDIU A1, V0, -30784
9D00D114  00601021   ADDU V0, V1, ZERO
9D00D118  00021080   SLL V0, V0, 2
9D00D11C  00021880   SLL V1, V0, 2
9D00D120  00621023   SUBU V0, V1, V0
9D00D124  00A21021   ADDU V0, A1, V0
9D00D128  AC440004   SW A0, 4(V0)
506:                         return true;
9D00D12C  24020001   ADDIU V0, ZERO, 1
9D00D130  0B403483   J 0x9D00D20C
9D00D134  00000000   NOP
507:                     }
508:                 
509:                 
510:                     // Read function for EEPROM
511:                     #if defined(MPFS_USE_EEPROM)
512:                         // For performance, cache the last read address
513:                         if(MPFSStubs[hMPFS].addr != lastRead+1)
514:                             XEEBeginRead(MPFSStubs[hMPFS].addr + MPFS_HEAD);
515:                         *c = XEERead();
516:                         lastRead = MPFSStubs[hMPFS].addr;
517:                         MPFSStubs[hMPFS].addr++;
518:                     #elif defined(MPFS_USE_SPI_FLASH)
519:                         SPIFlashReadArray(MPFSStubs[hMPFS].addr + MPFS_HEAD, c, 1);
520:                         MPFSStubs[hMPFS].addr++;
521:                     #else
522:                         #if defined(__XC16)
523:                         {
524:                             uint32_t addr;
525:                             TCPIP_UINT32_VAL read;
526:                             uint8_t i;
527:                 
528:                             // MPFS Images are addressed by the byte; Program memory by the word.
529:                             //
530:                             // Flash program memory is 24 bits wide and only even words are
531:                             // implemented.  The upper byte of the upper word is read as 0x00.
532:                             // Address in program memory of any given byte is (MPFSAddr * 2) / 3
533:                             //
534:                             // We will read 24 bits at a time, but need to support using only
535:                             // fractions of the first and last byte.
536:                 
537:                             // Find the beginning address in program memory.
538:                             addr = (MPFSStubs[hMPFS].addr / 3) << 1;
539:                 
540:                             // Find where to start in that first 3 bytes
541:                             read.Val = (addr * 3) >> 1;
542:                             if(read.Val == MPFSStubs[hMPFS].addr)
543:                                 i = 0;
544:                             else if(read.Val+1 == MPFSStubs[hMPFS].addr)
545:                                 i = 1;
546:                             else
547:                                 i = 2;
548:                 
549:                             // Add in the MPFS starting address offset
550:                             addr += MPFS_HEAD;
551:                 
552:                             // Update the MPFS Handle
553:                             MPFSStubs[hMPFS].addr++;
554:                 
555:                             // Read the uint32_t
556:                             read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
557:                             *c = read.v[i];
558:                 
559:                         }
560:                         #else
561:                         {
562:                             uint32_t dwHITECHWorkaround = MPFS_HEAD;
9D00D138  3C029D01   LUI V0, -25343
9D00D13C  2442B05C   ADDIU V0, V0, -20388
9D00D140  AFC20000   SW V0, 0(S8)
563:                         *c = *((ROM uint8_t*)(MPFSStubs[hMPFS].addr+dwHITECHWorkaround));
9D00D144  93C20010   LBU V0, 16(S8)
9D00D148  3C04A001   LUI A0, -24575
9D00D14C  00021080   SLL V0, V0, 2
9D00D150  00021880   SLL V1, V0, 2
9D00D154  00621823   SUBU V1, V1, V0
9D00D158  248287C0   ADDIU V0, A0, -30784
9D00D15C  00621021   ADDU V0, V1, V0
9D00D160  8C430000   LW V1, 0(V0)
9D00D164  8FC20000   LW V0, 0(S8)
9D00D168  00621021   ADDU V0, V1, V0
9D00D16C  90430000   LBU V1, 0(V0)
9D00D170  8FC20014   LW V0, 20(S8)
9D00D174  A0430000   SB V1, 0(V0)
564:                             MPFSStubs[hMPFS].addr++;
9D00D178  93C40010   LBU A0, 16(S8)
9D00D17C  3C05A001   LUI A1, -24575
9D00D180  00801021   ADDU V0, A0, ZERO
9D00D184  00021080   SLL V0, V0, 2
9D00D188  00021880   SLL V1, V0, 2
9D00D18C  00621823   SUBU V1, V1, V0
9D00D190  24A287C0   ADDIU V0, A1, -30784
9D00D194  00621021   ADDU V0, V1, V0
9D00D198  8C420000   LW V0, 0(V0)
9D00D19C  24450001   ADDIU A1, V0, 1
9D00D1A0  3C06A001   LUI A2, -24575
9D00D1A4  00801021   ADDU V0, A0, ZERO
9D00D1A8  00021080   SLL V0, V0, 2
9D00D1AC  00021880   SLL V1, V0, 2
9D00D1B0  00621823   SUBU V1, V1, V0
9D00D1B4  24C287C0   ADDIU V0, A2, -30784
9D00D1B8  00621021   ADDU V0, V1, V0
9D00D1BC  AC450000   SW A1, 0(V0)
565:                         }
566:                         #endif
567:                     #endif
568:                 
569:                     MPFSStubs[hMPFS].bytesRem--;
9D00D1C0  93C30010   LBU V1, 16(S8)
9D00D1C4  3C02A001   LUI V0, -24575
9D00D1C8  244487C0   ADDIU A0, V0, -30784
9D00D1CC  00601021   ADDU V0, V1, ZERO
9D00D1D0  00021080   SLL V0, V0, 2
9D00D1D4  00022880   SLL A1, V0, 2
9D00D1D8  00A21023   SUBU V0, A1, V0
9D00D1DC  00821021   ADDU V0, A0, V0
9D00D1E0  8C420004   LW V0, 4(V0)
9D00D1E4  2444FFFF   ADDIU A0, V0, -1
9D00D1E8  3C02A001   LUI V0, -24575
9D00D1EC  244587C0   ADDIU A1, V0, -30784
9D00D1F0  00601021   ADDU V0, V1, ZERO
9D00D1F4  00021080   SLL V0, V0, 2
9D00D1F8  00021880   SLL V1, V0, 2
9D00D1FC  00621023   SUBU V0, V1, V0
9D00D200  00A21021   ADDU V0, A1, V0
9D00D204  AC440004   SW A0, 4(V0)
570:                     return true;
9D00D208  24020001   ADDIU V0, ZERO, 1
571:                 }
9D00D20C  03C0E821   ADDU SP, S8, ZERO
9D00D210  8FBE000C   LW S8, 12(SP)
9D00D214  27BD0010   ADDIU SP, SP, 16
9D00D218  03E00008   JR RA
9D00D21C  00000000   NOP
572:                 
573:                 /*****************************************************************************
574:                   Function:
575:                     uint16_t MPFSGetArray(MPFS_HANDLE hMPFS, uint8_t* cData, uint16_t wLen)
576:                 
577:                   Description:
578:                     Reads a series of bytes from a file.
579:                 
580:                   Precondition:
581:                     The file handle referenced by hMPFS is already open.
582:                 
583:                   Parameters:
584:                     hMPFS - the file handle from which to read
585:                     cData - where to store the bytes that were read
586:                     wLen - how many bytes to read
587:                 
588:                   Returns:
589:                     The number of bytes successfully read.  If this is less than wLen,
590:                     an EOF occurred while attempting to read.
591:                   ***************************************************************************/
592:                 uint16_t MPFSGetArray(MPFS_HANDLE hMPFS, uint8_t* cData, uint16_t wLen)
593:                 {
9D00D220  27BDFFE0   ADDIU SP, SP, -32
9D00D224  AFBF001C   SW RA, 28(SP)
9D00D228  AFBE0018   SW S8, 24(SP)
9D00D22C  03A0F021   ADDU S8, SP, ZERO
9D00D230  00801821   ADDU V1, A0, ZERO
9D00D234  AFC50024   SW A1, 36(S8)
9D00D238  00C01021   ADDU V0, A2, ZERO
9D00D23C  A3C30020   SB V1, 32(S8)
9D00D240  A7C20028   SH V0, 40(S8)
594:                     // Make sure we're reading a valid address
595:                     if(hMPFS > MAX_MPFS_HANDLES)
9D00D244  93C20020   LBU V0, 32(S8)
9D00D248  2C420008   SLTIU V0, V0, 8
9D00D24C  14400004   BNE V0, ZERO, 0x9D00D260
9D00D250  00000000   NOP
596:                         return 0;
9D00D254  00001021   ADDU V0, ZERO, ZERO
9D00D258  0B403525   J 0x9D00D494
9D00D25C  00000000   NOP
597:                 
598:                     // Determine how many we can actually read
599:                     if(wLen > MPFSStubs[hMPFS].bytesRem)
9D00D260  97C30028   LHU V1, 40(S8)
9D00D264  93C20020   LBU V0, 32(S8)
9D00D268  3C04A001   LUI A0, -24575
9D00D26C  248487C0   ADDIU A0, A0, -30784
9D00D270  00021080   SLL V0, V0, 2
9D00D274  00022880   SLL A1, V0, 2
9D00D278  00A21023   SUBU V0, A1, V0
9D00D27C  00821021   ADDU V0, A0, V0
9D00D280  8C420004   LW V0, 4(V0)
9D00D284  0043102B   SLTU V0, V0, V1
9D00D288  1040000A   BEQ V0, ZERO, 0x9D00D2B4
9D00D28C  00000000   NOP
600:                         wLen = MPFSStubs[hMPFS].bytesRem;
9D00D290  93C20020   LBU V0, 32(S8)
9D00D294  3C03A001   LUI V1, -24575
9D00D298  246387C0   ADDIU V1, V1, -30784
9D00D29C  00021080   SLL V0, V0, 2
9D00D2A0  00022080   SLL A0, V0, 2
9D00D2A4  00821023   SUBU V0, A0, V0
9D00D2A8  00621021   ADDU V0, V1, V0
9D00D2AC  8C420004   LW V0, 4(V0)
9D00D2B0  A7C20028   SH V0, 40(S8)
601:                 
602:                     // Make sure we're reading a valid address
603:                     if(MPFSStubs[hMPFS].addr == MPFS_INVALID || wLen == 0u)
9D00D2B4  93C20020   LBU V0, 32(S8)
9D00D2B8  3C04A001   LUI A0, -24575
9D00D2BC  00021080   SLL V0, V0, 2
9D00D2C0  00021880   SLL V1, V0, 2
9D00D2C4  00621823   SUBU V1, V1, V0
9D00D2C8  248287C0   ADDIU V0, A0, -30784
9D00D2CC  00621021   ADDU V0, V1, V0
9D00D2D0  8C430000   LW V1, 0(V0)
9D00D2D4  2402FFFF   ADDIU V0, ZERO, -1
9D00D2D8  10620004   BEQ V1, V0, 0x9D00D2EC
9D00D2DC  00000000   NOP
9D00D2E0  97C20028   LHU V0, 40(S8)
9D00D2E4  14400004   BNE V0, ZERO, 0x9D00D2F8
9D00D2E8  00000000   NOP
604:                         return 0;
9D00D2EC  00001021   ADDU V0, ZERO, ZERO
9D00D2F0  0B403525   J 0x9D00D494
9D00D2F4  00000000   NOP
605:                 
606:                     if(cData == NULL)
9D00D2F8  8FC20024   LW V0, 36(S8)
9D00D2FC  1440002A   BNE V0, ZERO, 0x9D00D3A8
9D00D300  00000000   NOP
607:                     {
608:                         MPFSStubs[hMPFS].addr += wLen;
9D00D304  93C60020   LBU A2, 32(S8)
9D00D308  93C20020   LBU V0, 32(S8)
9D00D30C  3C04A001   LUI A0, -24575
9D00D310  00021080   SLL V0, V0, 2
9D00D314  00021880   SLL V1, V0, 2
9D00D318  00621823   SUBU V1, V1, V0
9D00D31C  248287C0   ADDIU V0, A0, -30784
9D00D320  00621021   ADDU V0, V1, V0
9D00D324  8C430000   LW V1, 0(V0)
9D00D328  97C20028   LHU V0, 40(S8)
9D00D32C  00622021   ADDU A0, V1, V0
9D00D330  3C05A001   LUI A1, -24575
9D00D334  00C01021   ADDU V0, A2, ZERO
9D00D338  00021080   SLL V0, V0, 2
9D00D33C  00021880   SLL V1, V0, 2
9D00D340  00621823   SUBU V1, V1, V0
9D00D344  24A287C0   ADDIU V0, A1, -30784
9D00D348  00621021   ADDU V0, V1, V0
9D00D34C  AC440000   SW A0, 0(V0)
609:                         MPFSStubs[hMPFS].bytesRem -= wLen;
9D00D350  93C50020   LBU A1, 32(S8)
9D00D354  93C20020   LBU V0, 32(S8)
9D00D358  3C03A001   LUI V1, -24575
9D00D35C  246387C0   ADDIU V1, V1, -30784
9D00D360  00021080   SLL V0, V0, 2
9D00D364  00022080   SLL A0, V0, 2
9D00D368  00821023   SUBU V0, A0, V0
9D00D36C  00621021   ADDU V0, V1, V0
9D00D370  8C430004   LW V1, 4(V0)
9D00D374  97C20028   LHU V0, 40(S8)
9D00D378  00621823   SUBU V1, V1, V0
9D00D37C  3C02A001   LUI V0, -24575
9D00D380  244487C0   ADDIU A0, V0, -30784
9D00D384  00A01021   ADDU V0, A1, ZERO
9D00D388  00021080   SLL V0, V0, 2
9D00D38C  00022880   SLL A1, V0, 2
9D00D390  00A21023   SUBU V0, A1, V0
9D00D394  00821021   ADDU V0, A0, V0
9D00D398  AC430004   SW V1, 4(V0)
610:                         return wLen;
9D00D39C  97C20028   LHU V0, 40(S8)
9D00D3A0  0B403525   J 0x9D00D494
9D00D3A4  00000000   NOP
611:                     }
612:                 
613:                     // Read the data
614:                     #if defined(MPFS_USE_EEPROM)
615:                         XEEReadArray(MPFSStubs[hMPFS].addr+MPFS_HEAD, cData, wLen);
616:                         MPFSStubs[hMPFS].addr += wLen;
617:                         MPFSStubs[hMPFS].bytesRem -= wLen;
618:                         lastRead = MPFS_INVALID;
619:                     #elif defined(MPFS_USE_SPI_FLASH)
620:                         SPIFlashReadArray(MPFSStubs[hMPFS].addr+MPFS_HEAD, cData, wLen);
621:                         MPFSStubs[hMPFS].addr += wLen;
622:                         MPFSStubs[hMPFS].bytesRem -= wLen;
623:                     #else
624:                         #if defined(__XC16)
625:                         {
626:                             uint32_t addr;
627:                             TCPIP_UINT32_VAL read;
628:                             uint16_t count;
629:                             uint8_t i;
630:                 
631:                             // MPFS Images are addressed by the byte; Program memory by the word.
632:                             //
633:                             // Flash program memory is 24 bits wide and only even words are
634:                             // implemented.  The upper byte of the upper word is read as 0x00.
635:                             // Address in program memory of any given byte is (MPFSAddr * 2) / 3
636:                             //
637:                             // We will read 24 bits at a time, but need to support using only
638:                             // fractions of the first and last byte.
639:                 
640:                             // Find the beginning address in program memory.
641:                             addr = (MPFSStubs[hMPFS].addr / 3) << 1;
642:                 
643:                             // Find where to start in that first 3 bytes
644:                             read.Val = (addr * 3) >> 1;
645:                             if(read.Val == MPFSStubs[hMPFS].addr)
646:                                 i = 0;
647:                             else if(read.Val+1 == MPFSStubs[hMPFS].addr)
648:                                 i = 1;
649:                             else
650:                                 i = 2;
651:                 
652:                             // Add in the MPFS starting address offset
653:                             addr += MPFS_HEAD;
654:                 
655:                             // Update the MPFS Handle
656:                             MPFSStubs[hMPFS].addr += wLen;
657:                             MPFSStubs[hMPFS].bytesRem -= wLen;
658:                 
659:                             // Read the first uint32_t
660:                             read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
661:                             addr += 2;
662:                 
663:                             // Copy values as needed
664:                             for(count = wLen; count > 0; cData++, count--)
665:                             {
666:                                 // Copy the next value in
667:                                 *cData = read.v[i++];
668:                 
669:                                 // Check if a new uint32_t is needed
670:                                 if(i == 3 && count != 1)
671:                                 {// Read in a new uint32_t
672:                                     read.Val = ReadProgramMemory(addr & 0x00FFFFFF);
673:                                     addr += 2;
674:                                     i = 0;
675:                                 }
676:                             }
677:                 
678:                         }
679:                         #else
680:                         {
681:                             uint32_t dwHITECHWorkaround = MPFS_HEAD;
9D00D3A8  3C029D01   LUI V0, -25343
9D00D3AC  2442B05C   ADDIU V0, V0, -20388
9D00D3B0  AFC20010   SW V0, 16(S8)
682:                             memcpypgm2ram(cData, (ROM void*)(MPFSStubs[hMPFS].addr + dwHITECHWorkaround), wLen);
9D00D3B4  93C20020   LBU V0, 32(S8)
9D00D3B8  3C04A001   LUI A0, -24575
9D00D3BC  00021080   SLL V0, V0, 2
9D00D3C0  00021880   SLL V1, V0, 2
9D00D3C4  00621823   SUBU V1, V1, V0
9D00D3C8  248287C0   ADDIU V0, A0, -30784
9D00D3CC  00621021   ADDU V0, V1, V0
9D00D3D0  8C430000   LW V1, 0(V0)
9D00D3D4  8FC20010   LW V0, 16(S8)
9D00D3D8  00621021   ADDU V0, V1, V0
9D00D3DC  00401821   ADDU V1, V0, ZERO
9D00D3E0  97C20028   LHU V0, 40(S8)
9D00D3E4  8FC40024   LW A0, 36(S8)
9D00D3E8  00602821   ADDU A1, V1, ZERO
9D00D3EC  00403021   ADDU A2, V0, ZERO
9D00D3F0  0F406788   JAL 0x9D019E20
9D00D3F4  00000000   NOP
683:                             MPFSStubs[hMPFS].addr += wLen;
9D00D3F8  93C60020   LBU A2, 32(S8)
9D00D3FC  93C20020   LBU V0, 32(S8)
9D00D400  3C04A001   LUI A0, -24575
9D00D404  00021080   SLL V0, V0, 2
9D00D408  00021880   SLL V1, V0, 2
9D00D40C  00621823   SUBU V1, V1, V0
9D00D410  248287C0   ADDIU V0, A0, -30784
9D00D414  00621021   ADDU V0, V1, V0
9D00D418  8C430000   LW V1, 0(V0)
9D00D41C  97C20028   LHU V0, 40(S8)
9D00D420  00622021   ADDU A0, V1, V0
9D00D424  3C05A001   LUI A1, -24575
9D00D428  00C01021   ADDU V0, A2, ZERO
9D00D42C  00021080   SLL V0, V0, 2
9D00D430  00021880   SLL V1, V0, 2
9D00D434  00621823   SUBU V1, V1, V0
9D00D438  24A287C0   ADDIU V0, A1, -30784
9D00D43C  00621021   ADDU V0, V1, V0
9D00D440  AC440000   SW A0, 0(V0)
684:                             MPFSStubs[hMPFS].bytesRem -= wLen;
9D00D444  93C50020   LBU A1, 32(S8)
9D00D448  93C20020   LBU V0, 32(S8)
9D00D44C  3C03A001   LUI V1, -24575
9D00D450  246387C0   ADDIU V1, V1, -30784
9D00D454  00021080   SLL V0, V0, 2
9D00D458  00022080   SLL A0, V0, 2
9D00D45C  00821023   SUBU V0, A0, V0
9D00D460  00621021   ADDU V0, V1, V0
9D00D464  8C430004   LW V1, 4(V0)
9D00D468  97C20028   LHU V0, 40(S8)
9D00D46C  00621823   SUBU V1, V1, V0
9D00D470  3C02A001   LUI V0, -24575
9D00D474  244487C0   ADDIU A0, V0, -30784
9D00D478  00A01021   ADDU V0, A1, ZERO
9D00D47C  00021080   SLL V0, V0, 2
9D00D480  00022880   SLL A1, V0, 2
9D00D484  00A21023   SUBU V0, A1, V0
9D00D488  00821021   ADDU V0, A0, V0
9D00D48C  AC430004   SW V1, 4(V0)
685:                         }
686:                         #endif
687:                     #endif
688:                 
689:                     return wLen;
9D00D490  97C20028   LHU V0, 40(S8)
690:                 }
9D00D494  03C0E821   ADDU SP, S8, ZERO
9D00D498  8FBF001C   LW RA, 28(SP)
9D00D49C  8FBE0018   LW S8, 24(SP)
9D00D4A0  27BD0020   ADDIU SP, SP, 32
9D00D4A4  03E00008   JR RA
9D00D4A8  00000000   NOP
691:                 
692:                 /*****************************************************************************
693:                   Function:
694:                     bool MPFSGetLong(MPFS_HANDLE hMPFS, uint32_t* ul)
695:                 
696:                   Description:
697:                     Reads a uint32_t or Long value from the MPFS.
698:                 
699:                   Precondition:
700:                     The file handle referenced by hMPFS is already open.
701:                 
702:                   Parameters:
703:                     hMPFS - the file handle from which to read
704:                     ul - where to store the uint32_t or long value that was read
705:                 
706:                   Returns:
707:                     true - The byte was successfully read
708:                     false - No byte was read because either the handle was invalid or
709:                             the end of the file has been reached.
710:                   ***************************************************************************/
711:                 bool MPFSGetLong(MPFS_HANDLE hMPFS, uint32_t* ul)
712:                 {
9D00D4AC  27BDFFE8   ADDIU SP, SP, -24
9D00D4B0  AFBF0014   SW RA, 20(SP)
9D00D4B4  AFBE0010   SW S8, 16(SP)
9D00D4B8  03A0F021   ADDU S8, SP, ZERO
9D00D4BC  00801021   ADDU V0, A0, ZERO
9D00D4C0  AFC5001C   SW A1, 28(S8)
9D00D4C4  A3C20018   SB V0, 24(S8)
713:                     return ( MPFSGetArray(hMPFS, (uint8_t*)ul, 4) == 4u );
9D00D4C8  93C30018   LBU V1, 24(S8)
9D00D4CC  8FC2001C   LW V0, 28(S8)
9D00D4D0  00602021   ADDU A0, V1, ZERO
9D00D4D4  00402821   ADDU A1, V0, ZERO
9D00D4D8  24060004   ADDIU A2, ZERO, 4
9D00D4DC  0F403488   JAL MPFSGetArray
9D00D4E0  00000000   NOP
9D00D4E4  38420004   XORI V0, V0, 4
9D00D4E8  2C420001   SLTIU V0, V0, 1
9D00D4EC  304200FF   ANDI V0, V0, 255
714:                 }
9D00D4F0  03C0E821   ADDU SP, S8, ZERO
9D00D4F4  8FBF0014   LW RA, 20(SP)
9D00D4F8  8FBE0010   LW S8, 16(SP)
9D00D4FC  27BD0018   ADDIU SP, SP, 24
9D00D500  03E00008   JR RA
9D00D504  00000000   NOP
715:                 
716:                 /*****************************************************************************
717:                   Function:
718:                     bool MPFSSeek(MPFS_HANDLE hMPFS, uint32_t dwOffset, MPFS_SEEK_MODE tMode)
719:                 
720:                   Description:
721:                     Moves the current read pointer to a new location.
722:                 
723:                   Precondition:
724:                     The file handle referenced by hMPFS is already open.
725:                 
726:                   Parameters:
727:                     hMPFS - the file handle to seek with
728:                     dwOffset - offset from the specified position in the specified direction
729:                     tMode - one of the MPFS_SEEK_MODE constants
730:                 
731:                   Returns:
732:                     true - the seek was successful
733:                     false - either the new location or the handle itself was invalid
734:                   ***************************************************************************/
735:                 bool MPFSSeek(MPFS_HANDLE hMPFS, uint32_t dwOffset, MPFS_SEEK_MODE tMode)
736:                 {
9D00D508  27BDFFD8   ADDIU SP, SP, -40
9D00D50C  AFBF0024   SW RA, 36(SP)
9D00D510  AFBE0020   SW S8, 32(SP)
9D00D514  AFB0001C   SW S0, 28(SP)
9D00D518  03A0F021   ADDU S8, SP, ZERO
9D00D51C  00801021   ADDU V0, A0, ZERO
9D00D520  AFC5002C   SW A1, 44(S8)
9D00D524  AFC60030   SW A2, 48(S8)
9D00D528  A3C20028   SB V0, 40(S8)
737:                     uint32_t temp;
738:                 
739:                     // Make sure a valid file is open
740:                     if(hMPFS > MAX_MPFS_HANDLES)
9D00D52C  93C20028   LBU V0, 40(S8)
9D00D530  2C420008   SLTIU V0, V0, 8
9D00D534  14400004   BNE V0, ZERO, 0x9D00D548
9D00D538  00000000   NOP
741:                         return false;
9D00D53C  00001021   ADDU V0, ZERO, ZERO
9D00D540  0B40363B   J 0x9D00D8EC
9D00D544  00000000   NOP
742:                     if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00D548  93C20028   LBU V0, 40(S8)
9D00D54C  3C04A001   LUI A0, -24575
9D00D550  00021080   SLL V0, V0, 2
9D00D554  00021880   SLL V1, V0, 2
9D00D558  00621823   SUBU V1, V1, V0
9D00D55C  248287C0   ADDIU V0, A0, -30784
9D00D560  00621021   ADDU V0, V1, V0
9D00D564  8C430000   LW V1, 0(V0)
9D00D568  2402FFFF   ADDIU V0, ZERO, -1
9D00D56C  14620004   BNE V1, V0, 0x9D00D580
9D00D570  00000000   NOP
743:                         return false;
9D00D574  00001021   ADDU V0, ZERO, ZERO
9D00D578  0B40363B   J 0x9D00D8EC
9D00D57C  00000000   NOP
744:                 
745:                     switch(tMode)
9D00D580  8FC20030   LW V0, 48(S8)
9D00D584  24030001   ADDIU V1, ZERO, 1
9D00D588  104300AE   BEQ V0, V1, 0x9D00D844
9D00D58C  00000000   NOP
9D00D590  2C430001   SLTIU V1, V0, 1
9D00D594  14600009   BNE V1, ZERO, 0x9D00D5BC
9D00D598  00000000   NOP
9D00D59C  24030002   ADDIU V1, ZERO, 2
9D00D5A0  10430031   BEQ V0, V1, 0x9D00D668
9D00D5A4  00000000   NOP
9D00D5A8  24030003   ADDIU V1, ZERO, 3
9D00D5AC  10430066   BEQ V0, V1, 0x9D00D748
9D00D5B0  00000000   NOP
9D00D5B4  0B40363A   J 0x9D00D8E8
9D00D5B8  00000000   NOP
746:                     {
747:                         // Seek offset bytes from start
748:                         case MPFS_SEEK_START:
749:                             temp = MPFSGetSize(hMPFS);
9D00D5BC  93C20028   LBU V0, 40(S8)
9D00D5C0  00402021   ADDU A0, V0, ZERO
9D00D5C4  0F403704   JAL MPFSGetSize
9D00D5C8  00000000   NOP
9D00D5CC  AFC20010   SW V0, 16(S8)
750:                             if(dwOffset > temp)
9D00D5D0  8FC3002C   LW V1, 44(S8)
9D00D5D4  8FC20010   LW V0, 16(S8)
9D00D5D8  0043102B   SLTU V0, V0, V1
9D00D5DC  10400004   BEQ V0, ZERO, 0x9D00D5F0
9D00D5E0  00000000   NOP
751:                                 return false;
9D00D5E4  00001021   ADDU V0, ZERO, ZERO
9D00D5E8  0B40363B   J 0x9D00D8EC
9D00D5EC  00000000   NOP
752:                 
753:                             MPFSStubs[hMPFS].addr = MPFSGetStartAddr(hMPFS) + dwOffset;
9D00D5F0  93D00028   LBU S0, 40(S8)
9D00D5F4  93C20028   LBU V0, 40(S8)
9D00D5F8  00402021   ADDU A0, V0, ZERO
9D00D5FC  0F40375A   JAL MPFSGetStartAddr
9D00D600  00000000   NOP
9D00D604  00401821   ADDU V1, V0, ZERO
9D00D608  8FC2002C   LW V0, 44(S8)
9D00D60C  00622021   ADDU A0, V1, V0
9D00D610  3C05A001   LUI A1, -24575
9D00D614  02001021   ADDU V0, S0, ZERO
9D00D618  00021080   SLL V0, V0, 2
9D00D61C  00021880   SLL V1, V0, 2
9D00D620  00621823   SUBU V1, V1, V0
9D00D624  24A287C0   ADDIU V0, A1, -30784
9D00D628  00621021   ADDU V0, V1, V0
9D00D62C  AC440000   SW A0, 0(V0)
754:                             MPFSStubs[hMPFS].bytesRem = temp - dwOffset;
9D00D630  93C20028   LBU V0, 40(S8)
9D00D634  8FC40010   LW A0, 16(S8)
9D00D638  8FC3002C   LW V1, 44(S8)
9D00D63C  00831823   SUBU V1, A0, V1
9D00D640  3C04A001   LUI A0, -24575
9D00D644  248487C0   ADDIU A0, A0, -30784
9D00D648  00021080   SLL V0, V0, 2
9D00D64C  00022880   SLL A1, V0, 2
9D00D650  00A21023   SUBU V0, A1, V0
9D00D654  00821021   ADDU V0, A0, V0
9D00D658  AC430004   SW V1, 4(V0)
755:                             return true;
9D00D65C  24020001   ADDIU V0, ZERO, 1
9D00D660  0B40363B   J 0x9D00D8EC
9D00D664  00000000   NOP
756:                 
757:                         // Seek forwards offset bytes
758:                         case MPFS_SEEK_FORWARD:
759:                             if(dwOffset > MPFSStubs[hMPFS].bytesRem)
9D00D668  93C20028   LBU V0, 40(S8)
9D00D66C  3C03A001   LUI V1, -24575
9D00D670  246387C0   ADDIU V1, V1, -30784
9D00D674  00021080   SLL V0, V0, 2
9D00D678  00022080   SLL A0, V0, 2
9D00D67C  00821023   SUBU V0, A0, V0
9D00D680  00621021   ADDU V0, V1, V0
9D00D684  8C430004   LW V1, 4(V0)
9D00D688  8FC2002C   LW V0, 44(S8)
9D00D68C  0062102B   SLTU V0, V1, V0
9D00D690  10400004   BEQ V0, ZERO, 0x9D00D6A4
9D00D694  00000000   NOP
760:                                 return false;
9D00D698  00001021   ADDU V0, ZERO, ZERO
9D00D69C  0B40363B   J 0x9D00D8EC
9D00D6A0  00000000   NOP
761:                 
762:                             MPFSStubs[hMPFS].addr += dwOffset;
9D00D6A4  93C60028   LBU A2, 40(S8)
9D00D6A8  93C20028   LBU V0, 40(S8)
9D00D6AC  3C04A001   LUI A0, -24575
9D00D6B0  00021080   SLL V0, V0, 2
9D00D6B4  00021880   SLL V1, V0, 2
9D00D6B8  00621823   SUBU V1, V1, V0
9D00D6BC  248287C0   ADDIU V0, A0, -30784
9D00D6C0  00621021   ADDU V0, V1, V0
9D00D6C4  8C430000   LW V1, 0(V0)
9D00D6C8  8FC2002C   LW V0, 44(S8)
9D00D6CC  00622021   ADDU A0, V1, V0
9D00D6D0  3C05A001   LUI A1, -24575
9D00D6D4  00C01021   ADDU V0, A2, ZERO
9D00D6D8  00021080   SLL V0, V0, 2
9D00D6DC  00021880   SLL V1, V0, 2
9D00D6E0  00621823   SUBU V1, V1, V0
9D00D6E4  24A287C0   ADDIU V0, A1, -30784
9D00D6E8  00621021   ADDU V0, V1, V0
9D00D6EC  AC440000   SW A0, 0(V0)
763:                             MPFSStubs[hMPFS].bytesRem -= dwOffset;
9D00D6F0  93C50028   LBU A1, 40(S8)
9D00D6F4  93C20028   LBU V0, 40(S8)
9D00D6F8  3C03A001   LUI V1, -24575
9D00D6FC  246387C0   ADDIU V1, V1, -30784
9D00D700  00021080   SLL V0, V0, 2
9D00D704  00022080   SLL A0, V0, 2
9D00D708  00821023   SUBU V0, A0, V0
9D00D70C  00621021   ADDU V0, V1, V0
9D00D710  8C430004   LW V1, 4(V0)
9D00D714  8FC2002C   LW V0, 44(S8)
9D00D718  00621823   SUBU V1, V1, V0
9D00D71C  3C02A001   LUI V0, -24575
9D00D720  244487C0   ADDIU A0, V0, -30784
9D00D724  00A01021   ADDU V0, A1, ZERO
9D00D728  00021080   SLL V0, V0, 2
9D00D72C  00022880   SLL A1, V0, 2
9D00D730  00A21023   SUBU V0, A1, V0
9D00D734  00821021   ADDU V0, A0, V0
9D00D738  AC430004   SW V1, 4(V0)
764:                             return true;
9D00D73C  24020001   ADDIU V0, ZERO, 1
9D00D740  0B40363B   J 0x9D00D8EC
9D00D744  00000000   NOP
765:                 
766:                         // Seek backwards offset bytes
767:                         case MPFS_SEEK_REWIND:
768:                             temp = MPFSGetStartAddr(hMPFS);
9D00D748  93C20028   LBU V0, 40(S8)
9D00D74C  00402021   ADDU A0, V0, ZERO
9D00D750  0F40375A   JAL MPFSGetStartAddr
9D00D754  00000000   NOP
9D00D758  AFC20010   SW V0, 16(S8)
769:                             if(MPFSStubs[hMPFS].addr < temp + dwOffset)
9D00D75C  93C20028   LBU V0, 40(S8)
9D00D760  3C04A001   LUI A0, -24575
9D00D764  00021080   SLL V0, V0, 2
9D00D768  00021880   SLL V1, V0, 2
9D00D76C  00621823   SUBU V1, V1, V0
9D00D770  248287C0   ADDIU V0, A0, -30784
9D00D774  00621021   ADDU V0, V1, V0
9D00D778  8C430000   LW V1, 0(V0)
9D00D77C  8FC40010   LW A0, 16(S8)
9D00D780  8FC2002C   LW V0, 44(S8)
9D00D784  00821021   ADDU V0, A0, V0
9D00D788  0062102B   SLTU V0, V1, V0
9D00D78C  10400004   BEQ V0, ZERO, 0x9D00D7A0
9D00D790  00000000   NOP
770:                                 return false;
9D00D794  00001021   ADDU V0, ZERO, ZERO
9D00D798  0B40363B   J 0x9D00D8EC
9D00D79C  00000000   NOP
771:                 
772:                             MPFSStubs[hMPFS].addr -= dwOffset;
9D00D7A0  93C60028   LBU A2, 40(S8)
9D00D7A4  93C20028   LBU V0, 40(S8)
9D00D7A8  3C04A001   LUI A0, -24575
9D00D7AC  00021080   SLL V0, V0, 2
9D00D7B0  00021880   SLL V1, V0, 2
9D00D7B4  00621823   SUBU V1, V1, V0
9D00D7B8  248287C0   ADDIU V0, A0, -30784
9D00D7BC  00621021   ADDU V0, V1, V0
9D00D7C0  8C430000   LW V1, 0(V0)
9D00D7C4  8FC2002C   LW V0, 44(S8)
9D00D7C8  00622023   SUBU A0, V1, V0
9D00D7CC  3C05A001   LUI A1, -24575
9D00D7D0  00C01021   ADDU V0, A2, ZERO
9D00D7D4  00021080   SLL V0, V0, 2
9D00D7D8  00021880   SLL V1, V0, 2
9D00D7DC  00621823   SUBU V1, V1, V0
9D00D7E0  24A287C0   ADDIU V0, A1, -30784
9D00D7E4  00621021   ADDU V0, V1, V0
9D00D7E8  AC440000   SW A0, 0(V0)
773:                             MPFSStubs[hMPFS].bytesRem += dwOffset;
9D00D7EC  93C50028   LBU A1, 40(S8)
9D00D7F0  93C20028   LBU V0, 40(S8)
9D00D7F4  3C03A001   LUI V1, -24575
9D00D7F8  246387C0   ADDIU V1, V1, -30784
9D00D7FC  00021080   SLL V0, V0, 2
9D00D800  00022080   SLL A0, V0, 2
9D00D804  00821023   SUBU V0, A0, V0
9D00D808  00621021   ADDU V0, V1, V0
9D00D80C  8C430004   LW V1, 4(V0)
9D00D810  8FC2002C   LW V0, 44(S8)
9D00D814  00621821   ADDU V1, V1, V0
9D00D818  3C02A001   LUI V0, -24575
9D00D81C  244487C0   ADDIU A0, V0, -30784
9D00D820  00A01021   ADDU V0, A1, ZERO
9D00D824  00021080   SLL V0, V0, 2
9D00D828  00022880   SLL A1, V0, 2
9D00D82C  00A21023   SUBU V0, A1, V0
9D00D830  00821021   ADDU V0, A0, V0
9D00D834  AC430004   SW V1, 4(V0)
774:                             return true;
9D00D838  24020001   ADDIU V0, ZERO, 1
9D00D83C  0B40363B   J 0x9D00D8EC
9D00D840  00000000   NOP
775:                 
776:                         // Seek so that offset bytes remain in file
777:                         case MPFS_SEEK_END:
778:                             temp = MPFSGetSize(hMPFS);
9D00D844  93C20028   LBU V0, 40(S8)
9D00D848  00402021   ADDU A0, V0, ZERO
9D00D84C  0F403704   JAL MPFSGetSize
9D00D850  00000000   NOP
9D00D854  AFC20010   SW V0, 16(S8)
779:                             if(dwOffset > temp)
9D00D858  8FC3002C   LW V1, 44(S8)
9D00D85C  8FC20010   LW V0, 16(S8)
9D00D860  0043102B   SLTU V0, V0, V1
9D00D864  10400004   BEQ V0, ZERO, 0x9D00D878
9D00D868  00000000   NOP
780:                                 return false;
9D00D86C  00001021   ADDU V0, ZERO, ZERO
9D00D870  0B40363B   J 0x9D00D8EC
9D00D874  00000000   NOP
781:                 
782:                             MPFSStubs[hMPFS].addr = MPFSGetEndAddr(hMPFS) - dwOffset;
9D00D878  93D00028   LBU S0, 40(S8)
9D00D87C  93C20028   LBU V0, 40(S8)
9D00D880  00402021   ADDU A0, V0, ZERO
9D00D884  0F403789   JAL MPFSGetEndAddr
9D00D888  00000000   NOP
9D00D88C  00401821   ADDU V1, V0, ZERO
9D00D890  8FC2002C   LW V0, 44(S8)
9D00D894  00622023   SUBU A0, V1, V0
9D00D898  3C05A001   LUI A1, -24575
9D00D89C  02001021   ADDU V0, S0, ZERO
9D00D8A0  00021080   SLL V0, V0, 2
9D00D8A4  00021880   SLL V1, V0, 2
9D00D8A8  00621823   SUBU V1, V1, V0
9D00D8AC  24A287C0   ADDIU V0, A1, -30784
9D00D8B0  00621021   ADDU V0, V1, V0
9D00D8B4  AC440000   SW A0, 0(V0)
783:                             MPFSStubs[hMPFS].bytesRem = dwOffset;
9D00D8B8  93C20028   LBU V0, 40(S8)
9D00D8BC  3C03A001   LUI V1, -24575
9D00D8C0  246387C0   ADDIU V1, V1, -30784
9D00D8C4  00021080   SLL V0, V0, 2
9D00D8C8  00022080   SLL A0, V0, 2
9D00D8CC  00821023   SUBU V0, A0, V0
9D00D8D0  00621021   ADDU V0, V1, V0
9D00D8D4  8FC3002C   LW V1, 44(S8)
9D00D8D8  AC430004   SW V1, 4(V0)
784:                             return true;
9D00D8DC  24020001   ADDIU V0, ZERO, 1
9D00D8E0  0B40363B   J 0x9D00D8EC
9D00D8E4  00000000   NOP
785:                 
786:                         default:
787:                             return false;
9D00D8E8  00001021   ADDU V0, ZERO, ZERO
788:                     }
789:                 }
9D00D8EC  03C0E821   ADDU SP, S8, ZERO
9D00D8F0  8FBF0024   LW RA, 36(SP)
9D00D8F4  8FBE0020   LW S8, 32(SP)
9D00D8F8  8FB0001C   LW S0, 28(SP)
9D00D8FC  27BD0028   ADDIU SP, SP, 40
9D00D900  03E00008   JR RA
9D00D904  00000000   NOP
790:                 
791:                 
792:                 /****************************************************************************
793:                   Section:
794:                     Data Writing Functions
795:                   ***************************************************************************/
796:                 
797:                 /*****************************************************************************
798:                   Function:
799:                     MPFS_HANDLE MPFSFormat(void)
800:                 
801:                   Summary:
802:                     Prepares the MPFS image for writing.
803:                 
804:                   Description:
805:                     Prepares the MPFS image for writing and locks the image so that other
806:                     processes may not access it.
807:                 
808:                   Precondition:
809:                     None
810:                 
811:                   Parameters:
812:                     None
813:                 
814:                   Returns:
815:                     An MPFS handle that can be used for MPFSPut commands, or
816:                     MPFS_INVALID_HANDLE when the EEPROM failed to initialize for writing.
817:                 
818:                   Remarks:
819:                     In order to prevent misreads, the MPFS will be inaccessible until
820:                     MPFSClose is called.  This function is not available when the MPFS
821:                     is stored in internal Flash program memory.
822:                   ***************************************************************************/
823:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
824:                 MPFS_HANDLE MPFSFormat(void)
825:                 {
826:                 
827:                     uint8_t i;
828:                 
829:                     // Close all files
830:                     for(i = 0; i < MAX_MPFS_HANDLES; i++)
831:                         MPFSStubs[i].addr = MPFS_INVALID;
832:                 
833:                     // Lock the image
834:                     isMPFSLocked = true;
835:                 
836:                     #if defined(MPFS_USE_EEPROM)
837:                         // Set FAT ptr for writing
838:                         MPFSStubs[0].addr = 0;
839:                         MPFSStubs[0].fatID = 0xffff;
840:                         MPFSStubs[0].bytesRem = MPFS_WRITE_PAGE_SIZE - ( ((uint8_t)MPFSStubs[0].addr+MPFS_HEAD) & (MPFS_WRITE_PAGE_SIZE-1) );
841:                 
842:                         // Set up EEPROM for writing
843:                         if( XEEBeginWrite(MPFSStubs[0].addr+MPFS_HEAD) == XEE_SUCCESS )
844:                             return 0x00;
845:                 
846:                         return MPFS_INVALID_HANDLE;
847:                     #else
848:                         // Set up SPI Flash for writing
849:                         SPIFlashBeginWrite(MPFS_HEAD);
850:                         return 0x00;
851:                     #endif
852:                 }
853:                 #endif
854:                 
855:                 /*****************************************************************************
856:                   Function:
857:                     uint16_t MPFSPutArray(MPFS_HANDLE hMPFS, uint8_t *cData, uint16_t wLen)
858:                 
859:                   Description:
860:                     Writes an array of data to the MPFS image.
861:                 
862:                   Precondition:
863:                     MPFSFormat was sucessfully called.
864:                 
865:                   Parameters:
866:                     hMPFS - the file handle for writing
867:                     cData - the array of bytes to write
868:                     wLen - how many bytes to write
869:                 
870:                   Returns:
871:                     The number of bytes successfully written.
872:                 
873:                   Remarks:
874:                     For EEPROM, the actual write may not initialize until the internal write
875:                     page is full.  To ensure that previously written data gets stored,
876:                     MPFSPutEnd must be called after the last call to MPFSPutArray.
877:                   ***************************************************************************/
878:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
879:                 uint16_t MPFSPutArray(MPFS_HANDLE hMPFS, uint8_t* cData, uint16_t wLen)
880:                 {
881:                     #if defined(MPFS_USE_EEPROM)
882:                         // Write to the EEPROM
883:                         uint16_t count;
884:                 
885:                         for(count = 0; count < wLen; count++)
886:                         {
887:                             XEEWrite(cData[count]);
888:                 
889:                             MPFSStubs[hMPFS].addr++;
890:                             MPFSStubs[hMPFS].bytesRem--;
891:                 
892:                             if(MPFSStubs[hMPFS].bytesRem == 0u)
893:                             {
894:                                 MPFSPutEnd(false);
895:                                 isMPFSLocked = true;
896:                                 XEEBeginWrite(MPFSStubs[hMPFS].addr+MPFS_HEAD);
897:                                 MPFSStubs[hMPFS].bytesRem = MPFS_WRITE_PAGE_SIZE;
898:                             }
899:                         }
900:                 
901:                         return count;
902:                 
903:                     #else
904:                         // Write to the SPI Flash
905:                         SPIFlashWriteArray(cData, wLen);
906:                         return wLen;
907:                     #endif
908:                 }
909:                 #endif
910:                 
911:                 /*****************************************************************************
912:                   Function:
913:                     void MPFSPutEnd(void)
914:                 
915:                   Description:
916:                     Finalizes an MPFS writing operation.
917:                 
918:                   Precondition:
919:                     MPFSFormat and MPFSPutArray were sucessfully called.
920:                 
921:                   Parameters:
922:                     final - true if the application is done writing, false if MPFS2 called
923:                         this function locally.
924:                 
925:                   Returns:
926:                     None
927:                   ***************************************************************************/
928:                 #if defined(MPFS_USE_EEPROM) || defined(MPFS_USE_SPI_FLASH)
929:                 void MPFSPutEnd(bool final)
930:                 {
931:                     isMPFSLocked = false;
932:                 
933:                     #if defined(MPFS_USE_EEPROM)
934:                         XEEEndWrite();
935:                         while(XEEIsBusy());
936:                     #endif
937:                 
938:                     if(final)
939:                         _Validate();
940:                 }
941:                 #endif
942:                 
943:                 
944:                 /****************************************************************************
945:                   Section:
946:                     Meta Data Accessors
947:                   ***************************************************************************/
948:                 
949:                 /*****************************************************************************
950:                   Function:
951:                     static void _LoadFATRecord(uint16_t fatID)
952:                 
953:                   Description:
954:                     Loads the FAT record for a specified handle.
955:                 
956:                   Precondition:
957:                     None
958:                 
959:                   Parameters:
960:                     fatID - the ID of the file whose FAT is to be loaded
961:                 
962:                   Returns:
963:                     None
964:                 
965:                   Remarks:
966:                     The FAT record will be stored in fatCache.
967:                   ***************************************************************************/
968:                 static void _LoadFATRecord(uint16_t fatID)
969:                 {
9D00D908  27BDFFE8   ADDIU SP, SP, -24
9D00D90C  AFBF0014   SW RA, 20(SP)
9D00D910  AFBE0010   SW S8, 16(SP)
9D00D914  03A0F021   ADDU S8, SP, ZERO
9D00D918  00801021   ADDU V0, A0, ZERO
9D00D91C  A7C20018   SH V0, 24(S8)
970:                     if(fatID == fatCacheID || fatID >= numFiles)
9D00D920  9782809E   LHU V0, -32610(GP)
9D00D924  97C30018   LHU V1, 24(S8)
9D00D928  10620022   BEQ V1, V0, 0x9D00D9B4
9D00D92C  00000000   NOP
9D00D930  978280A0   LHU V0, -32608(GP)
9D00D934  97C30018   LHU V1, 24(S8)
9D00D938  0062102B   SLTU V0, V1, V0
9D00D93C  10400020   BEQ V0, ZERO, 0x9D00D9C0
9D00D940  00000000   NOP
971:                         return;
9D00D9B4  00000000   NOP
9D00D9B8  0B403671   J 0x9D00D9C4
9D00D9BC  00000000   NOP
9D00D9C0  00000000   NOP
972:                 
973:                     // Read the FAT record to the cache
974:                     MPFSStubs[0].bytesRem = 22;
9D00D944  3C02A001   LUI V0, -24575
9D00D948  244287C0   ADDIU V0, V0, -30784
9D00D94C  24030016   ADDIU V1, ZERO, 22
9D00D950  AC430004   SW V1, 4(V0)
975:                     MPFSStubs[0].addr = 8 + numFiles*2 + fatID*22;
9D00D954  978280A0   LHU V0, -32608(GP)
9D00D958  24450004   ADDIU A1, V0, 4
9D00D95C  97C40018   LHU A0, 24(S8)
9D00D960  00801021   ADDU V0, A0, ZERO
9D00D964  00021080   SLL V0, V0, 2
9D00D968  00021880   SLL V1, V0, 2
9D00D96C  00621823   SUBU V1, V1, V0
9D00D970  00641023   SUBU V0, V1, A0
9D00D974  00A21021   ADDU V0, A1, V0
9D00D978  00021040   SLL V0, V0, 1
9D00D97C  00401821   ADDU V1, V0, ZERO
9D00D980  3C02A001   LUI V0, -24575
9D00D984  AC4387C0   SW V1, -30784(V0)
976:                     MPFSGetArray(0, (uint8_t*)&fatCache, 22);
9D00D988  3C02A001   LUI V0, -24575
9D00D98C  24428820   ADDIU V0, V0, -30688
9D00D990  00002021   ADDU A0, ZERO, ZERO
9D00D994  00402821   ADDU A1, V0, ZERO
9D00D998  24060016   ADDIU A2, ZERO, 22
9D00D99C  0F403488   JAL MPFSGetArray
9D00D9A0  00000000   NOP
977:                     fatCacheID = fatID;
9D00D9A4  97C20018   LHU V0, 24(S8)
9D00D9A8  A782809E   SH V0, -32610(GP)
9D00D9AC  0B403671   J 0x9D00D9C4
9D00D9B0  00000000   NOP
978:                 }
9D00D9C4  03C0E821   ADDU SP, S8, ZERO
9D00D9C8  8FBF0014   LW RA, 20(SP)
9D00D9CC  8FBE0010   LW S8, 16(SP)
9D00D9D0  27BD0018   ADDIU SP, SP, 24
9D00D9D4  03E00008   JR RA
9D00D9D8  00000000   NOP
979:                 
980:                 /*****************************************************************************
981:                   Function:
982:                     uint32_t MPFSGetTimestamp(MPFS_HANDLE hMPFS)
983:                 
984:                   Description:
985:                     Reads the timestamp for the specified file.
986:                 
987:                   Precondition:
988:                     The file handle referenced by hMPFS is already open.
989:                 
990:                   Parameters:
991:                     hMPFS - the file handle from which to read the metadata
992:                 
993:                   Returns:
994:                     The timestamp that was read as a uint32_t
995:                   ***************************************************************************/
996:                 uint32_t MPFSGetTimestamp(MPFS_HANDLE hMPFS)
997:                 {
9D00D9DC  27BDFFE8   ADDIU SP, SP, -24
9D00D9E0  AFBF0014   SW RA, 20(SP)
9D00D9E4  AFBE0010   SW S8, 16(SP)
9D00D9E8  03A0F021   ADDU S8, SP, ZERO
9D00D9EC  00801021   ADDU V0, A0, ZERO
9D00D9F0  A3C20018   SB V0, 24(S8)
998:                     // Make sure a valid file is open
999:                     if(hMPFS > MAX_MPFS_HANDLES)
9D00D9F4  93C20018   LBU V0, 24(S8)
9D00D9F8  2C420008   SLTIU V0, V0, 8
9D00D9FC  14400004   BNE V0, ZERO, 0x9D00DA10
9D00DA00  00000000   NOP
1000:                        return 0x00000000;
9D00DA04  00001021   ADDU V0, ZERO, ZERO
9D00DA08  0B4036A0   J 0x9D00DA80
9D00DA0C  00000000   NOP
1001:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DA10  93C20018   LBU V0, 24(S8)
9D00DA14  3C04A001   LUI A0, -24575
9D00DA18  00021080   SLL V0, V0, 2
9D00DA1C  00021880   SLL V1, V0, 2
9D00DA20  00621823   SUBU V1, V1, V0
9D00DA24  248287C0   ADDIU V0, A0, -30784
9D00DA28  00621021   ADDU V0, V1, V0
9D00DA2C  8C430000   LW V1, 0(V0)
9D00DA30  2402FFFF   ADDIU V0, ZERO, -1
9D00DA34  14620004   BNE V1, V0, 0x9D00DA48
9D00DA38  00000000   NOP
1002:                        return 0x00000000;
9D00DA3C  00001021   ADDU V0, ZERO, ZERO
9D00DA40  0B4036A0   J 0x9D00DA80
9D00DA44  00000000   NOP
1003:                
1004:                    // Move to the point for reading
1005:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DA48  93C20018   LBU V0, 24(S8)
9D00DA4C  3C04A001   LUI A0, -24575
9D00DA50  00021080   SLL V0, V0, 2
9D00DA54  00021880   SLL V1, V0, 2
9D00DA58  00621823   SUBU V1, V1, V0
9D00DA5C  248287C0   ADDIU V0, A0, -30784
9D00DA60  00621021   ADDU V0, V1, V0
9D00DA64  94420008   LHU V0, 8(V0)
9D00DA68  00402021   ADDU A0, V0, ZERO
9D00DA6C  0F403642   JAL 0x9D00D908
9D00DA70  00000000   NOP
1006:                    return fatCache.timestamp;
9D00DA74  3C02A001   LUI V0, -24575
9D00DA78  24428820   ADDIU V0, V0, -30688
9D00DA7C  8C42000C   LW V0, 12(V0)
1007:                }
9D00DA80  03C0E821   ADDU SP, S8, ZERO
9D00DA84  8FBF0014   LW RA, 20(SP)
9D00DA88  8FBE0010   LW S8, 16(SP)
9D00DA8C  27BD0018   ADDIU SP, SP, 24
9D00DA90  03E00008   JR RA
9D00DA94  00000000   NOP
1008:                
1009:                /*****************************************************************************
1010:                  Function:
1011:                    uint32_t MPFSGetMicrotime(MPFS_HANDLE hMPFS)
1012:                
1013:                  Description:
1014:                    Reads the microtime portion of a file's timestamp.
1015:                
1016:                  Precondition:
1017:                    The file handle referenced by hMPFS is already open.
1018:                
1019:                  Parameters:
1020:                    hMPFS - the file handle from which to read the metadata
1021:                
1022:                  Returns:
1023:                    The microtime that was read as a uint32_t
1024:                  ***************************************************************************/
1025:                uint32_t MPFSGetMicrotime(MPFS_HANDLE hMPFS)
1026:                {
9D00DA98  27BDFFE8   ADDIU SP, SP, -24
9D00DA9C  AFBF0014   SW RA, 20(SP)
9D00DAA0  AFBE0010   SW S8, 16(SP)
9D00DAA4  03A0F021   ADDU S8, SP, ZERO
9D00DAA8  00801021   ADDU V0, A0, ZERO
9D00DAAC  A3C20018   SB V0, 24(S8)
1027:                    // Make sure a valid file is open
1028:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DAB0  93C20018   LBU V0, 24(S8)
9D00DAB4  2C420008   SLTIU V0, V0, 8
9D00DAB8  14400004   BNE V0, ZERO, 0x9D00DACC
9D00DABC  00000000   NOP
1029:                        return 0x00000000;
9D00DAC0  00001021   ADDU V0, ZERO, ZERO
9D00DAC4  0B4036CF   J 0x9D00DB3C
9D00DAC8  00000000   NOP
1030:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DACC  93C20018   LBU V0, 24(S8)
9D00DAD0  3C04A001   LUI A0, -24575
9D00DAD4  00021080   SLL V0, V0, 2
9D00DAD8  00021880   SLL V1, V0, 2
9D00DADC  00621823   SUBU V1, V1, V0
9D00DAE0  248287C0   ADDIU V0, A0, -30784
9D00DAE4  00621021   ADDU V0, V1, V0
9D00DAE8  8C430000   LW V1, 0(V0)
9D00DAEC  2402FFFF   ADDIU V0, ZERO, -1
9D00DAF0  14620004   BNE V1, V0, 0x9D00DB04
9D00DAF4  00000000   NOP
1031:                        return 0x00000000;
9D00DAF8  00001021   ADDU V0, ZERO, ZERO
9D00DAFC  0B4036CF   J 0x9D00DB3C
9D00DB00  00000000   NOP
1032:                
1033:                    // Move to the point for reading
1034:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DB04  93C20018   LBU V0, 24(S8)
9D00DB08  3C04A001   LUI A0, -24575
9D00DB0C  00021080   SLL V0, V0, 2
9D00DB10  00021880   SLL V1, V0, 2
9D00DB14  00621823   SUBU V1, V1, V0
9D00DB18  248287C0   ADDIU V0, A0, -30784
9D00DB1C  00621021   ADDU V0, V1, V0
9D00DB20  94420008   LHU V0, 8(V0)
9D00DB24  00402021   ADDU A0, V0, ZERO
9D00DB28  0F403642   JAL 0x9D00D908
9D00DB2C  00000000   NOP
1035:                    return fatCache.microtime;
9D00DB30  3C02A001   LUI V0, -24575
9D00DB34  24428820   ADDIU V0, V0, -30688
9D00DB38  8C420010   LW V0, 16(V0)
1036:                }
9D00DB3C  03C0E821   ADDU SP, S8, ZERO
9D00DB40  8FBF0014   LW RA, 20(SP)
9D00DB44  8FBE0010   LW S8, 16(SP)
9D00DB48  27BD0018   ADDIU SP, SP, 24
9D00DB4C  03E00008   JR RA
9D00DB50  00000000   NOP
1037:                
1038:                /*****************************************************************************
1039:                  Function:
1040:                    uint16_t MPFSGetFlags(MPFS_HANDLE hMPFS)
1041:                
1042:                  Description:
1043:                    Reads a file's flags.
1044:                
1045:                  Precondition:
1046:                    The file handle referenced by hMPFS is already open.
1047:                
1048:                  Parameters:
1049:                    hMPFS - the file handle from which to read the metadata
1050:                
1051:                  Returns:
1052:                    The flags that were associated with the file
1053:                  ***************************************************************************/
1054:                uint16_t MPFSGetFlags(MPFS_HANDLE hMPFS)
1055:                {
9D00DB54  27BDFFE8   ADDIU SP, SP, -24
9D00DB58  AFBF0014   SW RA, 20(SP)
9D00DB5C  AFBE0010   SW S8, 16(SP)
9D00DB60  03A0F021   ADDU S8, SP, ZERO
9D00DB64  00801021   ADDU V0, A0, ZERO
9D00DB68  A3C20018   SB V0, 24(S8)
1056:                    // Make sure a valid file is open
1057:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DB6C  93C20018   LBU V0, 24(S8)
9D00DB70  2C420008   SLTIU V0, V0, 8
9D00DB74  14400004   BNE V0, ZERO, 0x9D00DB88
9D00DB78  00000000   NOP
1058:                        return 0x0000;
9D00DB7C  00001021   ADDU V0, ZERO, ZERO
9D00DB80  0B4036FE   J 0x9D00DBF8
9D00DB84  00000000   NOP
1059:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DB88  93C20018   LBU V0, 24(S8)
9D00DB8C  3C04A001   LUI A0, -24575
9D00DB90  00021080   SLL V0, V0, 2
9D00DB94  00021880   SLL V1, V0, 2
9D00DB98  00621823   SUBU V1, V1, V0
9D00DB9C  248287C0   ADDIU V0, A0, -30784
9D00DBA0  00621021   ADDU V0, V1, V0
9D00DBA4  8C430000   LW V1, 0(V0)
9D00DBA8  2402FFFF   ADDIU V0, ZERO, -1
9D00DBAC  14620004   BNE V1, V0, 0x9D00DBC0
9D00DBB0  00000000   NOP
1060:                        return 0x0000;
9D00DBB4  00001021   ADDU V0, ZERO, ZERO
9D00DBB8  0B4036FE   J 0x9D00DBF8
9D00DBBC  00000000   NOP
1061:                
1062:                    //move to the point for reading
1063:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DBC0  93C20018   LBU V0, 24(S8)
9D00DBC4  3C04A001   LUI A0, -24575
9D00DBC8  00021080   SLL V0, V0, 2
9D00DBCC  00021880   SLL V1, V0, 2
9D00DBD0  00621823   SUBU V1, V1, V0
9D00DBD4  248287C0   ADDIU V0, A0, -30784
9D00DBD8  00621021   ADDU V0, V1, V0
9D00DBDC  94420008   LHU V0, 8(V0)
9D00DBE0  00402021   ADDU A0, V0, ZERO
9D00DBE4  0F403642   JAL 0x9D00D908
9D00DBE8  00000000   NOP
1064:                    return fatCache.flags;
9D00DBEC  3C02A001   LUI V0, -24575
9D00DBF0  24428820   ADDIU V0, V0, -30688
9D00DBF4  94420014   LHU V0, 20(V0)
1065:                }
9D00DBF8  03C0E821   ADDU SP, S8, ZERO
9D00DBFC  8FBF0014   LW RA, 20(SP)
9D00DC00  8FBE0010   LW S8, 16(SP)
9D00DC04  27BD0018   ADDIU SP, SP, 24
9D00DC08  03E00008   JR RA
9D00DC0C  00000000   NOP
1066:                
1067:                /*****************************************************************************
1068:                  Function:
1069:                    uint32_t MPFSGetSize(MPFS_HANDLE hMPFS)
1070:                
1071:                  Description:
1072:                    Reads the size of a file.
1073:                
1074:                  Precondition:
1075:                    The file handle referenced by hMPFS is already open.
1076:                
1077:                  Parameters:
1078:                    hMPFS - the file handle from which to read the metadata
1079:                
1080:                  Returns:
1081:                    The size that was read as a uint32_t
1082:                  ***************************************************************************/
1083:                uint32_t MPFSGetSize(MPFS_HANDLE hMPFS)
1084:                {
9D00DC10  27BDFFE8   ADDIU SP, SP, -24
9D00DC14  AFBF0014   SW RA, 20(SP)
9D00DC18  AFBE0010   SW S8, 16(SP)
9D00DC1C  03A0F021   ADDU S8, SP, ZERO
9D00DC20  00801021   ADDU V0, A0, ZERO
9D00DC24  A3C20018   SB V0, 24(S8)
1085:                    // Make sure a valid file is open
1086:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DC28  93C20018   LBU V0, 24(S8)
9D00DC2C  2C420008   SLTIU V0, V0, 8
9D00DC30  14400004   BNE V0, ZERO, 0x9D00DC44
9D00DC34  00000000   NOP
1087:                        return 0x00000000;
9D00DC38  00001021   ADDU V0, ZERO, ZERO
9D00DC3C  0B40372D   J 0x9D00DCB4
9D00DC40  00000000   NOP
1088:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DC44  93C20018   LBU V0, 24(S8)
9D00DC48  3C04A001   LUI A0, -24575
9D00DC4C  00021080   SLL V0, V0, 2
9D00DC50  00021880   SLL V1, V0, 2
9D00DC54  00621823   SUBU V1, V1, V0
9D00DC58  248287C0   ADDIU V0, A0, -30784
9D00DC5C  00621021   ADDU V0, V1, V0
9D00DC60  8C430000   LW V1, 0(V0)
9D00DC64  2402FFFF   ADDIU V0, ZERO, -1
9D00DC68  14620004   BNE V1, V0, 0x9D00DC7C
9D00DC6C  00000000   NOP
1089:                        return 0x00000000;
9D00DC70  00001021   ADDU V0, ZERO, ZERO
9D00DC74  0B40372D   J 0x9D00DCB4
9D00DC78  00000000   NOP
1090:                
1091:                    // Move to the point for reading
1092:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DC7C  93C20018   LBU V0, 24(S8)
9D00DC80  3C04A001   LUI A0, -24575
9D00DC84  00021080   SLL V0, V0, 2
9D00DC88  00021880   SLL V1, V0, 2
9D00DC8C  00621823   SUBU V1, V1, V0
9D00DC90  248287C0   ADDIU V0, A0, -30784
9D00DC94  00621021   ADDU V0, V1, V0
9D00DC98  94420008   LHU V0, 8(V0)
9D00DC9C  00402021   ADDU A0, V0, ZERO
9D00DCA0  0F403642   JAL 0x9D00D908
9D00DCA4  00000000   NOP
1093:                    return fatCache.len;
9D00DCA8  3C02A001   LUI V0, -24575
9D00DCAC  24428820   ADDIU V0, V0, -30688
9D00DCB0  8C420008   LW V0, 8(V0)
1094:                }
9D00DCB4  03C0E821   ADDU SP, S8, ZERO
9D00DCB8  8FBF0014   LW RA, 20(SP)
9D00DCBC  8FBE0010   LW S8, 16(SP)
9D00DCC0  27BD0018   ADDIU SP, SP, 24
9D00DCC4  03E00008   JR RA
9D00DCC8  00000000   NOP
1095:                
1096:                /*****************************************************************************
1097:                  Function:
1098:                    uint32_t MPFSGetBytesRem(MPFS_HANDLE hMPFS)
1099:                
1100:                  Description:
1101:                    Determines how many bytes remain to be read.
1102:                
1103:                  Precondition:
1104:                    The file handle referenced by hMPFS is already open.
1105:                
1106:                  Parameters:
1107:                    hMPFS - the file handle from which to read the metadata
1108:                
1109:                  Returns:
1110:                    The number of bytes remaining in the file as a uint32_t
1111:                  ***************************************************************************/
1112:                uint32_t MPFSGetBytesRem(MPFS_HANDLE hMPFS)
1113:                {
9D00DCCC  27BDFFF8   ADDIU SP, SP, -8
9D00DCD0  AFBE0004   SW S8, 4(SP)
9D00DCD4  03A0F021   ADDU S8, SP, ZERO
9D00DCD8  00801021   ADDU V0, A0, ZERO
9D00DCDC  A3C20008   SB V0, 8(S8)
1114:                    // Make sure a valid file is open
1115:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DCE0  93C20008   LBU V0, 8(S8)
9D00DCE4  2C420008   SLTIU V0, V0, 8
9D00DCE8  14400004   BNE V0, ZERO, 0x9D00DCFC
9D00DCEC  00000000   NOP
1116:                        return 0x00000000;
9D00DCF0  00001021   ADDU V0, ZERO, ZERO
9D00DCF4  0B403755   J 0x9D00DD54
9D00DCF8  00000000   NOP
1117:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DCFC  93C20008   LBU V0, 8(S8)
9D00DD00  3C04A001   LUI A0, -24575
9D00DD04  00021080   SLL V0, V0, 2
9D00DD08  00021880   SLL V1, V0, 2
9D00DD0C  00621823   SUBU V1, V1, V0
9D00DD10  248287C0   ADDIU V0, A0, -30784
9D00DD14  00621021   ADDU V0, V1, V0
9D00DD18  8C430000   LW V1, 0(V0)
9D00DD1C  2402FFFF   ADDIU V0, ZERO, -1
9D00DD20  14620004   BNE V1, V0, 0x9D00DD34
9D00DD24  00000000   NOP
1118:                        return 0x00000000;
9D00DD28  00001021   ADDU V0, ZERO, ZERO
9D00DD2C  0B403755   J 0x9D00DD54
9D00DD30  00000000   NOP
1119:                
1120:                    return MPFSStubs[hMPFS].bytesRem;
9D00DD34  93C20008   LBU V0, 8(S8)
9D00DD38  3C03A001   LUI V1, -24575
9D00DD3C  246387C0   ADDIU V1, V1, -30784
9D00DD40  00021080   SLL V0, V0, 2
9D00DD44  00022080   SLL A0, V0, 2
9D00DD48  00821023   SUBU V0, A0, V0
9D00DD4C  00621021   ADDU V0, V1, V0
9D00DD50  8C420004   LW V0, 4(V0)
1121:                }
9D00DD54  03C0E821   ADDU SP, S8, ZERO
9D00DD58  8FBE0004   LW S8, 4(SP)
9D00DD5C  27BD0008   ADDIU SP, SP, 8
9D00DD60  03E00008   JR RA
9D00DD64  00000000   NOP
1122:                
1123:                /*****************************************************************************
1124:                  Function:
1125:                    MPFS_PTR MPFSGetStartAddr(MPFS_HANDLE hMPFS)
1126:                
1127:                  Description:
1128:                    Reads the starting address of a file.
1129:                
1130:                  Precondition:
1131:                    The file handle referenced by hMPFS is already open.
1132:                
1133:                  Parameters:
1134:                    hMPFS - the file handle from which to read the metadata
1135:                
1136:                  Returns:
1137:                    The starting address of the file in the MPFS image
1138:                  ***************************************************************************/
1139:                MPFS_PTR MPFSGetStartAddr(MPFS_HANDLE hMPFS)
1140:                {
9D00DD68  27BDFFE8   ADDIU SP, SP, -24
9D00DD6C  AFBF0014   SW RA, 20(SP)
9D00DD70  AFBE0010   SW S8, 16(SP)
9D00DD74  03A0F021   ADDU S8, SP, ZERO
9D00DD78  00801021   ADDU V0, A0, ZERO
9D00DD7C  A3C20018   SB V0, 24(S8)
1141:                    // Make sure a valid file is open
1142:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DD80  93C20018   LBU V0, 24(S8)
9D00DD84  2C420008   SLTIU V0, V0, 8
9D00DD88  14400004   BNE V0, ZERO, 0x9D00DD9C
9D00DD8C  00000000   NOP
1143:                        return 0;
9D00DD90  00001021   ADDU V0, ZERO, ZERO
9D00DD94  0B403783   J 0x9D00DE0C
9D00DD98  00000000   NOP
1144:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DD9C  93C20018   LBU V0, 24(S8)
9D00DDA0  3C04A001   LUI A0, -24575
9D00DDA4  00021080   SLL V0, V0, 2
9D00DDA8  00021880   SLL V1, V0, 2
9D00DDAC  00621823   SUBU V1, V1, V0
9D00DDB0  248287C0   ADDIU V0, A0, -30784
9D00DDB4  00621021   ADDU V0, V1, V0
9D00DDB8  8C430000   LW V1, 0(V0)
9D00DDBC  2402FFFF   ADDIU V0, ZERO, -1
9D00DDC0  14620004   BNE V1, V0, 0x9D00DDD4
9D00DDC4  00000000   NOP
1145:                        return MPFS_INVALID;
9D00DDC8  2402FFFF   ADDIU V0, ZERO, -1
9D00DDCC  0B403783   J 0x9D00DE0C
9D00DDD0  00000000   NOP
1146:                
1147:                    // Move to the point for reading
1148:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DDD4  93C20018   LBU V0, 24(S8)
9D00DDD8  3C04A001   LUI A0, -24575
9D00DDDC  00021080   SLL V0, V0, 2
9D00DDE0  00021880   SLL V1, V0, 2
9D00DDE4  00621823   SUBU V1, V1, V0
9D00DDE8  248287C0   ADDIU V0, A0, -30784
9D00DDEC  00621021   ADDU V0, V1, V0
9D00DDF0  94420008   LHU V0, 8(V0)
9D00DDF4  00402021   ADDU A0, V0, ZERO
9D00DDF8  0F403642   JAL 0x9D00D908
9D00DDFC  00000000   NOP
1149:                    return fatCache.data;
9D00DE00  3C02A001   LUI V0, -24575
9D00DE04  24428820   ADDIU V0, V0, -30688
9D00DE08  8C420004   LW V0, 4(V0)
1150:                }
9D00DE0C  03C0E821   ADDU SP, S8, ZERO
9D00DE10  8FBF0014   LW RA, 20(SP)
9D00DE14  8FBE0010   LW S8, 16(SP)
9D00DE18  27BD0018   ADDIU SP, SP, 24
9D00DE1C  03E00008   JR RA
9D00DE20  00000000   NOP
1151:                
1152:                /*****************************************************************************
1153:                  Function:
1154:                    MPFS_PTR MPFSGetEndAddr(MPFS_HANDLE hMPFS)
1155:                
1156:                  Description:
1157:                    Determines the ending address of a file.
1158:                
1159:                  Precondition:
1160:                    The file handle referenced by hMPFS is already open.
1161:                
1162:                  Parameters:
1163:                    hMPFS - the file handle from which to read the metadata
1164:                
1165:                  Returns:
1166:                    The address just after the file ends (start address of next file)
1167:                  ***************************************************************************/
1168:                MPFS_PTR MPFSGetEndAddr(MPFS_HANDLE hMPFS)
1169:                {
9D00DE24  27BDFFE8   ADDIU SP, SP, -24
9D00DE28  AFBF0014   SW RA, 20(SP)
9D00DE2C  AFBE0010   SW S8, 16(SP)
9D00DE30  03A0F021   ADDU S8, SP, ZERO
9D00DE34  00801021   ADDU V0, A0, ZERO
9D00DE38  A3C20018   SB V0, 24(S8)
1170:                    // Make sure a valid file is open
1171:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DE3C  93C20018   LBU V0, 24(S8)
9D00DE40  2C420008   SLTIU V0, V0, 8
9D00DE44  14400004   BNE V0, ZERO, 0x9D00DE58
9D00DE48  00000000   NOP
1172:                        return MPFS_INVALID;
9D00DE4C  2402FFFF   ADDIU V0, ZERO, -1
9D00DE50  0B4037B6   J 0x9D00DED8
9D00DE54  00000000   NOP
1173:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DE58  93C20018   LBU V0, 24(S8)
9D00DE5C  3C04A001   LUI A0, -24575
9D00DE60  00021080   SLL V0, V0, 2
9D00DE64  00021880   SLL V1, V0, 2
9D00DE68  00621823   SUBU V1, V1, V0
9D00DE6C  248287C0   ADDIU V0, A0, -30784
9D00DE70  00621021   ADDU V0, V1, V0
9D00DE74  8C430000   LW V1, 0(V0)
9D00DE78  2402FFFF   ADDIU V0, ZERO, -1
9D00DE7C  14620004   BNE V1, V0, 0x9D00DE90
9D00DE80  00000000   NOP
1174:                        return MPFS_INVALID;
9D00DE84  2402FFFF   ADDIU V0, ZERO, -1
9D00DE88  0B4037B6   J 0x9D00DED8
9D00DE8C  00000000   NOP
1175:                
1176:                    // Move to the point for reading
1177:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DE90  93C20018   LBU V0, 24(S8)
9D00DE94  3C04A001   LUI A0, -24575
9D00DE98  00021080   SLL V0, V0, 2
9D00DE9C  00021880   SLL V1, V0, 2
9D00DEA0  00621823   SUBU V1, V1, V0
9D00DEA4  248287C0   ADDIU V0, A0, -30784
9D00DEA8  00621021   ADDU V0, V1, V0
9D00DEAC  94420008   LHU V0, 8(V0)
9D00DEB0  00402021   ADDU A0, V0, ZERO
9D00DEB4  0F403642   JAL 0x9D00D908
9D00DEB8  00000000   NOP
1178:                    return fatCache.data + fatCache.len;
9D00DEBC  3C02A001   LUI V0, -24575
9D00DEC0  24428820   ADDIU V0, V0, -30688
9D00DEC4  8C430004   LW V1, 4(V0)
9D00DEC8  3C02A001   LUI V0, -24575
9D00DECC  24428820   ADDIU V0, V0, -30688
9D00DED0  8C420008   LW V0, 8(V0)
9D00DED4  00621021   ADDU V0, V1, V0
1179:                }
9D00DED8  03C0E821   ADDU SP, S8, ZERO
9D00DEDC  8FBF0014   LW RA, 20(SP)
9D00DEE0  8FBE0010   LW S8, 16(SP)
9D00DEE4  27BD0018   ADDIU SP, SP, 24
9D00DEE8  03E00008   JR RA
9D00DEEC  00000000   NOP
1180:                
1181:                /*****************************************************************************
1182:                  Function:
1183:                    bool MPFSGetFilename(MPFS_HANDLE hMPFS, uint8_t* cName, uint16_t wLen)
1184:                
1185:                  Description:
1186:                    Reads the file name of a file that is already open.
1187:                
1188:                  Precondition:
1189:                    The file handle referenced by hMPFS is already open.
1190:                
1191:                  Parameters:
1192:                    hMPFS - the file handle from which to determine the file name
1193:                    cName - where to store the name of the file
1194:                    wLen - the maximum length of data to store in cName
1195:                
1196:                  Return Values:
1197:                    true - the file name was successfully located
1198:                    false - the file handle provided is not currently open
1199:                  ***************************************************************************/
1200:                bool MPFSGetFilename(MPFS_HANDLE hMPFS, uint8_t* cName, uint16_t wLen)
1201:                {
9D00DEF0  27BDFFE0   ADDIU SP, SP, -32
9D00DEF4  AFBF001C   SW RA, 28(SP)
9D00DEF8  AFBE0018   SW S8, 24(SP)
9D00DEFC  03A0F021   ADDU S8, SP, ZERO
9D00DF00  00801821   ADDU V1, A0, ZERO
9D00DF04  AFC50024   SW A1, 36(S8)
9D00DF08  00C01021   ADDU V0, A2, ZERO
9D00DF0C  A3C30020   SB V1, 32(S8)
9D00DF10  A7C20028   SH V0, 40(S8)
1202:                    uint32_t addr;
1203:                
1204:                    // Make sure a valid file is open
1205:                    if(hMPFS > MAX_MPFS_HANDLES)
9D00DF14  93C20020   LBU V0, 32(S8)
9D00DF18  2C420008   SLTIU V0, V0, 8
9D00DF1C  14400004   BNE V0, ZERO, 0x9D00DF30
9D00DF20  00000000   NOP
1206:                        return false;
9D00DF24  00001021   ADDU V0, ZERO, ZERO
9D00DF28  0B4037F6   J 0x9D00DFD8
9D00DF2C  00000000   NOP
1207:                    if(MPFSStubs[hMPFS].addr == MPFS_INVALID)
9D00DF30  93C20020   LBU V0, 32(S8)
9D00DF34  3C04A001   LUI A0, -24575
9D00DF38  00021080   SLL V0, V0, 2
9D00DF3C  00021880   SLL V1, V0, 2
9D00DF40  00621823   SUBU V1, V1, V0
9D00DF44  248287C0   ADDIU V0, A0, -30784
9D00DF48  00621021   ADDU V0, V1, V0
9D00DF4C  8C430000   LW V1, 0(V0)
9D00DF50  2402FFFF   ADDIU V0, ZERO, -1
9D00DF54  14620004   BNE V1, V0, 0x9D00DF68
9D00DF58  00000000   NOP
1208:                        return false;
9D00DF5C  00001021   ADDU V0, ZERO, ZERO
9D00DF60  0B4037F6   J 0x9D00DFD8
9D00DF64  00000000   NOP
1209:                
1210:                    // Move to the point for reading
1211:                    _LoadFATRecord(MPFSStubs[hMPFS].fatID);
9D00DF68  93C20020   LBU V0, 32(S8)
9D00DF6C  3C04A001   LUI A0, -24575
9D00DF70  00021080   SLL V0, V0, 2
9D00DF74  00021880   SLL V1, V0, 2
9D00DF78  00621823   SUBU V1, V1, V0
9D00DF7C  248287C0   ADDIU V0, A0, -30784
9D00DF80  00621021   ADDU V0, V1, V0
9D00DF84  94420008   LHU V0, 8(V0)
9D00DF88  00402021   ADDU A0, V0, ZERO
9D00DF8C  0F403642   JAL 0x9D00D908
9D00DF90  00000000   NOP
1212:                    addr = fatCache.string;
9D00DF94  3C02A001   LUI V0, -24575
9D00DF98  8C428820   LW V0, -30688(V0)
9D00DF9C  AFC20010   SW V0, 16(S8)
1213:                    MPFSStubs[0].addr = addr;
9D00DFA0  3C02A001   LUI V0, -24575
9D00DFA4  8FC30010   LW V1, 16(S8)
9D00DFA8  AC4387C0   SW V1, -30784(V0)
1214:                    MPFSStubs[0].bytesRem = 255;
9D00DFAC  3C02A001   LUI V0, -24575
9D00DFB0  244287C0   ADDIU V0, V0, -30784
9D00DFB4  240300FF   ADDIU V1, ZERO, 255
9D00DFB8  AC430004   SW V1, 4(V0)
1215:                
1216:                    // Read the value and return
1217:                    MPFSGetArray(0, cName, wLen);
9D00DFBC  97C20028   LHU V0, 40(S8)
9D00DFC0  00002021   ADDU A0, ZERO, ZERO
9D00DFC4  8FC50024   LW A1, 36(S8)
9D00DFC8  00403021   ADDU A2, V0, ZERO
9D00DFCC  0F403488   JAL MPFSGetArray
9D00DFD0  00000000   NOP
1218:                    return true;
9D00DFD4  24020001   ADDIU V0, ZERO, 1
1219:                }
9D00DFD8  03C0E821   ADDU SP, S8, ZERO
9D00DFDC  8FBF001C   LW RA, 28(SP)
9D00DFE0  8FBE0018   LW S8, 24(SP)
9D00DFE4  27BD0020   ADDIU SP, SP, 32
9D00DFE8  03E00008   JR RA
9D00DFEC  00000000   NOP
1220:                
1221:                /*****************************************************************************
1222:                  Function:
1223:                    uint32_t MPFSGetPosition(MPFS_HANDLE hMPFS)
1224:                
1225:                  Description:
1226:                    Determines the current position in the file
1227:                
1228:                  Precondition:
1229:                    The file handle referenced by hMPFS is already open.
1230:                
1231:                  Parameters:
1232:                    hMPFS - the file handle for which to determine position
1233:                
1234:                  Returns:
1235:                    The position in the file as a uint32_t (or MPFS_PTR)
1236:                
1237:                  Remarks:
1238:                    Calling MPFSSeek(hMPFS, pos, MPFS_SEEK_START) will return the pointer
1239:                    to this position at a later time.  (Where pos is the value returned by
1240:                    this function.)
1241:                  ***************************************************************************/
1242:                uint32_t MPFSGetPosition(MPFS_HANDLE hMPFS)
1243:                {
9D00DFF0  27BDFFE0   ADDIU SP, SP, -32
9D00DFF4  AFBF001C   SW RA, 28(SP)
9D00DFF8  AFBE0018   SW S8, 24(SP)
9D00DFFC  AFB00014   SW S0, 20(SP)
9D00E000  03A0F021   ADDU S8, SP, ZERO
9D00E004  00801021   ADDU V0, A0, ZERO
9D00E008  A3C20020   SB V0, 32(S8)
1244:                    return MPFSStubs[hMPFS].addr - MPFSGetStartAddr(hMPFS);
9D00E00C  93C20020   LBU V0, 32(S8)
9D00E010  3C04A001   LUI A0, -24575
9D00E014  00021080   SLL V0, V0, 2
9D00E018  00021880   SLL V1, V0, 2
9D00E01C  00621823   SUBU V1, V1, V0
9D00E020  248287C0   ADDIU V0, A0, -30784
9D00E024  00621021   ADDU V0, V1, V0
9D00E028  8C500000   LW S0, 0(V0)
9D00E02C  93C20020   LBU V0, 32(S8)
9D00E030  00402021   ADDU A0, V0, ZERO
9D00E034  0F40375A   JAL MPFSGetStartAddr
9D00E038  00000000   NOP
9D00E03C  02021023   SUBU V0, S0, V0
1245:                }
9D00E040  03C0E821   ADDU SP, S8, ZERO
9D00E044  8FBF001C   LW RA, 28(SP)
9D00E048  8FBE0018   LW S8, 24(SP)
9D00E04C  8FB00014   LW S0, 20(SP)
9D00E050  27BD0020   ADDIU SP, SP, 32
9D00E054  03E00008   JR RA
9D00E058  00000000   NOP
1246:                
1247:                /*****************************************************************************
1248:                  Function:
1249:                    uint16_t MPFSGetID(MPFS_HANDLE hMPFS)
1250:                
1251:                  Description:
1252:                    Determines the ID in the FAT for a file.
1253:                
1254:                  Precondition:
1255:                    The file handle referenced by hMPFS is already open.
1256:                
1257:                  Parameters:
1258:                    hMPFS - the file handle from which to read the metadata
1259:                
1260:                  Returns:
1261:                    The ID in the FAT for this file
1262:                
1263:                  Remarks:
1264:                    Use this function in association with MPFSOpenID to quickly access file
1265:                    without permanently reserving a file handle.
1266:                  ***************************************************************************/
1267:                uint16_t MPFSGetID(MPFS_HANDLE hMPFS)
1268:                {
9D00E05C  27BDFFF8   ADDIU SP, SP, -8
9D00E060  AFBE0004   SW S8, 4(SP)
9D00E064  03A0F021   ADDU S8, SP, ZERO
9D00E068  00801021   ADDU V0, A0, ZERO
9D00E06C  A3C20008   SB V0, 8(S8)
1269:                    return MPFSStubs[hMPFS].fatID;
9D00E070  93C20008   LBU V0, 8(S8)
9D00E074  3C04A001   LUI A0, -24575
9D00E078  00021080   SLL V0, V0, 2
9D00E07C  00021880   SLL V1, V0, 2
9D00E080  00621823   SUBU V1, V1, V0
9D00E084  248287C0   ADDIU V0, A0, -30784
9D00E088  00621021   ADDU V0, V1, V0
9D00E08C  94420008   LHU V0, 8(V0)
1270:                }
9D00E090  03C0E821   ADDU SP, S8, ZERO
9D00E094  8FBE0004   LW S8, 4(SP)
9D00E098  27BD0008   ADDIU SP, SP, 8
9D00E09C  03E00008   JR RA
9D00E0A0  00000000   NOP
1271:                
1272:                
1273:                /****************************************************************************
1274:                  Section:
1275:                    Utility Functions
1276:                  ***************************************************************************/
1277:                
1278:                /*****************************************************************************
1279:                  Function:
1280:                    void _Validate(void)
1281:                
1282:                  Summary:
1283:                    Validates the MPFS Image
1284:                
1285:                  Description:
1286:                    Verifies that the MPFS image is valid, and reads the number of
1287:                    available files from the image header.  This function is called on
1288:                    boot, and again after any image is written.
1289:                
1290:                  Precondition:
1291:                    None
1292:                
1293:                  Parameters:
1294:                    None
1295:                
1296:                  Returns:
1297:                    None
1298:                  ***************************************************************************/
1299:                static void _Validate(void)
1300:                {
9D00E0A4  27BDFFE8   ADDIU SP, SP, -24
9D00E0A8  AFBF0014   SW RA, 20(SP)
9D00E0AC  AFBE0010   SW S8, 16(SP)
9D00E0B0  03A0F021   ADDU S8, SP, ZERO
1301:                    // If this function causes an Address Error Exception on 16-bit
1302:                    // platforms with code stored in internal Flash, make sure your
1303:                    // compiler memory model settings are correct.
1304:                    //
1305:                    // In MPLAB, choose Project Menu > Build Options > Project.
1306:                    // Select the MPLAB C30 tab and change Cagetory to Memory Model.
1307:                    // Ensure that Large Code Model is selected, and that the remaining
1308:                    //   options are set to Default.
1309:                
1310:                    // Validate the image and update numFiles
1311:                    MPFSStubs[0].addr = 0;
9D00E0B4  3C02A001   LUI V0, -24575
9D00E0B8  AC4087C0   SW ZERO, -30784(V0)
1312:                    MPFSStubs[0].bytesRem = 8;
9D00E0BC  3C02A001   LUI V0, -24575
9D00E0C0  244287C0   ADDIU V0, V0, -30784
9D00E0C4  24030008   ADDIU V1, ZERO, 8
9D00E0C8  AC430004   SW V1, 4(V0)
1313:                    MPFSGetArray(0, (uint8_t*)&fatCache, 6);
9D00E0CC  3C02A001   LUI V0, -24575
9D00E0D0  24428820   ADDIU V0, V0, -30688
9D00E0D4  00002021   ADDU A0, ZERO, ZERO
9D00E0D8  00402821   ADDU A1, V0, ZERO
9D00E0DC  24060006   ADDIU A2, ZERO, 6
9D00E0E0  0F403488   JAL MPFSGetArray
9D00E0E4  00000000   NOP
1314:                    if(!memcmppgm2ram((void*)&fatCache, (ROM void*)"MPFS\x02\x01", 6))
9D00E0E8  3C02A001   LUI V0, -24575
9D00E0EC  24448820   ADDIU A0, V0, -30688
9D00E0F0  3C029D02   LUI V0, -25342
9D00E0F4  2445C38C   ADDIU A1, V0, -15476
9D00E0F8  24060006   ADDIU A2, ZERO, 6
9D00E0FC  0F406D65   JAL 0x9D01B594
9D00E100  00000000   NOP
9D00E104  14400009   BNE V0, ZERO, 0x9D00E12C
9D00E108  00000000   NOP
1315:                        MPFSGetArray(0, (uint8_t*)&numFiles, 2);
9D00E10C  278280A0   ADDIU V0, GP, -32608
9D00E110  00002021   ADDU A0, ZERO, ZERO
9D00E114  00402821   ADDU A1, V0, ZERO
9D00E118  24060002   ADDIU A2, ZERO, 2
9D00E11C  0F403488   JAL MPFSGetArray
9D00E120  00000000   NOP
9D00E124  0B40384C   J 0x9D00E130
9D00E128  00000000   NOP
1316:                    else
1317:                        numFiles = 0;
9D00E12C  A78080A0   SH ZERO, -32608(GP)
1318:                    fatCacheID = MPFS_INVALID_FAT;
9D00E130  2402FFFF   ADDIU V0, ZERO, -1
9D00E134  A782809E   SH V0, -32610(GP)
1319:                }
9D00E138  03C0E821   ADDU SP, S8, ZERO
9D00E13C  8FBF0014   LW RA, 20(SP)
9D00E140  8FBE0010   LW S8, 16(SP)
9D00E144  27BD0018   ADDIU SP, SP, 24
9D00E148  03E00008   JR RA
9D00E14C  00000000   NOP
1320:                #endif //#if defined(STACK_USE_MPFS2)
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/ip.c  -----------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       ip.c
7:                   
8:                     Summary:
9:                       Module for Microchip TCP/IP Stack
10:                       -Provides a transport for TCP, UDP, and ICMP messages
11:                       -Reference: RFC 791
12:                  
13:                    Description:
14:                      Internet Protocol (IP) Version 4 Communications Layer
15:                  
16:                   *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #define __IP_C_
44:                  
45:                  #include "tcpip/tcpip.h"
46:                  
47:                  // This is left shifted by 4.  Actual value is 0x04.
48:                  #define IPv4                (0x40u)
49:                  #define IP_VERSION          IPv4
50:                  
51:                  // IHL (Internet Header Length) is # of DWORDs in a header.
52:                  // Since, we do not support options, our IP header length will be
53:                  // minimum i.e. 20 bytes : IHL = 20 / 4 = 5.
54:                  #define IP_IHL              (0x05)
55:                  
56:                  #define IP_SERVICE_NW_CTRL  (0x07)
57:                  #define IP_SERVICE_IN_CTRL  (0x06)
58:                  #define IP_SERVICE_ECP      (0x05)
59:                  #define IP_SERVICE_OVR      (0x04)
60:                  #define IP_SERVICE_FLASH    (0x03)
61:                  #define IP_SERVICE_IMM      (0x02)
62:                  #define IP_SERVICE_PRIOR    (0x01)
63:                  #define IP_SERVICE_ROUTINE  (0x00)
64:                  
65:                  #define IP_SERVICE_N_DELAY  (0x00)
66:                  #define IP_SERCICE_L_DELAY  (0x08)
67:                  #define IP_SERVICE_N_THRPT  (0x00)
68:                  #define IP_SERVICE_H_THRPT  (0x10)
69:                  #define IP_SERVICE_N_RELIB  (0x00)
70:                  #define IP_SERVICE_H_RELIB  (0x20)
71:                  
72:                  #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY)
73:                  
74:                  #if defined(STACK_USE_ZEROCONF_MDNS_SD)
75:                    #define MY_IP_TTL           (255)  // Time-To-Live in hops
76:                    // IP TTL is set to 255 for Multicast DNS compatibility. See mDNS-draft-08, section 4.
77:                  #else
78:                    #define MY_IP_TTL           (100)  // Time-To-Live in hops
79:                  #endif
80:                  
81:                  
82:                  
83:                  static uint16_t _Identifier = 0;
84:                  static uint8_t IPHeaderLen;
85:                  
86:                  
87:                  static void SwapIPHeader(IP_HEADER* h);
88:                  
89:                  
90:                  
91:                  
92:                  /*********************************************************************
93:                   * Function:        bool IPGetHeader( IP_ADDR    *localIP,
94:                   *                                    NODE_INFO  *remote,
95:                   *                                    uint8_t        *Protocol,
96:                   *                                    uint16_t        *len)
97:                   *
98:                   * PreCondition:    MACGetHeader() == true
99:                   *
100:                  * Input:           localIP     - Local node IP Address as received
101:                  *                                in current IP header.
102:                  *                                If this information is not required
103:                  *                                caller may pass NULL value.
104:                  *                  remote      - Remote node info
105:                  *                  Protocol    - Current packet protocol
106:                  *                  len         - Current packet data length
107:                  *
108:                  * Output:          true, if valid packet was received
109:                  *                  false otherwise
110:                  *
111:                  * Side Effects:    None
112:                  *
113:                  * Note:            Only one IP message can be received.
114:                  *                  Caller may not transmit and receive a message
115:                  *                  at the same time.
116:                  *
117:                  ********************************************************************/
118:                 bool IPGetHeader(IP_ADDR *localIP,
119:                                  NODE_INFO *remote,
120:                                  uint8_t *protocol,
121:                                  uint16_t *len)
122:                 {
9D017E14  27BDFFD0   ADDIU SP, SP, -48
9D017E18  AFBF002C   SW RA, 44(SP)
9D017E1C  AFBE0028   SW S8, 40(SP)
9D017E20  03A0F021   ADDU S8, SP, ZERO
9D017E24  AFC40030   SW A0, 48(S8)
9D017E28  AFC50034   SW A1, 52(S8)
9D017E2C  AFC60038   SW A2, 56(S8)
9D017E30  AFC7003C   SW A3, 60(S8)
123:                     TCPIP_UINT16_VAL    CalcChecksum;
124:                     IP_HEADER   header;
125:                 
126:                 #if defined(NON_MCHP_MAC)
127:                     TCPIP_UINT16_VAL    ReceivedChecksum;
128:                     uint16_t        checksums[2];
129:                     uint8_t        optionsLen;
130:                     #define MAX_OPTIONS_LEN     (40u)            // As per RFC 791.
131:                     uint8_t        options[MAX_OPTIONS_LEN];
132:                 #endif
133:                 
134:                     // Read IP header.
135:                     MACGetArray((uint8_t*)&header, sizeof(header));
9D017E34  27C20014   ADDIU V0, S8, 20
9D017E38  00402021   ADDU A0, V0, ZERO
9D017E3C  24050014   ADDIU A1, ZERO, 20
9D017E40  0F4046D1   JAL MACGetArray
9D017E44  00000000   NOP
136:                 
137:                     // Make sure that this is an IPv4 packet.
138:                     if((header.VersionIHL & 0xf0) != IP_VERSION)
9D017E48  93C20014   LBU V0, 20(S8)
9D017E4C  304300F0   ANDI V1, V0, 240
9D017E50  24020040   ADDIU V0, ZERO, 64
9D017E54  10620004   BEQ V1, V0, 0x9D017E68
9D017E58  00000000   NOP
139:                         return false;
9D017E5C  00001021   ADDU V0, ZERO, ZERO
9D017E60  0B405FCF   J 0x9D017F3C
9D017E64  00000000   NOP
140:                 
141:                     // Throw this packet away if it is a fragment.
142:                     // We don't have enough RAM for IP fragment reconstruction.
143:                     if(header.FragmentInfo & 0xFF1F)
9D017E68  97C2001A   LHU V0, 26(S8)
9D017E6C  3042FF1F   ANDI V0, V0, -225
9D017E70  10400004   BEQ V0, ZERO, 0x9D017E84
9D017E74  00000000   NOP
144:                         return false;
9D017E78  00001021   ADDU V0, ZERO, ZERO
9D017E7C  0B405FCF   J 0x9D017F3C
9D017E80  00000000   NOP
145:                 
146:                     IPHeaderLen = (header.VersionIHL & 0x0f) << 2;
9D017E84  93C20014   LBU V0, 20(S8)
9D017E88  3042000F   ANDI V0, V0, 15
9D017E8C  304200FF   ANDI V0, V0, 255
9D017E90  00021080   SLL V0, V0, 2
9D017E94  304200FF   ANDI V0, V0, 255
9D017E98  A3828032   SB V0, -32718(GP)
147:                 
148:                 #if !defined(NON_MCHP_MAC)
149:                     // Validate the IP header.  If it is correct, the checksum
150:                     // will come out to 0x0000 (because the header contains a
151:                     // precomputed checksum).  A corrupt header will have a
152:                     // nonzero checksum.
153:                     CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen);
9D017E9C  93828032   LBU V0, -32718(GP)
9D017EA0  00002021   ADDU A0, ZERO, ZERO
9D017EA4  00402821   ADDU A1, V0, ZERO
9D017EA8  0F404745   JAL MACCalcRxChecksum
9D017EAC  00000000   NOP
9D017EB0  A7C20010   SH V0, 16(S8)
154:                 
155:                     // Seek to the end of the IP header
156:                     MACSetReadPtrInRx(IPHeaderLen);
9D017EB4  93828032   LBU V0, -32718(GP)
9D017EB8  00402021   ADDU A0, V0, ZERO
9D017EBC  0F4046A7   JAL MACSetReadPtrInRx
9D017EC0  00000000   NOP
157:                 
158:                     if(CalcChecksum.Val)
9D017EC4  97C20010   LHU V0, 16(S8)
9D017EC8  10400004   BEQ V0, ZERO, 0x9D017EDC
9D017ECC  00000000   NOP
159:                 #else
160:                     // Calculate options length in this header, if there is any.
161:                     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual
162:                     // length is 4 times IHL.
163:                     optionsLen = IPHeaderLen - sizeof(header);
164:                 
165:                     // If there is any option(s), read it so that we can include them
166:                     // in checksum calculation.
167:                     if ( optionsLen > MAX_OPTIONS_LEN )
168:                         return false;
169:                 
170:                     if ( optionsLen > 0u )
171:                         MACGetArray(options, optionsLen);
172:                 
173:                     // Save header checksum; clear it and recalculate it ourselves.
174:                     ReceivedChecksum.Val = header.HeaderChecksum;
175:                     header.HeaderChecksum = 0;
176:                 
177:                     // Calculate checksum of header including options bytes.
178:                     checksums[0] = ~CalcIPChecksum((uint8_t*)&header, sizeof(header));
179:                 
180:                     // Calculate Options checksum too, if they are present.
181:                     if ( optionsLen > 0u )
182:                         checksums[1] = ~CalcIPChecksum((uint8_t*)options, optionsLen);
183:                     else
184:                         checksums[1] = 0;
185:                 
186:                     CalcChecksum.Val  = CalcIPChecksum((uint8_t*)checksums,
187:                                                             2 * sizeof(uint16_t));
188:                 
189:                     // Make sure that checksum is correct
190:                     if ( ReceivedChecksum.Val != CalcChecksum.Val )
191:                 #endif
192:                     {
193:                         // Bad packet. The function caller will be notified by means of the false
194:                         // return value and it should discard the packet.
195:                         return false;
9D017ED0  00001021   ADDU V0, ZERO, ZERO
9D017ED4  0B405FCF   J 0x9D017F3C
9D017ED8  00000000   NOP
196:                     }
197:                 
198:                     // Network to host conversion.
199:                     SwapIPHeader(&header);
9D017EDC  27C20014   ADDIU V0, S8, 20
9D017EE0  00402021   ADDU A0, V0, ZERO
9D017EE4  0F406034   JAL 0x9D0180D0
9D017EE8  00000000   NOP
200:                 
201:                     // If caller is intrested, return destination IP address
202:                     // as seen in this IP header.
203:                     if ( localIP )
9D017EEC  8FC20030   LW V0, 48(S8)
9D017EF0  10400004   BEQ V0, ZERO, 0x9D017F04
9D017EF4  00000000   NOP
204:                         localIP->Val    = header.DestAddress.Val;
9D017EF8  8FC30024   LW V1, 36(S8)
9D017EFC  8FC20030   LW V0, 48(S8)
9D017F00  AC430000   SW V1, 0(V0)
205:                 
206:                     remote->IPAddr.Val  = header.SourceAddress.Val;
9D017F04  8FC30020   LW V1, 32(S8)
9D017F08  8FC20034   LW V0, 52(S8)
9D017F0C  A8430003   SWL V1, 3(V0)
9D017F10  B8430000   SWR V1, 0(V0)
207:                     *protocol           = header.Protocol;
9D017F14  93C3001D   LBU V1, 29(S8)
9D017F18  8FC20038   LW V0, 56(S8)
9D017F1C  A0430000   SB V1, 0(V0)
208:                     *len                = header.TotalLength - IPHeaderLen;
9D017F20  97C30016   LHU V1, 22(S8)
9D017F24  93828032   LBU V0, -32718(GP)
9D017F28  00621023   SUBU V0, V1, V0
9D017F2C  3043FFFF   ANDI V1, V0, -1
9D017F30  8FC2003C   LW V0, 60(S8)
9D017F34  A4430000   SH V1, 0(V0)
209:                 
210:                     return true;
9D017F38  24020001   ADDIU V0, ZERO, 1
211:                 }
9D017F3C  03C0E821   ADDU SP, S8, ZERO
9D017F40  8FBF002C   LW RA, 44(SP)
9D017F44  8FBE0028   LW S8, 40(SP)
9D017F48  27BD0030   ADDIU SP, SP, 48
9D017F4C  03E00008   JR RA
9D017F50  00000000   NOP
212:                 
213:                 
214:                 
215:                 
216:                 /*********************************************************************
217:                  * Function: uint16_t IPPutHeader(NODE_INFO *remote,
218:                  *                            uint8_t protocol,
219:                  *                            uint16_t len)
220:                  *
221:                  * PreCondition:    IPIsTxReady() == true
222:                  *
223:                  * Input:           *remote     - Destination node address
224:                  *                  protocol    - Current packet protocol
225:                  *                  len         - Current packet data length
226:                  *
227:                  * Output:          (uint16_t)0
228:                  *
229:                  * Side Effects:    None
230:                  *
231:                  * Note:            Only one IP message can be transmitted at any
232:                  *                  time.
233:                  ********************************************************************/
234:                 uint16_t IPPutHeader(NODE_INFO *remote,
235:                                  uint8_t protocol,
236:                                  uint16_t len)
237:                 {
9D017F54  27BDFFD0   ADDIU SP, SP, -48
9D017F58  AFBF002C   SW RA, 44(SP)
9D017F5C  AFBE0028   SW S8, 40(SP)
9D017F60  03A0F021   ADDU S8, SP, ZERO
9D017F64  AFC40030   SW A0, 48(S8)
9D017F68  00A01821   ADDU V1, A1, ZERO
9D017F6C  00C01021   ADDU V0, A2, ZERO
9D017F70  A3C30034   SB V1, 52(S8)
9D017F74  A7C20038   SH V0, 56(S8)
238:                     IP_HEADER   header;
239:                 
240:                     IPHeaderLen = sizeof(IP_HEADER);
9D017F78  24020014   ADDIU V0, ZERO, 20
9D017F7C  A3828032   SB V0, -32718(GP)
241:                 
242:                     header.VersionIHL       = IP_VERSION | IP_IHL;
9D017F80  24020045   ADDIU V0, ZERO, 69
9D017F84  A3C20010   SB V0, 16(S8)
243:                     header.TypeOfService    = IP_SERVICE;
9D017F88  A3C00011   SB ZERO, 17(S8)
244:                     header.TotalLength      = sizeof(header) + len;
9D017F8C  97C20038   LHU V0, 56(S8)
9D017F90  24420014   ADDIU V0, V0, 20
9D017F94  3042FFFF   ANDI V0, V0, -1
9D017F98  A7C20012   SH V0, 18(S8)
245:                     header.Identification   = ++_Identifier;
9D017F9C  97828030   LHU V0, -32720(GP)
9D017FA0  24420001   ADDIU V0, V0, 1
9D017FA4  3042FFFF   ANDI V0, V0, -1
9D017FA8  A7828030   SH V0, -32720(GP)
9D017FAC  97828030   LHU V0, -32720(GP)
9D017FB0  A7C20014   SH V0, 20(S8)
246:                     header.FragmentInfo     = 0;
9D017FB4  A7C00016   SH ZERO, 22(S8)
247:                     header.TimeToLive       = MY_IP_TTL;
9D017FB8  24020064   ADDIU V0, ZERO, 100
9D017FBC  A3C20018   SB V0, 24(S8)
248:                     header.Protocol         = protocol;
9D017FC0  93C20034   LBU V0, 52(S8)
9D017FC4  A3C20019   SB V0, 25(S8)
249:                     header.HeaderChecksum   = 0;
9D017FC8  A7C0001A   SH ZERO, 26(S8)
250:                     header.SourceAddress    = AppConfig.MyIPAddr;
9D017FCC  3C02A000   LUI V0, -24576
9D017FD0  244308D8   ADDIU V1, V0, 2264
9D017FD4  88630003   LWL V1, 3(V1)
9D017FD8  00602021   ADDU A0, V1, ZERO
9D017FDC  984408D8   LWR A0, 2264(V0)
9D017FE0  00801021   ADDU V0, A0, ZERO
9D017FE4  AFC2001C   SW V0, 28(S8)
251:                 
252:                     header.DestAddress.Val = remote->IPAddr.Val;
9D017FE8  8FC20030   LW V0, 48(S8)
9D017FEC  88430003   LWL V1, 3(V0)
9D017FF0  00602021   ADDU A0, V1, ZERO
9D017FF4  98440000   LWR A0, 0(V0)
9D017FF8  00801021   ADDU V0, A0, ZERO
9D017FFC  AFC20020   SW V0, 32(S8)
253:                 
254:                     SwapIPHeader(&header);
9D018000  27C20010   ADDIU V0, S8, 16
9D018004  00402021   ADDU A0, V0, ZERO
9D018008  0F406034   JAL 0x9D0180D0
9D01800C  00000000   NOP
255:                 
256:                     header.HeaderChecksum   = CalcIPChecksum((uint8_t*)&header, sizeof(header));
9D018010  27C20010   ADDIU V0, S8, 16
9D018014  00402021   ADDU A0, V0, ZERO
9D018018  24050014   ADDIU A1, ZERO, 20
9D01801C  0F403F9D   JAL CalcIPChecksum
9D018020  00000000   NOP
9D018024  A7C2001A   SH V0, 26(S8)
257:                 
258:                     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len));
9D018028  8FC20030   LW V0, 48(S8)
9D01802C  24430004   ADDIU V1, V0, 4
9D018030  97C20038   LHU V0, 56(S8)
9D018034  24420014   ADDIU V0, V0, 20
9D018038  3042FFFF   ANDI V0, V0, -1
9D01803C  00602021   ADDU A0, V1, ZERO
9D018040  00002821   ADDU A1, ZERO, ZERO
9D018044  00403021   ADDU A2, V0, ZERO
9D018048  0F4045D5   JAL MACPutHeader
9D01804C  00000000   NOP
259:                     MACPutArray((uint8_t*)&header, sizeof(header));
9D018050  27C20010   ADDIU V0, S8, 16
9D018054  00402021   ADDU A0, V0, ZERO
9D018058  24050014   ADDIU A1, ZERO, 20
9D01805C  0F4045BD   JAL MACPutArray
9D018060  00000000   NOP
260:                 
261:                     return 0x0000;
9D018064  00001021   ADDU V0, ZERO, ZERO
262:                 
263:                 }
9D018068  03C0E821   ADDU SP, S8, ZERO
9D01806C  8FBF002C   LW RA, 44(SP)
9D018070  8FBE0028   LW S8, 40(SP)
9D018074  27BD0030   ADDIU SP, SP, 48
9D018078  03E00008   JR RA
9D01807C  00000000   NOP
264:                 
265:                 /*********************************************************************
266:                  * Function:        IPSetRxBuffer(uint16_t Offset)
267:                  *
268:                  * PreCondition:    IPHeaderLen must have been intialized by
269:                  *                  IPGetHeader() or IPPutHeader()
270:                  *
271:                  * Input:           Offset from beginning of IP data field
272:                  *
273:                  * Output:          Next Read/Write access to receive buffer is
274:                  *                  set to Offset
275:                  *
276:                  * Side Effects:    None
277:                  *
278:                  * Note:            None
279:                  *
280:                  ********************************************************************/
281:                 void IPSetRxBuffer(uint16_t Offset)
282:                 {
9D018080  27BDFFE8   ADDIU SP, SP, -24
9D018084  AFBF0014   SW RA, 20(SP)
9D018088  AFBE0010   SW S8, 16(SP)
9D01808C  03A0F021   ADDU S8, SP, ZERO
9D018090  00801021   ADDU V0, A0, ZERO
9D018094  A7C20018   SH V0, 24(S8)
283:                     MACSetReadPtrInRx(Offset+IPHeaderLen);
9D018098  93828032   LBU V0, -32718(GP)
9D01809C  00401821   ADDU V1, V0, ZERO
9D0180A0  97C20018   LHU V0, 24(S8)
9D0180A4  00621021   ADDU V0, V1, V0
9D0180A8  3042FFFF   ANDI V0, V0, -1
9D0180AC  00402021   ADDU A0, V0, ZERO
9D0180B0  0F4046A7   JAL MACSetReadPtrInRx
9D0180B4  00000000   NOP
284:                 }
9D0180B8  03C0E821   ADDU SP, S8, ZERO
9D0180BC  8FBF0014   LW RA, 20(SP)
9D0180C0  8FBE0010   LW S8, 16(SP)
9D0180C4  27BD0018   ADDIU SP, SP, 24
9D0180C8  03E00008   JR RA
9D0180CC  00000000   NOP
285:                 
286:                 
287:                 
288:                 static void SwapIPHeader(IP_HEADER* h)
289:                 {
9D0180D0  27BDFFE8   ADDIU SP, SP, -24
9D0180D4  AFBF0014   SW RA, 20(SP)
9D0180D8  AFBE0010   SW S8, 16(SP)
9D0180DC  03A0F021   ADDU S8, SP, ZERO
9D0180E0  AFC40018   SW A0, 24(S8)
290:                     h->TotalLength      = swaps(h->TotalLength);
9D0180E4  8FC20018   LW V0, 24(S8)
9D0180E8  94420002   LHU V0, 2(V0)
9D0180EC  00402021   ADDU A0, V0, ZERO
9D0180F0  0F403F50   JAL swaps
9D0180F4  00000000   NOP
9D0180F8  00401821   ADDU V1, V0, ZERO
9D0180FC  8FC20018   LW V0, 24(S8)
9D018100  A4430002   SH V1, 2(V0)
291:                     h->Identification   = swaps(h->Identification);
9D018104  8FC20018   LW V0, 24(S8)
9D018108  94420004   LHU V0, 4(V0)
9D01810C  00402021   ADDU A0, V0, ZERO
9D018110  0F403F50   JAL swaps
9D018114  00000000   NOP
9D018118  00401821   ADDU V1, V0, ZERO
9D01811C  8FC20018   LW V0, 24(S8)
9D018120  A4430004   SH V1, 4(V0)
292:                     h->HeaderChecksum   = swaps(h->HeaderChecksum);
9D018124  8FC20018   LW V0, 24(S8)
9D018128  9442000A   LHU V0, 10(V0)
9D01812C  00402021   ADDU A0, V0, ZERO
9D018130  0F403F50   JAL swaps
9D018134  00000000   NOP
9D018138  00401821   ADDU V1, V0, ZERO
9D01813C  8FC20018   LW V0, 24(S8)
9D018140  A443000A   SH V1, 10(V0)
293:                 }
9D018144  03C0E821   ADDU SP, S8, ZERO
9D018148  8FBF0014   LW RA, 20(SP)
9D01814C  8FBE0010   LW S8, 16(SP)
9D018150  27BD0018   ADDIU SP, SP, 24
9D018154  03E00008   JR RA
9D018158  00000000   NOP
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/icmp.c  ---------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       icmp.c
7:                   
8:                     Summary:
9:                       Module for Microchip TCP/IP Stack
10:                       -Provides "ping" diagnostics
11:                       -Reference: RFC 792
12:                  
13:                    Description:
14:                      Internet Control Message Protocol (ICMP) Server
15:                  
16:                   *******************************************************************************/
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #define __ICMP_C_
44:                  
45:                  #include "tcpip/tcpip.h"
46:                  
47:                  #if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
48:                  
49:                  #if defined(STACK_USE_ICMP_CLIENT)
50:                  
51:                  // ICMP Timeout Value
52:                  #define ICMP_TIMEOUT    (4ul*TICK_SECOND)
53:                  
54:                  // ICMP Packet Structure
55:                  typedef struct
56:                  {
57:                      uint8_t vType;
58:                      uint8_t vCode;
59:                      uint16_t wChecksum;
60:                      uint16_t wIdentifier;
61:                      uint16_t wSequenceNumber;
62:                      uint16_t wData;
63:                  } ICMP_PACKET;
64:                  
65:                  // ICMP Sequence Number
66:                  static uint16_t wICMPSequenceNumber;
67:                  // ICMP tick timer variable
68:                  static uint32_t ICMPTimer;
69:                  
70:                  // ICMP Flag structure
71:                  static struct
72:                  {
73:                      unsigned char bICMPInUse:1;         // Indicates that the ICMP Client is in use
74:                      unsigned char bReplyValid:1;        // Indicates that a correct Ping response to one of our pings was received
75:                      unsigned char bRemoteHostIsROM:1;   // Indicates that a remote host name was passed as a ROM pointer argument
76:                  } ICMPFlags = {0x00};
77:                  
78:                  // ICMP Static Variables
79:                  static union
80:                  {
81:                      union
82:                      {
83:                          ROM uint8_t *szROM;
84:                          uint8_t *szRAM;
85:                      } RemoteHost;
86:                      NODE_INFO ICMPRemote;
87:                  } StaticVars;
88:                  
89:                  // ICMP State Machine Enumeration
90:                  static enum
91:                  {
92:                      SM_IDLE = 0,
93:                      SM_DNS_SEND_QUERY,
94:                      SM_DNS_GET_RESPONSE,
95:                      SM_ARP_SEND_QUERY,
96:                      SM_ARP_GET_RESPONSE,
97:                      SM_ICMP_SEND_ECHO_REQUEST,
98:                      SM_ICMP_GET_ECHO_RESPONSE
99:                  } ICMPState;
100:                 
101:                 #endif
102:                 
103:                 /*********************************************************************
104:                  * Function:        void ICMPProcess(void)
105:                  *
106:                  * PreCondition:    MAC buffer contains ICMP type packet.
107:                  *
108:                  * Input:           *remote: Pointer to a NODE_INFO structure of the
109:                  *                  ping requester
110:                  *                  len: Count of how many bytes the ping header and
111:                  *                  payload are in this IP packet
112:                  *
113:                  * Output:          Generates an echo reply, if requested
114:                  *                  Validates and sets ICMPFlags.bReplyValid if a
115:                  *                  correct ping response to one of ours is received.
116:                  *
117:                  * Side Effects:    None
118:                  *
119:                  * Overview:        None
120:                  *
121:                  * Note:            None
122:                  ********************************************************************/
123:                 void ICMPProcess(NODE_INFO *remote, uint16_t len)
124:                 {
9D0199A0  27BDFFE0   ADDIU SP, SP, -32
9D0199A4  AFBF001C   SW RA, 28(SP)
9D0199A8  AFBE0018   SW S8, 24(SP)
9D0199AC  03A0F021   ADDU S8, SP, ZERO
9D0199B0  AFC40020   SW A0, 32(S8)
9D0199B4  00A01021   ADDU V0, A1, ZERO
9D0199B8  A7C20024   SH V0, 36(S8)
125:                     TCPIP_UINT32_VAL dwVal;
126:                 
127:                     // Obtain the ICMP header Type, Code, and Checksum fields
128:                     MACGetArray((uint8_t*)&dwVal, sizeof(dwVal));
9D0199BC  27C20010   ADDIU V0, S8, 16
9D0199C0  00402021   ADDU A0, V0, ZERO
9D0199C4  24050004   ADDIU A1, ZERO, 4
9D0199C8  0F4046D1   JAL MACGetArray
9D0199CC  00000000   NOP
129:                 
130:                     // See if this is an ICMP echo (ping) request
131:                     if(dwVal.w[0] == 0x0008u)
9D0199D0  97C30010   LHU V1, 16(S8)
9D0199D4  24020008   ADDIU V0, ZERO, 8
9D0199D8  1462004D   BNE V1, V0, 0x9D019B10
9D0199DC  00000000   NOP
132:                     {
133:                         // Validate the checksum using the Microchip MAC's DMA module
134:                         // The checksum data includes the precomputed checksum in the
135:                         // header, so a valid packet will always have a checksum of
136:                         // 0x0000 if the packet is not disturbed.
137:                         if(MACCalcRxChecksum(0+sizeof(IP_HEADER), len))
9D0199E0  97C20024   LHU V0, 36(S8)
9D0199E4  24040014   ADDIU A0, ZERO, 20
9D0199E8  00402821   ADDU A1, V0, ZERO
9D0199EC  0F404745   JAL MACCalcRxChecksum
9D0199F0  00000000   NOP
9D0199F4  14400045   BNE V0, ZERO, 0x9D019B0C
9D0199F8  00000000   NOP
138:                             return;
9D019B0C  00000000   NOP
139:                 
140:                         // Calculate new Type, Code, and Checksum values
141:                         dwVal.v[0] = 0x00;  // Type: 0 (ICMP echo/ping reply)
9D0199FC  A3C00010   SB ZERO, 16(S8)
142:                         dwVal.v[2] += 8;    // Subtract 0x0800 from the checksum
9D019A00  93C20012   LBU V0, 18(S8)
9D019A04  24420008   ADDIU V0, V0, 8
9D019A08  304200FF   ANDI V0, V0, 255
9D019A0C  A3C20012   SB V0, 18(S8)
143:                         if(dwVal.v[2] < 8u)
9D019A10  93C20012   LBU V0, 18(S8)
9D019A14  2C420008   SLTIU V0, V0, 8
9D019A18  1040000E   BEQ V0, ZERO, 0x9D019A54
9D019A1C  00000000   NOP
144:                         {
145:                             dwVal.v[3]++;
9D019A20  93C20013   LBU V0, 19(S8)
9D019A24  24420001   ADDIU V0, V0, 1
9D019A28  304200FF   ANDI V0, V0, 255
9D019A2C  A3C20013   SB V0, 19(S8)
146:                             if(dwVal.v[3] == 0u)
9D019A30  93C20013   LBU V0, 19(S8)
9D019A34  1440000A   BNE V0, ZERO, 0x9D019A60
9D019A38  00000000   NOP
147:                                 dwVal.v[2]++;
9D019A3C  93C20012   LBU V0, 18(S8)
9D019A40  24420001   ADDIU V0, V0, 1
9D019A44  304200FF   ANDI V0, V0, 255
9D019A48  A3C20012   SB V0, 18(S8)
148:                         }
149:                 
150:                         // Wait for TX hardware to become available (finish transmitting
151:                         // any previous packet)
152:                         while(!IPIsTxReady());
9D019A4C  0B406699   J 0x9D019A64
9D019A50  00000000   NOP
9D019A54  00000000   NOP
9D019A58  0B406699   J 0x9D019A64
9D019A5C  00000000   NOP
9D019A60  00000000   NOP
9D019A64  0F40453A   JAL MACIsTxReady
9D019A68  00000000   NOP
9D019A6C  38420001   XORI V0, V0, 1
9D019A70  304200FF   ANDI V0, V0, 255
9D019A74  1440FFFB   BNE V0, ZERO, 0x9D019A64
9D019A78  00000000   NOP
153:                 
154:                         // Position the write pointer for the next IPPutHeader operation
155:                         // NOTE: do not put this before the IPIsTxReady() call for WF compatbility
156:                         MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
9D019A7C  0F404508   JAL MACGetTxBaseAddr
9D019A80  00000000   NOP
9D019A84  2442000E   ADDIU V0, V0, 14
9D019A88  00402021   ADDU A0, V0, ZERO
9D019A8C  0F40452C   JAL MACSetWritePtr
9D019A90  00000000   NOP
157:                 
158:                         // Create IP header in TX memory
159:                         IPPutHeader(remote, IP_PROT_ICMP, len);
9D019A94  97C20024   LHU V0, 36(S8)
9D019A98  8FC40020   LW A0, 32(S8)
9D019A9C  24050001   ADDIU A1, ZERO, 1
9D019AA0  00403021   ADDU A2, V0, ZERO
9D019AA4  0F405FD5   JAL IPPutHeader
9D019AA8  00000000   NOP
160:                 
161:                         // Copy ICMP response into the TX memory
162:                         MACPutArray((uint8_t*)&dwVal, sizeof(dwVal));
9D019AAC  27C20010   ADDIU V0, S8, 16
9D019AB0  00402021   ADDU A0, V0, ZERO
9D019AB4  24050004   ADDIU A1, ZERO, 4
9D019AB8  0F4045BD   JAL MACPutArray
9D019ABC  00000000   NOP
163:                         MACMemCopyAsync(-1, -1, len-4);
9D019AC0  97C20024   LHU V0, 36(S8)
9D019AC4  2442FFFC   ADDIU V0, V0, -4
9D019AC8  3042FFFF   ANDI V0, V0, -1
9D019ACC  2404FFFF   ADDIU A0, ZERO, -1
9D019AD0  2405FFFF   ADDIU A1, ZERO, -1
9D019AD4  00403021   ADDU A2, V0, ZERO
9D019AD8  0F404701   JAL MACMemCopyAsync
9D019ADC  00000000   NOP
164:                         while(!MACIsMemCopyDone());
9D019AE0  00000000   NOP
9D019AE4  0F40472A   JAL MACIsMemCopyDone
9D019AE8  00000000   NOP
9D019AEC  38420001   XORI V0, V0, 1
9D019AF0  304200FF   ANDI V0, V0, 255
9D019AF4  1440FFFB   BNE V0, ZERO, 0x9D019AE4
9D019AF8  00000000   NOP
165:                 
166:                         // Transmit the echo reply packet
167:                         MACFlush();
9D019AFC  0F40460E   JAL MACFlush
9D019B00  00000000   NOP
9D019B04  0B4066C4   J 0x9D019B10
9D019B08  00000000   NOP
168:                     }
169:                 #if defined(STACK_USE_ICMP_CLIENT)
170:                     else if(dwVal.w[0] == 0x0000u)  // See if this an ICMP Echo reply to our request
171:                     {
172:                         // Get the sequence number and identifier fields
173:                         MACGetArray((uint8_t*)&dwVal, sizeof(dwVal));
174:                 
175:                         // See if the identifier matches the one we sent
176:                         if(dwVal.w[0] != 0xEFBE)
177:                             return;
178:                 
179:                         if(dwVal.w[1] != wICMPSequenceNumber)
180:                             return;
181:                 
182:                         // Validate the ICMP checksum field
183:                         IPSetRxBuffer(0);
184:                         if(CalcIPBufferChecksum(sizeof(ICMP_PACKET)))   // Two bytes of payload were sent in the echo request
185:                             return;
186:                 
187:                         // Flag that we received the response and stop the timer ticking
188:                         ICMPFlags.bReplyValid = 1;
189:                         ICMPTimer = TickGet() - ICMPTimer;
190:                     }
191:                 #endif
192:                 }
9D019B10  03C0E821   ADDU SP, S8, ZERO
9D019B14  8FBF001C   LW RA, 28(SP)
9D019B18  8FBE0018   LW S8, 24(SP)
9D019B1C  27BD0020   ADDIU SP, SP, 32
9D019B20  03E00008   JR RA
9D019B24  00000000   NOP
193:                 
194:                 #if defined(STACK_USE_ICMP_CLIENT)
195:                 /*********************************************************************
196:                  * Function:        void ICMPSendPing(uint32_t dwRemoteIP)
197:                  *
198:                  * PreCondition:    ICMPBeginUsage() returned true
199:                  *
200:                  * Input:           dwRemoteIP: IP Address to ping.  Must be stored
201:                  *                              big endian.  Ex. 192.168.0.1 should be
202:                  *                              passed as 0x0100A8C0.
203:                  *
204:                  * Output:          Begins the process of transmitting an ICMP echo
205:                  *                  request.  This normally involves an ARP
206:                  *                  resolution procedure first.
207:                  *
208:                  * Side Effects:    None
209:                  *
210:                  * Overview:        None
211:                  *
212:                  * Note:            None
213:                  ********************************************************************/
214:                 void ICMPSendPing(uint32_t dwRemoteIP)
215:                 {
216:                     ICMPFlags.bReplyValid = 0;
217:                     ICMPTimer = TickGet();
218:                     StaticVars.ICMPRemote.IPAddr.Val = dwRemoteIP;
219:                     ICMPState = SM_ARP_SEND_QUERY;
220:                 }
221:                 
222:                 #if defined(STACK_USE_DNS)
223:                 /*********************************************************************
224:                  * Function:        void ICMPSendPingToHost (uint8_t * szRemoteHost)
225:                  *
226:                  * PreCondition:    ICMPBeginUsage() returned true
227:                  *
228:                  * Input:           szRemoteHost: Host name to ping.  Must be stored
229:                  *                                in RAM if being called by PIC18.
230:                  *                                Ex. www.microchip.com
231:                  *
232:                  * Output:          Begins the process of transmitting an ICMP echo
233:                  *                  request.  This normally involves an ARP
234:                  *                  resolution procedure first.
235:                  *
236:                  * Side Effects:    None
237:                  *
238:                  * Overview:        None
239:                  *
240:                  * Note:            None
241:                  ********************************************************************/
242:                 void ICMPSendPingToHost(uint8_t * szRemoteHost)
243:                 {
244:                     ICMPFlags.bReplyValid = 0;
245:                     ICMPTimer = TickGet();
246:                     ICMPFlags.bRemoteHostIsROM = 0;
247:                     StaticVars.RemoteHost.szRAM = szRemoteHost;
248:                     ICMPState = SM_DNS_SEND_QUERY;
249:                 }
250:                 
251:                 #if defined(__XC8)
252:                 
253:                 /*********************************************************************
254:                  * Function:        void ICMPSendPingToHostROM (ROM uint8_t * szRemoteHost)
255:                  *
256:                  * PreCondition:    ICMPBeginUsage() returned true
257:                  *
258:                  * Input:           szRemoteHost: Host name to ping.  Must be stored
259:                  *                                in ROM. Should only be called by PIC18.
260:                  *                                Ex. www.microchip.com
261:                  *
262:                  * Output:          None
263:                  *
264:                  * Side Effects:    None
265:                  *
266:                  * Overview:        Begins the process of transmitting an ICMP echo
267:                  *                  request.  This normally involves an ARP
268:                  *                  resolution procedure first.
269:                  *
270:                  * Note:            None
271:                  ********************************************************************/
272:                 void ICMPSendPingToHostROM(ROM uint8_t * szRemoteHost)
273:                 {
274:                     ICMPFlags.bReplyValid = 0;
275:                     ICMPTimer = TickGet();
276:                     ICMPFlags.bRemoteHostIsROM = 1;
277:                     StaticVars.RemoteHost.szROM = szRemoteHost;
278:                     ICMPState = SM_DNS_SEND_QUERY;
279:                 }
280:                 
281:                 #endif
282:                 #endif
283:                 
284:                 /*********************************************************************
285:                  * Function:        int32_t ICMPGetReply(void)
286:                  *
287:                  * PreCondition:    ICMPBeginUsage() returned true and ICMPSendPing()
288:                  *                  was called
289:                  *
290:                  * Input:           None
291:                  *
292:                  * Output:          -3: Could not resolve hostname (DNS timeout or
293:                  *                      hostname invalid)
294:                  *                  -2: No response received yet
295:                  *                  -1: Operation timed out (longer than ICMP_TIMEOUT)
296:                  *                      has elapsed.
297:                  *                  >=0: Number of TICKs that elapsed between
298:                  *                       initial ICMP transmission and reception of
299:                  *                       a valid echo.
300:                  *
301:                  * Side Effects:    None
302:                  *
303:                  * Overview:        None
304:                  *
305:                  * Note:            None
306:                  ********************************************************************/
307:                 int32_t ICMPGetReply(void)
308:                 {
309:                     ICMP_PACKET ICMPPacket;
310:                 
311:                     switch(ICMPState)
312:                     {
313:                 #if defined(STACK_USE_DNS)
314:                         case SM_DNS_SEND_QUERY:
315:                             // Obtain DNS module ownership
316:                             if(!DNSBeginUsage())
317:                                 break;
318:                 
319:                             // Send DNS query
320:                             if(ICMPFlags.bRemoteHostIsROM)
321:                                 DNSResolveROM(StaticVars.RemoteHost.szROM, DNS_TYPE_A);
322:                             else
323:                                 DNSResolve(StaticVars.RemoteHost.szRAM, DNS_TYPE_A);
324:                 
325:                             ICMPState = SM_DNS_GET_RESPONSE;
326:                             break;
327:                 
328:                         case SM_DNS_GET_RESPONSE:
329:                             // See if DNS is done, and if so, get the remote IP address
330:                             if(!DNSIsResolved(&StaticVars.ICMPRemote.IPAddr))
331:                                 break;
332:                 
333:                             // Free the DNS module
334:                             DNSEndUsage();
335:                 
336:                             // Return error code if the DNS query failed
337:                             if(StaticVars.ICMPRemote.IPAddr.Val == 0x00000000ul)
338:                             {
339:                                 ICMPState = SM_IDLE;
340:                                 return -3;
341:                             }
342:                 
343:                             ICMPState = SM_ARP_SEND_QUERY;
344:                             // No break;
345:                 #endif
346:                 
347:                         case SM_ARP_SEND_QUERY:
348:                             ARPResolve(&StaticVars.ICMPRemote.IPAddr);
349:                             ICMPState = SM_ARP_GET_RESPONSE;
350:                             break;
351:                 
352:                         case SM_ARP_GET_RESPONSE:
353:                             // See if the ARP reponse was successfully received
354:                             if(!ARPIsResolved(&StaticVars.ICMPRemote.IPAddr, &StaticVars.ICMPRemote.MACAddr))
355:                                 break;
356:                 
357:                             ICMPState = SM_ICMP_SEND_ECHO_REQUEST;
358:                             // No break;
359:                 
360:                         case SM_ICMP_SEND_ECHO_REQUEST:
361:                             if(!IPIsTxReady())
362:                                 break;
363:                 
364:                             // Set up the ping packet
365:                             ICMPPacket.vType = 0x08;    // 0x08: Echo (ping) request
366:                             ICMPPacket.vCode = 0x00;
367:                             ICMPPacket.wChecksum = 0x0000;
368:                             ICMPPacket.wIdentifier = 0xEFBE;
369:                             wICMPSequenceNumber++;
370:                             ICMPPacket.wSequenceNumber = wICMPSequenceNumber;
371:                             ICMPPacket.wData = 0x2860;
372:                             ICMPPacket.wChecksum = CalcIPChecksum((uint8_t*)&ICMPPacket, sizeof(ICMPPacket));
373:                 
374:                             // Record the current time.  This will be used as a basis for
375:                             // finding the echo response time, which exludes the ARP and DNS
376:                             // steps
377:                             ICMPTimer = TickGet();
378:                 
379:                             // Position the write pointer for the next IPPutHeader operation
380:                             MACSetWritePtr(BASE_TX_ADDR + sizeof(ETHER_HEADER));
381:                 
382:                             // Create IP header in TX memory
383:                             IPPutHeader(&StaticVars.ICMPRemote, IP_PROT_ICMP, sizeof(ICMPPacket));
384:                             MACPutArray((uint8_t*)&ICMPPacket, sizeof(ICMPPacket));
385:                             MACFlush();
386:                 
387:                             // Echo sent, advance state
388:                             ICMPState = SM_ICMP_GET_ECHO_RESPONSE;
389:                             break;
390:                 
391:                         case SM_ICMP_GET_ECHO_RESPONSE:
392:                             // See if the echo was successfully received
393:                             if(ICMPFlags.bReplyValid)
394:                                 return (int32_t)ICMPTimer;
395:                 
396:                             break;
397:                 
398:                         // SM_IDLE or illegal/impossible state:
399:                         default:
400:                             return -1;
401:                     }
402:                 
403:                     // See if the DNS/ARP/echo request timed out
404:                     if(TickGet() - ICMPTimer > ICMP_TIMEOUT)
405:                     {
406:                         // Free DNS module if we have it in use
407:                         #if defined(STACK_USE_DNS)
408:                             if(ICMPState == SM_DNS_GET_RESPONSE)
409:                                 DNSEndUsage();
410:                         #endif
411:                 
412:                         // Stop ICMP echo test and return error to caller
413:                         ICMPState = SM_IDLE;
414:                         return -1;
415:                     }
416:                 
417:                     // Still working.  No response to report yet.
418:                     return -2;
419:                 }
420:                 
421:                 
422:                 /*********************************************************************
423:                  * Function:        bool ICMPBeginUsage(void)
424:                  *
425:                  * PreCondition:    None
426:                  *
427:                  * Input:           None
428:                  *
429:                  * Output:          true: You have successfully gained ownership of
430:                  *                        the ICMP client module and can now use the
431:                  *                        ICMPSendPing() and ICMPGetReply() functions.
432:                  *                  false: Some other application is using the ICMP
433:                  *                         client module.  Calling ICMPSendPing()
434:                  *                         will corrupt the other application's ping
435:                  *                         result.
436:                  *
437:                  * Side Effects:    None
438:                  *
439:                  * Overview:        Claims ownership of the ICMP module.
440:                  *
441:                  * Note:            None
442:                  ********************************************************************/
443:                 bool ICMPBeginUsage(void)
444:                 {
445:                     if(ICMPFlags.bICMPInUse)
446:                         return false;
447:                 
448:                     ICMPFlags.bICMPInUse = true;
449:                     return true;
450:                 }
451:                 
452:                 
453:                 /*********************************************************************
454:                  * Function:        void ICMPEndUsage(void)
455:                  *
456:                  * PreCondition:    ICMPBeginUsage() was called by you and it
457:                  *                  returned true.
458:                  *
459:                  * Input:           None
460:                  *
461:                  * Output:          Your ownership of the ICMP module is released.
462:                  *                  You can no longer use ICMPSendPing().
463:                  *
464:                  * Side Effects:    None
465:                  *
466:                  * Overview:        Gives up ownership of the ICMP module.
467:                  *
468:                  * Note:            None
469:                  ********************************************************************/
470:                 void ICMPEndUsage(void)
471:                 {
472:                     ICMPFlags.bICMPInUse = false;
473:                 }
474:                 
475:                 #endif //#if defined(STACK_USE_ICMP_CLIENT)
476:                 
477:                 #endif //#if defined(STACK_USE_ICMP_SERVER) || defined(STACK_USE_ICMP_CLIENT)
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/http2.c  --------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       http2.c
7:                   
8:                     Summary:
9:                       Module for Microchip TCP/IP Stack
10:                       -Serves dynamic pages to web browsers such as Microsoft Internet
11:                        Explorer, Mozilla Firefox, etc.
12:                       -Reference: RFC 2616
13:                  
14:                    Description:
15:                      HyperText Transfer Protocol (HTTP) Server
16:                  
17:                   *******************************************************************************/
18:                  
19:                  //DOM-IGNORE-BEGIN
20:                  /*******************************************************************************
21:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
22:                  
23:                  Microchip licenses to you the right to use, modify, copy and distribute
24:                  Software only when embedded on a Microchip microcontroller or digital signal
25:                  controller that is integrated into your product or third party product
26:                  (pursuant to the sublicense terms in the accompanying license agreement).
27:                  
28:                  You should refer to the license agreement accompanying this Software for
29:                  additional information regarding your rights and obligations.
30:                  
31:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
32:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
33:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
34:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
35:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
36:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
37:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
38:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
39:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
40:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
41:                   *******************************************************************************/
42:                  //DOM-IGNORE-END
43:                  
44:                  #define __HTTP2_C_
45:                  
46:                  #include "tcpip/tcpip.h"
47:                  
48:                  #if defined(STACK_USE_HTTP2_SERVER)
49:                  
50:                  #include "tcpip/http_print.h"
51:                  
52:                  /****************************************************************************
53:                    Section:
54:                      String Constants
55:                    ***************************************************************************/
56:                      static ROM uint8_t HTTP_CRLF[] = "\r\n";        // New line sequence
57:                      #define HTTP_CRLF_LEN   2                       // Length of above string
58:                  
59:                  /****************************************************************************
60:                    Section:
61:                      File and Content Type Settings
62:                    ***************************************************************************/
63:                      // File type extensions corresponding to HTTP_FILE_TYPE
64:                      static ROM char * ROM httpFileExtensions[HTTP_UNKNOWN+1] =
65:                      {
66:                          "txt",          // HTTP_TXT
67:                          "htm",          // HTTP_HTM
68:                          "html",         // HTTP_HTML
69:                          "cgi",          // HTTP_CGI
70:                          "xml",          // HTTP_XML
71:                          "css",          // HTTP_CSS
72:                          "gif",          // HTTP_GIF
73:                          "png",          // HTTP_PNG
74:                          "jpg",          // HTTP_JPG
75:                          "cla",          // HTTP_JAVA
76:                          "wav",          // HTTP_WAV
77:                          "\0\0\0"        // HTTP_UNKNOWN
78:                      };
79:                  
80:                      // Content-type strings corresponding to HTTP_FILE_TYPE
81:                      static ROM char * ROM httpContentTypes[HTTP_UNKNOWN+1] =
82:                      {
83:                          "text/plain",            // HTTP_TXT
84:                          "text/html",             // HTTP_HTM
85:                          "text/html",             // HTTP_HTML
86:                          "text/html",             // HTTP_CGI
87:                          "text/xml",              // HTTP_XML
88:                          "text/css",              // HTTP_CSS
89:                          "image/gif",             // HTTP_GIF
90:                          "image/png",             // HTTP_PNG
91:                          "image/jpeg",            // HTTP_JPG
92:                          "application/java-vm",   // HTTP_JAVA
93:                          "audio/x-wave",          // HTTP_WAV
94:                          ""                       // HTTP_UNKNOWN
95:                      };
96:                  
97:                  /****************************************************************************
98:                    Section:
99:                      Commands and Server Responses
100:                   ***************************************************************************/
101:                 
102:                     // Initial response strings (Corresponding to HTTP_STATUS)
103:                     static ROM char * ROM HTTPResponseHeaders[] =
104:                     {
105:                         "HTTP/1.1 200 OK\r\nConnection: close\r\n",
106:                         "HTTP/1.1 200 OK\r\nConnection: close\r\n",
107:                         "HTTP/1.1 400 Bad Request\r\nConnection: close\r\n\r\n400 Bad Request: can't handle Content-Length\r\n",
108:                         "HTTP/1.1 401 Unauthorized\r\nWWW-Authenticate: Basic realm=\"Protected\"\r\nConnection: close\r\n\r\n401 Unauthorized: Password required\r\n",
109:                         #if defined(HTTP_MPFS_UPLOAD)
110:                         "HTTP/1.1 404 Not found\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n404: File not found<br>Use <a href=\"/" HTTP_MPFS_UPLOAD "\">MPFS Upload</a> to program web pages\r\n",
111:                         #else
112:                         "HTTP/1.1 404 Not found\r\nConnection: close\r\n\r\n404: File not found\r\n",
113:                         #endif
114:                         "HTTP/1.1 414 Request-URI Too Long\r\nConnection: close\r\n\r\n414 Request-URI Too Long: Buffer overflow detected\r\n",
115:                         "HTTP/1.1 500 Internal Server Error\r\nConnection: close\r\n\r\n500 Internal Server Error: Expected data not present\r\n",
116:                         "HTTP/1.1 501 Not Implemented\r\nConnection: close\r\n\r\n501 Not Implemented: Only GET and POST supported\r\n",
117:                         #if defined(HTTP_MPFS_UPLOAD)
118:                         "HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><form method=post action=\"/" HTTP_MPFS_UPLOAD "\" enctype=\"multipart/form-data\"><b>MPFS Image Upload</b><p><input type=file name=i size=40> &nbsp; <input type=submit value=\"Upload\"></form></body></html>",
119:                         "",
120:                         "HTTP/1.1 200 OK\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><b>MPFS Update Successful</b><p><a href=\"/\">Site main page</a></body></html>",
121:                         "HTTP/1.1 500 Internal Server Error\r\nConnection: close\r\nContent-Type: text/html\r\n\r\n<html><body style=\"margin:100px\"><b>MPFS Image Corrupt or Wrong Version</b><p><a href=\"/" HTTP_MPFS_UPLOAD "\">Try again?</a></body></html>",
122:                         #endif
123:                         "HTTP/1.1 302 Found\r\nConnection: close\r\nLocation: ",
124:                         "HTTP/1.1 403 Forbidden\r\nConnection: close\r\n\r\n403 Forbidden: SSL Required - use HTTPS\r\n"
125:                     };
126:                 
127:                 /****************************************************************************
128:                   Section:
129:                     Header Parsing Configuration
130:                   ***************************************************************************/
131:                 
132:                     // Header strings for which we'd like to parse
133:                     static ROM char * ROM HTTPRequestHeaders[] =
134:                     {
135:                         "Cookie:",
136:                         "Authorization:",
137:                         "Content-Length:"
138:                     };
139:                 
140:                     // Set to length of longest string above
141:                     #define HTTP_MAX_HEADER_LEN     (15u)
142:                 
143:                 /****************************************************************************
144:                   Section:
145:                     HTTP Connection State Global Variables
146:                   ***************************************************************************/
147:                     #if defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
148:                         HTTP_CONN                   HTTPControlBlocks[MAX_HTTP_CONNECTIONS];
149:                         #define HTTPLoadConn(a)     do{curHTTPID = (a);}while(0)
150:                     #else
151:                         HTTP_CONN curHTTP;                          // Current HTTP connection state
152:                         static void HTTPLoadConn(uint8_t hHTTP);
153:                     #endif
154:                     HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];  // HTTP stubs with state machine and socket
155:                     uint8_t curHTTPID;                              // ID of the currently loaded HTTP_CONN
156:                 
157:                 /****************************************************************************
158:                   Section:
159:                     Function Prototypes
160:                   ***************************************************************************/
161:                     static void HTTPHeaderParseLookup(uint8_t i);
162:                     #if defined(HTTP_USE_COOKIES)
163:                     static void HTTPHeaderParseCookie(void);
164:                     #endif
165:                     #if defined(HTTP_USE_AUTHENTICATION)
166:                     static void HTTPHeaderParseAuthorization(void);
167:                     #endif
168:                     #if defined(HTTP_USE_POST)
169:                     static void HTTPHeaderParseContentLength(void);
170:                     static HTTP_READ_STATUS HTTPReadTo(uint8_t delim, uint8_t* buf, uint16_t len);
171:                     #endif
172:                 
173:                     static void HTTPProcess(void);
174:                     static bool HTTPSendFile(void);
175:                 
176:                     #if defined(HTTP_MPFS_UPLOAD)
177:                     static HTTP_IO_RESULT HTTPMPFSUpload(void);
178:                     #endif
179:                 
180:                     #define mMIN(a, b)  ((a<b)?a:b)
181:                     #define smHTTP      httpStubs[curHTTPID].sm         // Access the current state machine
182:                 
183:                 /*****************************************************************************
184:                   Function:
185:                     void HTTPInit(void)
186:                 
187:                   Summary:
188:                     Initializes the HTTP server module.
189:                 
190:                   Description:
191:                     Sets all HTTP sockets to the listening state, and initializes the
192:                     state machine and file handles for each connection.  If SSL is
193:                     enabled, opens a socket on that port as well.
194:                 
195:                   Precondition:
196:                     TCP must already be initialized.
197:                 
198:                   Parameters:
199:                     None
200:                 
201:                   Returns:
202:                     None
203:                 
204:                   Remarks:
205:                     This function is called only one during lifetime of the application.
206:                   ***************************************************************************/
207:                 void HTTPInit(void)
208:                 {
9D008540  27BDFFD8   ADDIU SP, SP, -40
9D008544  AFBF0024   SW RA, 36(SP)
9D008548  AFBE0020   SW S8, 32(SP)
9D00854C  AFB0001C   SW S0, 28(SP)
9D008550  03A0F021   ADDU S8, SP, ZERO
209:                     for(curHTTPID = 0; curHTTPID < MAX_HTTP_CONNECTIONS; curHTTPID++)
9D008554  A3808159   SB ZERO, -32423(GP)
9D008558  0B402192   J 0x9D008648
9D00855C  00000000   NOP
9D008638  93828159   LBU V0, -32423(GP)
9D00863C  24420001   ADDIU V0, V0, 1
9D008640  304200FF   ANDI V0, V0, 255
9D008644  A3828159   SB V0, -32423(GP)
9D008648  93828159   LBU V0, -32423(GP)
9D00864C  2C420002   SLTIU V0, V0, 2
9D008650  1440FFC3   BNE V0, ZERO, 0x9D008560
9D008654  00000000   NOP
210:                     {
211:                         smHTTP = SM_HTTP_IDLE;
9D008560  93828159   LBU V0, -32423(GP)
9D008564  00401821   ADDU V1, V0, ZERO
9D008568  3C02A000   LUI V0, -24576
9D00856C  000318C0   SLL V1, V1, 3
9D008570  244208C8   ADDIU V0, V0, 2248
9D008574  00621021   ADDU V0, V1, V0
9D008578  AC400000   SW ZERO, 0(V0)
212:                         sktHTTP = TCPOpen(0, TCP_OPEN_SERVER, HTTP_PORT, TCP_PURPOSE_HTTP_SERVER);
9D00857C  93828159   LBU V0, -32423(GP)
9D008580  00408021   ADDU S0, V0, ZERO
9D008584  00002021   ADDU A0, ZERO, ZERO
9D008588  00002821   ADDU A1, ZERO, ZERO
9D00858C  24060050   ADDIU A2, ZERO, 80
9D008590  24070008   ADDIU A3, ZERO, 8
9D008594  0F40010C   JAL TCPOpen
9D008598  00000000   NOP
9D00859C  00401821   ADDU V1, V0, ZERO
9D0085A0  3C02A000   LUI V0, -24576
9D0085A4  001020C0   SLL A0, S0, 3
9D0085A8  244208C8   ADDIU V0, V0, 2248
9D0085AC  00821021   ADDU V0, A0, V0
9D0085B0  A0430004   SB V1, 4(V0)
213:                         #if defined(STACK_USE_SSL_SERVER)
214:                         TCPAddSSLListener(sktHTTP, HTTPS_PORT);
215:                         #endif
216:                 
217:                         // Save the default record (just invalid file handles)
218:                         curHTTP.file = MPFS_INVALID_HANDLE;
9D0085B4  3C02A000   LUI V0, -24576
9D0085B8  244204A0   ADDIU V0, V0, 1184
9D0085BC  2403FFFF   ADDIU V1, ZERO, -1
9D0085C0  A0430018   SB V1, 24(V0)
219:                         curHTTP.offsets = MPFS_INVALID_HANDLE;
9D0085C4  3C02A000   LUI V0, -24576
9D0085C8  244204A0   ADDIU V0, V0, 1184
9D0085CC  2403FFFF   ADDIU V1, ZERO, -1
9D0085D0  A0430019   SB V1, 25(V0)
220:                         #if !defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
221:                         {
222:                             PTR_BASE oldPtr;
223:                 
224:                             oldPtr = MACSetWritePtr(BASE_HTTPB_ADDR + curHTTPID*sizeof(HTTP_CONN));
9D0085D4  0F404518   JAL MACGetHttpBaseAddr
9D0085D8  00000000   NOP
9D0085DC  00402021   ADDU A0, V0, ZERO
9D0085E0  93828159   LBU V0, -32423(GP)
9D0085E4  00401821   ADDU V1, V0, ZERO
9D0085E8  00601021   ADDU V0, V1, ZERO
9D0085EC  00021080   SLL V0, V0, 2
9D0085F0  00022940   SLL A1, V0, 5
9D0085F4  00451021   ADDU V0, V0, A1
9D0085F8  00431021   ADDU V0, V0, V1
9D0085FC  000210C0   SLL V0, V0, 3
9D008600  00821021   ADDU V0, A0, V0
9D008604  00402021   ADDU A0, V0, ZERO
9D008608  0F40452C   JAL MACSetWritePtr
9D00860C  00000000   NOP
9D008610  AFC20010   SW V0, 16(S8)
225:                             MACPutArray((uint8_t*)&curHTTP, sizeof(HTTP_CONN));
9D008614  3C02A000   LUI V0, -24576
9D008618  244204A0   ADDIU V0, V0, 1184
9D00861C  00402021   ADDU A0, V0, ZERO
9D008620  24050428   ADDIU A1, ZERO, 1064
9D008624  0F4045BD   JAL MACPutArray
9D008628  00000000   NOP
226:                             MACSetWritePtr(oldPtr);
9D00862C  8FC40010   LW A0, 16(S8)
9D008630  0F40452C   JAL MACSetWritePtr
9D008634  00000000   NOP
227:                         }
228:                         #endif
229:                     }
230:                 
231:                     // Set curHTTPID to zero so that first call to HTTPLoadConn() doesn't write
232:                     // dummy data outside reserved HTTP memory.
233:                     curHTTPID = 0;
9D008658  A3808159   SB ZERO, -32423(GP)
234:                 }
9D00865C  03C0E821   ADDU SP, S8, ZERO
9D008660  8FBF0024   LW RA, 36(SP)
9D008664  8FBE0020   LW S8, 32(SP)
9D008668  8FB0001C   LW S0, 28(SP)
9D00866C  27BD0028   ADDIU SP, SP, 40
9D008670  03E00008   JR RA
9D008674  00000000   NOP
235:                 
236:                 
237:                 /*****************************************************************************
238:                   Function:
239:                     void HTTPServer(void)
240:                 
241:                   Summary:
242:                     Performs periodic tasks for the HTTP2 module.
243:                 
244:                   Description:
245:                     Browses through each open connection and attempts to process any
246:                     pending operations.
247:                 
248:                   Precondition:
249:                     HTTPInit() must already be called.
250:                 
251:                   Parameters:
252:                     None
253:                 
254:                   Returns:
255:                     None
256:                 
257:                   Remarks:
258:                     This function acts as a task (similar to one in an RTOS).  It
259:                     performs its task in a co-operative manner, and the main application
260:                     must call this function repeatedly to ensure that all open or new
261:                     connections are served in a timely fashion.
262:                   ***************************************************************************/
263:                 void HTTPServer(void)
264:                 {
9D008678  27BDFFE0   ADDIU SP, SP, -32
9D00867C  AFBF001C   SW RA, 28(SP)
9D008680  AFBE0018   SW S8, 24(SP)
9D008684  03A0F021   ADDU S8, SP, ZERO
265:                     uint8_t conn;
266:                 
267:                     for(conn = 0; conn < MAX_HTTP_CONNECTIONS; conn++)
9D008688  A3C00010   SB ZERO, 16(S8)
9D00868C  0B402210   J 0x9D008840
9D008690  00000000   NOP
9D008834  93C20010   LBU V0, 16(S8)
9D008838  24420001   ADDIU V0, V0, 1
9D00883C  A3C20010   SB V0, 16(S8)
9D008840  93C20010   LBU V0, 16(S8)
9D008844  2C420002   SLTIU V0, V0, 2
9D008848  1440FF92   BNE V0, ZERO, 0x9D008694
9D00884C  00000000   NOP
268:                     {
269:                         if(httpStubs[conn].socket == INVALID_SOCKET)
9D008694  93C30010   LBU V1, 16(S8)
9D008698  3C02A000   LUI V0, -24576
9D00869C  000318C0   SLL V1, V1, 3
9D0086A0  244208C8   ADDIU V0, V0, 2248
9D0086A4  00621021   ADDU V0, V1, V0
9D0086A8  90430004   LBU V1, 4(V0)
9D0086AC  240200FE   ADDIU V0, ZERO, 254
9D0086B0  1062005F   BEQ V1, V0, 0x9D008830
9D0086B4  00000000   NOP
270:                             continue;
9D008830  00000000   NOP
271:                 
272:                         // If a socket is disconnected at any time
273:                         // forget about it and return to idle state.
274:                         // Must do this here, otherwise we will wait until a new
275:                         // connection arrives, which causes problems with Linux and with SSL
276:                         if(TCPWasReset(httpStubs[conn].socket))
9D0086B8  93C30010   LBU V1, 16(S8)
9D0086BC  3C02A000   LUI V0, -24576
9D0086C0  000318C0   SLL V1, V1, 3
9D0086C4  244208C8   ADDIU V0, V0, 2248
9D0086C8  00621021   ADDU V0, V1, V0
9D0086CC  90420004   LBU V0, 4(V0)
9D0086D0  00402021   ADDU A0, V0, ZERO
9D0086D4  0F400211   JAL TCPWasReset
9D0086D8  00000000   NOP
9D0086DC  10400039   BEQ V0, ZERO, 0x9D0087C4
9D0086E0  00000000   NOP
277:                         {
278:                             HTTPLoadConn(conn);
9D0086E4  93C20010   LBU V0, 16(S8)
9D0086E8  00402021   ADDU A0, V0, ZERO
9D0086EC  0F40221A   JAL 0x9D008868
9D0086F0  00000000   NOP
279:                             smHTTP = SM_HTTP_IDLE;
9D0086F4  93828159   LBU V0, -32423(GP)
9D0086F8  00401821   ADDU V1, V0, ZERO
9D0086FC  3C02A000   LUI V0, -24576
9D008700  000318C0   SLL V1, V1, 3
9D008704  244208C8   ADDIU V0, V0, 2248
9D008708  00621021   ADDU V0, V1, V0
9D00870C  AC400000   SW ZERO, 0(V0)
280:                 
281:                             // Make sure any opened files are closed
282:                             if(curHTTP.file != MPFS_INVALID_HANDLE)
9D008710  3C02A000   LUI V0, -24576
9D008714  244204A0   ADDIU V0, V0, 1184
9D008718  90430018   LBU V1, 24(V0)
9D00871C  240200FF   ADDIU V0, ZERO, 255
9D008720  1062000B   BEQ V1, V0, 0x9D008750
9D008724  00000000   NOP
283:                             {
284:                                 MPFSClose(curHTTP.file);
9D008728  3C02A000   LUI V0, -24576
9D00872C  244204A0   ADDIU V0, V0, 1184
9D008730  90420018   LBU V0, 24(V0)
9D008734  00402021   ADDU A0, V0, ZERO
9D008738  0F4033E5   JAL MPFSClose
9D00873C  00000000   NOP
285:                                 curHTTP.file = MPFS_INVALID_HANDLE;
9D008740  3C02A000   LUI V0, -24576
9D008744  244204A0   ADDIU V0, V0, 1184
9D008748  2403FFFF   ADDIU V1, ZERO, -1
9D00874C  A0430018   SB V1, 24(V0)
286:                             }
287:                             if(curHTTP.offsets != MPFS_INVALID_HANDLE)
9D008750  3C02A000   LUI V0, -24576
9D008754  244204A0   ADDIU V0, V0, 1184
9D008758  90430019   LBU V1, 25(V0)
9D00875C  240200FF   ADDIU V0, ZERO, 255
9D008760  1062000B   BEQ V1, V0, 0x9D008790
9D008764  00000000   NOP
288:                             {
289:                                 MPFSClose(curHTTP.offsets);
9D008768  3C02A000   LUI V0, -24576
9D00876C  244204A0   ADDIU V0, V0, 1184
9D008770  90420019   LBU V0, 25(V0)
9D008774  00402021   ADDU A0, V0, ZERO
9D008778  0F4033E5   JAL MPFSClose
9D00877C  00000000   NOP
290:                                 curHTTP.offsets = MPFS_INVALID_HANDLE;
9D008780  3C02A000   LUI V0, -24576
9D008784  244204A0   ADDIU V0, V0, 1184
9D008788  2403FFFF   ADDIU V1, ZERO, -1
9D00878C  A0430019   SB V1, 25(V0)
291:                             }
292:                 
293:                             // Adjust FIFO sizes to half and half.  Default state must remain
294:                             // here so that SSL handshakes, if required, can proceed
295:                             TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_PRESERVE_RX);
9D008790  93828159   LBU V0, -32423(GP)
9D008794  00401821   ADDU V1, V0, ZERO
9D008798  3C02A000   LUI V0, -24576
9D00879C  000318C0   SLL V1, V1, 3
9D0087A0  244208C8   ADDIU V0, V0, 2248
9D0087A4  00621021   ADDU V0, V1, V0
9D0087A8  90420004   LBU V0, 4(V0)
9D0087AC  00402021   ADDU A0, V0, ZERO
9D0087B0  24050001   ADDIU A1, ZERO, 1
9D0087B4  00003021   ADDU A2, ZERO, ZERO
9D0087B8  24070004   ADDIU A3, ZERO, 4
9D0087BC  0F401ED0   JAL TCPAdjustFIFOSize
9D0087C0  00000000   NOP
296:                         }
297:                 
298:                         // Determine if this connection is eligible for processing
299:                         if(httpStubs[conn].sm != SM_HTTP_IDLE || TCPIsGetReady(httpStubs[conn].socket))
9D0087C4  93C30010   LBU V1, 16(S8)
9D0087C8  3C02A000   LUI V0, -24576
9D0087CC  000318C0   SLL V1, V1, 3
9D0087D0  244208C8   ADDIU V0, V0, 2248
9D0087D4  00621021   ADDU V0, V1, V0
9D0087D8  8C420000   LW V0, 0(V0)
9D0087DC  1440000C   BNE V0, ZERO, 0x9D008810
9D0087E0  00000000   NOP
9D0087E4  93C30010   LBU V1, 16(S8)
9D0087E8  3C02A000   LUI V0, -24576
9D0087EC  000318C0   SLL V1, V1, 3
9D0087F0  244208C8   ADDIU V0, V0, 2248
9D0087F4  00621021   ADDU V0, V1, V0
9D0087F8  90420004   LBU V0, 4(V0)
9D0087FC  00402021   ADDU A0, V0, ZERO
9D008800  0F40066C   JAL TCPIsGetReady
9D008804  00000000   NOP
9D008808  1040000A   BEQ V0, ZERO, 0x9D008834
9D00880C  00000000   NOP
300:                         {
301:                             HTTPLoadConn(conn);
9D008810  93C20010   LBU V0, 16(S8)
9D008814  00402021   ADDU A0, V0, ZERO
9D008818  0F40221A   JAL 0x9D008868
9D00881C  00000000   NOP
302:                             HTTPProcess();
9D008820  0F402262   JAL 0x9D008988
9D008824  00000000   NOP
9D008828  0B40220D   J 0x9D008834
9D00882C  00000000   NOP
303:                         }
304:                     }
305:                 }
9D008850  03C0E821   ADDU SP, S8, ZERO
9D008854  8FBF001C   LW RA, 28(SP)
9D008858  8FBE0018   LW S8, 24(SP)
9D00885C  27BD0020   ADDIU SP, SP, 32
9D008860  03E00008   JR RA
9D008864  00000000   NOP
306:                 
307:                 /*****************************************************************************
308:                   Function:
309:                     static void HTTPLoadConn(uint8_t hHTTP)
310:                 
311:                   Summary:
312:                     Switches the currently loaded connection for the HTTP2 module.
313:                 
314:                   Description:
315:                     Saves the currently loaded HTTP connection back to Ethernet buffer
316:                     RAM, then loads the selected connection into curHTTP in local RAM
317:                     for processing.
318:                 
319:                   Precondition:
320:                     None
321:                 
322:                   Parameters:
323:                     hHTTP - the connection ID to load
324:                 
325:                   Returns:
326:                     None
327:                   ***************************************************************************/
328:                 #if !defined(HTTP_SAVE_CONTEXT_IN_PIC_RAM)
329:                 static void HTTPLoadConn(uint8_t hHTTP)
330:                 {
9D008868  27BDFFE0   ADDIU SP, SP, -32
9D00886C  AFBF001C   SW RA, 28(SP)
9D008870  AFBE0018   SW S8, 24(SP)
9D008874  03A0F021   ADDU S8, SP, ZERO
9D008878  00801021   ADDU V0, A0, ZERO
9D00887C  A3C20020   SB V0, 32(S8)
331:                     uint16_t oldPtr;
332:                 
333:                     // Return if already loaded
334:                     if(hHTTP == curHTTPID)
9D008880  93828159   LBU V0, -32423(GP)
9D008884  93C30020   LBU V1, 32(S8)
9D008888  10620038   BEQ V1, V0, 0x9D00896C
9D00888C  00000000   NOP
335:                         return;
9D00896C  00000000   NOP
336:                 
337:                     // Save the old one
338:                     oldPtr = MACSetWritePtr(BASE_HTTPB_ADDR + curHTTPID*sizeof(HTTP_CONN));
9D008890  0F404518   JAL MACGetHttpBaseAddr
9D008894  00000000   NOP
9D008898  00402021   ADDU A0, V0, ZERO
9D00889C  93828159   LBU V0, -32423(GP)
9D0088A0  00401821   ADDU V1, V0, ZERO
9D0088A4  00601021   ADDU V0, V1, ZERO
9D0088A8  00021080   SLL V0, V0, 2
9D0088AC  00022940   SLL A1, V0, 5
9D0088B0  00451021   ADDU V0, V0, A1
9D0088B4  00431021   ADDU V0, V0, V1
9D0088B8  000210C0   SLL V0, V0, 3
9D0088BC  00821021   ADDU V0, A0, V0
9D0088C0  00402021   ADDU A0, V0, ZERO
9D0088C4  0F40452C   JAL MACSetWritePtr
9D0088C8  00000000   NOP
9D0088CC  A7C20010   SH V0, 16(S8)
339:                     MACPutArray((uint8_t*)&curHTTP, sizeof(HTTP_CONN));
9D0088D0  3C02A000   LUI V0, -24576
9D0088D4  244204A0   ADDIU V0, V0, 1184
9D0088D8  00402021   ADDU A0, V0, ZERO
9D0088DC  24050428   ADDIU A1, ZERO, 1064
9D0088E0  0F4045BD   JAL MACPutArray
9D0088E4  00000000   NOP
340:                     MACSetWritePtr(oldPtr);
9D0088E8  97C20010   LHU V0, 16(S8)
9D0088EC  00402021   ADDU A0, V0, ZERO
9D0088F0  0F40452C   JAL MACSetWritePtr
9D0088F4  00000000   NOP
341:                 
342:                     // Load the new one
343:                     oldPtr = MACSetReadPtr(BASE_HTTPB_ADDR + hHTTP*sizeof(HTTP_CONN));
9D0088F8  0F404518   JAL MACGetHttpBaseAddr
9D0088FC  00000000   NOP
9D008900  00402021   ADDU A0, V0, ZERO
9D008904  93C30020   LBU V1, 32(S8)
9D008908  00601021   ADDU V0, V1, ZERO
9D00890C  00021080   SLL V0, V0, 2
9D008910  00022940   SLL A1, V0, 5
9D008914  00451021   ADDU V0, V0, A1
9D008918  00431021   ADDU V0, V0, V1
9D00891C  000210C0   SLL V0, V0, 3
9D008920  00821021   ADDU V0, A0, V0
9D008924  00402021   ADDU A0, V0, ZERO
9D008928  0F4046B6   JAL MACSetReadPtr
9D00892C  00000000   NOP
9D008930  A7C20010   SH V0, 16(S8)
344:                     MACGetArray((uint8_t*)&curHTTP, sizeof(HTTP_CONN));
9D008934  3C02A000   LUI V0, -24576
9D008938  244204A0   ADDIU V0, V0, 1184
9D00893C  00402021   ADDU A0, V0, ZERO
9D008940  24050428   ADDIU A1, ZERO, 1064
9D008944  0F4046D1   JAL MACGetArray
9D008948  00000000   NOP
345:                     MACSetReadPtr(oldPtr);
9D00894C  97C20010   LHU V0, 16(S8)
9D008950  00402021   ADDU A0, V0, ZERO
9D008954  0F4046B6   JAL MACSetReadPtr
9D008958  00000000   NOP
346:                 
347:                     // Remember which one is loaded
348:                     curHTTPID = hHTTP;
9D00895C  93C20020   LBU V0, 32(S8)
9D008960  A3828159   SB V0, -32423(GP)
9D008964  0B40225C   J 0x9D008970
9D008968  00000000   NOP
349:                 
350:                 }
9D008970  03C0E821   ADDU SP, S8, ZERO
9D008974  8FBF001C   LW RA, 28(SP)
9D008978  8FBE0018   LW S8, 24(SP)
9D00897C  27BD0020   ADDIU SP, SP, 32
9D008980  03E00008   JR RA
9D008984  00000000   NOP
351:                 #endif
352:                 
353:                 /*****************************************************************************
354:                   Function:
355:                     static void HTTPProcess(void)
356:                 
357:                   Description:
358:                     Performs any pending operations for the currently loaded HTTP connection.
359:                 
360:                   Precondition:
361:                     HTTPInit() and HTTPLoadConn() have been called.
362:                 
363:                   Parameters:
364:                     None
365:                 
366:                   Returns:
367:                     None
368:                   ***************************************************************************/
369:                 static void HTTPProcess(void)
370:                 {
9D008988  27BDFFB8   ADDIU SP, SP, -72
9D00898C  AFBF0044   SW RA, 68(SP)
9D008990  AFBE0040   SW S8, 64(SP)
9D008994  AFB0003C   SW S0, 60(SP)
9D008998  03A0F021   ADDU S8, SP, ZERO
371:                     uint16_t lenA, lenB;
372:                     uint8_t c, i;
373:                     bool isDone;
374:                     uint8_t *ext;
375:                     uint8_t buffer[HTTP_MAX_HEADER_LEN+1];
376:                 
377:                     do
378:                     {
379:                         isDone = true;
9D00899C  24020001   ADDIU V0, ZERO, 1
9D0089A0  A3C2001D   SB V0, 29(S8)
380:                 
381:                         switch(smHTTP)
9D0089A4  93828159   LBU V0, -32423(GP)
9D0089A8  00401821   ADDU V1, V0, ZERO
9D0089AC  3C02A000   LUI V0, -24576
9D0089B0  000318C0   SLL V1, V1, 3
9D0089B4  244208C8   ADDIU V0, V0, 2248
9D0089B8  00621021   ADDU V0, V1, V0
9D0089BC  8C420000   LW V0, 0(V0)
9D0089C0  2C43000C   SLTIU V1, V0, 12
9D0089C4  10600636   BEQ V1, ZERO, 0x9D00A2A0
9D0089C8  00000000   NOP
9D0089CC  00021880   SLL V1, V0, 2
9D0089D0  3C029D01   LUI V0, -25343
9D0089D4  244289E8   ADDIU V0, V0, -30232
9D0089D8  00621021   ADDU V0, V1, V0
9D0089DC  8C420000   LW V0, 0(V0)
9D0089E0  00400008   JR V0
9D0089E4  00000000   NOP
382:                         {
383:                 
384:                         case SM_HTTP_IDLE:
385:                 
386:                             // Check how much data is waiting
387:                             lenA = TCPIsGetReady(sktHTTP);
9D008A18  93828159   LBU V0, -32423(GP)
9D008A1C  00401821   ADDU V1, V0, ZERO
9D008A20  3C02A000   LUI V0, -24576
9D008A24  000318C0   SLL V1, V1, 3
9D008A28  244208C8   ADDIU V0, V0, 2248
9D008A2C  00621021   ADDU V0, V1, V0
9D008A30  90420004   LBU V0, 4(V0)
9D008A34  00402021   ADDU A0, V0, ZERO
9D008A38  0F40066C   JAL TCPIsGetReady
9D008A3C  00000000   NOP
9D008A40  A7C20018   SH V0, 24(S8)
388:                 
389:                             // If a connection has been made, then process the request
390:                             if(lenA)
9D008A44  97C20018   LHU V0, 24(S8)
9D008A48  10400602   BEQ V0, ZERO, 0x9D00A254
9D008A4C  00000000   NOP
391:                             {// Clear out state info and move to next state
392:                                 curHTTP.ptrData = curHTTP.data;
9D008A50  3C02A000   LUI V0, -24576
9D008A54  244204A0   ADDIU V0, V0, 1184
9D008A58  3C03A000   LUI V1, -24576
9D008A5C  246304C4   ADDIU V1, V1, 1220
9D008A60  AC430010   SW V1, 16(V0)
393:                                 smHTTP = SM_HTTP_PARSE_REQUEST;
9D008A64  93828159   LBU V0, -32423(GP)
9D008A68  00401821   ADDU V1, V0, ZERO
9D008A6C  3C02A000   LUI V0, -24576
9D008A70  000318C0   SLL V1, V1, 3
9D008A74  244208C8   ADDIU V0, V0, 2248
9D008A78  00621021   ADDU V0, V1, V0
9D008A7C  24030001   ADDIU V1, ZERO, 1
9D008A80  AC430000   SW V1, 0(V0)
394:                                 curHTTP.isAuthorized = 0xff;
9D008A84  3C02A000   LUI V0, -24576
9D008A88  244204A0   ADDIU V0, V0, 1184
9D008A8C  2403FFFF   ADDIU V1, ZERO, -1
9D008A90  A043001B   SB V1, 27(V0)
395:                                 curHTTP.hasArgs = false;
9D008A94  3C02A000   LUI V0, -24576
9D008A98  244204A0   ADDIU V0, V0, 1184
9D008A9C  A040001A   SB ZERO, 26(V0)
396:                                 curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D008AA0  0F405C42   JAL TickGet
9D008AA4  00000000   NOP
9D008AA8  00401821   ADDU V1, V0, ZERO
9D008AAC  3C0200D6   LUI V0, 214
9D008AB0  344293A4   ORI V0, V0, -27740
9D008AB4  00621821   ADDU V1, V1, V0
9D008AB8  3C02A000   LUI V0, -24576
9D008ABC  244204A0   ADDIU V0, V0, 1184
9D008AC0  AC430008   SW V1, 8(V0)
397:                                 curHTTP.callbackPos = 0xffffffff;
9D008AC4  3C02A000   LUI V0, -24576
9D008AC8  244204A0   ADDIU V0, V0, 1184
9D008ACC  2403FFFF   ADDIU V1, ZERO, -1
9D008AD0  AC43000C   SW V1, 12(V0)
398:                                 curHTTP.byteCount = 0;
9D008AD4  3C02A000   LUI V0, -24576
9D008AD8  AC4004A0   SW ZERO, 1184(V0)
399:                                 #if defined(HTTP_USE_POST)
400:                                 curHTTP.smPost = 0x00;
9D008ADC  3C02A000   LUI V0, -24576
9D008AE0  244204A0   ADDIU V0, V0, 1184
9D008AE4  A0400424   SB ZERO, 1060(V0)
401:                                 #endif
402:                 
403:                                 // Adjust the TCP FIFOs for optimal reception of
404:                                 // the next HTTP request from the browser
405:                                 TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_PRESERVE_RX | TCP_ADJUST_GIVE_REST_TO_RX);
9D008AE8  93828159   LBU V0, -32423(GP)
9D008AEC  00401821   ADDU V1, V0, ZERO
9D008AF0  3C02A000   LUI V0, -24576
9D008AF4  000318C0   SLL V1, V1, 3
9D008AF8  244208C8   ADDIU V0, V0, 2248
9D008AFC  00621021   ADDU V0, V1, V0
9D008B00  90420004   LBU V0, 4(V0)
9D008B04  00402021   ADDU A0, V0, ZERO
9D008B08  24050001   ADDIU A1, ZERO, 1
9D008B0C  00003021   ADDU A2, ZERO, ZERO
9D008B10  24070005   ADDIU A3, ZERO, 5
9D008B14  0F401ED0   JAL TCPAdjustFIFOSize
9D008B18  00000000   NOP
406:                             }
407:                             else
408:                                 // Don't break for new connections.  There may be
409:                                 // an entire request in the buffer already.
410:                                 break;
9D00A254  00000000   NOP
9D00A258  0B4028A8   J 0x9D00A2A0
9D00A25C  00000000   NOP
411:                 
412:                         case SM_HTTP_PARSE_REQUEST:
413:                 
414:                             // Verify the entire first line is in the FIFO
415:                             if(TCPFind(sktHTTP, '\n', 0, false) == 0xffff)
9D008B1C  93828159   LBU V0, -32423(GP)
9D008B20  00401821   ADDU V1, V0, ZERO
9D008B24  3C02A000   LUI V0, -24576
9D008B28  000318C0   SLL V1, V1, 3
9D008B2C  244208C8   ADDIU V0, V0, 2248
9D008B30  00621021   ADDU V0, V1, V0
9D008B34  90420004   LBU V0, 4(V0)
9D008B38  AFA00010   SW ZERO, 16(SP)
9D008B3C  00402021   ADDU A0, V0, ZERO
9D008B40  2405000A   ADDIU A1, ZERO, 10
9D008B44  00003021   ADDU A2, ZERO, ZERO
9D008B48  00003821   ADDU A3, ZERO, ZERO
9D008B4C  0F400AF0   JAL TCPFindEx
9D008B50  00000000   NOP
9D008B54  00401821   ADDU V1, V0, ZERO
9D008B58  3402FFFF   ORI V0, ZERO, -1
9D008B5C  14620038   BNE V1, V0, 0x9D008C40
9D008B60  00000000   NOP
416:                             {// First line isn't here yet
417:                                 if(TCPGetRxFIFOFree(sktHTTP) == 0u)
9D008B64  93828159   LBU V0, -32423(GP)
9D008B68  00401821   ADDU V1, V0, ZERO
9D008B6C  3C02A000   LUI V0, -24576
9D008B70  000318C0   SLL V1, V1, 3
9D008B74  244208C8   ADDIU V0, V0, 2248
9D008B78  00621021   ADDU V0, V1, V0
9D008B7C  90420004   LBU V0, 4(V0)
9D008B80  00402021   ADDU A0, V0, ZERO
9D008B84  0F40086C   JAL TCPGetRxFIFOFree
9D008B88  00000000   NOP
9D008B8C  1440000E   BNE V0, ZERO, 0x9D008BC8
9D008B90  00000000   NOP
418:                                 {// If the FIFO is full, we overflowed
419:                                     curHTTP.httpStatus = HTTP_OVERFLOW;
9D008B94  3C02A000   LUI V0, -24576
9D008B98  244204A0   ADDIU V0, V0, 1184
9D008B9C  24030005   ADDIU V1, ZERO, 5
9D008BA0  AC43001C   SW V1, 28(V0)
420:                                     smHTTP = SM_HTTP_SERVE_HEADERS;
9D008BA4  93828159   LBU V0, -32423(GP)
9D008BA8  00401821   ADDU V1, V0, ZERO
9D008BAC  3C02A000   LUI V0, -24576
9D008BB0  000318C0   SLL V1, V1, 3
9D008BB4  244208C8   ADDIU V0, V0, 2248
9D008BB8  00621021   ADDU V0, V1, V0
9D008BBC  24030007   ADDIU V1, ZERO, 7
9D008BC0  AC430000   SW V1, 0(V0)
421:                                     isDone = false;
9D008BC4  A3C0001D   SB ZERO, 29(S8)
422:                                 }
423:                                 if((int32_t)(TickGet() - curHTTP.callbackID) > (int32_t)0)
9D008BC8  0F405C42   JAL TickGet
9D008BCC  00000000   NOP
9D008BD0  00401821   ADDU V1, V0, ZERO
9D008BD4  3C02A000   LUI V0, -24576
9D008BD8  244204A0   ADDIU V0, V0, 1184
9D008BDC  8C420008   LW V0, 8(V0)
9D008BE0  00621023   SUBU V0, V1, V0
9D008BE4  1840059E   BLEZ V0, 0x9D00A260
9D008BE8  00000000   NOP
424:                                 {// A timeout has occurred
425:                                     TCPDisconnect(sktHTTP);
9D008BEC  93828159   LBU V0, -32423(GP)
9D008BF0  00401821   ADDU V1, V0, ZERO
9D008BF4  3C02A000   LUI V0, -24576
9D008BF8  000318C0   SLL V1, V1, 3
9D008BFC  244208C8   ADDIU V0, V0, 2248
9D008C00  00621021   ADDU V0, V1, V0
9D008C04  90420004   LBU V0, 4(V0)
9D008C08  00402021   ADDU A0, V0, ZERO
9D008C0C  0F40025C   JAL TCPDisconnect
9D008C10  00000000   NOP
426:                                     smHTTP = SM_HTTP_DISCONNECT;
9D008C14  93828159   LBU V0, -32423(GP)
9D008C18  00401821   ADDU V1, V0, ZERO
9D008C1C  3C02A000   LUI V0, -24576
9D008C20  000318C0   SLL V1, V1, 3
9D008C24  244208C8   ADDIU V0, V0, 2248
9D008C28  00621021   ADDU V0, V1, V0
9D008C2C  2403000B   ADDIU V1, ZERO, 11
9D008C30  AC430000   SW V1, 0(V0)
427:                                     isDone = false;
9D008C34  A3C0001D   SB ZERO, 29(S8)
428:                                 }
429:                                 break;
9D008C38  0B4028A8   J 0x9D00A2A0
9D008C3C  00000000   NOP
9D00A260  00000000   NOP
9D00A264  0B4028A8   J 0x9D00A2A0
9D00A268  00000000   NOP
430:                             }
431:                 
432:                             // Reset the watchdog timer
433:                             curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D008C40  0F405C42   JAL TickGet
9D008C44  00000000   NOP
9D008C48  00401821   ADDU V1, V0, ZERO
9D008C4C  3C0200D6   LUI V0, 214
9D008C50  344293A4   ORI V0, V0, -27740
9D008C54  00621821   ADDU V1, V1, V0
9D008C58  3C02A000   LUI V0, -24576
9D008C5C  244204A0   ADDIU V0, V0, 1184
9D008C60  AC430008   SW V1, 8(V0)
434:                 
435:                             // Determine the request method
436:                             lenA = TCPFind(sktHTTP, ' ', 0, false);
9D008C64  93828159   LBU V0, -32423(GP)
9D008C68  00401821   ADDU V1, V0, ZERO
9D008C6C  3C02A000   LUI V0, -24576
9D008C70  000318C0   SLL V1, V1, 3
9D008C74  244208C8   ADDIU V0, V0, 2248
9D008C78  00621021   ADDU V0, V1, V0
9D008C7C  90420004   LBU V0, 4(V0)
9D008C80  AFA00010   SW ZERO, 16(SP)
9D008C84  00402021   ADDU A0, V0, ZERO
9D008C88  24050020   ADDIU A1, ZERO, 32
9D008C8C  00003021   ADDU A2, ZERO, ZERO
9D008C90  00003821   ADDU A3, ZERO, ZERO
9D008C94  0F400AF0   JAL TCPFindEx
9D008C98  00000000   NOP
9D008C9C  A7C20018   SH V0, 24(S8)
437:                             if(lenA > 5u)
9D008CA0  97C20018   LHU V0, 24(S8)
9D008CA4  2C420006   SLTIU V0, V0, 6
9D008CA8  14400003   BNE V0, ZERO, 0x9D008CB8
9D008CAC  00000000   NOP
438:                                 lenA = 5;
9D008CB0  24020005   ADDIU V0, ZERO, 5
9D008CB4  A7C20018   SH V0, 24(S8)
439:                             TCPGetArray(sktHTTP, curHTTP.data, lenA+1);
9D008CB8  93828159   LBU V0, -32423(GP)
9D008CBC  00401821   ADDU V1, V0, ZERO
9D008CC0  3C02A000   LUI V0, -24576
9D008CC4  000318C0   SLL V1, V1, 3
9D008CC8  244208C8   ADDIU V0, V0, 2248
9D008CCC  00621021   ADDU V0, V1, V0
9D008CD0  90420004   LBU V0, 4(V0)
9D008CD4  00401821   ADDU V1, V0, ZERO
9D008CD8  97C20018   LHU V0, 24(S8)
9D008CDC  24420001   ADDIU V0, V0, 1
9D008CE0  3042FFFF   ANDI V0, V0, -1
9D008CE4  00602021   ADDU A0, V1, ZERO
9D008CE8  3C03A000   LUI V1, -24576
9D008CEC  246504C4   ADDIU A1, V1, 1220
9D008CF0  00403021   ADDU A2, V0, ZERO
9D008CF4  0F40077A   JAL TCPGetArray
9D008CF8  00000000   NOP
440:                 
441:                             if ( memcmppgm2ram(curHTTP.data, (ROM void*)"GET", 3) == 0)
9D008CFC  3C02A000   LUI V0, -24576
9D008D00  244404C4   ADDIU A0, V0, 1220
9D008D04  3C029D01   LUI V0, -25343
9D008D08  24455ADC   ADDIU A1, V0, 23260
9D008D0C  24060003   ADDIU A2, ZERO, 3
9D008D10  0F406D65   JAL 0x9D01B594
9D008D14  00000000   NOP
9D008D18  14400006   BNE V0, ZERO, 0x9D008D34
9D008D1C  00000000   NOP
442:                                 curHTTP.httpStatus = HTTP_GET;
9D008D20  3C02A000   LUI V0, -24576
9D008D24  244204A0   ADDIU V0, V0, 1184
9D008D28  AC40001C   SW ZERO, 28(V0)
9D008D2C  0B40236B   J 0x9D008DAC
9D008D30  00000000   NOP
443:                             #if defined(HTTP_USE_POST)
444:                             else if ( memcmppgm2ram(curHTTP.data, (ROM void*)"POST", 4) == 0)
9D008D34  3C02A000   LUI V0, -24576
9D008D38  244404C4   ADDIU A0, V0, 1220
9D008D3C  3C029D01   LUI V0, -25343
9D008D40  24455AE0   ADDIU A1, V0, 23264
9D008D44  24060004   ADDIU A2, ZERO, 4
9D008D48  0F406D65   JAL 0x9D01B594
9D008D4C  00000000   NOP
9D008D50  14400007   BNE V0, ZERO, 0x9D008D70
9D008D54  00000000   NOP
445:                                 curHTTP.httpStatus = HTTP_POST;
9D008D58  3C02A000   LUI V0, -24576
9D008D5C  244204A0   ADDIU V0, V0, 1184
9D008D60  24030001   ADDIU V1, ZERO, 1
9D008D64  AC43001C   SW V1, 28(V0)
9D008D68  0B40236B   J 0x9D008DAC
9D008D6C  00000000   NOP
446:                             #endif
447:                             else
448:                             {// Unrecognized method, so return not implemented
449:                                 curHTTP.httpStatus = HTTP_NOT_IMPLEMENTED;
9D008D70  3C02A000   LUI V0, -24576
9D008D74  244204A0   ADDIU V0, V0, 1184
9D008D78  24030007   ADDIU V1, ZERO, 7
9D008D7C  AC43001C   SW V1, 28(V0)
450:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
9D008D80  93828159   LBU V0, -32423(GP)
9D008D84  00401821   ADDU V1, V0, ZERO
9D008D88  3C02A000   LUI V0, -24576
9D008D8C  000318C0   SLL V1, V1, 3
9D008D90  244208C8   ADDIU V0, V0, 2248
9D008D94  00621021   ADDU V0, V1, V0
9D008D98  24030007   ADDIU V1, ZERO, 7
9D008D9C  AC430000   SW V1, 0(V0)
451:                                 isDone = false;
9D008DA0  A3C0001D   SB ZERO, 29(S8)
452:                                 break;
9D008DA4  0B4028A8   J 0x9D00A2A0
9D008DA8  00000000   NOP
453:                             }
454:                 
455:                             // Find end of filename
456:                             lenA = TCPFind(sktHTTP, ' ', 0, false);
9D008DAC  93828159   LBU V0, -32423(GP)
9D008DB0  00401821   ADDU V1, V0, ZERO
9D008DB4  3C02A000   LUI V0, -24576
9D008DB8  000318C0   SLL V1, V1, 3
9D008DBC  244208C8   ADDIU V0, V0, 2248
9D008DC0  00621021   ADDU V0, V1, V0
9D008DC4  90420004   LBU V0, 4(V0)
9D008DC8  AFA00010   SW ZERO, 16(SP)
9D008DCC  00402021   ADDU A0, V0, ZERO
9D008DD0  24050020   ADDIU A1, ZERO, 32
9D008DD4  00003021   ADDU A2, ZERO, ZERO
9D008DD8  00003821   ADDU A3, ZERO, ZERO
9D008DDC  0F400AF0   JAL TCPFindEx
9D008DE0  00000000   NOP
9D008DE4  A7C20018   SH V0, 24(S8)
457:                             lenB = TCPFindEx(sktHTTP, '?', 0, lenA, false);
9D008DE8  93828159   LBU V0, -32423(GP)
9D008DEC  00401821   ADDU V1, V0, ZERO
9D008DF0  3C02A000   LUI V0, -24576
9D008DF4  000318C0   SLL V1, V1, 3
9D008DF8  244208C8   ADDIU V0, V0, 2248
9D008DFC  00621021   ADDU V0, V1, V0
9D008E00  90420004   LBU V0, 4(V0)
9D008E04  00401821   ADDU V1, V0, ZERO
9D008E08  97C20018   LHU V0, 24(S8)
9D008E0C  AFA00010   SW ZERO, 16(SP)
9D008E10  00602021   ADDU A0, V1, ZERO
9D008E14  2405003F   ADDIU A1, ZERO, 63
9D008E18  00003021   ADDU A2, ZERO, ZERO
9D008E1C  00403821   ADDU A3, V0, ZERO
9D008E20  0F400AF0   JAL TCPFindEx
9D008E24  00000000   NOP
9D008E28  A7C2001A   SH V0, 26(S8)
458:                             lenA = mMIN(lenA, lenB);
9D008E2C  97C30018   LHU V1, 24(S8)
9D008E30  97C2001A   LHU V0, 26(S8)
9D008E34  3045FFFF   ANDI A1, V0, -1
9D008E38  3064FFFF   ANDI A0, V1, -1
9D008E3C  0085202B   SLTU A0, A0, A1
9D008E40  10800002   BEQ A0, ZERO, 0x9D008E4C
9D008E44  00000000   NOP
9D008E48  00601021   ADDU V0, V1, ZERO
9D008E4C  A7C20018   SH V0, 24(S8)
459:                 
460:                             // If the file name is too long, then reject the request
461:                             if(lenA > HTTP_MAX_DATA_LEN - HTTP_DEFAULT_LEN - 1)
9D008E50  97C20018   LHU V0, 24(S8)
9D008E54  2C4203F6   SLTIU V0, V0, 1014
9D008E58  14400010   BNE V0, ZERO, 0x9D008E9C
9D008E5C  00000000   NOP
462:                             {
463:                                 curHTTP.httpStatus = HTTP_OVERFLOW;
9D008E60  3C02A000   LUI V0, -24576
9D008E64  244204A0   ADDIU V0, V0, 1184
9D008E68  24030005   ADDIU V1, ZERO, 5
9D008E6C  AC43001C   SW V1, 28(V0)
464:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
9D008E70  93828159   LBU V0, -32423(GP)
9D008E74  00401821   ADDU V1, V0, ZERO
9D008E78  3C02A000   LUI V0, -24576
9D008E7C  000318C0   SLL V1, V1, 3
9D008E80  244208C8   ADDIU V0, V0, 2248
9D008E84  00621021   ADDU V0, V1, V0
9D008E88  24030007   ADDIU V1, ZERO, 7
9D008E8C  AC430000   SW V1, 0(V0)
465:                                 isDone = false;
9D008E90  A3C0001D   SB ZERO, 29(S8)
466:                                 break;
9D008E94  0B4028A8   J 0x9D00A2A0
9D008E98  00000000   NOP
467:                             }
468:                 
469:                             // Read in the filename and decode
470:                             lenB = TCPGetArray(sktHTTP, curHTTP.data, lenA);
9D008E9C  93828159   LBU V0, -32423(GP)
9D008EA0  00401821   ADDU V1, V0, ZERO
9D008EA4  3C02A000   LUI V0, -24576
9D008EA8  000318C0   SLL V1, V1, 3
9D008EAC  244208C8   ADDIU V0, V0, 2248
9D008EB0  00621021   ADDU V0, V1, V0
9D008EB4  90420004   LBU V0, 4(V0)
9D008EB8  00401821   ADDU V1, V0, ZERO
9D008EBC  97C20018   LHU V0, 24(S8)
9D008EC0  00602021   ADDU A0, V1, ZERO
9D008EC4  3C03A000   LUI V1, -24576
9D008EC8  246504C4   ADDIU A1, V1, 1220
9D008ECC  00403021   ADDU A2, V0, ZERO
9D008ED0  0F40077A   JAL TCPGetArray
9D008ED4  00000000   NOP
9D008ED8  A7C2001A   SH V0, 26(S8)
471:                             curHTTP.data[lenB] = '\0';
9D008EDC  97C3001A   LHU V1, 26(S8)
9D008EE0  3C02A000   LUI V0, -24576
9D008EE4  244204A0   ADDIU V0, V0, 1184
9D008EE8  00621021   ADDU V0, V1, V0
9D008EEC  A0400024   SB ZERO, 36(V0)
472:                             HTTPURLDecode(curHTTP.data);
9D008EF0  3C02A000   LUI V0, -24576
9D008EF4  244404C4   ADDIU A0, V0, 1220
9D008EF8  0F4029B5   JAL HTTPURLDecode
9D008EFC  00000000   NOP
473:                 
474:                             // Decode may have changed the string length - update it here
475:                             lenB = strlen((char*)curHTTP.data);
9D008F00  3C02A000   LUI V0, -24576
9D008F04  244204C4   ADDIU V0, V0, 1220
9D008F08  00402021   ADDU A0, V0, ZERO
9D008F0C  0F4067E2   JAL 0x9D019F88
9D008F10  00000000   NOP
9D008F14  A7C2001A   SH V0, 26(S8)
476:                 
477:                             // Check if this is an MPFS Upload
478:                             #if defined(HTTP_MPFS_UPLOAD)
479:                             if(memcmppgm2ram(&curHTTP.data[1], HTTP_MPFS_UPLOAD, sizeof(HTTP_MPFS_UPLOAD)) == 0)
480:                             {// Read remainder of line, and bypass all file opening, etc.
481:                                 #if defined(HTTP_USE_AUTHENTICATION)
482:                                 curHTTP.isAuthorized = HTTPNeedsAuth(&curHTTP.data[1]);
483:                                 #endif
484:                                 if(curHTTP.httpStatus == HTTP_GET)
485:                                     curHTTP.httpStatus = HTTP_MPFS_FORM;
486:                                 else
487:                                     curHTTP.httpStatus = HTTP_MPFS_UP;
488:                 
489:                                 smHTTP = SM_HTTP_PARSE_HEADERS;
490:                                 isDone = false;
491:                                 break;
492:                             }
493:                             #endif
494:                 
495:                             // If the last character is a not a directory delimiter, then try to open the file
496:                             // String starts at 2nd character, because the first is always a '/'
497:                             if(curHTTP.data[lenB-1] != '/')
9D008F18  97C2001A   LHU V0, 26(S8)
9D008F1C  2443FFFF   ADDIU V1, V0, -1
9D008F20  3C02A000   LUI V0, -24576
9D008F24  244204A0   ADDIU V0, V0, 1184
9D008F28  00621021   ADDU V0, V1, V0
9D008F2C  90430024   LBU V1, 36(V0)
9D008F30  2402002F   ADDIU V0, ZERO, 47
9D008F34  10620009   BEQ V1, V0, 0x9D008F5C
9D008F38  00000000   NOP
498:                                 curHTTP.file = MPFSOpen(&curHTTP.data[1]);
9D008F3C  3C02A000   LUI V0, -24576
9D008F40  244404C5   ADDIU A0, V0, 1221
9D008F44  0F4032C4   JAL MPFSOpen
9D008F48  00000000   NOP
9D008F4C  00401821   ADDU V1, V0, ZERO
9D008F50  3C02A000   LUI V0, -24576
9D008F54  244204A0   ADDIU V0, V0, 1184
9D008F58  A0430018   SB V1, 24(V0)
499:                 
500:                             // If the open fails, then add our default name and try again
501:                             if(curHTTP.file == MPFS_INVALID_HANDLE)
9D008F5C  3C02A000   LUI V0, -24576
9D008F60  244204A0   ADDIU V0, V0, 1184
9D008F64  90430018   LBU V1, 24(V0)
9D008F68  240200FF   ADDIU V0, ZERO, 255
9D008F6C  14620028   BNE V1, V0, 0x9D009010
9D008F70  00000000   NOP
502:                             {
503:                                 // Add the directory delimiter if needed
504:                                 if(curHTTP.data[lenB-1] != '/')
9D008F74  97C2001A   LHU V0, 26(S8)
9D008F78  2443FFFF   ADDIU V1, V0, -1
9D008F7C  3C02A000   LUI V0, -24576
9D008F80  244204A0   ADDIU V0, V0, 1184
9D008F84  00621021   ADDU V0, V1, V0
9D008F88  90430024   LBU V1, 36(V0)
9D008F8C  2402002F   ADDIU V0, ZERO, 47
9D008F90  1062000A   BEQ V1, V0, 0x9D008FBC
9D008F94  00000000   NOP
505:                                     curHTTP.data[lenB++] = '/';
9D008F98  97C3001A   LHU V1, 26(S8)
9D008F9C  3C02A000   LUI V0, -24576
9D008FA0  244204A0   ADDIU V0, V0, 1184
9D008FA4  00621021   ADDU V0, V1, V0
9D008FA8  2403002F   ADDIU V1, ZERO, 47
9D008FAC  A0430024   SB V1, 36(V0)
9D008FB0  97C2001A   LHU V0, 26(S8)
9D008FB4  24420001   ADDIU V0, V0, 1
9D008FB8  A7C2001A   SH V0, 26(S8)
506:                 
507:                                 // Add our default file name
508:                                 #if defined(STACK_USE_SSL_SERVER)
509:                                 if(TCPIsSSL(sktHTTP))
510:                                 {
511:                                     strcpypgm2ram((void*)&curHTTP.data[lenB], HTTPS_DEFAULT_FILE);
512:                                     lenB += strlenpgm(HTTPS_DEFAULT_FILE);
513:                                 }
514:                                 else
515:                                 #endif
516:                                 {
517:                                     strcpypgm2ram((void*)&curHTTP.data[lenB], HTTP_DEFAULT_FILE);
9D008FBC  3C02A000   LUI V0, -24576
9D008FC0  244304C4   ADDIU V1, V0, 1220
9D008FC4  97C2001A   LHU V0, 26(S8)
9D008FC8  00621021   ADDU V0, V1, V0
9D008FCC  00402021   ADDU A0, V0, ZERO
9D008FD0  3C029D01   LUI V0, -25343
9D008FD4  24455AE8   ADDIU A1, V0, 23272
9D008FD8  2406000A   ADDIU A2, ZERO, 10
9D008FDC  0F406788   JAL 0x9D019E20
9D008FE0  00000000   NOP
518:                                     lenB += strlenpgm(HTTP_DEFAULT_FILE);
9D008FE4  97C2001A   LHU V0, 26(S8)
9D008FE8  24420009   ADDIU V0, V0, 9
9D008FEC  A7C2001A   SH V0, 26(S8)
519:                                 }
520:                 
521:                                 // Try to open again
522:                                 curHTTP.file = MPFSOpen(&curHTTP.data[1]);
9D008FF0  3C02A000   LUI V0, -24576
9D008FF4  244404C5   ADDIU A0, V0, 1221
9D008FF8  0F4032C4   JAL MPFSOpen
9D008FFC  00000000   NOP
9D009000  00401821   ADDU V1, V0, ZERO
9D009004  3C02A000   LUI V0, -24576
9D009008  244204A0   ADDIU V0, V0, 1184
9D00900C  A0430018   SB V1, 24(V0)
523:                             }
524:                 
525:                             // Find the extension in the filename
526:                             for(ext = curHTTP.data + lenB-1; ext != curHTTP.data; ext--)
9D009010  97C2001A   LHU V0, 26(S8)
9D009014  2443FFFF   ADDIU V1, V0, -1
9D009018  3C02A000   LUI V0, -24576
9D00901C  244204C4   ADDIU V0, V0, 1220
9D009020  00621021   ADDU V0, V1, V0
9D009024  AFC20020   SW V0, 32(S8)
9D009028  0B402414   J 0x9D009050
9D00902C  00000000   NOP
9D009044  8FC20020   LW V0, 32(S8)
9D009048  2442FFFF   ADDIU V0, V0, -1
9D00904C  AFC20020   SW V0, 32(S8)
9D009050  8FC30020   LW V1, 32(S8)
9D009054  3C02A000   LUI V0, -24576
9D009058  244204C4   ADDIU V0, V0, 1220
9D00905C  1462FFF4   BNE V1, V0, 0x9D009030
9D009060  00000000   NOP
9D009064  0B40241C   J 0x9D009070
9D009068  00000000   NOP
527:                                 if(*ext == '.')
9D009030  8FC20020   LW V0, 32(S8)
9D009034  90430000   LBU V1, 0(V0)
9D009038  2402002E   ADDIU V0, ZERO, 46
9D00903C  1062000B   BEQ V1, V0, 0x9D00906C
9D009040  00000000   NOP
528:                                     break;
9D00906C  00000000   NOP
529:                 
530:                             // Compare to known extensions to determine Content-Type
531:                             ext++;
9D009070  8FC20020   LW V0, 32(S8)
9D009074  24420001   ADDIU V0, V0, 1
9D009078  AFC20020   SW V0, 32(S8)
532:                             for(curHTTP.fileType = HTTP_TXT; curHTTP.fileType < HTTP_UNKNOWN; curHTTP.fileType++)
9D00907C  3C02A000   LUI V0, -24576
9D009080  244204A0   ADDIU V0, V0, 1184
9D009084  AC400020   SW ZERO, 32(V0)
9D009088  0B402439   J 0x9D0090E4
9D00908C  00000000   NOP
9D0090C8  3C02A000   LUI V0, -24576
9D0090CC  244204A0   ADDIU V0, V0, 1184
9D0090D0  8C420020   LW V0, 32(V0)
9D0090D4  24430001   ADDIU V1, V0, 1
9D0090D8  3C02A000   LUI V0, -24576
9D0090DC  244204A0   ADDIU V0, V0, 1184
9D0090E0  AC430020   SW V1, 32(V0)
9D0090E4  3C02A000   LUI V0, -24576
9D0090E8  244204A0   ADDIU V0, V0, 1184
9D0090EC  8C420020   LW V0, 32(V0)
9D0090F0  2C42000B   SLTIU V0, V0, 11
9D0090F4  1440FFE6   BNE V0, ZERO, 0x9D009090
9D0090F8  00000000   NOP
9D0090FC  0B402442   J 0x9D009108
9D009100  00000000   NOP
533:                                 if(!stricmppgm2ram(ext, (ROM void*)httpFileExtensions[curHTTP.fileType]))
9D009090  3C02A000   LUI V0, -24576
9D009094  244204A0   ADDIU V0, V0, 1184
9D009098  8C430020   LW V1, 32(V0)
9D00909C  3C029D01   LUI V0, -25343
9D0090A0  00031880   SLL V1, V1, 2
9D0090A4  24425680   ADDIU V0, V0, 22144
9D0090A8  00621021   ADDU V0, V1, V0
9D0090AC  8C420000   LW V0, 0(V0)
9D0090B0  8FC40020   LW A0, 32(S8)
9D0090B4  00402821   ADDU A1, V0, ZERO
9D0090B8  0F403EF5   JAL stricmppgm2ram
9D0090BC  00000000   NOP
9D0090C0  10400010   BEQ V0, ZERO, 0x9D009104
9D0090C4  00000000   NOP
534:                                     break;
9D009104  00000000   NOP
535:                 
536:                             // Perform first round authentication (pass file name only)
537:                             #if defined(HTTP_USE_AUTHENTICATION)
538:                             curHTTP.isAuthorized = HTTPNeedsAuth(&curHTTP.data[1]);
539:                             #endif
540:                 
541:                             // If the file was found, see if it has an index
542:                             if(curHTTP.file != MPFS_INVALID_HANDLE &&
9D009108  3C02A000   LUI V0, -24576
9D00910C  244204A0   ADDIU V0, V0, 1184
9D009110  90430018   LBU V1, 24(V0)
9D009114  240200FF   ADDIU V0, ZERO, 255
9D009118  10620019   BEQ V1, V0, 0x9D009180
9D00911C  00000000   NOP
9D00913C  10400010   BEQ V0, ZERO, 0x9D009180
9D009140  00000000   NOP
543:                                 (MPFSGetFlags(curHTTP.file) & MPFS2_FLAG_HASINDEX) )
9D009120  3C02A000   LUI V0, -24576
9D009124  244204A0   ADDIU V0, V0, 1184
9D009128  90420018   LBU V0, 24(V0)
9D00912C  00402021   ADDU A0, V0, ZERO
9D009130  0F4036D5   JAL MPFSGetFlags
9D009134  00000000   NOP
9D009138  30420002   ANDI V0, V0, 2
544:                             {
545:                                 curHTTP.offsets = MPFSOpenID(MPFSGetID(curHTTP.file) + 1);
9D009144  3C02A000   LUI V0, -24576
9D009148  244204A0   ADDIU V0, V0, 1184
9D00914C  90420018   LBU V0, 24(V0)
9D009150  00402021   ADDU A0, V0, ZERO
9D009154  0F403817   JAL MPFSGetID
9D009158  00000000   NOP
9D00915C  24420001   ADDIU V0, V0, 1
9D009160  3042FFFF   ANDI V0, V0, -1
9D009164  00402021   ADDU A0, V0, ZERO
9D009168  0F40338A   JAL MPFSOpenID
9D00916C  00000000   NOP
9D009170  00401821   ADDU V1, V0, ZERO
9D009174  3C02A000   LUI V0, -24576
9D009178  244204A0   ADDIU V0, V0, 1184
9D00917C  A0430019   SB V1, 25(V0)
546:                             }
547:                 
548:                             // Read GET args, up to buffer size - 1
549:                             lenA = TCPFind(sktHTTP, ' ', 0, false);
9D009180  93828159   LBU V0, -32423(GP)
9D009184  00401821   ADDU V1, V0, ZERO
9D009188  3C02A000   LUI V0, -24576
9D00918C  000318C0   SLL V1, V1, 3
9D009190  244208C8   ADDIU V0, V0, 2248
9D009194  00621021   ADDU V0, V1, V0
9D009198  90420004   LBU V0, 4(V0)
9D00919C  AFA00010   SW ZERO, 16(SP)
9D0091A0  00402021   ADDU A0, V0, ZERO
9D0091A4  24050020   ADDIU A1, ZERO, 32
9D0091A8  00003021   ADDU A2, ZERO, ZERO
9D0091AC  00003821   ADDU A3, ZERO, ZERO
9D0091B0  0F400AF0   JAL TCPFindEx
9D0091B4  00000000   NOP
9D0091B8  A7C20018   SH V0, 24(S8)
550:                             if(lenA != 0u)
9D0091BC  97C20018   LHU V0, 24(S8)
9D0091C0  10400047   BEQ V0, ZERO, 0x9D0092E0
9D0091C4  00000000   NOP
551:                             {
552:                                 curHTTP.hasArgs = true;
9D0091C8  3C02A000   LUI V0, -24576
9D0091CC  244204A0   ADDIU V0, V0, 1184
9D0091D0  24030001   ADDIU V1, ZERO, 1
9D0091D4  A043001A   SB V1, 26(V0)
553:                 
554:                                 // Trash the '?'
555:                                 TCPGet(sktHTTP, &c);
9D0091D8  93828159   LBU V0, -32423(GP)
9D0091DC  00401821   ADDU V1, V0, ZERO
9D0091E0  3C02A000   LUI V0, -24576
9D0091E4  000318C0   SLL V1, V1, 3
9D0091E8  244208C8   ADDIU V0, V0, 2248
9D0091EC  00621021   ADDU V0, V1, V0
9D0091F0  90420004   LBU V0, 4(V0)
9D0091F4  00401821   ADDU V1, V0, ZERO
9D0091F8  27C20024   ADDIU V0, S8, 36
9D0091FC  00602021   ADDU A0, V1, ZERO
9D009200  00402821   ADDU A1, V0, ZERO
9D009204  0F4006D4   JAL TCPGet
9D009208  00000000   NOP
556:                 
557:                                 // Verify there's enough space
558:                                 lenA--;
9D00920C  97C20018   LHU V0, 24(S8)
9D009210  2442FFFF   ADDIU V0, V0, -1
9D009214  A7C20018   SH V0, 24(S8)
559:                                 if(lenA >= HTTP_MAX_DATA_LEN - 2)
9D009218  97C20018   LHU V0, 24(S8)
9D00921C  2C4203FE   SLTIU V0, V0, 1022
9D009220  14400010   BNE V0, ZERO, 0x9D009264
9D009224  00000000   NOP
560:                                 {
561:                                     curHTTP.httpStatus = HTTP_OVERFLOW;
9D009228  3C02A000   LUI V0, -24576
9D00922C  244204A0   ADDIU V0, V0, 1184
9D009230  24030005   ADDIU V1, ZERO, 5
9D009234  AC43001C   SW V1, 28(V0)
562:                                     smHTTP = SM_HTTP_SERVE_HEADERS;
9D009238  93828159   LBU V0, -32423(GP)
9D00923C  00401821   ADDU V1, V0, ZERO
9D009240  3C02A000   LUI V0, -24576
9D009244  000318C0   SLL V1, V1, 3
9D009248  244208C8   ADDIU V0, V0, 2248
9D00924C  00621021   ADDU V0, V1, V0
9D009250  24030007   ADDIU V1, ZERO, 7
9D009254  AC430000   SW V1, 0(V0)
563:                                     isDone = false;
9D009258  A3C0001D   SB ZERO, 29(S8)
564:                                     break;
9D00925C  0B4028A8   J 0x9D00A2A0
9D009260  00000000   NOP
565:                                 }
566:                 
567:                                 // Read in the arguments and '&'-terminate in anticipation of cookies
568:                                 curHTTP.ptrData += TCPGetArray(sktHTTP, curHTTP.data, lenA);
9D009264  3C02A000   LUI V0, -24576
9D009268  244204A0   ADDIU V0, V0, 1184
9D00926C  8C500010   LW S0, 16(V0)
9D009270  93828159   LBU V0, -32423(GP)
9D009274  00401821   ADDU V1, V0, ZERO
9D009278  3C02A000   LUI V0, -24576
9D00927C  000318C0   SLL V1, V1, 3
9D009280  244208C8   ADDIU V0, V0, 2248
9D009284  00621021   ADDU V0, V1, V0
9D009288  90420004   LBU V0, 4(V0)
9D00928C  00401821   ADDU V1, V0, ZERO
9D009290  97C20018   LHU V0, 24(S8)
9D009294  00602021   ADDU A0, V1, ZERO
9D009298  3C03A000   LUI V1, -24576
9D00929C  246504C4   ADDIU A1, V1, 1220
9D0092A0  00403021   ADDU A2, V0, ZERO
9D0092A4  0F40077A   JAL TCPGetArray
9D0092A8  00000000   NOP
9D0092AC  02021821   ADDU V1, S0, V0
9D0092B0  3C02A000   LUI V0, -24576
9D0092B4  244204A0   ADDIU V0, V0, 1184
9D0092B8  AC430010   SW V1, 16(V0)
569:                                 *(curHTTP.ptrData++) = '&';
9D0092BC  3C02A000   LUI V0, -24576
9D0092C0  244204A0   ADDIU V0, V0, 1184
9D0092C4  8C420010   LW V0, 16(V0)
9D0092C8  24030026   ADDIU V1, ZERO, 38
9D0092CC  A0430000   SB V1, 0(V0)
9D0092D0  24430001   ADDIU V1, V0, 1
9D0092D4  3C02A000   LUI V0, -24576
9D0092D8  244204A0   ADDIU V0, V0, 1184
9D0092DC  AC430010   SW V1, 16(V0)
570:                 
571:                             }
572:                 
573:                             // Clear the rest of the line
574:                             lenA = TCPFind(sktHTTP, '\n', 0, false);
9D0092E0  93828159   LBU V0, -32423(GP)
9D0092E4  00401821   ADDU V1, V0, ZERO
9D0092E8  3C02A000   LUI V0, -24576
9D0092EC  000318C0   SLL V1, V1, 3
9D0092F0  244208C8   ADDIU V0, V0, 2248
9D0092F4  00621021   ADDU V0, V1, V0
9D0092F8  90420004   LBU V0, 4(V0)
9D0092FC  AFA00010   SW ZERO, 16(SP)
9D009300  00402021   ADDU A0, V0, ZERO
9D009304  2405000A   ADDIU A1, ZERO, 10
9D009308  00003021   ADDU A2, ZERO, ZERO
9D00930C  00003821   ADDU A3, ZERO, ZERO
9D009310  0F400AF0   JAL TCPFindEx
9D009314  00000000   NOP
9D009318  A7C20018   SH V0, 24(S8)
575:                             TCPGetArray(sktHTTP, NULL, lenA + 1);
9D00931C  93828159   LBU V0, -32423(GP)
9D009320  00401821   ADDU V1, V0, ZERO
9D009324  3C02A000   LUI V0, -24576
9D009328  000318C0   SLL V1, V1, 3
9D00932C  244208C8   ADDIU V0, V0, 2248
9D009330  00621021   ADDU V0, V1, V0
9D009334  90420004   LBU V0, 4(V0)
9D009338  00401821   ADDU V1, V0, ZERO
9D00933C  97C20018   LHU V0, 24(S8)
9D009340  24420001   ADDIU V0, V0, 1
9D009344  3042FFFF   ANDI V0, V0, -1
9D009348  00602021   ADDU A0, V1, ZERO
9D00934C  00002821   ADDU A1, ZERO, ZERO
9D009350  00403021   ADDU A2, V0, ZERO
9D009354  0F40077A   JAL TCPGetArray
9D009358  00000000   NOP
576:                 
577:                             // Move to parsing the headers
578:                             smHTTP = SM_HTTP_PARSE_HEADERS;
9D00935C  93828159   LBU V0, -32423(GP)
9D009360  00401821   ADDU V1, V0, ZERO
9D009364  3C02A000   LUI V0, -24576
9D009368  000318C0   SLL V1, V1, 3
9D00936C  244208C8   ADDIU V0, V0, 2248
9D009370  00621021   ADDU V0, V1, V0
9D009374  24030002   ADDIU V1, ZERO, 2
9D009378  AC430000   SW V1, 0(V0)
579:                 
580:                             // No break, continue to parsing headers
581:                 
582:                         case SM_HTTP_PARSE_HEADERS:
583:                 
584:                             // Loop over all the headers
585:                             while(1)
586:                             {
587:                                 // Make sure entire line is in the FIFO
588:                                 lenA = TCPFind(sktHTTP, '\n', 0, false);
9D00937C  93828159   LBU V0, -32423(GP)
9D009380  00401821   ADDU V1, V0, ZERO
9D009384  3C02A000   LUI V0, -24576
9D009388  000318C0   SLL V1, V1, 3
9D00938C  244208C8   ADDIU V0, V0, 2248
9D009390  00621021   ADDU V0, V1, V0
9D009394  90420004   LBU V0, 4(V0)
9D009398  AFA00010   SW ZERO, 16(SP)
9D00939C  00402021   ADDU A0, V0, ZERO
9D0093A0  2405000A   ADDIU A1, ZERO, 10
9D0093A4  00003021   ADDU A2, ZERO, ZERO
9D0093A8  00003821   ADDU A3, ZERO, ZERO
9D0093AC  0F400AF0   JAL TCPFindEx
9D0093B0  00000000   NOP
9D0093B4  A7C20018   SH V0, 24(S8)
589:                                 if(lenA == 0xffff)
9D0093B8  97C30018   LHU V1, 24(S8)
9D0093BC  3402FFFF   ORI V0, ZERO, -1
9D0093C0  14620038   BNE V1, V0, 0x9D0094A4
9D0093C4  00000000   NOP
590:                                 {// If not, make sure we can receive more data
591:                                     if(TCPGetRxFIFOFree(sktHTTP) == 0u)
9D0093C8  93828159   LBU V0, -32423(GP)
9D0093CC  00401821   ADDU V1, V0, ZERO
9D0093D0  3C02A000   LUI V0, -24576
9D0093D4  000318C0   SLL V1, V1, 3
9D0093D8  244208C8   ADDIU V0, V0, 2248
9D0093DC  00621021   ADDU V0, V1, V0
9D0093E0  90420004   LBU V0, 4(V0)
9D0093E4  00402021   ADDU A0, V0, ZERO
9D0093E8  0F40086C   JAL TCPGetRxFIFOFree
9D0093EC  00000000   NOP
9D0093F0  1440000E   BNE V0, ZERO, 0x9D00942C
9D0093F4  00000000   NOP
592:                                     {// Overflow
593:                                         curHTTP.httpStatus = HTTP_OVERFLOW;
9D0093F8  3C02A000   LUI V0, -24576
9D0093FC  244204A0   ADDIU V0, V0, 1184
9D009400  24030005   ADDIU V1, ZERO, 5
9D009404  AC43001C   SW V1, 28(V0)
594:                                         smHTTP = SM_HTTP_SERVE_HEADERS;
9D009408  93828159   LBU V0, -32423(GP)
9D00940C  00401821   ADDU V1, V0, ZERO
9D009410  3C02A000   LUI V0, -24576
9D009414  000318C0   SLL V1, V1, 3
9D009418  244208C8   ADDIU V0, V0, 2248
9D00941C  00621021   ADDU V0, V1, V0
9D009420  24030007   ADDIU V1, ZERO, 7
9D009424  AC430000   SW V1, 0(V0)
595:                                         isDone = false;
9D009428  A3C0001D   SB ZERO, 29(S8)
596:                                     }
597:                                     if((int32_t)(TickGet() - curHTTP.callbackID) > (int32_t)0)
9D00942C  0F405C42   JAL TickGet
9D009430  00000000   NOP
9D009434  00401821   ADDU V1, V0, ZERO
9D009438  3C02A000   LUI V0, -24576
9D00943C  244204A0   ADDIU V0, V0, 1184
9D009440  8C420008   LW V0, 8(V0)
9D009444  00621023   SUBU V0, V1, V0
9D009448  18400014   BLEZ V0, 0x9D00949C
9D00944C  00000000   NOP
598:                                     {// A timeout has occured
599:                                         TCPDisconnect(sktHTTP);
9D009450  93828159   LBU V0, -32423(GP)
9D009454  00401821   ADDU V1, V0, ZERO
9D009458  3C02A000   LUI V0, -24576
9D00945C  000318C0   SLL V1, V1, 3
9D009460  244208C8   ADDIU V0, V0, 2248
9D009464  00621021   ADDU V0, V1, V0
9D009468  90420004   LBU V0, 4(V0)
9D00946C  00402021   ADDU A0, V0, ZERO
9D009470  0F40025C   JAL TCPDisconnect
9D009474  00000000   NOP
600:                                         smHTTP = SM_HTTP_DISCONNECT;
9D009478  93828159   LBU V0, -32423(GP)
9D00947C  00401821   ADDU V1, V0, ZERO
9D009480  3C02A000   LUI V0, -24576
9D009484  000318C0   SLL V1, V1, 3
9D009488  244208C8   ADDIU V0, V0, 2248
9D00948C  00621021   ADDU V0, V1, V0
9D009490  2403000B   ADDIU V1, ZERO, 11
9D009494  AC430000   SW V1, 0(V0)
601:                                         isDone = false;
9D009498  A3C0001D   SB ZERO, 29(S8)
602:                                     }
603:                                     break;
9D00949C  0B4025D1   J 0x9D009744
9D0094A0  00000000   NOP
604:                                 }
605:                 
606:                                 // Reset the watchdog timer
607:                                 curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D0094A4  0F405C42   JAL TickGet
9D0094A8  00000000   NOP
9D0094AC  00401821   ADDU V1, V0, ZERO
9D0094B0  3C0200D6   LUI V0, 214
9D0094B4  344293A4   ORI V0, V0, -27740
9D0094B8  00621821   ADDU V1, V1, V0
9D0094BC  3C02A000   LUI V0, -24576
9D0094C0  244204A0   ADDIU V0, V0, 1184
9D0094C4  AC430008   SW V1, 8(V0)
608:                 
609:                                 // If a CRLF is immediate, then headers are done
610:                                 if(lenA == 1u)
9D0094C8  97C30018   LHU V1, 24(S8)
9D0094CC  24020001   ADDIU V0, ZERO, 1
9D0094D0  14620018   BNE V1, V0, 0x9D009534
9D0094D4  00000000   NOP
611:                                 {// Remove the CRLF and move to next state
612:                                     TCPGetArray(sktHTTP, NULL, 2);
9D0094D8  93828159   LBU V0, -32423(GP)
9D0094DC  00401821   ADDU V1, V0, ZERO
9D0094E0  3C02A000   LUI V0, -24576
9D0094E4  000318C0   SLL V1, V1, 3
9D0094E8  244208C8   ADDIU V0, V0, 2248
9D0094EC  00621021   ADDU V0, V1, V0
9D0094F0  90420004   LBU V0, 4(V0)
9D0094F4  00402021   ADDU A0, V0, ZERO
9D0094F8  00002821   ADDU A1, ZERO, ZERO
9D0094FC  24060002   ADDIU A2, ZERO, 2
9D009500  0F40077A   JAL TCPGetArray
9D009504  00000000   NOP
613:                                     smHTTP = SM_HTTP_AUTHENTICATE;
9D009508  93828159   LBU V0, -32423(GP)
9D00950C  00401821   ADDU V1, V0, ZERO
9D009510  3C02A000   LUI V0, -24576
9D009514  000318C0   SLL V1, V1, 3
9D009518  244208C8   ADDIU V0, V0, 2248
9D00951C  00621021   ADDU V0, V1, V0
9D009520  24030003   ADDIU V1, ZERO, 3
9D009524  AC430000   SW V1, 0(V0)
614:                                     isDone = false;
9D009528  A3C0001D   SB ZERO, 29(S8)
615:                                     break;
9D00952C  0B4025D1   J 0x9D009744
9D009530  00000000   NOP
616:                                 }
617:                 
618:                                 // Find the header name, and use isDone as a flag to indicate a match
619:                                 lenB = TCPFindEx(sktHTTP, ':', 0, lenA, false) + 2;
9D009534  93828159   LBU V0, -32423(GP)
9D009538  00401821   ADDU V1, V0, ZERO
9D00953C  3C02A000   LUI V0, -24576
9D009540  000318C0   SLL V1, V1, 3
9D009544  244208C8   ADDIU V0, V0, 2248
9D009548  00621021   ADDU V0, V1, V0
9D00954C  90420004   LBU V0, 4(V0)
9D009550  00401821   ADDU V1, V0, ZERO
9D009554  97C20018   LHU V0, 24(S8)
9D009558  AFA00010   SW ZERO, 16(SP)
9D00955C  00602021   ADDU A0, V1, ZERO
9D009560  2405003A   ADDIU A1, ZERO, 58
9D009564  00003021   ADDU A2, ZERO, ZERO
9D009568  00403821   ADDU A3, V0, ZERO
9D00956C  0F400AF0   JAL TCPFindEx
9D009570  00000000   NOP
9D009574  24420002   ADDIU V0, V0, 2
9D009578  A7C2001A   SH V0, 26(S8)
620:                                 isDone = false;
9D00957C  A3C0001D   SB ZERO, 29(S8)
621:                 
622:                                 // If name is too long or this line isn't a header, ignore it
623:                                 if(lenB > sizeof(buffer))
9D009580  97C2001A   LHU V0, 26(S8)
9D009584  2C420011   SLTIU V0, V0, 17
9D009588  14400014   BNE V0, ZERO, 0x9D0095DC
9D00958C  00000000   NOP
624:                                 {
625:                                     TCPGetArray(sktHTTP, NULL, lenA+1);
9D009590  93828159   LBU V0, -32423(GP)
9D009594  00401821   ADDU V1, V0, ZERO
9D009598  3C02A000   LUI V0, -24576
9D00959C  000318C0   SLL V1, V1, 3
9D0095A0  244208C8   ADDIU V0, V0, 2248
9D0095A4  00621021   ADDU V0, V1, V0
9D0095A8  90420004   LBU V0, 4(V0)
9D0095AC  00401821   ADDU V1, V0, ZERO
9D0095B0  97C20018   LHU V0, 24(S8)
9D0095B4  24420001   ADDIU V0, V0, 1
9D0095B8  3042FFFF   ANDI V0, V0, -1
9D0095BC  00602021   ADDU A0, V1, ZERO
9D0095C0  00002821   ADDU A1, ZERO, ZERO
9D0095C4  00403021   ADDU A2, V0, ZERO
9D0095C8  0F40077A   JAL TCPGetArray
9D0095CC  00000000   NOP
626:                                     continue;
9D0095D0  00000000   NOP
627:                                 }
628:                 
629:                                 // Read in the header name
630:                                 TCPGetArray(sktHTTP, buffer, lenB);
9D0095DC  93828159   LBU V0, -32423(GP)
9D0095E0  00401821   ADDU V1, V0, ZERO
9D0095E4  3C02A000   LUI V0, -24576
9D0095E8  000318C0   SLL V1, V1, 3
9D0095EC  244208C8   ADDIU V0, V0, 2248
9D0095F0  00621021   ADDU V0, V1, V0
9D0095F4  90420004   LBU V0, 4(V0)
9D0095F8  00402021   ADDU A0, V0, ZERO
9D0095FC  97C2001A   LHU V0, 26(S8)
9D009600  27C30028   ADDIU V1, S8, 40
9D009604  00602821   ADDU A1, V1, ZERO
9D009608  00403021   ADDU A2, V0, ZERO
9D00960C  0F40077A   JAL TCPGetArray
9D009610  00000000   NOP
631:                                 buffer[lenB-1] = '\0';
9D009614  97C2001A   LHU V0, 26(S8)
9D009618  2442FFFF   ADDIU V0, V0, -1
9D00961C  27C30018   ADDIU V1, S8, 24
9D009620  00621021   ADDU V0, V1, V0
9D009624  A0400010   SB ZERO, 16(V0)
632:                                 lenA -= lenB;
9D009628  97C30018   LHU V1, 24(S8)
9D00962C  97C2001A   LHU V0, 26(S8)
9D009630  00621023   SUBU V0, V1, V0
9D009634  A7C20018   SH V0, 24(S8)
633:                 
634:                                 // Compare header read to ones we're interested in
635:                                 for(i = 0; i < sizeof(HTTPRequestHeaders)/sizeof(HTTPRequestHeaders[0]); i++)
9D009638  A3C0001C   SB ZERO, 28(S8)
9D00963C  0B4025A9   J 0x9D0096A4
9D009640  00000000   NOP
9D009698  93C2001C   LBU V0, 28(S8)
9D00969C  24420001   ADDIU V0, V0, 1
9D0096A0  A3C2001C   SB V0, 28(S8)
9D0096A4  93C2001C   LBU V0, 28(S8)
9D0096A8  2C420003   SLTIU V0, V0, 3
9D0096AC  1440FFE5   BNE V0, ZERO, 0x9D009644
9D0096B0  00000000   NOP
636:                                 {
637:                                     if(strcmppgm2ram((char*)buffer, (ROM char *)HTTPRequestHeaders[i]) == 0)
9D009644  27C30028   ADDIU V1, S8, 40
9D009648  93C4001C   LBU A0, 28(S8)
9D00964C  3C029D01   LUI V0, -25343
9D009650  00042080   SLL A0, A0, 2
9D009654  24425AD0   ADDIU V0, V0, 23248
9D009658  00821021   ADDU V0, A0, V0
9D00965C  8C420000   LW V0, 0(V0)
9D009660  00602021   ADDU A0, V1, ZERO
9D009664  00402821   ADDU A1, V0, ZERO
9D009668  0F406A15   JAL 0x9D01A854
9D00966C  00000000   NOP
9D009670  14400009   BNE V0, ZERO, 0x9D009698
9D009674  00000000   NOP
638:                                     {// Parse the header and stop the loop
639:                                         HTTPHeaderParseLookup(i);
9D009678  93C2001C   LBU V0, 28(S8)
9D00967C  00402021   ADDU A0, V0, ZERO
9D009680  0F402961   JAL 0x9D00A584
9D009684  00000000   NOP
640:                                         isDone = true;
9D009688  24020001   ADDIU V0, ZERO, 1
9D00968C  A3C2001D   SB V0, 29(S8)
641:                                         break;
9D009690  0B4025AD   J 0x9D0096B4
9D009694  00000000   NOP
642:                                     }
643:                                 }
644:                 
645:                                 // Clear the rest of the line, and call the loop again
646:                                 if(isDone)
9D0096B4  93C2001D   LBU V0, 29(S8)
9D0096B8  10400010   BEQ V0, ZERO, 0x9D0096FC
9D0096BC  00000000   NOP
647:                                 {// We already know how much to remove unless a header was found
648:                                     lenA = TCPFind(sktHTTP, '\n', 0, false);
9D0096C0  93828159   LBU V0, -32423(GP)
9D0096C4  00401821   ADDU V1, V0, ZERO
9D0096C8  3C02A000   LUI V0, -24576
9D0096CC  000318C0   SLL V1, V1, 3
9D0096D0  244208C8   ADDIU V0, V0, 2248
9D0096D4  00621021   ADDU V0, V1, V0
9D0096D8  90420004   LBU V0, 4(V0)
9D0096DC  AFA00010   SW ZERO, 16(SP)
9D0096E0  00402021   ADDU A0, V0, ZERO
9D0096E4  2405000A   ADDIU A1, ZERO, 10
9D0096E8  00003021   ADDU A2, ZERO, ZERO
9D0096EC  00003821   ADDU A3, ZERO, ZERO
9D0096F0  0F400AF0   JAL TCPFindEx
9D0096F4  00000000   NOP
9D0096F8  A7C20018   SH V0, 24(S8)
649:                                 }
650:                                 TCPGetArray(sktHTTP, NULL, lenA+1);
9D0096FC  93828159   LBU V0, -32423(GP)
9D009700  00401821   ADDU V1, V0, ZERO
9D009704  3C02A000   LUI V0, -24576
9D009708  000318C0   SLL V1, V1, 3
9D00970C  244208C8   ADDIU V0, V0, 2248
9D009710  00621021   ADDU V0, V1, V0
9D009714  90420004   LBU V0, 4(V0)
9D009718  00401821   ADDU V1, V0, ZERO
9D00971C  97C20018   LHU V0, 24(S8)
9D009720  24420001   ADDIU V0, V0, 1
9D009724  3042FFFF   ANDI V0, V0, -1
9D009728  00602021   ADDU A0, V1, ZERO
9D00972C  00002821   ADDU A1, ZERO, ZERO
9D009730  00403021   ADDU A2, V0, ZERO
9D009734  0F40077A   JAL TCPGetArray
9D009738  00000000   NOP
651:                             }
9D0095D4  0B4024DF   J 0x9D00937C
9D0095D8  00000000   NOP
9D00973C  0B4024DF   J 0x9D00937C
9D009740  00000000   NOP
652:                 
653:                             break;
9D009744  0B4028A8   J 0x9D00A2A0
9D009748  00000000   NOP
654:                 
655:                         case SM_HTTP_AUTHENTICATE:
656:                 
657:                             #if defined(HTTP_USE_AUTHENTICATION)
658:                             // Check current authorization state
659:                             if(curHTTP.isAuthorized < 0x80)
660:                             {// 401 error
661:                                 curHTTP.httpStatus = HTTP_UNAUTHORIZED;
662:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
663:                                 isDone = false;
664:                 
665:                                 #if defined(HTTP_NO_AUTH_WITHOUT_SSL)
666:                                 if(!TCPIsSSL(sktHTTP))
667:                                     curHTTP.httpStatus = HTTP_SSL_REQUIRED;
668:                                 #endif
669:                 
670:                                 break;
671:                             }
672:                             #endif
673:                 
674:                             // Parse the args string
675:                             *curHTTP.ptrData = '\0';
9D00974C  3C02A000   LUI V0, -24576
9D009750  244204A0   ADDIU V0, V0, 1184
9D009754  8C420010   LW V0, 16(V0)
9D009758  A0400000   SB ZERO, 0(V0)
676:                             curHTTP.ptrData = HTTPURLDecode(curHTTP.data);
9D00975C  3C02A000   LUI V0, -24576
9D009760  244404C4   ADDIU A0, V0, 1220
9D009764  0F4029B5   JAL HTTPURLDecode
9D009768  00000000   NOP
9D00976C  00401821   ADDU V1, V0, ZERO
9D009770  3C02A000   LUI V0, -24576
9D009774  244204A0   ADDIU V0, V0, 1184
9D009778  AC430010   SW V1, 16(V0)
677:                 
678:                             // If this is an MPFS upload form request, bypass to headers
679:                             #if defined(HTTP_MPFS_UPLOAD)
680:                             if(curHTTP.httpStatus == HTTP_MPFS_FORM)
681:                             {
682:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
683:                                 isDone = false;
684:                                 break;
685:                             }
686:                             #endif
687:                 
688:                             // Move on to GET args, unless there are none
689:                             smHTTP = SM_HTTP_PROCESS_GET;
9D00977C  93828159   LBU V0, -32423(GP)
9D009780  00401821   ADDU V1, V0, ZERO
9D009784  3C02A000   LUI V0, -24576
9D009788  000318C0   SLL V1, V1, 3
9D00978C  244208C8   ADDIU V0, V0, 2248
9D009790  00621021   ADDU V0, V1, V0
9D009794  24030004   ADDIU V1, ZERO, 4
9D009798  AC430000   SW V1, 0(V0)
690:                             if(!curHTTP.hasArgs)
9D00979C  3C02A000   LUI V0, -24576
9D0097A0  244204A0   ADDIU V0, V0, 1184
9D0097A4  9042001A   LBU V0, 26(V0)
9D0097A8  14400009   BNE V0, ZERO, 0x9D0097D0
9D0097AC  00000000   NOP
691:                                 smHTTP = SM_HTTP_PROCESS_POST;
9D0097B0  93828159   LBU V0, -32423(GP)
9D0097B4  00401821   ADDU V1, V0, ZERO
9D0097B8  3C02A000   LUI V0, -24576
9D0097BC  000318C0   SLL V1, V1, 3
9D0097C0  244208C8   ADDIU V0, V0, 2248
9D0097C4  00621021   ADDU V0, V1, V0
9D0097C8  24030005   ADDIU V1, ZERO, 5
9D0097CC  AC430000   SW V1, 0(V0)
692:                             isDone = false;
9D0097D0  A3C0001D   SB ZERO, 29(S8)
693:                             curHTTP.hasArgs = false;
9D0097D4  3C02A000   LUI V0, -24576
9D0097D8  244204A0   ADDIU V0, V0, 1184
9D0097DC  A040001A   SB ZERO, 26(V0)
694:                             break;
9D0097E0  0B4028A8   J 0x9D00A2A0
9D0097E4  00000000   NOP
695:                 
696:                         case SM_HTTP_PROCESS_GET:
697:                 
698:                             // Run the application callback HTTPExecuteGet()
699:                             if(HTTPExecuteGet() == HTTP_IO_WAITING)
9D0097E8  0F404DE9   JAL HTTPExecuteGet
9D0097EC  00000000   NOP
9D0097F0  00401821   ADDU V1, V0, ZERO
9D0097F4  24020002   ADDIU V0, ZERO, 2
9D0097F8  1062029C   BEQ V1, V0, 0x9D00A26C
9D0097FC  00000000   NOP
700:                             {// If waiting for asynchronous process, return to main app
701:                                 break;
9D00A26C  00000000   NOP
9D00A270  0B4028A8   J 0x9D00A2A0
9D00A274  00000000   NOP
702:                             }
703:                 
704:                             // Move on to POST data
705:                             smHTTP = SM_HTTP_PROCESS_POST;
9D009800  93828159   LBU V0, -32423(GP)
9D009804  00401821   ADDU V1, V0, ZERO
9D009808  3C02A000   LUI V0, -24576
9D00980C  000318C0   SLL V1, V1, 3
9D009810  244208C8   ADDIU V0, V0, 2248
9D009814  00621021   ADDU V0, V1, V0
9D009818  24030005   ADDIU V1, ZERO, 5
9D00981C  AC430000   SW V1, 0(V0)
706:                 
707:                         case SM_HTTP_PROCESS_POST:
708:                 
709:                             #if defined(HTTP_USE_POST)
710:                 
711:                             // See if we have any new data
712:                             if(TCPIsGetReady(sktHTTP) == curHTTP.callbackPos)
9D009820  93828159   LBU V0, -32423(GP)
9D009824  00401821   ADDU V1, V0, ZERO
9D009828  3C02A000   LUI V0, -24576
9D00982C  000318C0   SLL V1, V1, 3
9D009830  244208C8   ADDIU V0, V0, 2248
9D009834  00621021   ADDU V0, V1, V0
9D009838  90420004   LBU V0, 4(V0)
9D00983C  00402021   ADDU A0, V0, ZERO
9D009840  0F40066C   JAL TCPIsGetReady
9D009844  00000000   NOP
9D009848  00401821   ADDU V1, V0, ZERO
9D00984C  3C02A000   LUI V0, -24576
9D009850  244204A0   ADDIU V0, V0, 1184
9D009854  8C42000C   LW V0, 12(V0)
9D009858  1462001F   BNE V1, V0, 0x9D0098D8
9D00985C  00000000   NOP
713:                             {
714:                                 if((int32_t)(TickGet() - curHTTP.callbackID) > (int32_t)0)
9D009860  0F405C42   JAL TickGet
9D009864  00000000   NOP
9D009868  00401821   ADDU V1, V0, ZERO
9D00986C  3C02A000   LUI V0, -24576
9D009870  244204A0   ADDIU V0, V0, 1184
9D009874  8C420008   LW V0, 8(V0)
9D009878  00621023   SUBU V0, V1, V0
9D00987C  18400016   BLEZ V0, 0x9D0098D8
9D009880  00000000   NOP
715:                                 {// If a timeout has occured, disconnect
716:                                     TCPDisconnect(sktHTTP);
9D009884  93828159   LBU V0, -32423(GP)
9D009888  00401821   ADDU V1, V0, ZERO
9D00988C  3C02A000   LUI V0, -24576
9D009890  000318C0   SLL V1, V1, 3
9D009894  244208C8   ADDIU V0, V0, 2248
9D009898  00621021   ADDU V0, V1, V0
9D00989C  90420004   LBU V0, 4(V0)
9D0098A0  00402021   ADDU A0, V0, ZERO
9D0098A4  0F40025C   JAL TCPDisconnect
9D0098A8  00000000   NOP
717:                                     smHTTP = SM_HTTP_DISCONNECT;
9D0098AC  93828159   LBU V0, -32423(GP)
9D0098B0  00401821   ADDU V1, V0, ZERO
9D0098B4  3C02A000   LUI V0, -24576
9D0098B8  000318C0   SLL V1, V1, 3
9D0098BC  244208C8   ADDIU V0, V0, 2248
9D0098C0  00621021   ADDU V0, V1, V0
9D0098C4  2403000B   ADDIU V1, ZERO, 11
9D0098C8  AC430000   SW V1, 0(V0)
718:                                     isDone = false;
9D0098CC  A3C0001D   SB ZERO, 29(S8)
719:                                     break;
9D0098D0  0B4028A8   J 0x9D00A2A0
9D0098D4  00000000   NOP
720:                                 }
721:                             }
722:                 
723:                             if(curHTTP.httpStatus == HTTP_POST
9D0098D8  3C02A000   LUI V0, -24576
9D0098DC  244204A0   ADDIU V0, V0, 1184
9D0098E0  8C43001C   LW V1, 28(V0)
9D0098E4  24020001   ADDIU V0, ZERO, 1
9D0098E8  14620058   BNE V1, V0, 0x9D009A4C
9D0098EC  00000000   NOP
724:                                 #if defined(HTTP_MPFS_UPLOAD)
725:                                 || (curHTTP.httpStatus >= HTTP_MPFS_UP && curHTTP.httpStatus <= HTTP_MPFS_ERROR)
726:                                 #endif
727:                                  )
728:                             {
729:                                 // Run the application callback HTTPExecutePost()
730:                                 #if defined(HTTP_MPFS_UPLOAD)
731:                                 if(curHTTP.httpStatus >= HTTP_MPFS_UP && curHTTP.httpStatus <= HTTP_MPFS_ERROR)
732:                                 {
733:                                     c = HTTPMPFSUpload();
734:                                     if(c == (uint8_t)HTTP_IO_DONE)
735:                                     {
736:                                         smHTTP = SM_HTTP_SERVE_HEADERS;
737:                                         isDone = false;
738:                                         break;
739:                                     }
740:                                 }
741:                                 else
742:                                 #endif
743:                                 c = HTTPExecutePost();
9D0098F0  0F404E7C   JAL HTTPExecutePost
9D0098F4  00000000   NOP
9D0098F8  304200FF   ANDI V0, V0, 255
9D0098FC  A3C20024   SB V0, 36(S8)
744:                 
745:                                 // If waiting for asynchronous process, return to main app
746:                                 if(c == (uint8_t)HTTP_IO_WAITING)
9D009900  93C30024   LBU V1, 36(S8)
9D009904  24020002   ADDIU V0, ZERO, 2
9D009908  14620012   BNE V1, V0, 0x9D009954
9D00990C  00000000   NOP
747:                                 {// return to main app and make sure we don't get stuck by the watchdog
748:                                     curHTTP.callbackPos = TCPIsGetReady(sktHTTP) - 1;
9D009910  93828159   LBU V0, -32423(GP)
9D009914  00401821   ADDU V1, V0, ZERO
9D009918  3C02A000   LUI V0, -24576
9D00991C  000318C0   SLL V1, V1, 3
9D009920  244208C8   ADDIU V0, V0, 2248
9D009924  00621021   ADDU V0, V1, V0
9D009928  90420004   LBU V0, 4(V0)
9D00992C  00402021   ADDU A0, V0, ZERO
9D009930  0F40066C   JAL TCPIsGetReady
9D009934  00000000   NOP
9D009938  2442FFFF   ADDIU V0, V0, -1
9D00993C  00401821   ADDU V1, V0, ZERO
9D009940  3C02A000   LUI V0, -24576
9D009944  244204A0   ADDIU V0, V0, 1184
9D009948  AC43000C   SW V1, 12(V0)
749:                                     break;
9D00994C  0B4028A8   J 0x9D00A2A0
9D009950  00000000   NOP
750:                                 }
751:                                 else if(c == (uint8_t)HTTP_IO_NEED_DATA)
9D009954  93C30024   LBU V1, 36(S8)
9D009958  24020001   ADDIU V0, ZERO, 1
9D00995C  1462003B   BNE V1, V0, 0x9D009A4C
9D009960  00000000   NOP
752:                                 {// If waiting for more data
753:                                     curHTTP.callbackPos = TCPIsGetReady(sktHTTP);
9D009964  93828159   LBU V0, -32423(GP)
9D009968  00401821   ADDU V1, V0, ZERO
9D00996C  3C02A000   LUI V0, -24576
9D009970  000318C0   SLL V1, V1, 3
9D009974  244208C8   ADDIU V0, V0, 2248
9D009978  00621021   ADDU V0, V1, V0
9D00997C  90420004   LBU V0, 4(V0)
9D009980  00402021   ADDU A0, V0, ZERO
9D009984  0F40066C   JAL TCPIsGetReady
9D009988  00000000   NOP
9D00998C  00401821   ADDU V1, V0, ZERO
9D009990  3C02A000   LUI V0, -24576
9D009994  244204A0   ADDIU V0, V0, 1184
9D009998  AC43000C   SW V1, 12(V0)
754:                                     curHTTP.callbackID = TickGet() + HTTP_TIMEOUT*TICK_SECOND;
9D00999C  0F405C42   JAL TickGet
9D0099A0  00000000   NOP
9D0099A4  00401821   ADDU V1, V0, ZERO
9D0099A8  3C0200D6   LUI V0, 214
9D0099AC  344293A4   ORI V0, V0, -27740
9D0099B0  00621821   ADDU V1, V1, V0
9D0099B4  3C02A000   LUI V0, -24576
9D0099B8  244204A0   ADDIU V0, V0, 1184
9D0099BC  AC430008   SW V1, 8(V0)
755:                 
756:                                     // If more is expected and space is available, return to main app
757:                                     if(curHTTP.byteCount > curHTTP.callbackPos && TCPGetRxFIFOFree(sktHTTP) != 0u)
9D0099C0  3C02A000   LUI V0, -24576
9D0099C4  8C4304A0   LW V1, 1184(V0)
9D0099C8  3C02A000   LUI V0, -24576
9D0099CC  244204A0   ADDIU V0, V0, 1184
9D0099D0  8C42000C   LW V0, 12(V0)
9D0099D4  0043102B   SLTU V0, V0, V1
9D0099D8  1040000D   BEQ V0, ZERO, 0x9D009A10
9D0099DC  00000000   NOP
9D0099E0  93828159   LBU V0, -32423(GP)
9D0099E4  00401821   ADDU V1, V0, ZERO
9D0099E8  3C02A000   LUI V0, -24576
9D0099EC  000318C0   SLL V1, V1, 3
9D0099F0  244208C8   ADDIU V0, V0, 2248
9D0099F4  00621021   ADDU V0, V1, V0
9D0099F8  90420004   LBU V0, 4(V0)
9D0099FC  00402021   ADDU A0, V0, ZERO
9D009A00  0F40086C   JAL TCPGetRxFIFOFree
9D009A04  00000000   NOP
9D009A08  1440021B   BNE V0, ZERO, 0x9D00A278
9D009A0C  00000000   NOP
758:                                         break;
9D00A278  00000000   NOP
9D00A27C  0B4028A8   J 0x9D00A2A0
9D00A280  00000000   NOP
759:                 
760:                                     // Handle cases where application ran out of data or buffer space
761:                                     curHTTP.httpStatus = HTTP_INTERNAL_SERVER_ERROR;
9D009A10  3C02A000   LUI V0, -24576
9D009A14  244204A0   ADDIU V0, V0, 1184
9D009A18  24030006   ADDIU V1, ZERO, 6
9D009A1C  AC43001C   SW V1, 28(V0)
762:                                     smHTTP = SM_HTTP_SERVE_HEADERS;
9D009A20  93828159   LBU V0, -32423(GP)
9D009A24  00401821   ADDU V1, V0, ZERO
9D009A28  3C02A000   LUI V0, -24576
9D009A2C  000318C0   SLL V1, V1, 3
9D009A30  244208C8   ADDIU V0, V0, 2248
9D009A34  00621021   ADDU V0, V1, V0
9D009A38  24030007   ADDIU V1, ZERO, 7
9D009A3C  AC430000   SW V1, 0(V0)
763:                                     isDone = false;
9D009A40  A3C0001D   SB ZERO, 29(S8)
764:                                     break;
9D009A44  0B4028A8   J 0x9D00A2A0
9D009A48  00000000   NOP
765:                                 }
766:                             }
767:                             #endif
768:                 
769:                             // We're done with POST
770:                             smHTTP = SM_HTTP_PROCESS_REQUEST;
9D009A4C  93828159   LBU V0, -32423(GP)
9D009A50  00401821   ADDU V1, V0, ZERO
9D009A54  3C02A000   LUI V0, -24576
9D009A58  000318C0   SLL V1, V1, 3
9D009A5C  244208C8   ADDIU V0, V0, 2248
9D009A60  00621021   ADDU V0, V1, V0
9D009A64  24030006   ADDIU V1, ZERO, 6
9D009A68  AC430000   SW V1, 0(V0)
771:                             // No break, continue to sending request
772:                 
773:                         case SM_HTTP_PROCESS_REQUEST:
774:                 
775:                             // Check for 404
776:                             if(curHTTP.file == MPFS_INVALID_HANDLE)
9D009A6C  3C02A000   LUI V0, -24576
9D009A70  244204A0   ADDIU V0, V0, 1184
9D009A74  90430018   LBU V1, 24(V0)
9D009A78  240200FF   ADDIU V0, ZERO, 255
9D009A7C  14620010   BNE V1, V0, 0x9D009AC0
9D009A80  00000000   NOP
777:                             {
778:                                 curHTTP.httpStatus = HTTP_NOT_FOUND;
9D009A84  3C02A000   LUI V0, -24576
9D009A88  244204A0   ADDIU V0, V0, 1184
9D009A8C  24030004   ADDIU V1, ZERO, 4
9D009A90  AC43001C   SW V1, 28(V0)
779:                                 smHTTP = SM_HTTP_SERVE_HEADERS;
9D009A94  93828159   LBU V0, -32423(GP)
9D009A98  00401821   ADDU V1, V0, ZERO
9D009A9C  3C02A000   LUI V0, -24576
9D009AA0  000318C0   SLL V1, V1, 3
9D009AA4  244208C8   ADDIU V0, V0, 2248
9D009AA8  00621021   ADDU V0, V1, V0
9D009AAC  24030007   ADDIU V1, ZERO, 7
9D009AB0  AC430000   SW V1, 0(V0)
780:                                 isDone = false;
9D009AB4  A3C0001D   SB ZERO, 29(S8)
781:                                 break;
9D009AB8  0B4028A8   J 0x9D00A2A0
9D009ABC  00000000   NOP
782:                             }
783:                 
784:                             // Set up the dynamic substitutions
785:                             curHTTP.byteCount = 0;
9D009AC0  3C02A000   LUI V0, -24576
9D009AC4  AC4004A0   SW ZERO, 1184(V0)
786:                             if(curHTTP.offsets == MPFS_INVALID_HANDLE)
9D009AC8  3C02A000   LUI V0, -24576
9D009ACC  244204A0   ADDIU V0, V0, 1184
9D009AD0  90430019   LBU V1, 25(V0)
9D009AD4  240200FF   ADDIU V0, ZERO, 255
9D009AD8  14620007   BNE V1, V0, 0x9D009AF8
9D009ADC  00000000   NOP
787:                             {// If no index file, then set next offset to huge
788:                                 curHTTP.nextCallback = 0xffffffff;
9D009AE0  3C02A000   LUI V0, -24576
9D009AE4  244204A0   ADDIU V0, V0, 1184
9D009AE8  2403FFFF   ADDIU V1, ZERO, -1
9D009AEC  AC430004   SW V1, 4(V0)
9D009AF0  0B4026C6   J 0x9D009B18
9D009AF4  00000000   NOP
789:                             }
790:                             else
791:                             {// Read in the next callback index
792:                                 MPFSGetLong(curHTTP.offsets, &(curHTTP.nextCallback));
9D009AF8  3C02A000   LUI V0, -24576
9D009AFC  244204A0   ADDIU V0, V0, 1184
9D009B00  90420019   LBU V0, 25(V0)
9D009B04  00402021   ADDU A0, V0, ZERO
9D009B08  3C02A000   LUI V0, -24576
9D009B0C  244504A4   ADDIU A1, V0, 1188
9D009B10  0F40352B   JAL MPFSGetLong
9D009B14  00000000   NOP
793:                             }
794:                 
795:                             // Move to next state
796:                             smHTTP = SM_HTTP_SERVE_HEADERS;
9D009B18  93828159   LBU V0, -32423(GP)
9D009B1C  00401821   ADDU V1, V0, ZERO
9D009B20  3C02A000   LUI V0, -24576
9D009B24  000318C0   SLL V1, V1, 3
9D009B28  244208C8   ADDIU V0, V0, 2248
9D009B2C  00621021   ADDU V0, V1, V0
9D009B30  24030007   ADDIU V1, ZERO, 7
9D009B34  AC430000   SW V1, 0(V0)
797:                 
798:                         case SM_HTTP_SERVE_HEADERS:
799:                 
800:                             // We're in write mode now:
801:                             // Adjust the TCP FIFOs for optimal transmission of
802:                             // the HTTP response to the browser
803:                             TCPAdjustFIFOSize(sktHTTP, 1, 0, TCP_ADJUST_GIVE_REST_TO_TX);
9D009B38  93828159   LBU V0, -32423(GP)
9D009B3C  00401821   ADDU V1, V0, ZERO
9D009B40  3C02A000   LUI V0, -24576
9D009B44  000318C0   SLL V1, V1, 3
9D009B48  244208C8   ADDIU V0, V0, 2248
9D009B4C  00621021   ADDU V0, V1, V0
9D009B50  90420004   LBU V0, 4(V0)
9D009B54  00402021   ADDU A0, V0, ZERO
9D009B58  24050001   ADDIU A1, ZERO, 1
9D009B5C  00003021   ADDU A2, ZERO, ZERO
9D009B60  24070002   ADDIU A3, ZERO, 2
9D009B64  0F401ED0   JAL TCPAdjustFIFOSize
9D009B68  00000000   NOP
804:                 
805:                             // Send headers
806:                             TCPPutROMString(sktHTTP, (ROM uint8_t*)HTTPResponseHeaders[curHTTP.httpStatus]);
9D009B6C  93828159   LBU V0, -32423(GP)
9D009B70  00401821   ADDU V1, V0, ZERO
9D009B74  3C02A000   LUI V0, -24576
9D009B78  000318C0   SLL V1, V1, 3
9D009B7C  244208C8   ADDIU V0, V0, 2248
9D009B80  00621021   ADDU V0, V1, V0
9D009B84  90420004   LBU V0, 4(V0)
9D009B88  00401821   ADDU V1, V0, ZERO
9D009B8C  3C02A000   LUI V0, -24576
9D009B90  244204A0   ADDIU V0, V0, 1184
9D009B94  8C44001C   LW A0, 28(V0)
9D009B98  3C029D01   LUI V0, -25343
9D009B9C  00042080   SLL A0, A0, 2
9D009BA0  24425A80   ADDIU V0, V0, 23168
9D009BA4  00821021   ADDU V0, A0, V0
9D009BA8  8C420000   LW V0, 0(V0)
9D009BAC  00602021   ADDU A0, V1, ZERO
9D009BB0  00402821   ADDU A1, V0, ZERO
9D009BB4  0F4005F2   JAL TCPPutString
9D009BB8  00000000   NOP
807:                 
808:                             // If this is a redirect, print the rest of the Location: header
809:                             if(curHTTP.httpStatus == HTTP_REDIRECT)
9D009BBC  3C02A000   LUI V0, -24576
9D009BC0  244204A0   ADDIU V0, V0, 1184
9D009BC4  8C43001C   LW V1, 28(V0)
9D009BC8  24020008   ADDIU V0, ZERO, 8
9D009BCC  14620033   BNE V1, V0, 0x9D009C9C
9D009BD0  00000000   NOP
810:                             {
811:                                 TCPPutString(sktHTTP, curHTTP.data);
9D009BD4  93828159   LBU V0, -32423(GP)
9D009BD8  00401821   ADDU V1, V0, ZERO
9D009BDC  3C02A000   LUI V0, -24576
9D009BE0  000318C0   SLL V1, V1, 3
9D009BE4  244208C8   ADDIU V0, V0, 2248
9D009BE8  00621021   ADDU V0, V1, V0
9D009BEC  90420004   LBU V0, 4(V0)
9D009BF0  00402021   ADDU A0, V0, ZERO
9D009BF4  3C02A000   LUI V0, -24576
9D009BF8  244504C4   ADDIU A1, V0, 1220
9D009BFC  0F4005F2   JAL TCPPutString
9D009C00  00000000   NOP
812:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)"\r\n\r\n304 Redirect: ");
9D009C04  93828159   LBU V0, -32423(GP)
9D009C08  00401821   ADDU V1, V0, ZERO
9D009C0C  3C02A000   LUI V0, -24576
9D009C10  000318C0   SLL V1, V1, 3
9D009C14  244208C8   ADDIU V0, V0, 2248
9D009C18  00621021   ADDU V0, V1, V0
9D009C1C  90420004   LBU V0, 4(V0)
9D009C20  00401821   ADDU V1, V0, ZERO
9D009C24  3C029D01   LUI V0, -25343
9D009C28  24425AF4   ADDIU V0, V0, 23284
9D009C2C  00602021   ADDU A0, V1, ZERO
9D009C30  00402821   ADDU A1, V0, ZERO
9D009C34  0F4005F2   JAL TCPPutString
9D009C38  00000000   NOP
813:                                 TCPPutString(sktHTTP, curHTTP.data);
9D009C3C  93828159   LBU V0, -32423(GP)
9D009C40  00401821   ADDU V1, V0, ZERO
9D009C44  3C02A000   LUI V0, -24576
9D009C48  000318C0   SLL V1, V1, 3
9D009C4C  244208C8   ADDIU V0, V0, 2248
9D009C50  00621021   ADDU V0, V1, V0
9D009C54  90420004   LBU V0, 4(V0)
9D009C58  00402021   ADDU A0, V0, ZERO
9D009C5C  3C02A000   LUI V0, -24576
9D009C60  244504C4   ADDIU A1, V0, 1220
9D009C64  0F4005F2   JAL TCPPutString
9D009C68  00000000   NOP
814:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)HTTP_CRLF);
9D009C6C  93828159   LBU V0, -32423(GP)
9D009C70  00401821   ADDU V1, V0, ZERO
9D009C74  3C02A000   LUI V0, -24576
9D009C78  000318C0   SLL V1, V1, 3
9D009C7C  244208C8   ADDIU V0, V0, 2248
9D009C80  00621021   ADDU V0, V1, V0
9D009C84  90420004   LBU V0, 4(V0)
9D009C88  00402021   ADDU A0, V0, ZERO
9D009C8C  3C029D01   LUI V0, -25343
9D009C90  24455648   ADDIU A1, V0, 22088
9D009C94  0F4005F2   JAL TCPPutString
9D009C98  00000000   NOP
815:                             }
816:                 
817:                             // If not GET or POST, we're done
818:                             if(curHTTP.httpStatus != HTTP_GET && curHTTP.httpStatus != HTTP_POST)
9D009C9C  3C02A000   LUI V0, -24576
9D009CA0  244204A0   ADDIU V0, V0, 1184
9D009CA4  8C42001C   LW V0, 28(V0)
9D009CA8  10400011   BEQ V0, ZERO, 0x9D009CF0
9D009CAC  00000000   NOP
9D009CB0  3C02A000   LUI V0, -24576
9D009CB4  244204A0   ADDIU V0, V0, 1184
9D009CB8  8C43001C   LW V1, 28(V0)
9D009CBC  24020001   ADDIU V0, ZERO, 1
9D009CC0  1062000B   BEQ V1, V0, 0x9D009CF0
9D009CC4  00000000   NOP
819:                             {// Disconnect
820:                                 smHTTP = SM_HTTP_DISCONNECT;
9D009CC8  93828159   LBU V0, -32423(GP)
9D009CCC  00401821   ADDU V1, V0, ZERO
9D009CD0  3C02A000   LUI V0, -24576
9D009CD4  000318C0   SLL V1, V1, 3
9D009CD8  244208C8   ADDIU V0, V0, 2248
9D009CDC  00621021   ADDU V0, V1, V0
9D009CE0  2403000B   ADDIU V1, ZERO, 11
9D009CE4  AC430000   SW V1, 0(V0)
821:                                 break;
9D009CE8  0B4028A8   J 0x9D00A2A0
9D009CEC  00000000   NOP
822:                             }
823:                 
824:                             // Output the content type, if known
825:                             if(curHTTP.fileType != HTTP_UNKNOWN)
9D009CF0  3C02A000   LUI V0, -24576
9D009CF4  244204A0   ADDIU V0, V0, 1184
9D009CF8  8C430020   LW V1, 32(V0)
9D009CFC  2402000B   ADDIU V0, ZERO, 11
9D009D00  1062002F   BEQ V1, V0, 0x9D009DC0
9D009D04  00000000   NOP
826:                             {
827:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)"Content-Type: ");
9D009D08  93828159   LBU V0, -32423(GP)
9D009D0C  00401821   ADDU V1, V0, ZERO
9D009D10  3C02A000   LUI V0, -24576
9D009D14  000318C0   SLL V1, V1, 3
9D009D18  244208C8   ADDIU V0, V0, 2248
9D009D1C  00621021   ADDU V0, V1, V0
9D009D20  90420004   LBU V0, 4(V0)
9D009D24  00401821   ADDU V1, V0, ZERO
9D009D28  3C029D01   LUI V0, -25343
9D009D2C  24425B08   ADDIU V0, V0, 23304
9D009D30  00602021   ADDU A0, V1, ZERO
9D009D34  00402821   ADDU A1, V0, ZERO
9D009D38  0F4005F2   JAL TCPPutString
9D009D3C  00000000   NOP
828:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)httpContentTypes[curHTTP.fileType]);
9D009D40  93828159   LBU V0, -32423(GP)
9D009D44  00401821   ADDU V1, V0, ZERO
9D009D48  3C02A000   LUI V0, -24576
9D009D4C  000318C0   SLL V1, V1, 3
9D009D50  244208C8   ADDIU V0, V0, 2248
9D009D54  00621021   ADDU V0, V1, V0
9D009D58  90420004   LBU V0, 4(V0)
9D009D5C  00401821   ADDU V1, V0, ZERO
9D009D60  3C02A000   LUI V0, -24576
9D009D64  244204A0   ADDIU V0, V0, 1184
9D009D68  8C440020   LW A0, 32(V0)
9D009D6C  3C029D01   LUI V0, -25343
9D009D70  00042080   SLL A0, A0, 2
9D009D74  2442572C   ADDIU V0, V0, 22316
9D009D78  00821021   ADDU V0, A0, V0
9D009D7C  8C420000   LW V0, 0(V0)
9D009D80  00602021   ADDU A0, V1, ZERO
9D009D84  00402821   ADDU A1, V0, ZERO
9D009D88  0F4005F2   JAL TCPPutString
9D009D8C  00000000   NOP
829:                                 TCPPutROMString(sktHTTP, HTTP_CRLF);
9D009D90  93828159   LBU V0, -32423(GP)
9D009D94  00401821   ADDU V1, V0, ZERO
9D009D98  3C02A000   LUI V0, -24576
9D009D9C  000318C0   SLL V1, V1, 3
9D009DA0  244208C8   ADDIU V0, V0, 2248
9D009DA4  00621021   ADDU V0, V1, V0
9D009DA8  90420004   LBU V0, 4(V0)
9D009DAC  00402021   ADDU A0, V0, ZERO
9D009DB0  3C029D01   LUI V0, -25343
9D009DB4  24455648   ADDIU A1, V0, 22088
9D009DB8  0F4005F2   JAL TCPPutString
9D009DBC  00000000   NOP
830:                             }
831:                 
832:                             // Output the gzip encoding header if needed
833:                             if(MPFSGetFlags(curHTTP.file) & MPFS2_FLAG_ISZIPPED)
9D009DC0  3C02A000   LUI V0, -24576
9D009DC4  244204A0   ADDIU V0, V0, 1184
9D009DC8  90420018   LBU V0, 24(V0)
9D009DCC  00402021   ADDU A0, V0, ZERO
9D009DD0  0F4036D5   JAL MPFSGetFlags
9D009DD4  00000000   NOP
9D009DD8  30420001   ANDI V0, V0, 1
9D009DDC  304200FF   ANDI V0, V0, 255
9D009DE0  1040000F   BEQ V0, ZERO, 0x9D009E20
9D009DE4  00000000   NOP
834:                             {
835:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)"Content-Encoding: gzip\r\n");
9D009DE8  93828159   LBU V0, -32423(GP)
9D009DEC  00401821   ADDU V1, V0, ZERO
9D009DF0  3C02A000   LUI V0, -24576
9D009DF4  000318C0   SLL V1, V1, 3
9D009DF8  244208C8   ADDIU V0, V0, 2248
9D009DFC  00621021   ADDU V0, V1, V0
9D009E00  90420004   LBU V0, 4(V0)
9D009E04  00401821   ADDU V1, V0, ZERO
9D009E08  3C029D01   LUI V0, -25343
9D009E0C  24425B18   ADDIU V0, V0, 23320
9D009E10  00602021   ADDU A0, V1, ZERO
9D009E14  00402821   ADDU A1, V0, ZERO
9D009E18  0F4005F2   JAL TCPPutString
9D009E1C  00000000   NOP
836:                             }
837:                 
838:                             // Output the cache-control
839:                             TCPPutROMString(sktHTTP, (ROM uint8_t*)"Cache-Control: ");
9D009E20  93828159   LBU V0, -32423(GP)
9D009E24  00401821   ADDU V1, V0, ZERO
9D009E28  3C02A000   LUI V0, -24576
9D009E2C  000318C0   SLL V1, V1, 3
9D009E30  244208C8   ADDIU V0, V0, 2248
9D009E34  00621021   ADDU V0, V1, V0
9D009E38  90420004   LBU V0, 4(V0)
9D009E3C  00401821   ADDU V1, V0, ZERO
9D009E40  3C029D01   LUI V0, -25343
9D009E44  24425B34   ADDIU V0, V0, 23348
9D009E48  00602021   ADDU A0, V1, ZERO
9D009E4C  00402821   ADDU A1, V0, ZERO
9D009E50  0F4005F2   JAL TCPPutString
9D009E54  00000000   NOP
840:                             if(curHTTP.httpStatus == HTTP_POST || curHTTP.nextCallback != 0xffffffff)
9D009E58  3C02A000   LUI V0, -24576
9D009E5C  244204A0   ADDIU V0, V0, 1184
9D009E60  8C43001C   LW V1, 28(V0)
9D009E64  24020001   ADDIU V0, ZERO, 1
9D009E68  10620007   BEQ V1, V0, 0x9D009E88
9D009E6C  00000000   NOP
9D009E70  3C02A000   LUI V0, -24576
9D009E74  244204A0   ADDIU V0, V0, 1184
9D009E78  8C430004   LW V1, 4(V0)
9D009E7C  2402FFFF   ADDIU V0, ZERO, -1
9D009E80  10620011   BEQ V1, V0, 0x9D009EC8
9D009E84  00000000   NOP
841:                             {// This is a dynamic page or a POST request, so no cache
842:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)"no-cache");
9D009E88  93828159   LBU V0, -32423(GP)
9D009E8C  00401821   ADDU V1, V0, ZERO
9D009E90  3C02A000   LUI V0, -24576
9D009E94  000318C0   SLL V1, V1, 3
9D009E98  244208C8   ADDIU V0, V0, 2248
9D009E9C  00621021   ADDU V0, V1, V0
9D009EA0  90420004   LBU V0, 4(V0)
9D009EA4  00401821   ADDU V1, V0, ZERO
9D009EA8  3C029D01   LUI V0, -25343
9D009EAC  24425B44   ADDIU V0, V0, 23364
9D009EB0  00602021   ADDU A0, V1, ZERO
9D009EB4  00402821   ADDU A1, V0, ZERO
9D009EB8  0F4005F2   JAL TCPPutString
9D009EBC  00000000   NOP
9D009EC0  0B4027CE   J 0x9D009F38
9D009EC4  00000000   NOP
843:                             }
844:                             else
845:                             {// This is a static page, so save it for the specified amount of time
846:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)"max-age=");
9D009EC8  93828159   LBU V0, -32423(GP)
9D009ECC  00401821   ADDU V1, V0, ZERO
9D009ED0  3C02A000   LUI V0, -24576
9D009ED4  000318C0   SLL V1, V1, 3
9D009ED8  244208C8   ADDIU V0, V0, 2248
9D009EDC  00621021   ADDU V0, V1, V0
9D009EE0  90420004   LBU V0, 4(V0)
9D009EE4  00401821   ADDU V1, V0, ZERO
9D009EE8  3C029D01   LUI V0, -25343
9D009EEC  24425B50   ADDIU V0, V0, 23376
9D009EF0  00602021   ADDU A0, V1, ZERO
9D009EF4  00402821   ADDU A1, V0, ZERO
9D009EF8  0F4005F2   JAL TCPPutString
9D009EFC  00000000   NOP
847:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)HTTP_CACHE_LEN);
9D009F00  93828159   LBU V0, -32423(GP)
9D009F04  00401821   ADDU V1, V0, ZERO
9D009F08  3C02A000   LUI V0, -24576
9D009F0C  000318C0   SLL V1, V1, 3
9D009F10  244208C8   ADDIU V0, V0, 2248
9D009F14  00621021   ADDU V0, V1, V0
9D009F18  90420004   LBU V0, 4(V0)
9D009F1C  00401821   ADDU V1, V0, ZERO
9D009F20  3C029D01   LUI V0, -25343
9D009F24  24425B5C   ADDIU V0, V0, 23388
9D009F28  00602021   ADDU A0, V1, ZERO
9D009F2C  00402821   ADDU A1, V0, ZERO
9D009F30  0F4005F2   JAL TCPPutString
9D009F34  00000000   NOP
848:                             }
849:                             TCPPutROMString(sktHTTP, HTTP_CRLF);
9D009F38  93828159   LBU V0, -32423(GP)
9D009F3C  00401821   ADDU V1, V0, ZERO
9D009F40  3C02A000   LUI V0, -24576
9D009F44  000318C0   SLL V1, V1, 3
9D009F48  244208C8   ADDIU V0, V0, 2248
9D009F4C  00621021   ADDU V0, V1, V0
9D009F50  90420004   LBU V0, 4(V0)
9D009F54  00402021   ADDU A0, V0, ZERO
9D009F58  3C029D01   LUI V0, -25343
9D009F5C  24455648   ADDIU A1, V0, 22088
9D009F60  0F4005F2   JAL TCPPutString
9D009F64  00000000   NOP
850:                 
851:                             // Check if we should output cookies
852:                             if(curHTTP.hasArgs)
9D009F68  3C02A000   LUI V0, -24576
9D009F6C  244204A0   ADDIU V0, V0, 1184
9D009F70  9042001A   LBU V0, 26(V0)
9D009F74  1040000B   BEQ V0, ZERO, 0x9D009FA4
9D009F78  00000000   NOP
853:                                 smHTTP = SM_HTTP_SERVE_COOKIES;
9D009F7C  93828159   LBU V0, -32423(GP)
9D009F80  00401821   ADDU V1, V0, ZERO
9D009F84  3C02A000   LUI V0, -24576
9D009F88  000318C0   SLL V1, V1, 3
9D009F8C  244208C8   ADDIU V0, V0, 2248
9D009F90  00621021   ADDU V0, V1, V0
9D009F94  24030008   ADDIU V1, ZERO, 8
9D009F98  AC430000   SW V1, 0(V0)
9D009F9C  0B4027FD   J 0x9D009FF4
9D009FA0  00000000   NOP
854:                             else
855:                             {// Terminate the headers
856:                                 TCPPutROMString(sktHTTP, HTTP_CRLF);
9D009FA4  93828159   LBU V0, -32423(GP)
9D009FA8  00401821   ADDU V1, V0, ZERO
9D009FAC  3C02A000   LUI V0, -24576
9D009FB0  000318C0   SLL V1, V1, 3
9D009FB4  244208C8   ADDIU V0, V0, 2248
9D009FB8  00621021   ADDU V0, V1, V0
9D009FBC  90420004   LBU V0, 4(V0)
9D009FC0  00402021   ADDU A0, V0, ZERO
9D009FC4  3C029D01   LUI V0, -25343
9D009FC8  24455648   ADDIU A1, V0, 22088
9D009FCC  0F4005F2   JAL TCPPutString
9D009FD0  00000000   NOP
857:                                 smHTTP = SM_HTTP_SERVE_BODY;
9D009FD4  93828159   LBU V0, -32423(GP)
9D009FD8  00401821   ADDU V1, V0, ZERO
9D009FDC  3C02A000   LUI V0, -24576
9D009FE0  000318C0   SLL V1, V1, 3
9D009FE4  244208C8   ADDIU V0, V0, 2248
9D009FE8  00621021   ADDU V0, V1, V0
9D009FEC  24030009   ADDIU V1, ZERO, 9
9D009FF0  AC430000   SW V1, 0(V0)
858:                             }
859:                 
860:                             // Move to next stage
861:                             isDone = false;
9D009FF4  A3C0001D   SB ZERO, 29(S8)
862:                             break;
9D009FF8  0B4028A8   J 0x9D00A2A0
9D009FFC  00000000   NOP
863:                 
864:                         case SM_HTTP_SERVE_COOKIES:
865:                 
866:                             #if defined(HTTP_USE_COOKIES)
867:                             // If the TX FIFO runs out of space, the client will never get CRLFCRLF
868:                             // Avoid writing huge cookies - keep it under a hundred bytes max
869:                 
870:                             // Write cookies one at a time as space permits
871:                             for(curHTTP.ptrRead = curHTTP.data; curHTTP.hasArgs != 0u; curHTTP.hasArgs--)
872:                             {
873:                                 // Write the header
874:                                 TCPPutROMString(sktHTTP, (ROM uint8_t*)"Set-Cookie: ");
875:                 
876:                                 // Write the name, URL encoded, one character at a time
877:                                 while((c = *(curHTTP.ptrRead++)))
878:                                 {
879:                                     if(c == ' ')
880:                                         TCPPut(sktHTTP, '+');
881:                                     else if(c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')
882:                                     {
883:                                         TCPPut(sktHTTP, '%');
884:                                         TCPPut(sktHTTP, btohexa_high(c));
885:                                         TCPPut(sktHTTP, btohexa_low(c));
886:                                     }
887:                                     else
888:                                         TCPPut(sktHTTP, c);
889:                                 }
890:                 
891:                                 TCPPut(sktHTTP, '=');
892:                 
893:                                 // Write the value, URL encoded, one character at a time
894:                                 while((c = *(curHTTP.ptrRead++)))
895:                                 {
896:                                     if(c == ' ')
897:                                         TCPPut(sktHTTP, '+');
898:                                     else if(c < '0' || (c > '9' && c < 'A') || (c > 'Z' && c < 'a') || c > 'z')
899:                                     {
900:                                         TCPPut(sktHTTP, '%');
901:                                         TCPPut(sktHTTP, btohexa_high(c));
902:                                         TCPPut(sktHTTP, btohexa_low(c));
903:                                     }
904:                                     else
905:                                         TCPPut(sktHTTP, c);
906:                                 }
907:                 
908:                                 // Finish the line
909:                                 TCPPutROMString(sktHTTP, HTTP_CRLF);
910:                 
911:                             }
912:                             #endif
913:                 
914:                             // We're done, move to next state
915:                             TCPPutROMString(sktHTTP, HTTP_CRLF);
9D00A000  93828159   LBU V0, -32423(GP)
9D00A004  00401821   ADDU V1, V0, ZERO
9D00A008  3C02A000   LUI V0, -24576
9D00A00C  000318C0   SLL V1, V1, 3
9D00A010  244208C8   ADDIU V0, V0, 2248
9D00A014  00621021   ADDU V0, V1, V0
9D00A018  90420004   LBU V0, 4(V0)
9D00A01C  00402021   ADDU A0, V0, ZERO
9D00A020  3C029D01   LUI V0, -25343
9D00A024  24455648   ADDIU A1, V0, 22088
9D00A028  0F4005F2   JAL TCPPutString
9D00A02C  00000000   NOP
916:                             smHTTP = SM_HTTP_SERVE_BODY;
9D00A030  93828159   LBU V0, -32423(GP)
9D00A034  00401821   ADDU V1, V0, ZERO
9D00A038  3C02A000   LUI V0, -24576
9D00A03C  000318C0   SLL V1, V1, 3
9D00A040  244208C8   ADDIU V0, V0, 2248
9D00A044  00621021   ADDU V0, V1, V0
9D00A048  24030009   ADDIU V1, ZERO, 9
9D00A04C  AC430000   SW V1, 0(V0)
917:                 
918:                         case SM_HTTP_SERVE_BODY:
919:                 
920:                             isDone = false;
9D00A050  A3C0001D   SB ZERO, 29(S8)
921:                 
922:                             // Try to send next packet
923:                             if(HTTPSendFile())
9D00A054  0F4028B4   JAL 0x9D00A2D0
9D00A058  00000000   NOP
9D00A05C  10400015   BEQ V0, ZERO, 0x9D00A0B4
9D00A060  00000000   NOP
924:                             {// If EOF, then we're done so close and disconnect
925:                                 MPFSClose(curHTTP.file);
9D00A064  3C02A000   LUI V0, -24576
9D00A068  244204A0   ADDIU V0, V0, 1184
9D00A06C  90420018   LBU V0, 24(V0)
9D00A070  00402021   ADDU A0, V0, ZERO
9D00A074  0F4033E5   JAL MPFSClose
9D00A078  00000000   NOP
926:                                 curHTTP.file = MPFS_INVALID_HANDLE;
9D00A07C  3C02A000   LUI V0, -24576
9D00A080  244204A0   ADDIU V0, V0, 1184
9D00A084  2403FFFF   ADDIU V1, ZERO, -1
9D00A088  A0430018   SB V1, 24(V0)
927:                                 smHTTP = SM_HTTP_DISCONNECT;
9D00A08C  93828159   LBU V0, -32423(GP)
9D00A090  00401821   ADDU V1, V0, ZERO
9D00A094  3C02A000   LUI V0, -24576
9D00A098  000318C0   SLL V1, V1, 3
9D00A09C  244208C8   ADDIU V0, V0, 2248
9D00A0A0  00621021   ADDU V0, V1, V0
9D00A0A4  2403000B   ADDIU V1, ZERO, 11
9D00A0A8  AC430000   SW V1, 0(V0)
928:                                 isDone = true;
9D00A0AC  24020001   ADDIU V0, ZERO, 1
9D00A0B0  A3C2001D   SB V0, 29(S8)
929:                             }
930:                 
931:                             // If the TX FIFO is full, then return to main app loop
932:                             if(TCPIsPutReady(sktHTTP) == 0u)
9D00A0B4  93828159   LBU V0, -32423(GP)
9D00A0B8  00401821   ADDU V1, V0, ZERO
9D00A0BC  3C02A000   LUI V0, -24576
9D00A0C0  000318C0   SLL V1, V1, 3
9D00A0C4  244208C8   ADDIU V0, V0, 2248
9D00A0C8  00621021   ADDU V0, V1, V0
9D00A0CC  90420004   LBU V0, 4(V0)
9D00A0D0  00402021   ADDU A0, V0, ZERO
9D00A0D4  0F400373   JAL TCPIsPutReady
9D00A0D8  00000000   NOP
9D00A0DC  14400069   BNE V0, ZERO, 0x9D00A284
9D00A0E0  00000000   NOP
933:                                 isDone = true;
9D00A0E4  24020001   ADDIU V0, ZERO, 1
9D00A0E8  A3C2001D   SB V0, 29(S8)
934:                             break;
9D00A0EC  0B4028A8   J 0x9D00A2A0
9D00A0F0  00000000   NOP
9D00A284  00000000   NOP
9D00A288  0B4028A8   J 0x9D00A2A0
9D00A28C  00000000   NOP
935:                 
936:                         case SM_HTTP_SEND_FROM_CALLBACK:
937:                 
938:                             isDone = true;
9D00A0F4  24020001   ADDIU V0, ZERO, 1
9D00A0F8  A3C2001D   SB V0, 29(S8)
939:                 
940:                             // Check that at least the minimum bytes are free
941:                             if(TCPIsPutReady(sktHTTP) < HTTP_MIN_CALLBACK_FREE)
9D00A0FC  93828159   LBU V0, -32423(GP)
9D00A100  00401821   ADDU V1, V0, ZERO
9D00A104  3C02A000   LUI V0, -24576
9D00A108  000318C0   SLL V1, V1, 3
9D00A10C  244208C8   ADDIU V0, V0, 2248
9D00A110  00621021   ADDU V0, V1, V0
9D00A114  90420004   LBU V0, 4(V0)
9D00A118  00402021   ADDU A0, V0, ZERO
9D00A11C  0F400373   JAL TCPIsPutReady
9D00A120  00000000   NOP
9D00A124  2C420010   SLTIU V0, V0, 16
9D00A128  14400059   BNE V0, ZERO, 0x9D00A290
9D00A12C  00000000   NOP
942:                                 break;
9D00A290  00000000   NOP
9D00A294  0B4028A8   J 0x9D00A2A0
9D00A298  00000000   NOP
943:                 
944:                             // Fill TX FIFO from callback
945:                             HTTPPrint(curHTTP.callbackID);
9D00A130  3C02A000   LUI V0, -24576
9D00A134  244204A0   ADDIU V0, V0, 1184
9D00A138  8C420008   LW V0, 8(V0)
9D00A13C  00402021   ADDU A0, V0, ZERO
9D00A140  0F402109   JAL HTTPPrint
9D00A144  00000000   NOP
946:                 
947:                             if(curHTTP.callbackPos == 0u)
9D00A148  3C02A000   LUI V0, -24576
9D00A14C  244204A0   ADDIU V0, V0, 1184
9D00A150  8C42000C   LW V0, 12(V0)
9D00A154  14400051   BNE V0, ZERO, 0x9D00A29C
9D00A158  00000000   NOP
948:                             {// Callback finished its output, so move on
949:                                 isDone = false;
9D00A15C  A3C0001D   SB ZERO, 29(S8)
950:                                 smHTTP = SM_HTTP_SERVE_BODY;
9D00A160  93828159   LBU V0, -32423(GP)
9D00A164  00401821   ADDU V1, V0, ZERO
9D00A168  3C02A000   LUI V0, -24576
9D00A16C  000318C0   SLL V1, V1, 3
9D00A170  244208C8   ADDIU V0, V0, 2248
9D00A174  00621021   ADDU V0, V1, V0
9D00A178  24030009   ADDIU V1, ZERO, 9
9D00A17C  AC430000   SW V1, 0(V0)
951:                             }// Otherwise, callback needs more buffer space, so return and wait
952:                 
953:                             break;
9D00A180  0B4028A8   J 0x9D00A2A0
9D00A184  00000000   NOP
9D00A29C  00000000   NOP
954:                 
955:                         case SM_HTTP_DISCONNECT:
956:                             // Make sure any opened files are closed
957:                             if(curHTTP.file != MPFS_INVALID_HANDLE)
9D00A188  3C02A000   LUI V0, -24576
9D00A18C  244204A0   ADDIU V0, V0, 1184
9D00A190  90430018   LBU V1, 24(V0)
9D00A194  240200FF   ADDIU V0, ZERO, 255
9D00A198  1062000B   BEQ V1, V0, 0x9D00A1C8
9D00A19C  00000000   NOP
958:                             {
959:                                 MPFSClose(curHTTP.file);
9D00A1A0  3C02A000   LUI V0, -24576
9D00A1A4  244204A0   ADDIU V0, V0, 1184
9D00A1A8  90420018   LBU V0, 24(V0)
9D00A1AC  00402021   ADDU A0, V0, ZERO
9D00A1B0  0F4033E5   JAL MPFSClose
9D00A1B4  00000000   NOP
960:                                 curHTTP.file = MPFS_INVALID_HANDLE;
9D00A1B8  3C02A000   LUI V0, -24576
9D00A1BC  244204A0   ADDIU V0, V0, 1184
9D00A1C0  2403FFFF   ADDIU V1, ZERO, -1
9D00A1C4  A0430018   SB V1, 24(V0)
961:                             }
962:                             if(curHTTP.offsets != MPFS_INVALID_HANDLE)
9D00A1C8  3C02A000   LUI V0, -24576
9D00A1CC  244204A0   ADDIU V0, V0, 1184
9D00A1D0  90430019   LBU V1, 25(V0)
9D00A1D4  240200FF   ADDIU V0, ZERO, 255
9D00A1D8  1062000B   BEQ V1, V0, 0x9D00A208
9D00A1DC  00000000   NOP
963:                             {
964:                                 MPFSClose(curHTTP.offsets);
9D00A1E0  3C02A000   LUI V0, -24576
9D00A1E4  244204A0   ADDIU V0, V0, 1184
9D00A1E8  90420019   LBU V0, 25(V0)
9D00A1EC  00402021   ADDU A0, V0, ZERO
9D00A1F0  0F4033E5   JAL MPFSClose
9D00A1F4  00000000   NOP
965:                                 curHTTP.offsets = MPFS_INVALID_HANDLE;
9D00A1F8  3C02A000   LUI V0, -24576
9D00A1FC  244204A0   ADDIU V0, V0, 1184
9D00A200  2403FFFF   ADDIU V1, ZERO, -1
9D00A204  A0430019   SB V1, 25(V0)
966:                             }
967:                 
968:                             TCPDisconnect(sktHTTP);
9D00A208  93828159   LBU V0, -32423(GP)
9D00A20C  00401821   ADDU V1, V0, ZERO
9D00A210  3C02A000   LUI V0, -24576
9D00A214  000318C0   SLL V1, V1, 3
9D00A218  244208C8   ADDIU V0, V0, 2248
9D00A21C  00621021   ADDU V0, V1, V0
9D00A220  90420004   LBU V0, 4(V0)
9D00A224  00402021   ADDU A0, V0, ZERO
9D00A228  0F40025C   JAL TCPDisconnect
9D00A22C  00000000   NOP
969:                             smHTTP = SM_HTTP_IDLE;
9D00A230  93828159   LBU V0, -32423(GP)
9D00A234  00401821   ADDU V1, V0, ZERO
9D00A238  3C02A000   LUI V0, -24576
9D00A23C  000318C0   SLL V1, V1, 3
9D00A240  244208C8   ADDIU V0, V0, 2248
9D00A244  00621021   ADDU V0, V1, V0
9D00A248  AC400000   SW ZERO, 0(V0)
970:                             break;
9D00A24C  0B4028A8   J 0x9D00A2A0
9D00A250  00000000   NOP
971:                         }
972:                     } while(!isDone);
9D00A2A0  93C2001D   LBU V0, 29(S8)
9D00A2A4  38420001   XORI V0, V0, 1
9D00A2A8  304200FF   ANDI V0, V0, 255
9D00A2AC  1440F9BB   BNE V0, ZERO, 0x9D00899C
9D00A2B0  00000000   NOP
973:                 
974:                 }
9D00A2B4  03C0E821   ADDU SP, S8, ZERO
9D00A2B8  8FBF0044   LW RA, 68(SP)
9D00A2BC  8FBE0040   LW S8, 64(SP)
9D00A2C0  8FB0003C   LW S0, 60(SP)
9D00A2C4  27BD0048   ADDIU SP, SP, 72
9D00A2C8  03E00008   JR RA
9D00A2CC  00000000   NOP
975:                 
976:                 
977:                 /*****************************************************************************
978:                   Function:
979:                     static bool HTTPSendFile(void)
980:                 
981:                   Description:
982:                     Serves up the next chunk of curHTTP's file, up to a) available TX FIFO
983:                     space or b) the next callback index, whichever comes first.
984:                 
985:                   Precondition:
986:                     curHTTP.file and curHTTP.offsets have both been opened for reading.
987:                 
988:                   Parameters:
989:                     None
990:                 
991:                   Return Values:
992:                     true - the end of the file was reached and reading is done
993:                     false - more data remains to be read
994:                   ***************************************************************************/
995:                 static bool HTTPSendFile(void)
996:                 {
9D00A2D0  27BDFFA0   ADDIU SP, SP, -96
9D00A2D4  AFBF005C   SW RA, 92(SP)
9D00A2D8  AFBE0058   SW S8, 88(SP)
9D00A2DC  03A0F021   ADDU S8, SP, ZERO
997:                     uint16_t numBytes, len;
998:                     uint8_t c, data[64];
999:                 
1000:                    // Determine how many bytes we can read right now
1001:                    len = TCPIsPutReady(sktHTTP);
9D00A2E0  93828159   LBU V0, -32423(GP)
9D00A2E4  00401821   ADDU V1, V0, ZERO
9D00A2E8  3C02A000   LUI V0, -24576
9D00A2EC  000318C0   SLL V1, V1, 3
9D00A2F0  244208C8   ADDIU V0, V0, 2248
9D00A2F4  00621021   ADDU V0, V1, V0
9D00A2F8  90420004   LBU V0, 4(V0)
9D00A2FC  00402021   ADDU A0, V0, ZERO
9D00A300  0F400373   JAL TCPIsPutReady
9D00A304  00000000   NOP
9D00A308  A7C20012   SH V0, 18(S8)
1002:                    numBytes = mMIN(len, curHTTP.nextCallback - curHTTP.byteCount);
9D00A30C  3C02A000   LUI V0, -24576
9D00A310  244204A0   ADDIU V0, V0, 1184
9D00A314  8C430004   LW V1, 4(V0)
9D00A318  3C02A000   LUI V0, -24576
9D00A31C  8C4204A0   LW V0, 1184(V0)
9D00A320  00621823   SUBU V1, V1, V0
9D00A324  97C20012   LHU V0, 18(S8)
9D00A328  0043202B   SLTU A0, V0, V1
9D00A32C  0064100A   MOVZ V0, V1, A0
9D00A330  A7C20010   SH V0, 16(S8)
1003:                
1004:                    // Get/put as many bytes as possible
1005:                    curHTTP.byteCount += numBytes;
9D00A334  3C02A000   LUI V0, -24576
9D00A338  8C4304A0   LW V1, 1184(V0)
9D00A33C  97C20010   LHU V0, 16(S8)
9D00A340  00621821   ADDU V1, V1, V0
9D00A344  3C02A000   LUI V0, -24576
9D00A348  AC4304A0   SW V1, 1184(V0)
1006:                    while(numBytes > 0u)
9D00A34C  0B4028FE   J 0x9D00A3F8
9D00A350  00000000   NOP
9D00A3F8  97C20010   LHU V0, 16(S8)
9D00A3FC  1440FFD5   BNE V0, ZERO, 0x9D00A354
9D00A400  00000000   NOP
1007:                    {
1008:                        len = MPFSGetArray(curHTTP.file, data, mMIN(numBytes, sizeof(data)));
9D00A354  3C02A000   LUI V0, -24576
9D00A358  244204A0   ADDIU V0, V0, 1184
9D00A35C  90420018   LBU V0, 24(V0)
9D00A360  00402021   ADDU A0, V0, ZERO
9D00A364  97C20010   LHU V0, 16(S8)
9D00A368  3043FFFF   ANDI V1, V0, -1
9D00A36C  2C630041   SLTIU V1, V1, 65
9D00A370  14600002   BNE V1, ZERO, 0x9D00A37C
9D00A374  00000000   NOP
9D00A378  24020040   ADDIU V0, ZERO, 64
9D00A37C  3042FFFF   ANDI V0, V0, -1
9D00A380  27C30018   ADDIU V1, S8, 24
9D00A384  00602821   ADDU A1, V1, ZERO
9D00A388  00403021   ADDU A2, V0, ZERO
9D00A38C  0F403488   JAL MPFSGetArray
9D00A390  00000000   NOP
9D00A394  A7C20012   SH V0, 18(S8)
1009:                        if(len == 0u)
9D00A398  97C20012   LHU V0, 18(S8)
9D00A39C  14400004   BNE V0, ZERO, 0x9D00A3B0
9D00A3A0  00000000   NOP
1010:                            return true;
9D00A3A4  24020001   ADDIU V0, ZERO, 1
9D00A3A8  0B40295B   J 0x9D00A56C
9D00A3AC  00000000   NOP
1011:                        else
1012:                            TCPPutArray(sktHTTP, data, len);
9D00A3B0  93828159   LBU V0, -32423(GP)
9D00A3B4  00401821   ADDU V1, V0, ZERO
9D00A3B8  3C02A000   LUI V0, -24576
9D00A3BC  000318C0   SLL V1, V1, 3
9D00A3C0  244208C8   ADDIU V0, V0, 2248
9D00A3C4  00621021   ADDU V0, V1, V0
9D00A3C8  90420004   LBU V0, 4(V0)
9D00A3CC  00402021   ADDU A0, V0, ZERO
9D00A3D0  97C20012   LHU V0, 18(S8)
9D00A3D4  27C30018   ADDIU V1, S8, 24
9D00A3D8  00602821   ADDU A1, V1, ZERO
9D00A3DC  00403021   ADDU A2, V0, ZERO
9D00A3E0  0F4004D0   JAL TCPPutArray
9D00A3E4  00000000   NOP
1013:                        numBytes -= len;
9D00A3E8  97C30010   LHU V1, 16(S8)
9D00A3EC  97C20012   LHU V0, 18(S8)
9D00A3F0  00621023   SUBU V0, V1, V0
9D00A3F4  A7C20010   SH V0, 16(S8)
1014:                    }
1015:                
1016:                    // Check if a callback index was reached
1017:                    if(curHTTP.byteCount == curHTTP.nextCallback)
9D00A404  3C02A000   LUI V0, -24576
9D00A408  8C4304A0   LW V1, 1184(V0)
9D00A40C  3C02A000   LUI V0, -24576
9D00A410  244204A0   ADDIU V0, V0, 1184
9D00A414  8C420004   LW V0, 4(V0)
9D00A418  14620053   BNE V1, V0, 0x9D00A568
9D00A41C  00000000   NOP
1018:                    {
1019:                        // Update the state machine
1020:                        smHTTP = SM_HTTP_SEND_FROM_CALLBACK;
9D00A420  93828159   LBU V0, -32423(GP)
9D00A424  00401821   ADDU V1, V0, ZERO
9D00A428  3C02A000   LUI V0, -24576
9D00A42C  000318C0   SLL V1, V1, 3
9D00A430  244208C8   ADDIU V0, V0, 2248
9D00A434  00621021   ADDU V0, V1, V0
9D00A438  2403000A   ADDIU V1, ZERO, 10
9D00A43C  AC430000   SW V1, 0(V0)
1021:                        curHTTP.callbackPos = 0;
9D00A440  3C02A000   LUI V0, -24576
9D00A444  244204A0   ADDIU V0, V0, 1184
9D00A448  AC40000C   SW ZERO, 12(V0)
1022:                
1023:                        // Read past the variable name and close the MPFS
1024:                        MPFSGet(curHTTP.file, NULL);
9D00A44C  3C02A000   LUI V0, -24576
9D00A450  244204A0   ADDIU V0, V0, 1184
9D00A454  90420018   LBU V0, 24(V0)
9D00A458  00402021   ADDU A0, V0, ZERO
9D00A45C  00002821   ADDU A1, ZERO, ZERO
9D00A460  0F4033FF   JAL MPFSGet
9D00A464  00000000   NOP
1025:                        do
1026:                        {
1027:                            if(!MPFSGet(curHTTP.file, &c))
9D00A468  3C02A000   LUI V0, -24576
9D00A46C  244204A0   ADDIU V0, V0, 1184
9D00A470  90420018   LBU V0, 24(V0)
9D00A474  00401821   ADDU V1, V0, ZERO
9D00A478  27C20014   ADDIU V0, S8, 20
9D00A47C  00602021   ADDU A0, V1, ZERO
9D00A480  00402821   ADDU A1, V0, ZERO
9D00A484  0F4033FF   JAL MPFSGet
9D00A488  00000000   NOP
9D00A48C  38420001   XORI V0, V0, 1
9D00A490  304200FF   ANDI V0, V0, 255
9D00A494  1440000C   BNE V0, ZERO, 0x9D00A4C8
9D00A498  00000000   NOP
1028:                                break;
9D00A4C8  00000000   NOP
1029:                            curHTTP.byteCount++;
9D00A49C  3C02A000   LUI V0, -24576
9D00A4A0  8C4204A0   LW V0, 1184(V0)
9D00A4A4  24430001   ADDIU V1, V0, 1
9D00A4A8  3C02A000   LUI V0, -24576
9D00A4AC  AC4304A0   SW V1, 1184(V0)
1030:                        } while(c != '~');
9D00A4B0  93C30014   LBU V1, 20(S8)
9D00A4B4  2402007E   ADDIU V0, ZERO, 126
9D00A4B8  1462FFEB   BNE V1, V0, 0x9D00A468
9D00A4BC  00000000   NOP
9D00A4C0  0B402933   J 0x9D00A4CC
9D00A4C4  00000000   NOP
1031:                        curHTTP.byteCount++;
9D00A4CC  3C02A000   LUI V0, -24576
9D00A4D0  8C4204A0   LW V0, 1184(V0)
9D00A4D4  24430001   ADDIU V1, V0, 1
9D00A4D8  3C02A000   LUI V0, -24576
9D00A4DC  AC4304A0   SW V1, 1184(V0)
1032:                
1033:                        // Read in the callback address and next offset
1034:                        MPFSGetLong(curHTTP.offsets, &(curHTTP.callbackID));
9D00A4E0  3C02A000   LUI V0, -24576
9D00A4E4  244204A0   ADDIU V0, V0, 1184
9D00A4E8  90420019   LBU V0, 25(V0)
9D00A4EC  00402021   ADDU A0, V0, ZERO
9D00A4F0  3C02A000   LUI V0, -24576
9D00A4F4  244504A8   ADDIU A1, V0, 1192
9D00A4F8  0F40352B   JAL MPFSGetLong
9D00A4FC  00000000   NOP
1035:                        if(!MPFSGetLong(curHTTP.offsets, &(curHTTP.nextCallback)))
9D00A500  3C02A000   LUI V0, -24576
9D00A504  244204A0   ADDIU V0, V0, 1184
9D00A508  90420019   LBU V0, 25(V0)
9D00A50C  00402021   ADDU A0, V0, ZERO
9D00A510  3C02A000   LUI V0, -24576
9D00A514  244504A4   ADDIU A1, V0, 1188
9D00A518  0F40352B   JAL MPFSGetLong
9D00A51C  00000000   NOP
9D00A520  38420001   XORI V0, V0, 1
9D00A524  304200FF   ANDI V0, V0, 255
9D00A528  1040000F   BEQ V0, ZERO, 0x9D00A568
9D00A52C  00000000   NOP
1036:                        {
1037:                            curHTTP.nextCallback = 0xffffffff;
9D00A530  3C02A000   LUI V0, -24576
9D00A534  244204A0   ADDIU V0, V0, 1184
9D00A538  2403FFFF   ADDIU V1, ZERO, -1
9D00A53C  AC430004   SW V1, 4(V0)
1038:                            MPFSClose(curHTTP.offsets);
9D00A540  3C02A000   LUI V0, -24576
9D00A544  244204A0   ADDIU V0, V0, 1184
9D00A548  90420019   LBU V0, 25(V0)
9D00A54C  00402021   ADDU A0, V0, ZERO
9D00A550  0F4033E5   JAL MPFSClose
9D00A554  00000000   NOP
1039:                            curHTTP.offsets = MPFS_INVALID_HANDLE;
9D00A558  3C02A000   LUI V0, -24576
9D00A55C  244204A0   ADDIU V0, V0, 1184
9D00A560  2403FFFF   ADDIU V1, ZERO, -1
9D00A564  A0430019   SB V1, 25(V0)
1040:                        }
1041:                    }
1042:                
1043:                    // We are not done sending a file yet...
1044:                    return false;
9D00A568  00001021   ADDU V0, ZERO, ZERO
1045:                }
9D00A56C  03C0E821   ADDU SP, S8, ZERO
9D00A570  8FBF005C   LW RA, 92(SP)
9D00A574  8FBE0058   LW S8, 88(SP)
9D00A578  27BD0060   ADDIU SP, SP, 96
9D00A57C  03E00008   JR RA
9D00A580  00000000   NOP
1046:                
1047:                /*****************************************************************************
1048:                  Function:
1049:                    static void HTTPHeaderParseLookup(uint8_t i)
1050:                
1051:                  Description:
1052:                    Calls the appropriate header parser based on the index of the header
1053:                    that was read from the request.
1054:                
1055:                  Precondition:
1056:                    None
1057:                
1058:                  Parameters:
1059:                    i - the index of the string found in HTTPRequestHeaders
1060:                
1061:                  Return Values:
1062:                    true - the end of the file was reached and reading is done
1063:                    false - more data remains to be read
1064:                  ***************************************************************************/
1065:                static void HTTPHeaderParseLookup(uint8_t i)
1066:                {
9D00A584  27BDFFE8   ADDIU SP, SP, -24
9D00A588  AFBF0014   SW RA, 20(SP)
9D00A58C  AFBE0010   SW S8, 16(SP)
9D00A590  03A0F021   ADDU S8, SP, ZERO
9D00A594  00801021   ADDU V0, A0, ZERO
9D00A598  A3C20018   SB V0, 24(S8)
1067:                    // i corresponds to an index in HTTPRequestHeaders
1068:                
1069:                    #if defined(HTTP_USE_COOKIES)
1070:                    if(i == 0u)
1071:                    {
1072:                        HTTPHeaderParseCookie();
1073:                        return;
1074:                    }
1075:                    #endif
1076:                
1077:                    #if defined(HTTP_USE_AUTHENTICATION)
1078:                    if(i == 1u)
1079:                    {
1080:                        HTTPHeaderParseAuthorization();
1081:                        return;
1082:                    }
1083:                    #endif
1084:                
1085:                    #if defined(HTTP_USE_POST)
1086:                    if(i == 2u)
9D00A59C  93C30018   LBU V1, 24(S8)
9D00A5A0  24020002   ADDIU V0, ZERO, 2
9D00A5A4  14620004   BNE V1, V0, 0x9D00A5B8
9D00A5A8  00000000   NOP
1087:                    {
1088:                        HTTPHeaderParseContentLength();
9D00A5AC  0F402974   JAL 0x9D00A5D0
9D00A5B0  00000000   NOP
1089:                        return;
9D00A5B4  00000000   NOP
1090:                    }
1091:                    #endif
1092:                }
9D00A5B8  03C0E821   ADDU SP, S8, ZERO
9D00A5BC  8FBF0014   LW RA, 20(SP)
9D00A5C0  8FBE0010   LW S8, 16(SP)
9D00A5C4  27BD0018   ADDIU SP, SP, 24
9D00A5C8  03E00008   JR RA
9D00A5CC  00000000   NOP
1093:                
1094:                /*****************************************************************************
1095:                  Function:
1096:                    static void HTTPHeaderParseAuthorization(void)
1097:                
1098:                  Summary:
1099:                    Parses the "Authorization:" header for a request and verifies the
1100:                    credentials.
1101:                
1102:                  Description:
1103:                    Parses the "Authorization:" header for a request.  For example,
1104:                    "BASIC YWRtaW46cGFzc3dvcmQ=" is decoded to a user name of "admin" and
1105:                    a password of "password".  Once read, HTTPCheckAuth is called from
1106:                    custom_http_app.c to determine if the credentials are acceptable.
1107:                
1108:                    The return value of HTTPCheckAuth is saved in curHTTP.isAuthorized for
1109:                    later use by the application.
1110:                
1111:                  Precondition:
1112:                    None
1113:                
1114:                  Parameters:
1115:                    None
1116:                
1117:                  Returns:
1118:                    None
1119:                
1120:                  Remarks:
1121:                    This function is ony available when HTTP_USE_AUTHENTICATION is defined.
1122:                  ***************************************************************************/
1123:                #if defined(HTTP_USE_AUTHENTICATION)
1124:                static void HTTPHeaderParseAuthorization(void)
1125:                {
1126:                    uint16_t len;
1127:                    uint8_t buf[40];
1128:                    uint8_t *ptrBuf;
1129:                
1130:                    // If auth processing is not required, return
1131:                    if(curHTTP.isAuthorized & 0x80)
1132:                        return;
1133:                
1134:                    // Clear the auth type ("BASIC ")
1135:                    TCPGetArray(sktHTTP, NULL, 6);
1136:                
1137:                    // Find the terminating CRLF and make sure it's a multiple of four
1138:                    len = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, false);
1139:                    len += 3;
1140:                    len &= 0xfc;
1141:                    len = mMIN(len, sizeof(buf)-4);
1142:                
1143:                    // Read in 4 bytes at a time and decode (slower, but saves RAM)
1144:                    for(ptrBuf = buf; len > 0u; len-=4, ptrBuf+=3)
1145:                    {
1146:                        TCPGetArray(sktHTTP, ptrBuf, 4);
1147:                        Base64Decode(ptrBuf, 4, ptrBuf, 3);
1148:                    }
1149:                
1150:                    // Null terminate both, and make sure there's at least two terminators
1151:                    *ptrBuf = '\0';
1152:                    for(len = 0, ptrBuf = buf; len < sizeof(buf); len++, ptrBuf++)
1153:                        if(*ptrBuf == ':')
1154:                            break;
1155:                    *(ptrBuf++) = '\0';
1156:                
1157:                    // Verify credentials
1158:                    curHTTP.isAuthorized = HTTPCheckAuth(buf, ptrBuf);
1159:                
1160:                    return;
1161:                }
1162:                #endif
1163:                
1164:                /*****************************************************************************
1165:                  Function:
1166:                    static void HTTPHeaderParseCookie(void)
1167:                
1168:                  Summary:
1169:                    Parses the "Cookie:" headers for a request and stores them as GET
1170:                    variables.
1171:                
1172:                  Description:
1173:                    Parses the "Cookie:" headers for a request.  For example,
1174:                    "Cookie: name=Wile+E.+Coyote; order=ROCKET_LAUNCHER" is decoded to
1175:                    "name=Wile+E.+Coyote&order=ROCKET_LAUNCHER&" and stored as any other
1176:                    GET variable in curHTTP.data.
1177:                
1178:                    The user application can easily access these values later using the
1179:                    HTTPGetArg() and HTTPGetROMArg() functions.
1180:                
1181:                  Precondition:
1182:                    None
1183:                
1184:                  Parameters:
1185:                    None
1186:                
1187:                  Returns:
1188:                    None
1189:                
1190:                  Remarks:
1191:                    This function is ony available when HTTP_USE_COOKIES is defined.
1192:                  ***************************************************************************/
1193:                #if defined(HTTP_USE_COOKIES)
1194:                static void HTTPHeaderParseCookie(void)
1195:                {
1196:                    uint16_t lenA, lenB;
1197:                
1198:                    // Verify there's enough space
1199:                    lenB = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, false);
1200:                    if(lenB >= (uint16_t)(curHTTP.data + HTTP_MAX_DATA_LEN - curHTTP.ptrData - 2))
1201:                    {// If not, overflow
1202:                        curHTTP.httpStatus = HTTP_OVERFLOW;
1203:                        smHTTP = SM_HTTP_SERVE_HEADERS;
1204:                        return;
1205:                    }
1206:                
1207:                    // While a CRLF is not immediate, grab a cookie value
1208:                    while(lenB != 0u)
1209:                    {
1210:                        // Look for a ';' and use the shorter of that or a CRLF
1211:                        lenA = TCPFind(sktHTTP, ';', 0, false);
1212:                
1213:                        // Read to the terminator
1214:                        curHTTP.ptrData += TCPGetArray(sktHTTP, curHTTP.ptrData, mMIN(lenA, lenB));
1215:                
1216:                        // Insert an & to anticipate another cookie
1217:                        *(curHTTP.ptrData++) = '&';
1218:                
1219:                        // If semicolon, trash it and whitespace
1220:                        if(lenA < lenB)
1221:                        {
1222:                            TCPGet(sktHTTP, NULL);
1223:                            while(TCPFind(sktHTTP, ' ', 0, false) == 0u)
1224:                                TCPGet(sktHTTP, NULL);
1225:                        }
1226:                
1227:                        // Find the new distance to the CRLF
1228:                        lenB = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, false);
1229:                    }
1230:                
1231:                    return;
1232:                
1233:                }
1234:                #endif
1235:                
1236:                /*****************************************************************************
1237:                  Function:
1238:                    static void HTTPHeaderParseContentLength(void)
1239:                
1240:                  Summary:
1241:                    Parses the "Content-Length:" header for a request.
1242:                
1243:                  Description:
1244:                    Parses the "Content-Length:" header to determine how many bytes of
1245:                    POST data to expect after the request.  This value is stored in
1246:                    curHTTP.byteCount.
1247:                
1248:                  Precondition:
1249:                    None
1250:                
1251:                  Parameters:
1252:                    None
1253:                
1254:                  Returns:
1255:                    None
1256:                
1257:                  Remarks:
1258:                    This function is ony available when HTTP_USE_POST is defined.
1259:                  ***************************************************************************/
1260:                #if defined(HTTP_USE_POST)
1261:                static void HTTPHeaderParseContentLength(void)
1262:                {
9D00A5D0  27BDFFD0   ADDIU SP, SP, -48
9D00A5D4  AFBF002C   SW RA, 44(SP)
9D00A5D8  AFBE0028   SW S8, 40(SP)
9D00A5DC  03A0F021   ADDU S8, SP, ZERO
1263:                    uint16_t len;
1264:                    uint8_t buf[10];
1265:                
1266:                    // Read up to the CRLF (max 9 bytes or ~1GB)
1267:                    len = TCPFindROMArray(sktHTTP, HTTP_CRLF, HTTP_CRLF_LEN, 0, false);
9D00A5E0  93828159   LBU V0, -32423(GP)
9D00A5E4  00401821   ADDU V1, V0, ZERO
9D00A5E8  3C02A000   LUI V0, -24576
9D00A5EC  000318C0   SLL V1, V1, 3
9D00A5F0  244208C8   ADDIU V0, V0, 2248
9D00A5F4  00621021   ADDU V0, V1, V0
9D00A5F8  90420004   LBU V0, 4(V0)
9D00A5FC  AFA00010   SW ZERO, 16(SP)
9D00A600  AFA00014   SW ZERO, 20(SP)
9D00A604  00402021   ADDU A0, V0, ZERO
9D00A608  3C029D01   LUI V0, -25343
9D00A60C  24455648   ADDIU A1, V0, 22088
9D00A610  24060002   ADDIU A2, ZERO, 2
9D00A614  00003821   ADDU A3, ZERO, ZERO
9D00A618  0F400961   JAL TCPFindArrayEx
9D00A61C  00000000   NOP
9D00A620  A7C20018   SH V0, 24(S8)
1268:                    if(len >= sizeof(buf))
9D00A624  97C20018   LHU V0, 24(S8)
9D00A628  2C42000A   SLTIU V0, V0, 10
9D00A62C  14400009   BNE V0, ZERO, 0x9D00A654
9D00A630  00000000   NOP
1269:                    {
1270:                        curHTTP.httpStatus = HTTP_BAD_REQUEST;
9D00A634  3C02A000   LUI V0, -24576
9D00A638  244204A0   ADDIU V0, V0, 1184
9D00A63C  24030002   ADDIU V1, ZERO, 2
9D00A640  AC43001C   SW V1, 28(V0)
1271:                        curHTTP.byteCount = 0;
9D00A644  3C02A000   LUI V0, -24576
9D00A648  AC4004A0   SW ZERO, 1184(V0)
1272:                        return;
9D00A64C  0B4029AF   J 0x9D00A6BC
9D00A650  00000000   NOP
1273:                    }
1274:                    len = TCPGetArray(sktHTTP, buf, len);
9D00A654  93828159   LBU V0, -32423(GP)
9D00A658  00401821   ADDU V1, V0, ZERO
9D00A65C  3C02A000   LUI V0, -24576
9D00A660  000318C0   SLL V1, V1, 3
9D00A664  244208C8   ADDIU V0, V0, 2248
9D00A668  00621021   ADDU V0, V1, V0
9D00A66C  90420004   LBU V0, 4(V0)
9D00A670  00402021   ADDU A0, V0, ZERO
9D00A674  97C20018   LHU V0, 24(S8)
9D00A678  27C3001C   ADDIU V1, S8, 28
9D00A67C  00602821   ADDU A1, V1, ZERO
9D00A680  00403021   ADDU A2, V0, ZERO
9D00A684  0F40077A   JAL TCPGetArray
9D00A688  00000000   NOP
9D00A68C  A7C20018   SH V0, 24(S8)
1275:                    buf[len] = '\0';
9D00A690  97C20018   LHU V0, 24(S8)
9D00A694  27C30018   ADDIU V1, S8, 24
9D00A698  00621021   ADDU V0, V1, V0
9D00A69C  A0400004   SB ZERO, 4(V0)
1276:                
1277:                    curHTTP.byteCount = atol((char*)buf);
9D00A6A0  27C2001C   ADDIU V0, S8, 28
9D00A6A4  00402021   ADDU A0, V0, ZERO
9D00A6A8  0F406D10   JAL atol
9D00A6AC  00000000   NOP
9D00A6B0  00401821   ADDU V1, V0, ZERO
9D00A6B4  3C02A000   LUI V0, -24576
9D00A6B8  AC4304A0   SW V1, 1184(V0)
1278:                }
9D00A6BC  03C0E821   ADDU SP, S8, ZERO
9D00A6C0  8FBF002C   LW RA, 44(SP)
9D00A6C4  8FBE0028   LW S8, 40(SP)
9D00A6C8  27BD0030   ADDIU SP, SP, 48
9D00A6CC  03E00008   JR RA
9D00A6D0  00000000   NOP
1279:                #endif
1280:                
1281:                /*****************************************************************************
1282:                  Function:
1283:                    uint8_t* HTTPURLDecode(uint8_t* cData)
1284:                
1285:                  Summary:
1286:                    Parses a string from URL encoding to plain-text.
1287:                
1288:                  Description:
1289:                    Parses a string from URL encoding to plain-text.  The following
1290:                    conversions are made: ?=? to ?\0?, ?&? to ?\0?, ?+? to ? ?, and
1291:                    ?%xx? to a single hex byte.
1292:                
1293:                    After completion, the data has been decoded and a null terminator
1294:                    signifies the end of a name or value.  A second null terminator (or a
1295:                    null name parameter) indicates the end of all the data.
1296:                
1297:                  Precondition:
1298:                    The data parameter is null terminated and has at least one extra
1299:                    byte free.
1300:                
1301:                  Parameters:
1302:                    cData - The string which is to be decoded in place.
1303:                
1304:                  Returns:
1305:                    A pointer to the last null terminator in data, which is also the
1306:                    first free byte for new data.
1307:                
1308:                  Remarks:
1309:                    This function is called by the stack to parse GET arguments and
1310:                    cookie data.  User applications can use this function to decode POST
1311:                    data, but first need to verify that the string is null-terminated.
1312:                  ***************************************************************************/
1313:                uint8_t* HTTPURLDecode(uint8_t* cData)
1314:                {
9D00A6D4  27BDFFD8   ADDIU SP, SP, -40
9D00A6D8  AFBF0024   SW RA, 36(SP)
9D00A6DC  AFBE0020   SW S8, 32(SP)
9D00A6E0  03A0F021   ADDU S8, SP, ZERO
9D00A6E4  AFC40028   SW A0, 40(S8)
1315:                    uint8_t *pRead, *pWrite;
1316:                    uint16_t wLen;
1317:                    uint8_t c;
1318:                    uint16_t hex;
1319:                
1320:                    // Determine length of input
1321:                    wLen = strlen((char*)cData);
9D00A6E8  8FC20028   LW V0, 40(S8)
9D00A6EC  00402021   ADDU A0, V0, ZERO
9D00A6F0  0F4067E2   JAL 0x9D019F88
9D00A6F4  00000000   NOP
9D00A6F8  A7C20018   SH V0, 24(S8)
1322:                
1323:                    // Read all characters in the string
1324:                    for(pRead = pWrite = cData; wLen != 0u; )
9D00A6FC  8FC20028   LW V0, 40(S8)
9D00A700  AFC20014   SW V0, 20(S8)
9D00A704  8FC20014   LW V0, 20(S8)
9D00A708  AFC20010   SW V0, 16(S8)
9D00A70C  0B402A1B   J 0x9D00A86C
9D00A710  00000000   NOP
9D00A86C  97C20018   LHU V0, 24(S8)
9D00A870  1440FFA8   BNE V0, ZERO, 0x9D00A714
9D00A874  00000000   NOP
1325:                    {
1326:                        c = *pRead++;
9D00A714  8FC20010   LW V0, 16(S8)
9D00A718  90420000   LBU V0, 0(V0)
9D00A71C  A3C2001A   SB V0, 26(S8)
9D00A720  8FC20010   LW V0, 16(S8)
9D00A724  24420001   ADDIU V0, V0, 1
9D00A728  AFC20010   SW V0, 16(S8)
1327:                        wLen--;
9D00A72C  97C20018   LHU V0, 24(S8)
9D00A730  2442FFFF   ADDIU V0, V0, -1
9D00A734  A7C20018   SH V0, 24(S8)
1328:                
1329:                        if(c == '=' || c == '&')
9D00A738  93C3001A   LBU V1, 26(S8)
9D00A73C  2402003D   ADDIU V0, ZERO, 61
9D00A740  10620005   BEQ V1, V0, 0x9D00A758
9D00A744  00000000   NOP
9D00A748  93C3001A   LBU V1, 26(S8)
9D00A74C  24020026   ADDIU V0, ZERO, 38
9D00A750  14620008   BNE V1, V0, 0x9D00A774
9D00A754  00000000   NOP
1330:                            *pWrite++ = '\0';
9D00A758  8FC20014   LW V0, 20(S8)
9D00A75C  A0400000   SB ZERO, 0(V0)
9D00A760  8FC20014   LW V0, 20(S8)
9D00A764  24420001   ADDIU V0, V0, 1
9D00A768  AFC20014   SW V0, 20(S8)
9D00A76C  0B402A1B   J 0x9D00A86C
9D00A770  00000000   NOP
1331:                        else if(c == '+')
9D00A774  93C3001A   LBU V1, 26(S8)
9D00A778  2402002B   ADDIU V0, ZERO, 43
9D00A77C  14620009   BNE V1, V0, 0x9D00A7A4
9D00A780  00000000   NOP
1332:                            *pWrite++ = ' ';
9D00A784  8FC20014   LW V0, 20(S8)
9D00A788  24030020   ADDIU V1, ZERO, 32
9D00A78C  A0430000   SB V1, 0(V0)
9D00A790  8FC20014   LW V0, 20(S8)
9D00A794  24420001   ADDIU V0, V0, 1
9D00A798  AFC20014   SW V0, 20(S8)
9D00A79C  0B402A1B   J 0x9D00A86C
9D00A7A0  00000000   NOP
1333:                        else if(c == '%')
9D00A7A4  93C3001A   LBU V1, 26(S8)
9D00A7A8  24020025   ADDIU V0, ZERO, 37
9D00A7AC  14620029   BNE V1, V0, 0x9D00A854
9D00A7B0  00000000   NOP
1334:                        {
1335:                            if(wLen < 2u)
9D00A7B4  97C20018   LHU V0, 24(S8)
9D00A7B8  2C420002   SLTIU V0, V0, 2
9D00A7BC  10400004   BEQ V0, ZERO, 0x9D00A7D0
9D00A7C0  00000000   NOP
1336:                                wLen = 0;
9D00A7C4  A7C00018   SH ZERO, 24(S8)
9D00A7C8  0B402A1B   J 0x9D00A86C
9D00A7CC  00000000   NOP
1337:                            else
1338:                            {
1339:                                ((uint8_t*)&hex)[1] = *pRead++;
9D00A7D0  27C2001C   ADDIU V0, S8, 28
9D00A7D4  24420001   ADDIU V0, V0, 1
9D00A7D8  8FC30010   LW V1, 16(S8)
9D00A7DC  90630000   LBU V1, 0(V1)
9D00A7E0  A0430000   SB V1, 0(V0)
9D00A7E4  8FC20010   LW V0, 16(S8)
9D00A7E8  24420001   ADDIU V0, V0, 1
9D00A7EC  AFC20010   SW V0, 16(S8)
1340:                                ((uint8_t*)&hex)[0] = *pRead++;
9D00A7F0  27C2001C   ADDIU V0, S8, 28
9D00A7F4  8FC30010   LW V1, 16(S8)
9D00A7F8  90630000   LBU V1, 0(V1)
9D00A7FC  A0430000   SB V1, 0(V0)
9D00A800  8FC20010   LW V0, 16(S8)
9D00A804  24420001   ADDIU V0, V0, 1
9D00A808  AFC20010   SW V0, 16(S8)
1341:                                wLen--;
9D00A80C  97C20018   LHU V0, 24(S8)
9D00A810  2442FFFF   ADDIU V0, V0, -1
9D00A814  A7C20018   SH V0, 24(S8)
1342:                                wLen--;
9D00A818  97C20018   LHU V0, 24(S8)
9D00A81C  2442FFFF   ADDIU V0, V0, -1
9D00A820  A7C20018   SH V0, 24(S8)
1343:                                *pWrite++ = hexatob(*((TCPIP_UINT16_VAL*)&hex));
9D00A824  27C2001C   ADDIU V0, S8, 28
9D00A828  94440000   LHU A0, 0(V0)
9D00A82C  0F403E86   JAL hexatob
9D00A830  00000000   NOP
9D00A834  00401821   ADDU V1, V0, ZERO
9D00A838  8FC20014   LW V0, 20(S8)
9D00A83C  A0430000   SB V1, 0(V0)
9D00A840  8FC20014   LW V0, 20(S8)
9D00A844  24420001   ADDIU V0, V0, 1
9D00A848  AFC20014   SW V0, 20(S8)
9D00A84C  0B402A1B   J 0x9D00A86C
9D00A850  00000000   NOP
1344:                            }
1345:                        }
1346:                        else
1347:                            *pWrite++ = c;
9D00A854  8FC20014   LW V0, 20(S8)
9D00A858  93C3001A   LBU V1, 26(S8)
9D00A85C  A0430000   SB V1, 0(V0)
9D00A860  8FC20014   LW V0, 20(S8)
9D00A864  24420001   ADDIU V0, V0, 1
9D00A868  AFC20014   SW V0, 20(S8)
1348:                    }
1349:                
1350:                    // Double null terminate the last value
1351:                    *pWrite++ = '\0';
9D00A878  8FC20014   LW V0, 20(S8)
9D00A87C  A0400000   SB ZERO, 0(V0)
9D00A880  8FC20014   LW V0, 20(S8)
9D00A884  24420001   ADDIU V0, V0, 1
9D00A888  AFC20014   SW V0, 20(S8)
1352:                    *pWrite = '\0';
9D00A88C  8FC20014   LW V0, 20(S8)
9D00A890  A0400000   SB ZERO, 0(V0)
1353:                
1354:                    return pWrite;
9D00A894  8FC20014   LW V0, 20(S8)
1355:                }
9D00A898  03C0E821   ADDU SP, S8, ZERO
9D00A89C  8FBF0024   LW RA, 36(SP)
9D00A8A0  8FBE0020   LW S8, 32(SP)
9D00A8A4  27BD0028   ADDIU SP, SP, 40
9D00A8A8  03E00008   JR RA
9D00A8AC  00000000   NOP
1356:                
1357:                /*****************************************************************************
1358:                  Function:
1359:                    uint8_t* HTTPGetArg(uint8_t* cData, uint8_t* cArg)
1360:                
1361:                  Summary:
1362:                    Locates a form field value in a given data array.
1363:                
1364:                  Description:
1365:                    Searches through a data array to find the value associated with a
1366:                    given argument.  It can be used to find form field values in data
1367:                    received over GET or POST.
1368:                
1369:                    The end of data is assumed to be reached when a null name parameter is
1370:                    encountered.  This requires the string to have an even number of
1371:                    null-terminated strings, followed by an additional null terminator.
1372:                
1373:                  Precondition:
1374:                    The data array has a valid series of null terminated name/value pairs.
1375:                
1376:                  Parameters:
1377:                    data - the buffer to search
1378:                    arg - the name of the argument to find
1379:                
1380:                  Returns:
1381:                    A pointer to the argument value, or NULL if not found.
1382:                  ***************************************************************************/
1383:                uint8_t* HTTPGetArg(uint8_t* cData, uint8_t* cArg)
1384:                {
9D00A8B0  27BDFFE8   ADDIU SP, SP, -24
9D00A8B4  AFBF0014   SW RA, 20(SP)
9D00A8B8  AFBE0010   SW S8, 16(SP)
9D00A8BC  03A0F021   ADDU S8, SP, ZERO
9D00A8C0  AFC40018   SW A0, 24(S8)
9D00A8C4  AFC5001C   SW A1, 28(S8)
1385:                    // Search through the array while bytes remain
1386:                    while(*cData != '\0')
9D00A8C8  0B402A55   J 0x9D00A954
9D00A8CC  00000000   NOP
9D00A954  8FC20018   LW V0, 24(S8)
9D00A958  90420000   LBU V0, 0(V0)
9D00A95C  1440FFDC   BNE V0, ZERO, 0x9D00A8D0
9D00A960  00000000   NOP
1387:                    {
1388:                        // Look for arg at current position
1389:                        if(!strcmp((char*)cArg, (char*)cData))
9D00A8D0  8FC3001C   LW V1, 28(S8)
9D00A8D4  8FC20018   LW V0, 24(S8)
9D00A8D8  00602021   ADDU A0, V1, ZERO
9D00A8DC  00402821   ADDU A1, V0, ZERO
9D00A8E0  0F406A15   JAL 0x9D01A854
9D00A8E4  00000000   NOP
9D00A8E8  1440000A   BNE V0, ZERO, 0x9D00A914
9D00A8EC  00000000   NOP
1390:                        {// Found it, so return parameter
1391:                            return cData + strlen((char*)cArg) + 1;
9D00A8F0  8FC2001C   LW V0, 28(S8)
9D00A8F4  00402021   ADDU A0, V0, ZERO
9D00A8F8  0F4067E2   JAL 0x9D019F88
9D00A8FC  00000000   NOP
9D00A900  24420001   ADDIU V0, V0, 1
9D00A904  8FC30018   LW V1, 24(S8)
9D00A908  00621021   ADDU V0, V1, V0
9D00A90C  0B402A5A   J 0x9D00A968
9D00A910  00000000   NOP
1392:                        }
1393:                
1394:                        // Skip past two strings (NUL bytes)
1395:                        cData += strlen((char*)cData) + 1;
9D00A914  8FC20018   LW V0, 24(S8)
9D00A918  00402021   ADDU A0, V0, ZERO
9D00A91C  0F4067E2   JAL 0x9D019F88
9D00A920  00000000   NOP
9D00A924  24420001   ADDIU V0, V0, 1
9D00A928  8FC30018   LW V1, 24(S8)
9D00A92C  00621021   ADDU V0, V1, V0
9D00A930  AFC20018   SW V0, 24(S8)
1396:                        cData += strlen((char*)cData) + 1;
9D00A934  8FC20018   LW V0, 24(S8)
9D00A938  00402021   ADDU A0, V0, ZERO
9D00A93C  0F4067E2   JAL 0x9D019F88
9D00A940  00000000   NOP
9D00A944  24420001   ADDIU V0, V0, 1
9D00A948  8FC30018   LW V1, 24(S8)
9D00A94C  00621021   ADDU V0, V1, V0
9D00A950  AFC20018   SW V0, 24(S8)
1397:                    }
1398:                
1399:                    // Return NULL if not found
1400:                    return NULL;
9D00A964  00001021   ADDU V0, ZERO, ZERO
1401:                }
9D00A968  03C0E821   ADDU SP, S8, ZERO
9D00A96C  8FBF0014   LW RA, 20(SP)
9D00A970  8FBE0010   LW S8, 16(SP)
9D00A974  27BD0018   ADDIU SP, SP, 24
9D00A978  03E00008   JR RA
9D00A97C  00000000   NOP
1402:                
1403:                /*****************************************************************************
1404:                  Function:
1405:                    uint8_t* HTTPGetROMArg(uint8_t* cData, ROM uint8_t* cArg)
1406:                
1407:                  Summary:
1408:                    Locates a form field value in a given data array.
1409:                
1410:                  Description:
1411:                    Searches through a data array to find the value associated with a
1412:                    given argument.  It can be used to find form field values in data
1413:                    received over GET or POST.
1414:                
1415:                    The end of data is assumed to be reached when a null name parameter is
1416:                    encountered.  This requires the string to have an even number of
1417:                    null-terminated strings, followed by an additional null terminator.
1418:                
1419:                  Precondition:
1420:                    The data array has a valid series of null terminated name/value pairs.
1421:                
1422:                  Parameters:
1423:                    data - the buffer to search
1424:                    arg - the name of the argument to find
1425:                
1426:                  Returns:
1427:                    A pointer to the argument value, or NULL if not found.
1428:                
1429:                  Remarks:
1430:                    This function is aliased to HTTPGetArg on non-PIC18 platforms.
1431:                  ***************************************************************************/
1432:                #if defined(__XC8)
1433:                uint8_t* HTTPGetROMArg(uint8_t* cData, ROM uint8_t* cArg)
1434:                {
1435:                    // Search through the array while bytes remain
1436:                    while(*cData != '\0')
1437:                    {
1438:                        // Look for arg at current position
1439:                        if(!memcmppgm2ram(cData, (ROM void*)cArg, strlenpgm((ROM char*)cArg) + 1))
1440:                        {// Found it, so skip to next string
1441:                            return cData + strlenpgm((ROM char*)cArg) + 1;
1442:                        }
1443:                
1444:                        // Skip past two strings (NUL bytes)
1445:                        cData += strlen((char*)cData) + 1;
1446:                        cData += strlen((char*)cData) + 1;
1447:                    }
1448:                
1449:                    // Return NULL if not found
1450:                    return NULL;
1451:                }
1452:                #endif
1453:                
1454:                /*****************************************************************************
1455:                  Function:
1456:                    HTTP_READ_STATUS HTTPReadPostName(uint8_t* cData, uint16_t wLen)
1457:                
1458:                  Summary:
1459:                    Reads a name from a URL encoded string in the TCP buffer.
1460:                
1461:                  Description:
1462:                    Reads a name from a URL encoded string in the TCP buffer.  This function
1463:                    is meant to be called from an HTTPExecutePost callback to facilitate
1464:                    easier parsing of incoming data.  This function also prevents buffer
1465:                    overflows by forcing the programmer to indicate how many bytes are
1466:                    expected.  At least 2 extra bytes are needed in cData over the maximum
1467:                    length of data expected to be read.
1468:                
1469:                    This function will read until the next '=' character, which indicates the
1470:                    end of a name parameter.  It assumes that the front of the buffer is
1471:                    the beginning of the name paramter to be read.
1472:                
1473:                    This function properly updates curHTTP.byteCount by decrementing it
1474:                    by the number of bytes read.  It also removes the delimiting '=' from
1475:                    the buffer.
1476:                
1477:                  Precondition:
1478:                    Front of TCP buffer is the beginning of a name parameter, and the rest of
1479:                    the TCP buffer contains a URL-encoded string with a name parameter
1480:                    terminated by a '=' character.
1481:                
1482:                  Parameters:
1483:                    cData - where to store the name once it is read
1484:                    wLen - how many bytes can be written to cData
1485:                
1486:                  Return Values:
1487:                    HTTP_READ_OK - name was successfully read
1488:                    HTTP_READ_TRUNCTATED - entire name could not fit in the buffer, so the
1489:                                            value was truncated and data has been lost
1490:                    HTTP_READ_INCOMPLETE - entire name was not yet in the buffer, so call
1491:                                            this function again later to retrieve
1492:                  ***************************************************************************/
1493:                #if defined(HTTP_USE_POST)
1494:                HTTP_READ_STATUS HTTPReadPostName(uint8_t* cData, uint16_t wLen)
1495:                {
9D00A980  27BDFFE0   ADDIU SP, SP, -32
9D00A984  AFBF001C   SW RA, 28(SP)
9D00A988  AFBE0018   SW S8, 24(SP)
9D00A98C  03A0F021   ADDU S8, SP, ZERO
9D00A990  AFC40020   SW A0, 32(S8)
9D00A994  00A01021   ADDU V0, A1, ZERO
9D00A998  A7C20024   SH V0, 36(S8)
1496:                    HTTP_READ_STATUS status;
1497:                
1498:                    status = HTTPReadTo('=', cData, wLen);
9D00A99C  97C20024   LHU V0, 36(S8)
9D00A9A0  2404003D   ADDIU A0, ZERO, 61
9D00A9A4  8FC50020   LW A1, 32(S8)
9D00A9A8  00403021   ADDU A2, V0, ZERO
9D00A9AC  0F402AB9   JAL 0x9D00AAE4
9D00A9B0  00000000   NOP
9D00A9B4  AFC20010   SW V0, 16(S8)
1499:                
1500:                    // Decode the data (if not reading to null or blank) and return
1501:                    if(cData && *cData)
9D00A9B8  8FC20020   LW V0, 32(S8)
9D00A9BC  10400008   BEQ V0, ZERO, 0x9D00A9E0
9D00A9C0  00000000   NOP
9D00A9C4  8FC20020   LW V0, 32(S8)
9D00A9C8  90420000   LBU V0, 0(V0)
9D00A9CC  10400004   BEQ V0, ZERO, 0x9D00A9E0
9D00A9D0  00000000   NOP
1502:                        HTTPURLDecode(cData);
9D00A9D4  8FC40020   LW A0, 32(S8)
9D00A9D8  0F4029B5   JAL HTTPURLDecode
9D00A9DC  00000000   NOP
1503:                    return status;
9D00A9E0  8FC20010   LW V0, 16(S8)
1504:                }
9D00A9E4  03C0E821   ADDU SP, S8, ZERO
9D00A9E8  8FBF001C   LW RA, 28(SP)
9D00A9EC  8FBE0018   LW S8, 24(SP)
9D00A9F0  27BD0020   ADDIU SP, SP, 32
9D00A9F4  03E00008   JR RA
9D00A9F8  00000000   NOP
1505:                #endif
1506:                
1507:                /*****************************************************************************
1508:                  Function:
1509:                    HTTP_READ_STATUS HTTPReadPostValue(uint8_t* cData, uint16_t wLen)
1510:                
1511:                  Summary:
1512:                    Reads a value from a URL encoded string in the TCP buffer.
1513:                
1514:                  Description:
1515:                    Reads a value from a URL encoded string in the TCP buffer.  This function
1516:                    is meant to be called from an HTTPExecutePost callback to facilitate
1517:                    easier parsing of incoming data.  This function also prevents buffer
1518:                    overflows by forcing the programmer to indicate how many bytes are
1519:                    expected.  At least 2 extra bytes are needed in cData above the maximum
1520:                    length of data expected to be read.
1521:                
1522:                    This function will read until the next '&' character, which indicates the
1523:                    end of a value parameter.  It assumes that the front of the buffer is
1524:                    the beginning of the value paramter to be read.  If curHTTP.byteCount
1525:                    indicates that all expected bytes are in the buffer, it assumes that
1526:                    all remaining data is the value and acts accordingly.
1527:                
1528:                    This function properly updates curHTTP.byteCount by decrementing it
1529:                    by the number of bytes read.  The terminating '&' character is also
1530:                    removed from the buffer.
1531:                
1532:                  Precondition:
1533:                    Front of TCP buffer is the beginning of a name parameter, and the rest of
1534:                    the TCP buffer contains a URL-encoded string with a name parameter
1535:                    terminated by a '=' character.
1536:                
1537:                  Parameters:
1538:                    cData - where to store the value once it is read
1539:                    wLen - how many bytes can be written to cData
1540:                
1541:                  Return Values:
1542:                    HTTP_READ_OK - value was successfully read
1543:                    HTTP_READ_TRUNCTATED - entire value could not fit in the buffer, so the
1544:                                            value was truncated and data has been lost
1545:                    HTTP_READ_INCOMPLETE - entire value was not yet in the buffer, so call
1546:                                            this function again later to retrieve
1547:                  ***************************************************************************/
1548:                #if defined(HTTP_USE_POST)
1549:                HTTP_READ_STATUS HTTPReadPostValue(uint8_t* cData, uint16_t wLen)
1550:                {
9D00A9FC  27BDFFD8   ADDIU SP, SP, -40
9D00AA00  AFBF0024   SW RA, 36(SP)
9D00AA04  AFBE0020   SW S8, 32(SP)
9D00AA08  AFB0001C   SW S0, 28(SP)
9D00AA0C  03A0F021   ADDU S8, SP, ZERO
9D00AA10  AFC40028   SW A0, 40(S8)
9D00AA14  00A01021   ADDU V0, A1, ZERO
9D00AA18  A7C2002C   SH V0, 44(S8)
1551:                    HTTP_READ_STATUS status;
1552:                
1553:                    // Try to read the value
1554:                    status = HTTPReadTo('&', cData, wLen);
9D00AA1C  97C2002C   LHU V0, 44(S8)
9D00AA20  24040026   ADDIU A0, ZERO, 38
9D00AA24  8FC50028   LW A1, 40(S8)
9D00AA28  00403021   ADDU A2, V0, ZERO
9D00AA2C  0F402AB9   JAL 0x9D00AAE4
9D00AA30  00000000   NOP
9D00AA34  AFC20010   SW V0, 16(S8)
1555:                
1556:                    // If read was incomplete, check if we're at the end
1557:                    if(status == HTTP_READ_INCOMPLETE)
9D00AA38  8FC30010   LW V1, 16(S8)
9D00AA3C  24020002   ADDIU V0, ZERO, 2
9D00AA40  14620016   BNE V1, V0, 0x9D00AA9C
9D00AA44  00000000   NOP
1558:                    {
1559:                        // If all data has arrived, read all remaining data
1560:                        if(curHTTP.byteCount == TCPIsGetReady(sktHTTP))
9D00AA48  3C02A000   LUI V0, -24576
9D00AA4C  8C5004A0   LW S0, 1184(V0)
9D00AA50  93828159   LBU V0, -32423(GP)
9D00AA54  00401821   ADDU V1, V0, ZERO
9D00AA58  3C02A000   LUI V0, -24576
9D00AA5C  000318C0   SLL V1, V1, 3
9D00AA60  244208C8   ADDIU V0, V0, 2248
9D00AA64  00621021   ADDU V0, V1, V0
9D00AA68  90420004   LBU V0, 4(V0)
9D00AA6C  00402021   ADDU A0, V0, ZERO
9D00AA70  0F40066C   JAL TCPIsGetReady
9D00AA74  00000000   NOP
9D00AA78  16020008   BNE S0, V0, 0x9D00AA9C
9D00AA7C  00000000   NOP
1561:                            status = HTTPReadTo('\0', cData, wLen);
9D00AA80  97C2002C   LHU V0, 44(S8)
9D00AA84  00002021   ADDU A0, ZERO, ZERO
9D00AA88  8FC50028   LW A1, 40(S8)
9D00AA8C  00403021   ADDU A2, V0, ZERO
9D00AA90  0F402AB9   JAL 0x9D00AAE4
9D00AA94  00000000   NOP
9D00AA98  AFC20010   SW V0, 16(S8)
1562:                    }
1563:                
1564:                    // Decode the data (if not reading to null or blank) and return
1565:                    if(cData && *cData)
9D00AA9C  8FC20028   LW V0, 40(S8)
9D00AAA0  10400008   BEQ V0, ZERO, 0x9D00AAC4
9D00AAA4  00000000   NOP
9D00AAA8  8FC20028   LW V0, 40(S8)
9D00AAAC  90420000   LBU V0, 0(V0)
9D00AAB0  10400004   BEQ V0, ZERO, 0x9D00AAC4
9D00AAB4  00000000   NOP
1566:                        HTTPURLDecode(cData);
9D00AAB8  8FC40028   LW A0, 40(S8)
9D00AABC  0F4029B5   JAL HTTPURLDecode
9D00AAC0  00000000   NOP
1567:                    return status;
9D00AAC4  8FC20010   LW V0, 16(S8)
1568:                }
9D00AAC8  03C0E821   ADDU SP, S8, ZERO
9D00AACC  8FBF0024   LW RA, 36(SP)
9D00AAD0  8FBE0020   LW S8, 32(SP)
9D00AAD4  8FB0001C   LW S0, 28(SP)
9D00AAD8  27BD0028   ADDIU SP, SP, 40
9D00AADC  03E00008   JR RA
9D00AAE0  00000000   NOP
1569:                #endif
1570:                
1571:                /*****************************************************************************
1572:                  Function:
1573:                    static HTTP_READ_STATUS HTTPReadTo(uint8_t cDelim, uint8_t* cData, uint16_t wLen)
1574:                
1575:                  Summary:
1576:                    Reads to a buffer until a specified delimiter character.
1577:                
1578:                  Description:
1579:                    Reads from the TCP buffer to cData until either cDelim is reached, or
1580:                    until wLen - 2 bytes have been read.  The value read is saved to cData and
1581:                    null terminated.  (wLen - 2 is used so that the value can be passed to
1582:                    HTTPURLDecode later, which requires a null terminator plus one extra free
1583:                    byte.)
1584:                
1585:                    The delimiter character is removed from the buffer, but not saved to
1586:                    cData. If all data cannot fit into cData, it will still be removed from
1587:                    the buffer but will not be saved anywhere.
1588:                
1589:                    This function properly updates curHTTP.byteCount by decrementing it
1590:                    by the number of bytes read.
1591:                
1592:                  Precondition:
1593:                    None
1594:                
1595:                  Parameters:
1596:                    cDelim - the character at which to stop reading, or NULL to read to
1597:                             the end of the buffer
1598:                    cData - where to store the data being read
1599:                    wLen - how many bytes can be written to cData
1600:                
1601:                  Return Values:
1602:                    HTTP_READ_OK - data was successfully read
1603:                    HTTP_READ_TRUNCTATED - entire data could not fit in the buffer, so the
1604:                                            data was truncated and data has been lost
1605:                    HTTP_READ_INCOMPLETE - delimiter character was not found
1606:                  ***************************************************************************/
1607:                #if defined(HTTP_USE_POST)
1608:                static HTTP_READ_STATUS HTTPReadTo(uint8_t cDelim, uint8_t* cData, uint16_t wLen)
1609:                {
9D00AAE4  27BDFFD0   ADDIU SP, SP, -48
9D00AAE8  AFBF002C   SW RA, 44(SP)
9D00AAEC  AFBE0028   SW S8, 40(SP)
9D00AAF0  AFB00024   SW S0, 36(SP)
9D00AAF4  03A0F021   ADDU S8, SP, ZERO
9D00AAF8  00801821   ADDU V1, A0, ZERO
9D00AAFC  AFC50034   SW A1, 52(S8)
9D00AB00  00C01021   ADDU V0, A2, ZERO
9D00AB04  A3C30030   SB V1, 48(S8)
9D00AB08  A7C20038   SH V0, 56(S8)
1610:                    HTTP_READ_STATUS status;
1611:                    uint16_t wPos;
1612:                
1613:                    // Either look for delimiter, or read all available data
1614:                    if(cDelim)
9D00AB0C  93C20030   LBU V0, 48(S8)
9D00AB10  10400014   BEQ V0, ZERO, 0x9D00AB64
9D00AB14  00000000   NOP
1615:                        wPos = TCPFind(sktHTTP, cDelim, 0, false);
9D00AB18  93828159   LBU V0, -32423(GP)
9D00AB1C  00401821   ADDU V1, V0, ZERO
9D00AB20  3C02A000   LUI V0, -24576
9D00AB24  000318C0   SLL V1, V1, 3
9D00AB28  244208C8   ADDIU V0, V0, 2248
9D00AB2C  00621021   ADDU V0, V1, V0
9D00AB30  90420004   LBU V0, 4(V0)
9D00AB34  00401821   ADDU V1, V0, ZERO
9D00AB38  93C20030   LBU V0, 48(S8)
9D00AB3C  AFA00010   SW ZERO, 16(SP)
9D00AB40  00602021   ADDU A0, V1, ZERO
9D00AB44  00402821   ADDU A1, V0, ZERO
9D00AB48  00003021   ADDU A2, ZERO, ZERO
9D00AB4C  00003821   ADDU A3, ZERO, ZERO
9D00AB50  0F400AF0   JAL TCPFindEx
9D00AB54  00000000   NOP
9D00AB58  A7C2001C   SH V0, 28(S8)
9D00AB5C  0B402AE4   J 0x9D00AB90
9D00AB60  00000000   NOP
1616:                    else
1617:                        wPos = TCPIsGetReady(sktHTTP);
9D00AB64  93828159   LBU V0, -32423(GP)
9D00AB68  00401821   ADDU V1, V0, ZERO
9D00AB6C  3C02A000   LUI V0, -24576
9D00AB70  000318C0   SLL V1, V1, 3
9D00AB74  244208C8   ADDIU V0, V0, 2248
9D00AB78  00621021   ADDU V0, V1, V0
9D00AB7C  90420004   LBU V0, 4(V0)
9D00AB80  00402021   ADDU A0, V0, ZERO
9D00AB84  0F40066C   JAL TCPIsGetReady
9D00AB88  00000000   NOP
9D00AB8C  A7C2001C   SH V0, 28(S8)
1618:                
1619:                    // If not found, return incomplete
1620:                    if(wPos == 0xffff)
9D00AB90  97C3001C   LHU V1, 28(S8)
9D00AB94  3402FFFF   ORI V0, ZERO, -1
9D00AB98  14620004   BNE V1, V0, 0x9D00ABAC
9D00AB9C  00000000   NOP
1621:                        return HTTP_READ_INCOMPLETE;
9D00ABA0  24020002   ADDIU V0, ZERO, 2
9D00ABA4  0B402B8A   J 0x9D00AE28
9D00ABA8  00000000   NOP
1622:                
1623:                    // Read the value
1624:                    if(wLen < 2u && cData != NULL)
9D00ABAC  97C20038   LHU V0, 56(S8)
9D00ABB0  2C420002   SLTIU V0, V0, 2
9D00ABB4  1040001B   BEQ V0, ZERO, 0x9D00AC24
9D00ABB8  00000000   NOP
9D00ABBC  8FC20034   LW V0, 52(S8)
9D00ABC0  10400018   BEQ V0, ZERO, 0x9D00AC24
9D00ABC4  00000000   NOP
1625:                    {// Buffer is too small, so read to NULL instead
1626:                        curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos);
9D00ABC8  3C02A000   LUI V0, -24576
9D00ABCC  8C5004A0   LW S0, 1184(V0)
9D00ABD0  93828159   LBU V0, -32423(GP)
9D00ABD4  00401821   ADDU V1, V0, ZERO
9D00ABD8  3C02A000   LUI V0, -24576
9D00ABDC  000318C0   SLL V1, V1, 3
9D00ABE0  244208C8   ADDIU V0, V0, 2248
9D00ABE4  00621021   ADDU V0, V1, V0
9D00ABE8  90420004   LBU V0, 4(V0)
9D00ABEC  00401821   ADDU V1, V0, ZERO
9D00ABF0  97C2001C   LHU V0, 28(S8)
9D00ABF4  00602021   ADDU A0, V1, ZERO
9D00ABF8  00002821   ADDU A1, ZERO, ZERO
9D00ABFC  00403021   ADDU A2, V0, ZERO
9D00AC00  0F40077A   JAL TCPGetArray
9D00AC04  00000000   NOP
9D00AC08  02021823   SUBU V1, S0, V0
9D00AC0C  3C02A000   LUI V0, -24576
9D00AC10  AC4304A0   SW V1, 1184(V0)
1627:                        status = HTTP_READ_TRUNCATED;
9D00AC14  24020001   ADDIU V0, ZERO, 1
9D00AC18  AFC20018   SW V0, 24(S8)
9D00AC1C  0B402B76   J 0x9D00ADD8
9D00AC20  00000000   NOP
1628:                    }
1629:                    else if(cData == NULL)
9D00AC24  8FC20034   LW V0, 52(S8)
9D00AC28  14400017   BNE V0, ZERO, 0x9D00AC88
9D00AC2C  00000000   NOP
1630:                    {// Just remove the data
1631:                        curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos);
9D00AC30  3C02A000   LUI V0, -24576
9D00AC34  8C5004A0   LW S0, 1184(V0)
9D00AC38  93828159   LBU V0, -32423(GP)
9D00AC3C  00401821   ADDU V1, V0, ZERO
9D00AC40  3C02A000   LUI V0, -24576
9D00AC44  000318C0   SLL V1, V1, 3
9D00AC48  244208C8   ADDIU V0, V0, 2248
9D00AC4C  00621021   ADDU V0, V1, V0
9D00AC50  90420004   LBU V0, 4(V0)
9D00AC54  00401821   ADDU V1, V0, ZERO
9D00AC58  97C2001C   LHU V0, 28(S8)
9D00AC5C  00602021   ADDU A0, V1, ZERO
9D00AC60  00002821   ADDU A1, ZERO, ZERO
9D00AC64  00403021   ADDU A2, V0, ZERO
9D00AC68  0F40077A   JAL TCPGetArray
9D00AC6C  00000000   NOP
9D00AC70  02021823   SUBU V1, S0, V0
9D00AC74  3C02A000   LUI V0, -24576
9D00AC78  AC4304A0   SW V1, 1184(V0)
1632:                        status = HTTP_READ_OK;
9D00AC7C  AFC00018   SW ZERO, 24(S8)
9D00AC80  0B402B76   J 0x9D00ADD8
9D00AC84  00000000   NOP
1633:                    }
1634:                    else if(wPos > wLen - 2)
9D00AC88  97C3001C   LHU V1, 28(S8)
9D00AC8C  97C20038   LHU V0, 56(S8)
9D00AC90  2442FFFE   ADDIU V0, V0, -2
9D00AC94  0043102A   SLT V0, V0, V1
9D00AC98  10400037   BEQ V0, ZERO, 0x9D00AD78
9D00AC9C  00000000   NOP
1635:                    {// Read data, but truncate at max length
1636:                        curHTTP.byteCount -= TCPGetArray(sktHTTP, cData, wLen - 2);
9D00ACA0  3C02A000   LUI V0, -24576
9D00ACA4  8C5004A0   LW S0, 1184(V0)
9D00ACA8  93828159   LBU V0, -32423(GP)
9D00ACAC  00401821   ADDU V1, V0, ZERO
9D00ACB0  3C02A000   LUI V0, -24576
9D00ACB4  000318C0   SLL V1, V1, 3
9D00ACB8  244208C8   ADDIU V0, V0, 2248
9D00ACBC  00621021   ADDU V0, V1, V0
9D00ACC0  90420004   LBU V0, 4(V0)
9D00ACC4  00401821   ADDU V1, V0, ZERO
9D00ACC8  97C20038   LHU V0, 56(S8)
9D00ACCC  2442FFFE   ADDIU V0, V0, -2
9D00ACD0  3042FFFF   ANDI V0, V0, -1
9D00ACD4  00602021   ADDU A0, V1, ZERO
9D00ACD8  8FC50034   LW A1, 52(S8)
9D00ACDC  00403021   ADDU A2, V0, ZERO
9D00ACE0  0F40077A   JAL TCPGetArray
9D00ACE4  00000000   NOP
9D00ACE8  02021823   SUBU V1, S0, V0
9D00ACEC  3C02A000   LUI V0, -24576
9D00ACF0  AC4304A0   SW V1, 1184(V0)
1637:                        curHTTP.byteCount -= TCPGetArray(sktHTTP, NULL, wPos - (wLen - 2));
9D00ACF4  3C02A000   LUI V0, -24576
9D00ACF8  8C5004A0   LW S0, 1184(V0)
9D00ACFC  93828159   LBU V0, -32423(GP)
9D00AD00  00401821   ADDU V1, V0, ZERO
9D00AD04  3C02A000   LUI V0, -24576
9D00AD08  000318C0   SLL V1, V1, 3
9D00AD0C  244208C8   ADDIU V0, V0, 2248
9D00AD10  00621021   ADDU V0, V1, V0
9D00AD14  90420004   LBU V0, 4(V0)
9D00AD18  00401821   ADDU V1, V0, ZERO
9D00AD1C  97C4001C   LHU A0, 28(S8)
9D00AD20  97C20038   LHU V0, 56(S8)
9D00AD24  00821023   SUBU V0, A0, V0
9D00AD28  3042FFFF   ANDI V0, V0, -1
9D00AD2C  24420002   ADDIU V0, V0, 2
9D00AD30  3042FFFF   ANDI V0, V0, -1
9D00AD34  00602021   ADDU A0, V1, ZERO
9D00AD38  00002821   ADDU A1, ZERO, ZERO
9D00AD3C  00403021   ADDU A2, V0, ZERO
9D00AD40  0F40077A   JAL TCPGetArray
9D00AD44  00000000   NOP
9D00AD48  02021823   SUBU V1, S0, V0
9D00AD4C  3C02A000   LUI V0, -24576
9D00AD50  AC4304A0   SW V1, 1184(V0)
1638:                        cData[wLen - 2] = '\0';
9D00AD54  97C20038   LHU V0, 56(S8)
9D00AD58  2442FFFE   ADDIU V0, V0, -2
9D00AD5C  8FC30034   LW V1, 52(S8)
9D00AD60  00621021   ADDU V0, V1, V0
9D00AD64  A0400000   SB ZERO, 0(V0)
1639:                        status = HTTP_READ_TRUNCATED;
9D00AD68  24020001   ADDIU V0, ZERO, 1
9D00AD6C  AFC20018   SW V0, 24(S8)
9D00AD70  0B402B76   J 0x9D00ADD8
9D00AD74  00000000   NOP
1640:                    }
1641:                    else
1642:                    {// Read the data normally
1643:                        curHTTP.byteCount -= TCPGetArray(sktHTTP, cData, wPos);
9D00AD78  3C02A000   LUI V0, -24576
9D00AD7C  8C5004A0   LW S0, 1184(V0)
9D00AD80  93828159   LBU V0, -32423(GP)
9D00AD84  00401821   ADDU V1, V0, ZERO
9D00AD88  3C02A000   LUI V0, -24576
9D00AD8C  000318C0   SLL V1, V1, 3
9D00AD90  244208C8   ADDIU V0, V0, 2248
9D00AD94  00621021   ADDU V0, V1, V0
9D00AD98  90420004   LBU V0, 4(V0)
9D00AD9C  00401821   ADDU V1, V0, ZERO
9D00ADA0  97C2001C   LHU V0, 28(S8)
9D00ADA4  00602021   ADDU A0, V1, ZERO
9D00ADA8  8FC50034   LW A1, 52(S8)
9D00ADAC  00403021   ADDU A2, V0, ZERO
9D00ADB0  0F40077A   JAL TCPGetArray
9D00ADB4  00000000   NOP
9D00ADB8  02021823   SUBU V1, S0, V0
9D00ADBC  3C02A000   LUI V0, -24576
9D00ADC0  AC4304A0   SW V1, 1184(V0)
1644:                        cData[wPos] = '\0';
9D00ADC4  97C2001C   LHU V0, 28(S8)
9D00ADC8  8FC30034   LW V1, 52(S8)
9D00ADCC  00621021   ADDU V0, V1, V0
9D00ADD0  A0400000   SB ZERO, 0(V0)
1645:                        status = HTTP_READ_OK;
9D00ADD4  AFC00018   SW ZERO, 24(S8)
1646:                    }
1647:                
1648:                    // Remove the delimiter
1649:                    if(cDelim)
9D00ADD8  93C20030   LBU V0, 48(S8)
9D00ADDC  10400011   BEQ V0, ZERO, 0x9D00AE24
9D00ADE0  00000000   NOP
1650:                        curHTTP.byteCount -= TCPGet(sktHTTP, NULL);
9D00ADE4  3C02A000   LUI V0, -24576
9D00ADE8  8C5004A0   LW S0, 1184(V0)
9D00ADEC  93828159   LBU V0, -32423(GP)
9D00ADF0  00401821   ADDU V1, V0, ZERO
9D00ADF4  3C02A000   LUI V0, -24576
9D00ADF8  000318C0   SLL V1, V1, 3
9D00ADFC  244208C8   ADDIU V0, V0, 2248
9D00AE00  00621021   ADDU V0, V1, V0
9D00AE04  90420004   LBU V0, 4(V0)
9D00AE08  00402021   ADDU A0, V0, ZERO
9D00AE0C  00002821   ADDU A1, ZERO, ZERO
9D00AE10  0F4006D4   JAL TCPGet
9D00AE14  00000000   NOP
9D00AE18  02021823   SUBU V1, S0, V0
9D00AE1C  3C02A000   LUI V0, -24576
9D00AE20  AC4304A0   SW V1, 1184(V0)
1651:                
1652:                    return status;
9D00AE24  8FC20018   LW V0, 24(S8)
1653:                }
9D00AE28  03C0E821   ADDU SP, S8, ZERO
9D00AE2C  8FBF002C   LW RA, 44(SP)
9D00AE30  8FBE0028   LW S8, 40(SP)
9D00AE34  8FB00024   LW S0, 36(SP)
9D00AE38  27BD0030   ADDIU SP, SP, 48
9D00AE3C  03E00008   JR RA
9D00AE40  00000000   NOP
1654:                #endif
1655:                
1656:                /*****************************************************************************
1657:                  Function:
1658:                    HTTP_IO_RESULT HTTPMPFSUpload(void)
1659:                
1660:                  Summary:
1661:                    Saves a file uploaded via POST as the new MPFS image in EEPROM or
1662:                    external Flash.
1663:                
1664:                  Description:
1665:                    Allows the MPFS image in EEPROM or external Flash to be updated via a
1666:                    web page by accepting a file upload and storing it to the external memory.
1667:                
1668:                  Precondition:
1669:                    MPFSFormat() has been called.
1670:                
1671:                  Parameters:
1672:                    None
1673:                
1674:                  Return Values:
1675:                    HTTP_IO_DONE - on success
1676:                    HTTP_IO_NEED_DATA - if more data is still expected
1677:                
1678:                  Remarks:
1679:                    This function is only available when MPFS uploads are enabled and
1680:                    the MPFS image is stored in EEPROM.
1681:                
1682:                  Internal:
1683:                    After the headers, the first line from the form will be the MIME
1684:                    separator.  Following that is more headers about the file, which
1685:                    are discarded.  After another CRLFCRLF pair the file data begins,
1686:                    which is read 16 bytes at a time and written to external memory.
1687:                  ***************************************************************************/
1688:                #if defined(HTTP_MPFS_UPLOAD)
1689:                static HTTP_IO_RESULT HTTPMPFSUpload(void)
1690:                {
1691:                    uint8_t c[16];
1692:                    uint16_t lenA, lenB;
1693:                
1694:                    switch(curHTTP.httpStatus)
1695:                    {
1696:                        // New upload, so look for the CRLFCRLF
1697:                        case HTTP_MPFS_UP:
1698:                
1699:                            lenA = TCPFindROMArray(sktHTTP, (ROM uint8_t*)"\r\n\r\n", 4, 0, false);
1700:                
1701:                            if(lenA != 0xffff)
1702:                            {// Found it, so remove all data up to and including
1703:                                lenA = TCPGetArray(sktHTTP, NULL, lenA);
1704:                                curHTTP.byteCount -= lenA;
1705:                
1706:                                // Make sure first 6 bytes are also in
1707:                                if(TCPIsGetReady(sktHTTP) < (4u + 6u) )
1708:                                {
1709:                                    lenA++;
1710:                                    return HTTP_IO_NEED_DATA;
1711:                                }
1712:                
1713:                                // Make sure it's an MPFS of the correct version
1714:                                lenA = TCPGetArray(sktHTTP, c, 10);
1715:                                curHTTP.byteCount -= lenA;
1716:                                if(memcmppgm2ram(c, (ROM void*)"\r\n\r\nMPFS\x02\x01", 10) == 0)
1717:                                {// Read as Ver 2.1
1718:                                    curHTTP.httpStatus = HTTP_MPFS_OK;
1719:                
1720:                                    // Format MPFS storage and put 6 byte tag
1721:                                    curHTTP.file = MPFSFormat();
1722:                                    MPFSPutArray(curHTTP.file, &c[4], 6);
1723:                                }
1724:                                else
1725:                                {// Version is wrong
1726:                                    curHTTP.httpStatus = HTTP_MPFS_ERROR;
1727:                                }
1728:                
1729:                                return HTTP_IO_WAITING;
1730:                            }
1731:                            else
1732:                            {// Otherwise, remove as much as possible
1733:                                lenA = TCPGetArray(sktHTTP, NULL, TCPIsGetReady(sktHTTP) - 4);
1734:                                curHTTP.byteCount -= lenA;
1735:                            }
1736:                
1737:                            break;
1738:                
1739:                        // Received file is invalid
1740:                        case HTTP_MPFS_ERROR:
1741:                            curHTTP.byteCount -= TCPIsGetReady(sktHTTP);
1742:                            TCPDiscard(sktHTTP);
1743:                            if(curHTTP.byteCount < 100u || curHTTP.byteCount > 0x80000000u)
1744:                            {// If almost all data was read, or if we overflowed, then return
1745:                                smHTTP = SM_HTTP_SERVE_HEADERS;
1746:                                return HTTP_IO_DONE;
1747:                            }
1748:                            break;
1749:                
1750:                        // File is verified, so write the data
1751:                        case HTTP_MPFS_OK:
1752:                            // Determine how much to read
1753:                            lenA = TCPIsGetReady(sktHTTP);
1754:                            if(lenA > curHTTP.byteCount)
1755:                                lenA = curHTTP.byteCount;
1756:                
1757:                            while(lenA > 0u)
1758:                            {
1759:                                lenB = TCPGetArray(sktHTTP, c, mMIN(lenA,16u));
1760:                                curHTTP.byteCount -= lenB;
1761:                                lenA -= lenB;
1762:                                MPFSPutArray(curHTTP.file, c, lenB);
1763:                            }
1764:                
1765:                            // If we've read all the data
1766:                            if(curHTTP.byteCount == 0u)
1767:                            {
1768:                                MPFSPutEnd(true);
1769:                                smHTTP = SM_HTTP_SERVE_HEADERS;
1770:                                return HTTP_IO_DONE;
1771:                            }
1772:                
1773:                        // Other states are not valid here
1774:                        default:
1775:                            break;
1776:                    }
1777:                
1778:                    // Ask for more data
1779:                    return HTTP_IO_NEED_DATA;
1780:                
1781:                }
1782:                #endif
1783:                
1784:                /*****************************************************************************
1785:                  Function:
1786:                    void HTTPIncFile(ROM uint8_t* cFile)
1787:                
1788:                  Summary:
1789:                    Writes a file byte-for-byte to the currently loaded TCP socket.
1790:                
1791:                  Description:
1792:                    Allows an entire file to be included as a dynamic variable, providing
1793:                    a basic templating system for HTML web pages.  This reduces unneeded
1794:                    duplication of visual elements such as headers, menus, etc.
1795:                
1796:                    When curHTTP.callbackPos is 0, the file is opened and as many bytes
1797:                    as possible are written.  The current position is then saved to
1798:                    curHTTP.callbackPos and the file is closed.  On subsequent calls,
1799:                    reading begins at the saved location and continues.  Once the end of
1800:                    the input file is reached, curHTTP.callbackPos is set back to 0 to
1801:                    indicate completion.
1802:                
1803:                  Precondition:
1804:                    None
1805:                
1806:                  Parameters:
1807:                    cFile - the name of the file to be sent
1808:                
1809:                  Returns:
1810:                    None
1811:                
1812:                  Remarks:
1813:                    Users should not call this function directly, but should instead add
1814:                    dynamic variables in the form of ~inc:filename.ext~ in their HTML code
1815:                    to include (for example) the file "filename.ext" at that specified
1816:                    location.  The MPFS2 Generator utility will handle the rest.
1817:                  ***************************************************************************/
1818:                void HTTPIncFile(ROM uint8_t* cFile)
1819:                {
9D00AE44  27BDFF98   ADDIU SP, SP, -104
9D00AE48  AFBF0064   SW RA, 100(SP)
9D00AE4C  AFBE0060   SW S8, 96(SP)
9D00AE50  AFB0005C   SW S0, 92(SP)
9D00AE54  03A0F021   ADDU S8, SP, ZERO
9D00AE58  AFC40068   SW A0, 104(S8)
1820:                    uint16_t wCount, wLen;
1821:                    uint8_t data[64];
1822:                    MPFS_HANDLE fp;
1823:                
1824:                    // Check if this is a first round call
1825:                    if(curHTTP.callbackPos == 0x00u)
9D00AE5C  3C02A000   LUI V0, -24576
9D00AE60  244204A0   ADDIU V0, V0, 1184
9D00AE64  8C42000C   LW V0, 12(V0)
9D00AE68  14400012   BNE V0, ZERO, 0x9D00AEB4
9D00AE6C  00000000   NOP
1826:                    {// On initial call, open the file and save its ID
1827:                        fp = MPFSOpenROM(cFile);
9D00AE70  8FC40068   LW A0, 104(S8)
9D00AE74  0F4032C4   JAL MPFSOpen
9D00AE78  00000000   NOP
9D00AE7C  A3C20012   SB V0, 18(S8)
1828:                        if(fp == MPFS_INVALID_HANDLE)
9D00AE80  93C30012   LBU V1, 18(S8)
9D00AE84  240200FF   ADDIU V0, ZERO, 255
9D00AE88  10620069   BEQ V1, V0, 0x9D00B030
9D00AE8C  00000000   NOP
1829:                        {// File not found, so abort
1830:                            return;
9D00B030  00000000   NOP
9D00B034  0B402C10   J 0x9D00B040
9D00B038  00000000   NOP
1831:                        }
1832:                        ((TCPIP_UINT32_VAL*)&curHTTP.callbackPos)->w[0] = MPFSGetID(fp);
9D00AE90  3C02A000   LUI V0, -24576
9D00AE94  245004AC   ADDIU S0, V0, 1196
9D00AE98  93C20012   LBU V0, 18(S8)
9D00AE9C  00402021   ADDU A0, V0, ZERO
9D00AEA0  0F403817   JAL MPFSGetID
9D00AEA4  00000000   NOP
9D00AEA8  A6020000   SH V0, 0(S0)
9D00AEAC  0B402BC1   J 0x9D00AF04
9D00AEB0  00000000   NOP
1833:                    }
1834:                    else
1835:                    {// The file was already opened, so load up its ID and seek
1836:                        fp = MPFSOpenID(((TCPIP_UINT32_VAL*)&curHTTP.callbackPos)->w[0]);
9D00AEB4  3C02A000   LUI V0, -24576
9D00AEB8  244204AC   ADDIU V0, V0, 1196
9D00AEBC  94420000   LHU V0, 0(V0)
9D00AEC0  00402021   ADDU A0, V0, ZERO
9D00AEC4  0F40338A   JAL MPFSOpenID
9D00AEC8  00000000   NOP
9D00AECC  A3C20012   SB V0, 18(S8)
1837:                        if(fp == MPFS_INVALID_HANDLE)
9D00AED0  93C30012   LBU V1, 18(S8)
9D00AED4  240200FF   ADDIU V0, ZERO, 255
9D00AED8  10620058   BEQ V1, V0, 0x9D00B03C
9D00AEDC  00000000   NOP
1838:                        {// No file handles available, so wait for now
1839:                            return;
9D00B03C  00000000   NOP
1840:                        }
1841:                        MPFSSeek(fp, ((TCPIP_UINT32_VAL*)&curHTTP.callbackPos)->w[1], MPFS_SEEK_FORWARD);
9D00AEE0  93C30012   LBU V1, 18(S8)
9D00AEE4  3C02A000   LUI V0, -24576
9D00AEE8  244204AC   ADDIU V0, V0, 1196
9D00AEEC  94420002   LHU V0, 2(V0)
9D00AEF0  00602021   ADDU A0, V1, ZERO
9D00AEF4  00402821   ADDU A1, V0, ZERO
9D00AEF8  24060002   ADDIU A2, ZERO, 2
9D00AEFC  0F403542   JAL MPFSSeek
9D00AF00  00000000   NOP
1842:                    }
1843:                
1844:                    // Get/put as many bytes as possible
1845:                    wCount = TCPIsPutReady(sktHTTP);
9D00AF04  93828159   LBU V0, -32423(GP)
9D00AF08  00401821   ADDU V1, V0, ZERO
9D00AF0C  3C02A000   LUI V0, -24576
9D00AF10  000318C0   SLL V1, V1, 3
9D00AF14  244208C8   ADDIU V0, V0, 2248
9D00AF18  00621021   ADDU V0, V1, V0
9D00AF1C  90420004   LBU V0, 4(V0)
9D00AF20  00402021   ADDU A0, V0, ZERO
9D00AF24  0F400373   JAL TCPIsPutReady
9D00AF28  00000000   NOP
9D00AF2C  A7C20010   SH V0, 16(S8)
1846:                    while(wCount > 0u)
9D00AF30  0B402BFA   J 0x9D00AFE8
9D00AF34  00000000   NOP
9D00AFE8  97C20010   LHU V0, 16(S8)
9D00AFEC  1440FFD2   BNE V0, ZERO, 0x9D00AF38
9D00AFF0  00000000   NOP
1847:                    {
1848:                        wLen = MPFSGetArray(fp, data, mMIN(wCount, sizeof(data)));
9D00AF38  93C40012   LBU A0, 18(S8)
9D00AF3C  97C20010   LHU V0, 16(S8)
9D00AF40  3043FFFF   ANDI V1, V0, -1
9D00AF44  2C630041   SLTIU V1, V1, 65
9D00AF48  14600002   BNE V1, ZERO, 0x9D00AF54
9D00AF4C  00000000   NOP
9D00AF50  24020040   ADDIU V0, ZERO, 64
9D00AF54  3042FFFF   ANDI V0, V0, -1
9D00AF58  27C30018   ADDIU V1, S8, 24
9D00AF5C  00602821   ADDU A1, V1, ZERO
9D00AF60  00403021   ADDU A2, V0, ZERO
9D00AF64  0F403488   JAL MPFSGetArray
9D00AF68  00000000   NOP
9D00AF6C  A7C20014   SH V0, 20(S8)
1849:                        if(wLen == 0u)
9D00AF70  97C20014   LHU V0, 20(S8)
9D00AF74  1440000A   BNE V0, ZERO, 0x9D00AFA0
9D00AF78  00000000   NOP
1850:                        {// If no bytes were read, an EOF was reached
1851:                            MPFSClose(fp);
9D00AF7C  93C20012   LBU V0, 18(S8)
9D00AF80  00402021   ADDU A0, V0, ZERO
9D00AF84  0F4033E5   JAL MPFSClose
9D00AF88  00000000   NOP
1852:                            curHTTP.callbackPos = 0x00;
9D00AF8C  3C02A000   LUI V0, -24576
9D00AF90  244204A0   ADDIU V0, V0, 1184
9D00AF94  AC40000C   SW ZERO, 12(V0)
1853:                            return;
9D00AF98  0B402C10   J 0x9D00B040
9D00AF9C  00000000   NOP
1854:                        }
1855:                        else
1856:                        {// Write the bytes to the socket
1857:                            TCPPutArray(sktHTTP, data, wLen);
9D00AFA0  93828159   LBU V0, -32423(GP)
9D00AFA4  00401821   ADDU V1, V0, ZERO
9D00AFA8  3C02A000   LUI V0, -24576
9D00AFAC  000318C0   SLL V1, V1, 3
9D00AFB0  244208C8   ADDIU V0, V0, 2248
9D00AFB4  00621021   ADDU V0, V1, V0
9D00AFB8  90420004   LBU V0, 4(V0)
9D00AFBC  00402021   ADDU A0, V0, ZERO
9D00AFC0  97C20014   LHU V0, 20(S8)
9D00AFC4  27C30018   ADDIU V1, S8, 24
9D00AFC8  00602821   ADDU A1, V1, ZERO
9D00AFCC  00403021   ADDU A2, V0, ZERO
9D00AFD0  0F4004D0   JAL TCPPutArray
9D00AFD4  00000000   NOP
1858:                            wCount -= wLen;
9D00AFD8  97C30010   LHU V1, 16(S8)
9D00AFDC  97C20014   LHU V0, 20(S8)
9D00AFE0  00621023   SUBU V0, V1, V0
9D00AFE4  A7C20010   SH V0, 16(S8)
1859:                        }
1860:                    }
1861:                
1862:                    // Save the new address and close the file
1863:                    ((TCPIP_UINT32_VAL*)&curHTTP.callbackPos)->w[1] = MPFSTell(fp);
9D00AFF4  3C02A000   LUI V0, -24576
9D00AFF8  245004AC   ADDIU S0, V0, 1196
9D00AFFC  93C20012   LBU V0, 18(S8)
9D00B000  00402021   ADDU A0, V0, ZERO
9D00B004  0F4037FC   JAL MPFSGetPosition
9D00B008  00000000   NOP
9D00B00C  3042FFFF   ANDI V0, V0, -1
9D00B010  A6020002   SH V0, 2(S0)
1864:                    MPFSClose(fp);
9D00B014  93C20012   LBU V0, 18(S8)
9D00B018  00402021   ADDU A0, V0, ZERO
9D00B01C  0F4033E5   JAL MPFSClose
9D00B020  00000000   NOP
1865:                
1866:                    return;
9D00B024  00000000   NOP
9D00B028  0B402C10   J 0x9D00B040
9D00B02C  00000000   NOP
1867:                }
9D00B040  03C0E821   ADDU SP, S8, ZERO
9D00B044  8FBF0064   LW RA, 100(SP)
9D00B048  8FBE0060   LW S8, 96(SP)
9D00B04C  8FB0005C   LW S0, 92(SP)
9D00B050  27BD0068   ADDIU SP, SP, 104
9D00B054  03E00008   JR RA
9D00B058  00000000   NOP
1868:                
1869:                
1870:                #endif
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/helpers.c  ------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       helpers.c
7:                   
8:                     Summary:
9:                       
10:                  
11:                    Description:
12:                      Helper Functions for Microchip TCPIP Stack
13:                  
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
18:                  
19:                  Microchip licenses to you the right to use, modify, copy and distribute
20:                  Software only when embedded on a Microchip microcontroller or digital signal
21:                  controller that is integrated into your product or third party product
22:                  (pursuant to the sublicense terms in the accompanying license agreement).
23:                  
24:                  You should refer to the license agreement accompanying this Software for
25:                  additional information regarding your rights and obligations.
26:                  
27:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
28:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
29:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
30:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
31:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
32:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
33:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
34:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
35:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
36:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
37:                   *******************************************************************************/
38:                  //DOM-IGNORE-END
39:                  
40:                  #define __HELPERS_C_
41:                  
42:                  #include <stdarg.h>
43:                  
44:                  #include "tcpip/tcpip.h"
45:                  
46:                  // Default Random Number Generator seed. 0x41FE9F9E corresponds to calling LFSRSeedRand(1)
47:                  static uint32_t dwLFSRRandSeed = 0x41FE9F9E;
48:                  
49:                  /*****************************************************************************
50:                    Function:
51:                      uint32_t LFSRSeedRand(uint32_t dwSeed)
52:                  
53:                    Summary:
54:                      Seeds the LFSR random number generator invoked by the LFSRRand() function.
55:                      The prior seed is returned.
56:                  
57:                    Description:
58:                      Seeds the LFSR random number generator invoked by the LFSRRand() function.
59:                      The prior seed is returned.
60:                  
61:                    Precondition:
62:                      None
63:                  
64:                    Parameters:
65:                      wSeed - The new 32-bit seed value to assign to the LFSR.
66:                  
67:                    Returns:
68:                      The last seed in use.  This can be saved and restored by a subsequent call
69:                      to LFSRSeedRand() if you wish to use LFSRRand() in multiple contexts
70:                      without disrupting the random number sequence from the alternative
71:                      context.  For example, if App 1 needs a given sequence of random numbers
72:                      to perform a test, if you save and restore the seed in App 2, it is
73:                      possible for App 2 to not disrupt the random number sequence provided to
74:                      App 1, even if the number of times App 2 calls LFSRRand() varies.
75:                  
76:                    Side Effects:
77:                      None
78:                  
79:                    Remarks:
80:                      Upon initial power up, the internal seed is initialized to 0x1.  Using a
81:                      dwSeed value of 0x0 will return the same sequence of random numbers as
82:                      using the seed of 0x1.
83:                    ***************************************************************************/
84:                  uint32_t LFSRSeedRand(uint32_t dwSeed)
85:                  {
9D00F22C  27BDFFE0   ADDIU SP, SP, -32
9D00F230  AFBF001C   SW RA, 28(SP)
9D00F234  AFBE0018   SW S8, 24(SP)
9D00F238  03A0F021   ADDU S8, SP, ZERO
9D00F23C  AFC40020   SW A0, 32(S8)
86:                      uint32_t dwOldSeed;
87:                      uint8_t i;
88:                  
89:                      // Save original seed to be returned later
90:                      dwOldSeed = dwLFSRRandSeed;
9D00F240  8F828010   LW V0, -32752(GP)
9D00F244  AFC20014   SW V0, 20(S8)
91:                  
92:                      // Ensure zero isn't selected as a seed value, this would result in all
93:                      // 0x0000 output values from the LFSR
94:                      if(dwSeed == 0u)
9D00F248  8FC20020   LW V0, 32(S8)
9D00F24C  14400003   BNE V0, ZERO, 0x9D00F25C
9D00F250  00000000   NOP
95:                          dwSeed = 1;
9D00F254  24020001   ADDIU V0, ZERO, 1
9D00F258  AFC20020   SW V0, 32(S8)
96:                  
97:                      // Set the new seed
98:                      dwLFSRRandSeed = dwSeed;
9D00F25C  8FC20020   LW V0, 32(S8)
9D00F260  AF828010   SW V0, -32752(GP)
99:                  
100:                     // Run the LFSR a few times to get rid of obvious start up artifacts for
101:                     // seed values that don't have many set bits.
102:                     for(i = 0; i < 16; i++)
9D00F264  A3C00010   SB ZERO, 16(S8)
9D00F268  0B403CA1   J 0x9D00F284
9D00F26C  00000000   NOP
9D00F278  93C20010   LBU V0, 16(S8)
9D00F27C  24420001   ADDIU V0, V0, 1
9D00F280  A3C20010   SB V0, 16(S8)
9D00F284  93C20010   LBU V0, 16(S8)
9D00F288  2C420010   SLTIU V0, V0, 16
9D00F28C  1440FFF8   BNE V0, ZERO, 0x9D00F270
9D00F290  00000000   NOP
103:                         LFSRRand();
9D00F270  0F403CAC   JAL LFSRRand
9D00F274  00000000   NOP
104:                 
105:                     // Return saved old seed
106:                     return dwOldSeed;
9D00F294  8FC20014   LW V0, 20(S8)
107:                 }
9D00F298  03C0E821   ADDU SP, S8, ZERO
9D00F29C  8FBF001C   LW RA, 28(SP)
9D00F2A0  8FBE0018   LW S8, 24(SP)
9D00F2A4  27BD0020   ADDIU SP, SP, 32
9D00F2A8  03E00008   JR RA
9D00F2AC  00000000   NOP
108:                 
109:                 /*****************************************************************************
110:                   Function:
111:                     uint16_t LFSRRand(void)
112:                 
113:                   Summary:
114:                     Returns a pseudo-random 16-bit unsigned integer in the range from 0
115:                     to 65535 (0x0000 to 0xFFFF).
116:                 
117:                   Description:
118:                     Returns a pseudo-random 16-bit unsigned integer in the range from 0
119:                     to 65535 (0x0000 to 0xFFFF).  The random number is generated using a
120:                     Linear Feedback Shift Register (LFSR) type pseudo-random number generator
121:                     algorithm.  The LFSR can be seeded by calling the LFSRSeedRand() function
122:                     to generate the same sequence of random numbers as a prior string of calls.
123:                 
124:                     The internal LFSR will repeat after 2^32-1 iterations.
125:                 
126:                   Precondition:
127:                     None
128:                 
129:                   Parameters:
130:                     None
131:                 
132:                   Returns:
133:                     Random 16-bit unsigned integer.
134:                 
135:                   Side Effects:
136:                     The internal LFSR seed is updated so that the next call to LFSRRand()
137:                     will return a different random number.
138:                 
139:                   Remarks:
140:                     None
141:                   ***************************************************************************/
142:                 uint16_t LFSRRand(void)
143:                 {
9D00F2B0  27BDFFF0   ADDIU SP, SP, -16
9D00F2B4  AFBE000C   SW S8, 12(SP)
9D00F2B8  03A0F021   ADDU S8, SP, ZERO
144:                     uint8_t i;
145:                 
146:                     // Taps: 32 31 29 1
147:                     // Characteristic polynomial: x^32 + x^31 + x^29 + x + 1
148:                     // Repeat 15 times to make the shift pattern less obvious
149:                     for(i = 0; i < 15; i++)
9D00F2BC  A3C00000   SB ZERO, 0(S8)
9D00F2C0  0B403CBF   J 0x9D00F2FC
9D00F2C4  00000000   NOP
9D00F2F0  93C20000   LBU V0, 0(S8)
9D00F2F4  24420001   ADDIU V0, V0, 1
9D00F2F8  A3C20000   SB V0, 0(S8)
9D00F2FC  93C20000   LBU V0, 0(S8)
9D00F300  2C42000F   SLTIU V0, V0, 15
9D00F304  1440FFF0   BNE V0, ZERO, 0x9D00F2C8
9D00F308  00000000   NOP
150:                         dwLFSRRandSeed = (dwLFSRRandSeed >> 1) ^ ((0ul - (dwLFSRRandSeed & 1ul)) & 0xD0000001ul);
9D00F2C8  8F828010   LW V0, -32752(GP)
9D00F2CC  00021842   SRL V1, V0, 1
9D00F2D0  8F828010   LW V0, -32752(GP)
9D00F2D4  30420001   ANDI V0, V0, 1
9D00F2D8  00022023   SUBU A0, ZERO, V0
9D00F2DC  3C02D000   LUI V0, -12288
9D00F2E0  34420001   ORI V0, V0, 1
9D00F2E4  00821024   AND V0, A0, V0
9D00F2E8  00621026   XOR V0, V1, V0
9D00F2EC  AF828010   SW V0, -32752(GP)
151:                 
152:                     // Return 16-bits as pseudo-random number
153:                     return (uint16_t)dwLFSRRandSeed;
9D00F30C  8F828010   LW V0, -32752(GP)
9D00F310  3042FFFF   ANDI V0, V0, -1
154:                 }
9D00F314  03C0E821   ADDU SP, S8, ZERO
9D00F318  8FBE000C   LW S8, 12(SP)
9D00F31C  27BD0010   ADDIU SP, SP, 16
9D00F320  03E00008   JR RA
9D00F324  00000000   NOP
155:                 
156:                 
157:                 /*****************************************************************************
158:                   Function:
159:                     uint32_t GenerateRandomDWORD(void)
160:                 
161:                   Summary:
162:                     Generates a random uint32_t.
163:                 
164:                   Description:
165:                     This function generates a random 32-bit integer.  It collects
166:                     randomness by comparing the A/D converter's internal R/C oscillator
167:                     clock with our main system clock.  By passing collected entropy to the
168:                     LFSRSeedRand()/LFSRRand() functions, the output is normalized (deskewed)
169:                     in the hopes of meeting statistical randomness tests.
170:                 
171:                   Precondition:
172:                     None
173:                 
174:                   Parameters:
175:                     None
176:                 
177:                   Returns:
178:                     Random 32-bit number.
179:                 
180:                   Side Effects:
181:                     This function uses the A/D converter (and so you must disable
182:                     interrupts if you use the A/D converted in your ISR).  The LFSRRand()
183:                     function will be reseeded, and Timer0 (PIC18) and Timer1 (PIC24,
184:                     dsPIC, and PIC32) will be used.  TMR#H:TMR#L will have a new value.
185:                     Note that this is the same timer used by the Tick module.
186:                 
187:                   Remarks:
188:                     This function times out after 1 second of attempting to generate the
189:                     random uint32_t.  In such a case, the output may not be truly random.
190:                     Typically, this function executes in around 500,000 instruction cycles.
191:                 
192:                     The intent of this function is to produce statistically random and
193:                     cryptographically secure random number.  Whether or not this is true on
194:                     all (or any) devices/voltages/temperatures is not tested.
195:                   ***************************************************************************/
196:                 uint32_t GenerateRandomDWORD(void)
197:                 {
9D00F328  27BDFFC0   ADDIU SP, SP, -64
9D00F32C  AFBF003C   SW RA, 60(SP)
9D00F330  AFBE0038   SW S8, 56(SP)
9D00F334  AFB00034   SW S0, 52(SP)
9D00F338  03A0F021   ADDU S8, SP, ZERO
198:                     uint8_t vBitCount;
199:                     uint16_t w, wTime, wLastValue;
200:                     uint32_t dwTotalTime;
201:                     union
202:                     {
203:                         uint32_t    dw;
204:                         uint16_t    w[2];
205:                     } randomResult;
206:                 
207:                 #if defined __XC8
208:                 {
209:                     uint8_t ADCON0Save, ADCON2Save;
210:                     uint8_t T0CONSave, TMR0HSave, TMR0LSave;
211:                 
212:                     // Save hardware SFRs
213:                     ADCON0Save = ADCON0;
214:                     ADCON2Save = ADCON2;
215:                     T0CONSave = T0CON;
216:                     TMR0LSave = TMR0L;
217:                     TMR0HSave = TMR0H;
218:                 
219:                     // Set up Timer and A/D converter module
220:                     ADCON0 = 0x01;  // Turn on the A/D module
221:                     ADCON2 = 0x3F;  // 20 Tad acquisition, Frc A/D clock used for conversion
222:                     T0CON = 0x88;   // TMR0ON = 1, no prescalar
223:                     vBitCount = 0;
224:                     dwTotalTime = 0;
225:                     wLastValue = 0;
226:                     randomResult.dw = LFSRRand();
227:                     while(1)
228:                     {
229:                         // Time the duration of an A/D acquisition and conversion
230:                         TMR0H = 0x00;
231:                         TMR0L = 0x00;
232:                         ADCON0bits.GO = 1;
233:                         ClrWdt();
234:                         while(ADCON0bits.GO);
235:                         ((uint8_t*)&wTime)[0] = TMR0L;
236:                         ((uint8_t*)&wTime)[1] = TMR0H;
237:                         w = LFSRRand();
238:                 
239:                         // Wait no longer than 1 second obtaining entropy
240:                         dwTotalTime += wTime;
241:                         if(dwTotalTime >= GetInstructionClock())
242:                         {
243:                             randomResult.w[0] ^= LFSRRand();
244:                             randomResult.w[1] ^= LFSRRand();
245:                             break;
246:                         }
247:                 
248:                         // Keep sampling if minimal entropy was likely obtained this round
249:                         if(wLastValue == wTime)
250:                             continue;
251:                 
252:                         // Add this entropy into the pseudo random number generator by reseeding
253:                         LFSRSeedRand(w + (wLastValue - wTime));
254:                         wLastValue = wTime;
255:                 
256:                         // Accumulate at least 32 bits of randomness over time
257:                         randomResult.dw <<= 1;
258:                         if(LFSRRand() & 0x0080)
259:                             randomResult.w[0] |= 0x1;
260:                 
261:                         // See if we've collected a fair amount of entropy and can quit early
262:                         if(++vBitCount == 0u)
263:                             break;
264:                     }
265:                 
266:                     // Restore hardware SFRs
267:                     ADCON0 = ADCON0Save;
268:                     ADCON2 = ADCON2Save;
269:                     TMR0H = TMR0HSave;
270:                     TMR0L = TMR0LSave;
271:                     T0CON = T0CONSave;
272:                 }
273:                 #else
274:                 {
275:                     uint16_t AD1CON1Save, AD1CON2Save, AD1CON3Save;
276:                     uint16_t T1CONSave, PR1Save;
277:                 
278:                     // Save hardware SFRs
279:                     AD1CON1Save = AD1CON1;
9D00F33C  3C02BF81   LUI V0, -16511
9D00F340  8C429000   LW V0, -28672(V0)
9D00F344  A7C20018   SH V0, 24(S8)
280:                     AD1CON2Save = AD1CON2;
9D00F348  3C02BF81   LUI V0, -16511
9D00F34C  8C429010   LW V0, -28656(V0)
9D00F350  A7C2001A   SH V0, 26(S8)
281:                     AD1CON3Save = AD1CON3;
9D00F354  3C02BF81   LUI V0, -16511
9D00F358  8C429020   LW V0, -28640(V0)
9D00F35C  A7C2001C   SH V0, 28(S8)
282:                     T1CONSave = T1CON;
9D00F360  3C02BF80   LUI V0, -16512
9D00F364  8C420600   LW V0, 1536(V0)
9D00F368  A7C2001E   SH V0, 30(S8)
283:                     PR1Save = PR1;
9D00F36C  3C02BF80   LUI V0, -16512
9D00F370  8C420620   LW V0, 1568(V0)
9D00F374  A7C20020   SH V0, 32(S8)
284:                 
285:                     // Set up Timer and A/D converter module
286:                     AD1CON1 = 0x0000;       // Turn off the ADC so we can write to it
9D00F378  3C02BF81   LUI V0, -16511
9D00F37C  AC409000   SW ZERO, -28672(V0)
287:                     AD1CON3 = 0x9F00;       // Frc A/D clock, 31 Tad acquisition
9D00F380  3C02BF81   LUI V0, -16511
9D00F384  34039F00   ORI V1, ZERO, -24832
9D00F388  AC439020   SW V1, -28640(V0)
288:                     AD1CON2 = 0x003F;       // Interrupt after every 16th sample/convert
9D00F38C  3C02BF81   LUI V0, -16511
9D00F390  2403003F   ADDIU V1, ZERO, 63
9D00F394  AC439010   SW V1, -28656(V0)
289:                     AD1CON1 = 0x80E4;       // Turn on the A/D module, auto-convert
9D00F398  3C02BF81   LUI V0, -16511
9D00F39C  340380E4   ORI V1, ZERO, -32540
9D00F3A0  AC439000   SW V1, -28672(V0)
290:                     T1CON = 0x8000;         // TON = 1, no prescalar
9D00F3A4  3C02BF80   LUI V0, -16512
9D00F3A8  34038000   ORI V1, ZERO, -32768
9D00F3AC  AC430600   SW V1, 1536(V0)
291:                     PR1 = 0xFFFF;           // Don't clear timer early
9D00F3B0  3C02BF80   LUI V0, -16512
9D00F3B4  3403FFFF   ORI V1, ZERO, -1
9D00F3B8  AC430620   SW V1, 1568(V0)
292:                     vBitCount = 0;
9D00F3BC  A3C00010   SB ZERO, 16(S8)
293:                     dwTotalTime = 0;
9D00F3C0  AFC00014   SW ZERO, 20(S8)
294:                     wLastValue = 0;
9D00F3C4  A7C00012   SH ZERO, 18(S8)
295:                     randomResult.dw = LFSRRand();
9D00F3C8  0F403CAC   JAL LFSRRand
9D00F3CC  00000000   NOP
9D00F3D0  AFC20028   SW V0, 40(S8)
9D00F3D4  0B403CF8   J 0x9D00F3E0
9D00F3D8  00000000   NOP
296:                     while(1)
297:                     {
298:                         ClrWdt();
9D00F3E0  3C02BF80   LUI V0, -16512
9D00F3E4  24030001   ADDIU V1, ZERO, 1
9D00F3E8  AC430008   SW V1, 8(V0)
299:                         #if defined(__XC16)
300:                             while(!IFS0bits.AD1IF);
301:                         #else
302:                             while(!IFS1bits.AD1IF);
9D00F3EC  00000000   NOP
9D00F3F0  3C02BF88   LUI V0, -16504
9D00F3F4  8C421040   LW V0, 4160(V0)
9D00F3F8  30420002   ANDI V0, V0, 2
9D00F3FC  1040FFFC   BEQ V0, ZERO, 0x9D00F3F0
9D00F400  00000000   NOP
303:                         #endif
304:                         wTime = TMR1;
9D00F404  3C02BF80   LUI V0, -16512
9D00F408  8C420610   LW V0, 1552(V0)
9D00F40C  A7C20022   SH V0, 34(S8)
305:                         TMR1 = 0x0000;
9D00F410  3C02BF80   LUI V0, -16512
9D00F414  AC400610   SW ZERO, 1552(V0)
306:                 
307:                         #if defined(__XC16)
308:                             IFS0bits.AD1IF = 0;
309:                         #else
310:                             IFS1CLR = _IFS1_AD1IF_MASK;
9D00F418  3C02BF88   LUI V0, -16504
9D00F41C  24030002   ADDIU V1, ZERO, 2
9D00F420  AC431044   SW V1, 4164(V0)
311:                         #endif
312:                         w = LFSRRand();
9D00F424  0F403CAC   JAL LFSRRand
9D00F428  00000000   NOP
9D00F42C  A7C20024   SH V0, 36(S8)
313:                 
314:                         // Wait no longer than 1 second obtaining entropy
315:                         dwTotalTime += wTime;
9D00F430  97C20022   LHU V0, 34(S8)
9D00F434  8FC30014   LW V1, 20(S8)
9D00F438  00621021   ADDU V0, V1, V0
9D00F43C  AFC20014   SW V0, 20(S8)
316:                         if(dwTotalTime >= GetInstructionClock())
9D00F440  8FC30014   LW V1, 20(S8)
9D00F444  3C0204C4   LUI V0, 1220
9D00F448  3442B400   ORI V0, V0, -19456
9D00F44C  0062102B   SLTU V0, V1, V0
9D00F450  1440000F   BNE V0, ZERO, 0x9D00F490
9D00F454  00000000   NOP
317:                         {
318:                             randomResult.w[0] ^= LFSRRand();
9D00F458  97D00028   LHU S0, 40(S8)
9D00F45C  0F403CAC   JAL LFSRRand
9D00F460  00000000   NOP
9D00F464  02021026   XOR V0, S0, V0
9D00F468  3042FFFF   ANDI V0, V0, -1
9D00F46C  A7C20028   SH V0, 40(S8)
319:                             randomResult.w[1] ^= LFSRRand();
9D00F470  97D0002A   LHU S0, 42(S8)
9D00F474  0F403CAC   JAL LFSRRand
9D00F478  00000000   NOP
9D00F47C  02021026   XOR V0, S0, V0
9D00F480  3042FFFF   ANDI V0, V0, -1
9D00F484  A7C2002A   SH V0, 42(S8)
320:                             break;
9D00F488  0B403D48   J 0x9D00F520
9D00F48C  00000000   NOP
321:                         }
322:                 
323:                         // Keep sampling if minimal entropy was likely obtained this round
324:                         if(wLastValue == wTime)
9D00F490  97C30012   LHU V1, 18(S8)
9D00F494  97C20022   LHU V0, 34(S8)
9D00F498  14620004   BNE V1, V0, 0x9D00F4AC
9D00F49C  00000000   NOP
325:                             continue;
9D00F4A0  00000000   NOP
326:                 
327:                         // Add this entropy into the pseudo random number generator by reseeding
328:                         LFSRSeedRand(w + (wLastValue - wTime));
9D00F4AC  97C30024   LHU V1, 36(S8)
9D00F4B0  97C40012   LHU A0, 18(S8)
9D00F4B4  97C20022   LHU V0, 34(S8)
9D00F4B8  00821023   SUBU V0, A0, V0
9D00F4BC  00621021   ADDU V0, V1, V0
9D00F4C0  00402021   ADDU A0, V0, ZERO
9D00F4C4  0F403C8B   JAL LFSRSeedRand
9D00F4C8  00000000   NOP
329:                         wLastValue = wTime;
9D00F4CC  97C20022   LHU V0, 34(S8)
9D00F4D0  A7C20012   SH V0, 18(S8)
330:                 
331:                         // Accumulate at least 32 bits of randomness over time
332:                         randomResult.dw <<= 1;
9D00F4D4  8FC20028   LW V0, 40(S8)
9D00F4D8  00021040   SLL V0, V0, 1
9D00F4DC  AFC20028   SW V0, 40(S8)
333:                         if(LFSRRand() & 0x0080)
9D00F4E0  0F403CAC   JAL LFSRRand
9D00F4E4  00000000   NOP
9D00F4E8  30420080   ANDI V0, V0, 128
9D00F4EC  10400005   BEQ V0, ZERO, 0x9D00F504
9D00F4F0  00000000   NOP
334:                             randomResult.w[0] |= 0x1;
9D00F4F4  97C20028   LHU V0, 40(S8)
9D00F4F8  34420001   ORI V0, V0, 1
9D00F4FC  3042FFFF   ANDI V0, V0, -1
9D00F500  A7C20028   SH V0, 40(S8)
335:                 
336:                         // See if we've collected a fair amount of entropy and can quit early
337:                         if(++vBitCount == 0u)
9D00F504  93C20010   LBU V0, 16(S8)
9D00F508  24420001   ADDIU V0, V0, 1
9D00F50C  A3C20010   SB V0, 16(S8)
9D00F510  93C20010   LBU V0, 16(S8)
9D00F514  1440FFB1   BNE V0, ZERO, 0x9D00F3DC
9D00F518  00000000   NOP
338:                             break;
9D00F51C  00000000   NOP
339:                     }
9D00F3DC  00000000   NOP
9D00F4A4  0B403CF8   J 0x9D00F3E0
9D00F4A8  00000000   NOP
340:                 
341:                 
342:                     // Restore hardware SFRs
343:                     AD1CON1 = 0x0000;       // Turn off the ADC so we can write to it
9D00F520  3C02BF81   LUI V0, -16511
9D00F524  AC409000   SW ZERO, -28672(V0)
344:                     AD1CON3 = AD1CON3Save;
9D00F528  97C3001C   LHU V1, 28(S8)
9D00F52C  3C02BF81   LUI V0, -16511
9D00F530  AC439020   SW V1, -28640(V0)
345:                     AD1CON2 = AD1CON2Save;
9D00F534  97C3001A   LHU V1, 26(S8)
9D00F538  3C02BF81   LUI V0, -16511
9D00F53C  AC439010   SW V1, -28656(V0)
346:                     AD1CON1 = AD1CON1Save;
9D00F540  97C30018   LHU V1, 24(S8)
9D00F544  3C02BF81   LUI V0, -16511
9D00F548  AC439000   SW V1, -28672(V0)
347:                     T1CON = T1CONSave;
9D00F54C  97C3001E   LHU V1, 30(S8)
9D00F550  3C02BF80   LUI V0, -16512
9D00F554  AC430600   SW V1, 1536(V0)
348:                     PR1 = PR1Save;
9D00F558  97C30020   LHU V1, 32(S8)
9D00F55C  3C02BF80   LUI V0, -16512
9D00F560  AC430620   SW V1, 1568(V0)
349:                 }
350:                 #endif
351:                 
352:                     return randomResult.dw;
9D00F564  8FC20028   LW V0, 40(S8)
353:                 }
9D00F568  03C0E821   ADDU SP, S8, ZERO
9D00F56C  8FBF003C   LW RA, 60(SP)
9D00F570  8FBE0038   LW S8, 56(SP)
9D00F574  8FB00034   LW S0, 52(SP)
9D00F578  27BD0040   ADDIU SP, SP, 64
9D00F57C  03E00008   JR RA
9D00F580  00000000   NOP
354:                 
355:                 
356:                 #if defined(STACK_USE_HTTP_SERVER)
357:                 /*****************************************************************************
358:                   Function:
359:                     void UnencodeURL(uint8_t* URL)
360:                 
361:                   Summary:
362:                     Decodes a URL-encoded string.
363:                 
364:                   Description:
365:                     This function is deprecated except for use with HTTP Classic.  It
366:                     attempts to decode a URL encoded string, converting all hex escape
367:                     sequences into a literal byte.  However, it is inefficient over long
368:                     strings and does not handle URL-encoded data strings ('&' and '=').
369:                 
370:                   Precondition:
371:                     None
372:                 
373:                   Parameters:
374:                     URL - the null-terminated string to decode
375:                 
376:                   Returns:
377:                     None
378:                   ***************************************************************************/
379:                 void UnencodeURL(uint8_t* URL)
380:                 {
381:                     uint8_t *Right, *Copy;
382:                     TCPIP_UINT16_VAL Number;
383:                 
384:                     while((Right = (uint8_t*)strchr((char*)URL, '%')))
385:                     {
386:                         // Make sure the string is long enough
387:                         if(Right[1] == '\0')
388:                             break;
389:                         if(Right[2] == '\0')
390:                             break;
391:                 
392:                         // Update the string in place
393:                         Number.v[0] = Right[2];
394:                         Number.v[1] = Right[1];
395:                         *Right++ = hexatob(Number);
396:                         URL = Right;
397:                 
398:                         // Remove two blank spots by shifting all remaining characters right two
399:                         Copy = Right + 2;
400:                         while((*Right++ = *Copy++));
401:                     }
402:                 }
403:                 #endif
404:                 
405:                 
406:                 /*****************************************************************************
407:                   Function:
408:                     bool StringToIPAddress(uint8_t* str, IP_ADDR* IPAddress)
409:                 
410:                   Summary:
411:                     Converts a string to an IP address
412:                 
413:                   Description:
414:                     This function parses a dotted-quad decimal IP address string into an
415:                     IP_ADDR struct.  The output result is big-endian.
416:                 
417:                   Precondition:
418:                     None
419:                 
420:                   Parameters:
421:                     str - Pointer to a dotted-quad IP address string
422:                     IPAddress - Pointer to IP_ADDR in which to store the result
423:                 
424:                   Return Values:
425:                     true - an IP address was successfully decoded
426:                     false - no IP address could be found, or the format was incorrect
427:                   ***************************************************************************/
428:                 bool StringToIPAddress(uint8_t* str, IP_ADDR* IPAddress)
429:                 {
9D00F584  27BDFFF0   ADDIU SP, SP, -16
9D00F588  AFBE000C   SW S8, 12(SP)
9D00F58C  03A0F021   ADDU S8, SP, ZERO
9D00F590  AFC40010   SW A0, 16(S8)
9D00F594  AFC50014   SW A1, 20(S8)
430:                     TCPIP_UINT32_VAL dwVal;
431:                     uint8_t i, charLen, currentOctet;
432:                 
433:                     charLen = 0;
9D00F598  A3C00000   SB ZERO, 0(S8)
434:                     currentOctet = 0;
9D00F59C  A3C00001   SB ZERO, 1(S8)
435:                     dwVal.Val = 0;
9D00F5A0  AFC00004   SW ZERO, 4(S8)
436:                     while((i = *str++))
9D00F5A4  0B403DEA   J 0x9D00F7A8
9D00F5A8  00000000   NOP
9D00F7A8  8FC20010   LW V0, 16(S8)
9D00F7AC  90420000   LBU V0, 0(V0)
9D00F7B0  A3C20002   SB V0, 2(S8)
9D00F7B4  93C20002   LBU V0, 2(S8)
9D00F7B8  0002102B   SLTU V0, ZERO, V0
9D00F7BC  304200FF   ANDI V0, V0, 255
9D00F7C0  8FC30010   LW V1, 16(S8)
9D00F7C4  24630001   ADDIU V1, V1, 1
9D00F7C8  AFC30010   SW V1, 16(S8)
9D00F7CC  1440FF77   BNE V0, ZERO, 0x9D00F5AC
9D00F7D0  00000000   NOP
9D00F7D4  0B403DF8   J 0x9D00F7E0
9D00F7D8  00000000   NOP
437:                     {
438:                         if(currentOctet > 3u)
9D00F5AC  93C20001   LBU V0, 1(S8)
9D00F5B0  2C420004   SLTIU V0, V0, 4
9D00F5B4  10400089   BEQ V0, ZERO, 0x9D00F7DC
9D00F5B8  00000000   NOP
439:                             break;
9D00F7DC  00000000   NOP
440:                 
441:                         i -= '0';
9D00F5BC  93C20002   LBU V0, 2(S8)
9D00F5C0  2442FFD0   ADDIU V0, V0, -48
9D00F5C4  A3C20002   SB V0, 2(S8)
442:                 
443:                 
444:                         // Validate the character is a numerical digit or dot, depending on location
445:                         if(charLen == 0u)
9D00F5C8  93C20000   LBU V0, 0(S8)
9D00F5CC  14400008   BNE V0, ZERO, 0x9D00F5F0
9D00F5D0  00000000   NOP
446:                         {
447:                             if(i > 9u)
9D00F5D4  93C20002   LBU V0, 2(S8)
9D00F5D8  2C42000A   SLTIU V0, V0, 10
9D00F5DC  1440006A   BNE V0, ZERO, 0x9D00F788
9D00F5E0  00000000   NOP
448:                                 return false;
9D00F5E4  00001021   ADDU V0, ZERO, ZERO
9D00F5E8  0B403E36   J 0x9D00F8D8
9D00F5EC  00000000   NOP
449:                         }
450:                         else if(charLen == 3u)
9D00F5F0  93C30000   LBU V1, 0(S8)
9D00F5F4  24020003   ADDIU V0, ZERO, 3
9D00F5F8  14620030   BNE V1, V0, 0x9D00F6BC
9D00F5FC  00000000   NOP
451:                         {
452:                             if(i != (uint8_t)('.' - '0'))
9D00F600  93C30002   LBU V1, 2(S8)
9D00F604  240200FE   ADDIU V0, ZERO, 254
9D00F608  10620004   BEQ V1, V0, 0x9D00F61C
9D00F60C  00000000   NOP
453:                                 return false;
9D00F610  00001021   ADDU V0, ZERO, ZERO
9D00F614  0B403E36   J 0x9D00F8D8
9D00F618  00000000   NOP
454:                 
455:                             if(dwVal.Val > 0x00020505ul)
9D00F61C  8FC30004   LW V1, 4(S8)
9D00F620  3C020002   LUI V0, 2
9D00F624  34420506   ORI V0, V0, 1286
9D00F628  0062102B   SLTU V0, V1, V0
9D00F62C  14400004   BNE V0, ZERO, 0x9D00F640
9D00F630  00000000   NOP
456:                                 return false;
9D00F634  00001021   ADDU V0, ZERO, ZERO
9D00F638  0B403E36   J 0x9D00F8D8
9D00F63C  00000000   NOP
457:                 
458:                             IPAddress->v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
9D00F640  93C40001   LBU A0, 1(S8)
9D00F644  93C20006   LBU V0, 6(S8)
9D00F648  00021080   SLL V0, V0, 2
9D00F64C  00021880   SLL V1, V0, 2
9D00F650  00431021   ADDU V0, V0, V1
9D00F654  00401821   ADDU V1, V0, ZERO
9D00F658  00032880   SLL A1, V1, 2
9D00F65C  00401821   ADDU V1, V0, ZERO
9D00F660  00A01021   ADDU V0, A1, ZERO
9D00F664  00621021   ADDU V0, V1, V0
9D00F668  304300FF   ANDI V1, V0, 255
9D00F66C  93C20005   LBU V0, 5(S8)
9D00F670  00021040   SLL V0, V0, 1
9D00F674  00022880   SLL A1, V0, 2
9D00F678  00451021   ADDU V0, V0, A1
9D00F67C  304200FF   ANDI V0, V0, 255
9D00F680  00621021   ADDU V0, V1, V0
9D00F684  304300FF   ANDI V1, V0, 255
9D00F688  93C20004   LBU V0, 4(S8)
9D00F68C  00621021   ADDU V0, V1, V0
9D00F690  304300FF   ANDI V1, V0, 255
9D00F694  8FC20014   LW V0, 20(S8)
9D00F698  00441021   ADDU V0, V0, A0
9D00F69C  A0430000   SB V1, 0(V0)
9D00F6A0  93C20001   LBU V0, 1(S8)
9D00F6A4  24420001   ADDIU V0, V0, 1
9D00F6A8  A3C20001   SB V0, 1(S8)
459:                             charLen = 0;
9D00F6AC  A3C00000   SB ZERO, 0(S8)
460:                             dwVal.Val = 0;
9D00F6B0  AFC00004   SW ZERO, 4(S8)
461:                             continue;
9D00F6B4  0B403DEA   J 0x9D00F7A8
9D00F6B8  00000000   NOP
462:                         }
463:                         else
464:                         {
465:                             if(i == (uint8_t)('.' - '0'))
9D00F6BC  93C30002   LBU V1, 2(S8)
9D00F6C0  240200FE   ADDIU V0, ZERO, 254
9D00F6C4  14620029   BNE V1, V0, 0x9D00F76C
9D00F6C8  00000000   NOP
466:                             {
467:                                 if(dwVal.Val > 0x00020505ul)
9D00F6CC  8FC30004   LW V1, 4(S8)
9D00F6D0  3C020002   LUI V0, 2
9D00F6D4  34420506   ORI V0, V0, 1286
9D00F6D8  0062102B   SLTU V0, V1, V0
9D00F6DC  14400004   BNE V0, ZERO, 0x9D00F6F0
9D00F6E0  00000000   NOP
468:                                     return false;
9D00F6E4  00001021   ADDU V0, ZERO, ZERO
9D00F6E8  0B403E36   J 0x9D00F8D8
9D00F6EC  00000000   NOP
469:                 
470:                                 IPAddress->v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
9D00F6F0  93C40001   LBU A0, 1(S8)
9D00F6F4  93C20006   LBU V0, 6(S8)
9D00F6F8  00021080   SLL V0, V0, 2
9D00F6FC  00021880   SLL V1, V0, 2
9D00F700  00431021   ADDU V0, V0, V1
9D00F704  00401821   ADDU V1, V0, ZERO
9D00F708  00032880   SLL A1, V1, 2
9D00F70C  00401821   ADDU V1, V0, ZERO
9D00F710  00A01021   ADDU V0, A1, ZERO
9D00F714  00621021   ADDU V0, V1, V0
9D00F718  304300FF   ANDI V1, V0, 255
9D00F71C  93C20005   LBU V0, 5(S8)
9D00F720  00021040   SLL V0, V0, 1
9D00F724  00022880   SLL A1, V0, 2
9D00F728  00451021   ADDU V0, V0, A1
9D00F72C  304200FF   ANDI V0, V0, 255
9D00F730  00621021   ADDU V0, V1, V0
9D00F734  304300FF   ANDI V1, V0, 255
9D00F738  93C20004   LBU V0, 4(S8)
9D00F73C  00621021   ADDU V0, V1, V0
9D00F740  304300FF   ANDI V1, V0, 255
9D00F744  8FC20014   LW V0, 20(S8)
9D00F748  00441021   ADDU V0, V0, A0
9D00F74C  A0430000   SB V1, 0(V0)
9D00F750  93C20001   LBU V0, 1(S8)
9D00F754  24420001   ADDIU V0, V0, 1
9D00F758  A3C20001   SB V0, 1(S8)
471:                                 charLen = 0;
9D00F75C  A3C00000   SB ZERO, 0(S8)
472:                                 dwVal.Val = 0;
9D00F760  AFC00004   SW ZERO, 4(S8)
473:                                 continue;
9D00F764  0B403DEA   J 0x9D00F7A8
9D00F768  00000000   NOP
474:                             }
475:                             if(i > 9u)
9D00F76C  93C20002   LBU V0, 2(S8)
9D00F770  2C42000A   SLTIU V0, V0, 10
9D00F774  14400004   BNE V0, ZERO, 0x9D00F788
9D00F778  00000000   NOP
476:                                 return false;
9D00F77C  00001021   ADDU V0, ZERO, ZERO
9D00F780  0B403E36   J 0x9D00F8D8
9D00F784  00000000   NOP
477:                         }
478:                 
479:                         charLen++;
9D00F788  93C20000   LBU V0, 0(S8)
9D00F78C  24420001   ADDIU V0, V0, 1
9D00F790  A3C20000   SB V0, 0(S8)
480:                         dwVal.Val <<= 8;
9D00F794  8FC20004   LW V0, 4(S8)
9D00F798  00021200   SLL V0, V0, 8
9D00F79C  AFC20004   SW V0, 4(S8)
481:                         dwVal.v[0] = i;
9D00F7A0  93C20002   LBU V0, 2(S8)
9D00F7A4  A3C20004   SB V0, 4(S8)
482:                     }
483:                 
484:                     // Make sure the very last character is a valid termination character
485:                     // (i.e., not more hostname, which could be legal and not an IP
486:                     // address as in "10.5.13.233.picsaregood.com"
487:                     if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t' && i != ':')
9D00F7E0  93C20002   LBU V0, 2(S8)
9D00F7E4  1040001C   BEQ V0, ZERO, 0x9D00F858
9D00F7E8  00000000   NOP
9D00F7EC  93C30002   LBU V1, 2(S8)
9D00F7F0  2402002F   ADDIU V0, ZERO, 47
9D00F7F4  10620018   BEQ V1, V0, 0x9D00F858
9D00F7F8  00000000   NOP
9D00F7FC  93C30002   LBU V1, 2(S8)
9D00F800  2402000D   ADDIU V0, ZERO, 13
9D00F804  10620014   BEQ V1, V0, 0x9D00F858
9D00F808  00000000   NOP
9D00F80C  93C30002   LBU V1, 2(S8)
9D00F810  2402000A   ADDIU V0, ZERO, 10
9D00F814  10620010   BEQ V1, V0, 0x9D00F858
9D00F818  00000000   NOP
9D00F81C  93C30002   LBU V1, 2(S8)
9D00F820  24020020   ADDIU V0, ZERO, 32
9D00F824  1062000C   BEQ V1, V0, 0x9D00F858
9D00F828  00000000   NOP
9D00F82C  93C30002   LBU V1, 2(S8)
9D00F830  24020009   ADDIU V0, ZERO, 9
9D00F834  10620008   BEQ V1, V0, 0x9D00F858
9D00F838  00000000   NOP
9D00F83C  93C30002   LBU V1, 2(S8)
9D00F840  2402003A   ADDIU V0, ZERO, 58
9D00F844  10620004   BEQ V1, V0, 0x9D00F858
9D00F848  00000000   NOP
488:                         return false;
9D00F84C  00001021   ADDU V0, ZERO, ZERO
9D00F850  0B403E36   J 0x9D00F8D8
9D00F854  00000000   NOP
489:                 
490:                     // Verify and convert the last octet and return the result
491:                     if(dwVal.Val > 0x00020505ul)
9D00F858  8FC30004   LW V1, 4(S8)
9D00F85C  3C020002   LUI V0, 2
9D00F860  34420506   ORI V0, V0, 1286
9D00F864  0062102B   SLTU V0, V1, V0
9D00F868  14400004   BNE V0, ZERO, 0x9D00F87C
9D00F86C  00000000   NOP
492:                         return false;
9D00F870  00001021   ADDU V0, ZERO, ZERO
9D00F874  0B403E36   J 0x9D00F8D8
9D00F878  00000000   NOP
493:                 
494:                     IPAddress->v[3] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
9D00F87C  93C20006   LBU V0, 6(S8)
9D00F880  00021080   SLL V0, V0, 2
9D00F884  00021880   SLL V1, V0, 2
9D00F888  00431021   ADDU V0, V0, V1
9D00F88C  00401821   ADDU V1, V0, ZERO
9D00F890  00032080   SLL A0, V1, 2
9D00F894  00401821   ADDU V1, V0, ZERO
9D00F898  00801021   ADDU V0, A0, ZERO
9D00F89C  00621021   ADDU V0, V1, V0
9D00F8A0  304300FF   ANDI V1, V0, 255
9D00F8A4  93C20005   LBU V0, 5(S8)
9D00F8A8  00021040   SLL V0, V0, 1
9D00F8AC  00022080   SLL A0, V0, 2
9D00F8B0  00441021   ADDU V0, V0, A0
9D00F8B4  304200FF   ANDI V0, V0, 255
9D00F8B8  00621021   ADDU V0, V1, V0
9D00F8BC  304300FF   ANDI V1, V0, 255
9D00F8C0  93C20004   LBU V0, 4(S8)
9D00F8C4  00621021   ADDU V0, V1, V0
9D00F8C8  304300FF   ANDI V1, V0, 255
9D00F8CC  8FC20014   LW V0, 20(S8)
9D00F8D0  A0430003   SB V1, 3(V0)
495:                 
496:                     return true;
9D00F8D4  24020001   ADDIU V0, ZERO, 1
497:                 }
9D00F8D8  03C0E821   ADDU SP, S8, ZERO
9D00F8DC  8FBE000C   LW S8, 12(SP)
9D00F8E0  27BD0010   ADDIU SP, SP, 16
9D00F8E4  03E00008   JR RA
9D00F8E8  00000000   NOP
498:                 
499:                 /*****************************************************************************
500:                   Function:
501:                     bool ROMStringToIPAddress(ROM uint8_t* str, IP_ADDR* IPAddress)
502:                 
503:                   Summary:
504:                     Converts a string to an IP address
505:                 
506:                   Description:
507:                     This function parses a dotted-quad decimal IP address string into an
508:                     IP_ADDR struct.  The output result is big-endian.
509:                 
510:                   Precondition:
511:                     None
512:                 
513:                   Parameters:
514:                     str - Pointer to a dotted-quad IP address string
515:                     IPAddress - Pointer to IP_ADDR in which to store the result
516:                 
517:                   Return Values:
518:                     true - an IP address was successfully decoded
519:                     false - no IP address could be found, or the format was incorrect
520:                 
521:                   Remarks:
522:                     This function is aliased to StringToIPAddress on non-PIC18 platforms.
523:                   ***************************************************************************/
524:                 #if defined(__XC8)
525:                 bool ROMStringToIPAddress(ROM uint8_t* str, IP_ADDR* IPAddress)
526:                 {
527:                     TCPIP_UINT32_VAL dwVal;
528:                     uint8_t i, charLen, currentOctet;
529:                 
530:                     charLen = 0;
531:                     currentOctet = 0;
532:                     dwVal.Val = 0;
533:                     while(i = *str++)
534:                     {
535:                         if(currentOctet > 3u)
536:                             break;
537:                 
538:                         i -= '0';
539:                 
540:                 
541:                         // Validate the character is a numerical digit or dot, depending on location
542:                         if(charLen == 0u)
543:                         {
544:                             if(i > 9u)
545:                                 return false;
546:                         }
547:                         else if(charLen == 3u)
548:                         {
549:                             if(i != (uint8_t)('.' - '0'))
550:                                 return false;
551:                 
552:                             if(dwVal.Val > 0x00020505ul)
553:                                 return false;
554:                 
555:                             IPAddress->v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
556:                             charLen = 0;
557:                             dwVal.Val = 0;
558:                             continue;
559:                         }
560:                         else
561:                         {
562:                             if(i == (uint8_t)('.' - '0'))
563:                             {
564:                                 if(dwVal.Val > 0x00020505ul)
565:                                     return false;
566:                 
567:                                 IPAddress->v[currentOctet++] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
568:                                 charLen = 0;
569:                                 dwVal.Val = 0;
570:                                 continue;
571:                             }
572:                             if(i > 9u)
573:                                 return false;
574:                         }
575:                 
576:                         charLen++;
577:                         dwVal.Val <<= 8;
578:                         dwVal.v[0] = i;
579:                     }
580:                 
581:                     // Make sure the very last character is a valid termination character
582:                     // (i.e., not more hostname, which could be legal and not an IP
583:                     // address as in "10.5.13.233.picsaregood.com"
584:                     if(i != 0u && i != '/' && i != '\r' && i != '\n' && i != ' ' && i != '\t')
585:                         return false;
586:                 
587:                     // Verify and convert the last octet and return the result
588:                     if(dwVal.Val > 0x00020505ul)
589:                         return false;
590:                 
591:                     IPAddress->v[3] = dwVal.v[2]*((uint8_t)100) + dwVal.v[1]*((uint8_t)10) + dwVal.v[0];
592:                 
593:                     return true;
594:                 }
595:                 #endif
596:                 
597:                 
598:                 
599:                 /*****************************************************************************
600:                   Function:
601:                     uint16_t Base64Decode(uint8_t* cSourceData, uint16_t wSourceLen,
602:                                         uint8_t* cDestData, uint16_t wDestLen)
603:                 
604:                   Description:
605:                     Decodes a Base-64 array to its literal representation.
606:                 
607:                   Precondition:
608:                     None
609:                 
610:                   Parameters:
611:                     cSourceData - Pointer to a string of Base-64 encoded data
612:                     wSourceLen  - Length of the Base-64 source data
613:                     cDestData   - Pointer to write the decoded data
614:                     wSourceLen  - Maximum length that can be written to cDestData
615:                 
616:                   Returns:
617:                     Number of decoded bytes written to cDestData.
618:                 
619:                   Remarks:
620:                     This function is binary safe and will ignore invalid characters (CR, LF,
621:                     etc).  If cSourceData is equal to cDestData, the data will be converted
622:                     in-place.  If cSourceData is not equal to cDestData, but the regions
623:                     overlap, the behavior is undefined.
624:                 
625:                     Decoded data is always at least 1/4 smaller than the source data.
626:                   ***************************************************************************/
627:                 #if defined(STACK_USE_BASE64_DECODE)
628:                 uint16_t Base64Decode(uint8_t* cSourceData, uint16_t wSourceLen, uint8_t* cDestData, uint16_t wDestLen)
629:                 {
630:                     uint8_t i;
631:                     uint8_t vByteNumber;
632:                     uint16_t wBytesOutput;
633:                 
634:                     vByteNumber = 0;
635:                     wBytesOutput = 0;
636:                 
637:                     // Loop over all provided bytes
638:                     while(wSourceLen--)
639:                     {
640:                         // Fetch a Base64 byte and decode it to the original 6 bits
641:                         i = *cSourceData++;
642:                         if(i >= 'A' && i <= 'Z')    // Regular data
643:                             i -= 'A' - 0;
644:                         else if(i >= 'a' && i <= 'z')
645:                             i -= 'a' - 26;
646:                         else if(i >= '0' && i <= '9')
647:                             i -= '0' - 52;
648:                         else if(i == '+' || i == '-')
649:                             i = 62;
650:                         else if(i == '/' || i == '_')
651:                             i = 63;
652:                         else                        // Skip all padding (=) and non-Base64 characters
653:                             continue;
654:                 
655:                 
656:                         // Write the 6 bits to the correct destination location(s)
657:                         if(vByteNumber == 0u)
658:                         {
659:                             vByteNumber++;
660:                             if(wBytesOutput >= wDestLen)
661:                                 break;
662:                             wBytesOutput++;
663:                             *cDestData = i << 2;
664:                         }
665:                         else if(vByteNumber == 1u)
666:                         {
667:                             vByteNumber++;
668:                             *cDestData++ |= i >> 4;
669:                             if(wBytesOutput >= wDestLen)
670:                                 break;
671:                             wBytesOutput++;
672:                             *cDestData = i << 4;
673:                         }
674:                         else if(vByteNumber == 2u)
675:                         {
676:                             vByteNumber++;
677:                             *cDestData++ |= i >> 2;
678:                             if(wBytesOutput >= wDestLen)
679:                                 break;
680:                             wBytesOutput++;
681:                             *cDestData = i << 6;
682:                         }
683:                         else
684:                         {
685:                             vByteNumber = 0;
686:                             *cDestData++ |= i;
687:                         }
688:                     }
689:                 
690:                     return wBytesOutput;
691:                 }
692:                 #endif  // #if defined(STACK_USE_BASE64_DECODE)
693:                 
694:                 
695:                 /*****************************************************************************
696:                   Function:
697:                     uint16_t Base64Encode(uint8_t* cSourceData, uint16_t wSourceLen,
698:                                         uint8_t* cDestData, uint16_t wDestLen)
699:                 
700:                   Description:
701:                     Encodes a binary array to Base-64.
702:                 
703:                   Precondition:
704:                     None
705:                 
706:                   Parameters:
707:                     cSourceData - Pointer to a string of binary data
708:                     wSourceLen  - Length of the binary source data
709:                     cDestData   - Pointer to write the Base-64 encoded data
710:                     wSourceLen  - Maximum length that can be written to cDestData
711:                 
712:                   Returns:
713:                     Number of encoded bytes written to cDestData.  This will always be
714:                     a multiple of 4.
715:                 
716:                   Remarks:
717:                     Encoding cannot be performed in-place.  If cSourceData overlaps with
718:                     cDestData, the behavior is undefined.
719:                 
720:                     Encoded data is always at least 1/3 larger than the source data.  It may
721:                     be 1 or 2 bytes larger than that.
722:                   ***************************************************************************/
723:                 #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP_CLIENT) || defined(STACK_USE_DYNAMICDNS_CLIENT)
724:                 uint16_t Base64Encode(uint8_t* cSourceData, uint16_t wSourceLen, uint8_t* cDestData, uint16_t wDestLen)
725:                 {
726:                     uint8_t i, j;
727:                     uint8_t vOutput[4];
728:                     uint16_t wOutputLen;
729:                 
730:                     wOutputLen = 0;
731:                     while(wDestLen >= 4u)
732:                     {
733:                         // Start out treating the output as all padding
734:                         vOutput[0] = 0xFF;
735:                         vOutput[1] = 0xFF;
736:                         vOutput[2] = 0xFF;
737:                         vOutput[3] = 0xFF;
738:                 
739:                         // Get 3 input octets and split them into 4 output hextets (6-bits each)
740:                         if(wSourceLen == 0u)
741:                             break;
742:                         i = *cSourceData++;
743:                         wSourceLen--;
744:                         vOutput[0] = (i & 0xFC)>>2;
745:                         vOutput[1] = (i & 0x03)<<4;
746:                         if(wSourceLen)
747:                         {
748:                             i = *cSourceData++;
749:                             wSourceLen--;
750:                             vOutput[1] |= (i & 0xF0)>>4;
751:                             vOutput[2] = (i & 0x0F)<<2;
752:                             if(wSourceLen)
753:                             {
754:                                 i = *cSourceData++;
755:                                 wSourceLen--;
756:                                 vOutput[2] |= (i & 0xC0)>>6;
757:                                 vOutput[3] = i & 0x3F;
758:                             }
759:                         }
760:                 
761:                         // Convert hextets into Base 64 alphabet and store result
762:                         for(i = 0; i < 4u; i++)
763:                         {
764:                             j = vOutput[i];
765:                 
766:                             if(j <= 25u)
767:                                 j += 'A' - 0;
768:                             else if(j <= 51u)
769:                                 j += 'a' - 26;
770:                             else if(j <= 61u)
771:                                 j += '0' - 52;
772:                             else if(j == 62u)
773:                                 j = '+';
774:                             else if(j == 63u)
775:                                 j = '/';
776:                             else                // Padding
777:                                 j = '=';
778:                 
779:                             *cDestData++ = j;
780:                         }
781:                 
782:                         // Update counters
783:                         wDestLen -= 4;
784:                         wOutputLen += 4;
785:                     }
786:                 
787:                     return wOutputLen;
788:                 }
789:                 #endif // #if defined(STACK_USE_BASE64_ENCODE) || defined(STACK_USE_SMTP) || defined(STACK_USE_DYNAMICDNS_CLIENT)
790:                 
791:                 
792:                 /*****************************************************************************
793:                   Function:
794:                     void uitoa(uint16_t Value, uint8_t* Buffer)
795:                 
796:                   Summary:
797:                     Converts an unsigned integer to a decimal string.
798:                 
799:                   Description:
800:                     Converts a 16-bit unsigned integer to a null-terminated decimal string.
801:                 
802:                   Precondition:
803:                     None
804:                 
805:                   Parameters:
806:                     Value   - The number to be converted
807:                     Buffer  - Pointer in which to store the converted string
808:                 
809:                   Returns:
810:                     None
811:                   ***************************************************************************/
812:                 void uitoa(uint16_t Value, uint8_t* Buffer)
813:                 {
9D00F8EC  27BDFFF0   ADDIU SP, SP, -16
9D00F8F0  AFBE000C   SW S8, 12(SP)
9D00F8F4  03A0F021   ADDU S8, SP, ZERO
9D00F8F8  00801021   ADDU V0, A0, ZERO
9D00F8FC  AFC50014   SW A1, 20(S8)
9D00F900  A7C20010   SH V0, 16(S8)
814:                     uint8_t i;
815:                     uint16_t Digit;
816:                     uint16_t Divisor;
817:                     bool Printed = false;
9D00F904  A3C00004   SB ZERO, 4(S8)
818:                 
819:                     if(Value)
9D00F908  97C20010   LHU V0, 16(S8)
9D00F90C  10400035   BEQ V0, ZERO, 0x9D00F9E4
9D00F910  00000000   NOP
820:                     {
821:                         for(i = 0, Divisor = 10000; i < 5u; i++)
9D00F914  A3C00000   SB ZERO, 0(S8)
9D00F918  24022710   ADDIU V0, ZERO, 10000
9D00F91C  A7C20002   SH V0, 2(S8)
9D00F920  0B403E73   J 0x9D00F9CC
9D00F924  00000000   NOP
9D00F9C0  93C20000   LBU V0, 0(S8)
9D00F9C4  24420001   ADDIU V0, V0, 1
9D00F9C8  A3C20000   SB V0, 0(S8)
9D00F9CC  93C20000   LBU V0, 0(S8)
9D00F9D0  2C420005   SLTIU V0, V0, 5
9D00F9D4  1440FFD4   BNE V0, ZERO, 0x9D00F928
9D00F9D8  00000000   NOP
9D00F9DC  0B403E7F   J 0x9D00F9FC
9D00F9E0  00000000   NOP
822:                         {
823:                             Digit = Value/Divisor;
9D00F928  97C30010   LHU V1, 16(S8)
9D00F92C  97C20002   LHU V0, 2(S8)
9D00F930  0062001B   DIVU V1, V0
9D00F934  004001F4   TEQ V0, ZERO
9D00F938  00001810   MFHI V1, 0
9D00F93C  00001012   MFLO V0, 0
9D00F940  A7C20006   SH V0, 6(S8)
824:                             if(Digit || Printed)
9D00F944  97C20006   LHU V0, 6(S8)
9D00F948  14400004   BNE V0, ZERO, 0x9D00F95C
9D00F94C  00000000   NOP
9D00F950  93C20004   LBU V0, 4(S8)
9D00F954  10400013   BEQ V0, ZERO, 0x9D00F9A4
9D00F958  00000000   NOP
825:                             {
826:                                 *Buffer++ = '0' + Digit;
9D00F95C  97C20006   LHU V0, 6(S8)
9D00F960  304200FF   ANDI V0, V0, 255
9D00F964  24420030   ADDIU V0, V0, 48
9D00F968  304300FF   ANDI V1, V0, 255
9D00F96C  8FC20014   LW V0, 20(S8)
9D00F970  A0430000   SB V1, 0(V0)
9D00F974  8FC20014   LW V0, 20(S8)
9D00F978  24420001   ADDIU V0, V0, 1
9D00F97C  AFC20014   SW V0, 20(S8)
827:                                 Value -= Digit*Divisor;
9D00F980  97C30006   LHU V1, 6(S8)
9D00F984  97C20002   LHU V0, 2(S8)
9D00F988  70621002   MUL V0, V1, V0
9D00F98C  3042FFFF   ANDI V0, V0, -1
9D00F990  97C30010   LHU V1, 16(S8)
9D00F994  00621023   SUBU V0, V1, V0
9D00F998  A7C20010   SH V0, 16(S8)
828:                                 Printed = true;
9D00F99C  24020001   ADDIU V0, ZERO, 1
9D00F9A0  A3C20004   SB V0, 4(S8)
829:                             }
830:                             Divisor /= 10;
9D00F9A4  97C30002   LHU V1, 2(S8)
9D00F9A8  2402000A   ADDIU V0, ZERO, 10
9D00F9AC  0062001B   DIVU V1, V0
9D00F9B0  004001F4   TEQ V0, ZERO
9D00F9B4  00001810   MFHI V1, 0
9D00F9B8  00001012   MFLO V0, 0
9D00F9BC  A7C20002   SH V0, 2(S8)
831:                         }
832:                     }
833:                     else
834:                     {
835:                         *Buffer++ = '0';
9D00F9E4  8FC20014   LW V0, 20(S8)
9D00F9E8  24030030   ADDIU V1, ZERO, 48
9D00F9EC  A0430000   SB V1, 0(V0)
9D00F9F0  8FC20014   LW V0, 20(S8)
9D00F9F4  24420001   ADDIU V0, V0, 1
9D00F9F8  AFC20014   SW V0, 20(S8)
836:                     }
837:                 
838:                     *Buffer = '\0';
9D00F9FC  8FC20014   LW V0, 20(S8)
9D00FA00  A0400000   SB ZERO, 0(V0)
839:                 }
9D00FA04  03C0E821   ADDU SP, S8, ZERO
9D00FA08  8FBE000C   LW S8, 12(SP)
9D00FA0C  27BD0010   ADDIU SP, SP, 16
9D00FA10  03E00008   JR RA
9D00FA14  00000000   NOP
840:                 
841:                 /*****************************************************************************
842:                   Function:
843:                     void ultoa(uint32_t Value, uint8_t* Buffer)
844:                 
845:                   Summary:
846:                     Converts an unsigned integer to a decimal string.
847:                 
848:                   Description:
849:                     Converts a 32-bit unsigned integer to a null-terminated decimal string.
850:                 
851:                   Precondition:
852:                     None
853:                 
854:                   Parameters:
855:                     Value   - The number to be converted
856:                     Buffer  - Pointer in which to store the converted string
857:                 
858:                   Returns:
859:                     None
860:                   ***************************************************************************/
861:                 // HI-TECH PICC-18 PRO 9.63, C30 v3.25, and C32 v1.12 already have a ultoa() library function
862:                 // C18 already has a ultoa() function that more-or-less matches this one
863:                 // C32 < 1.12 and C30 < v3.25 need this function
864:                 #if (defined(__XC32) && (__C32_VERSION__ < 112)) || (defined (__XC16) && (__C30_VERSION__ < 325)) || defined(__C30_LEGACY_LIBC__) || defined(__C32_LEGACY_LIBC__)
865:                 void ultoa(uint32_t Value, uint8_t* Buffer)
866:                 {
867:                     uint8_t i;
868:                     uint32_t Digit;
869:                     uint32_t Divisor;
870:                     bool Printed = false;
871:                 
872:                     if(Value)
873:                     {
874:                         for(i = 0, Divisor = 1000000000; i < 10; i++)
875:                         {
876:                             Digit = Value/Divisor;
877:                             if(Digit || Printed)
878:                             {
879:                                 *Buffer++ = '0' + Digit;
880:                                 Value -= Digit*Divisor;
881:                                 Printed = true;
882:                             }
883:                             Divisor /= 10;
884:                         }
885:                     }
886:                     else
887:                     {
888:                         *Buffer++ = '0';
889:                     }
890:                 
891:                     *Buffer = '\0';
892:                 }
893:                 #endif
894:                 
895:                 /*****************************************************************************
896:                   Function:
897:                     uint8_t hexatob(TCPIP_UINT16_VAL AsciiChars)
898:                 
899:                   Summary:
900:                     Converts a hex string to a single byte.
901:                 
902:                   Description:
903:                     Converts a two-character ASCII hex string to a single packed byte.
904:                 
905:                   Precondition:
906:                     None
907:                 
908:                   Parameters:
909:                     AsciiChars - TCPIP_UINT16_VAL where .v[0] is the ASCII value for the lower nibble
910:                                     and .v[1] is the ASCII value for the upper nibble.  Each
911:                                     must range from '0'-'9', 'A'-'F', or 'a'-'f'.
912:                 
913:                   Returns:
914:                     Resulting packed byte 0x00 - 0xFF.
915:                   ***************************************************************************/
916:                 uint8_t hexatob(TCPIP_UINT16_VAL AsciiChars)
917:                 {
9D00FA18  27BDFFF8   ADDIU SP, SP, -8
9D00FA1C  AFBE0004   SW S8, 4(SP)
9D00FA20  03A0F021   ADDU S8, SP, ZERO
9D00FA24  A7C40008   SH A0, 8(S8)
918:                     // Convert lowercase to uppercase
919:                     if(AsciiChars.v[1] > 'F')
9D00FA28  93C20009   LBU V0, 9(S8)
9D00FA2C  2C420047   SLTIU V0, V0, 71
9D00FA30  14400005   BNE V0, ZERO, 0x9D00FA48
9D00FA34  00000000   NOP
920:                         AsciiChars.v[1] -= 'a'-'A';
9D00FA38  93C20009   LBU V0, 9(S8)
9D00FA3C  2442FFE0   ADDIU V0, V0, -32
9D00FA40  304200FF   ANDI V0, V0, 255
9D00FA44  A3C20009   SB V0, 9(S8)
921:                     if(AsciiChars.v[0] > 'F')
9D00FA48  93C20008   LBU V0, 8(S8)
9D00FA4C  2C420047   SLTIU V0, V0, 71
9D00FA50  14400005   BNE V0, ZERO, 0x9D00FA68
9D00FA54  00000000   NOP
922:                         AsciiChars.v[0] -= 'a'-'A';
9D00FA58  93C20008   LBU V0, 8(S8)
9D00FA5C  2442FFE0   ADDIU V0, V0, -32
9D00FA60  304200FF   ANDI V0, V0, 255
9D00FA64  A3C20008   SB V0, 8(S8)
923:                 
924:                     // Convert 0-9, A-F to 0x0-0xF
925:                     if(AsciiChars.v[1] > '9')
9D00FA68  93C20009   LBU V0, 9(S8)
9D00FA6C  2C42003A   SLTIU V0, V0, 58
9D00FA70  14400007   BNE V0, ZERO, 0x9D00FA90
9D00FA74  00000000   NOP
926:                         AsciiChars.v[1] -= 'A' - 10;
9D00FA78  93C20009   LBU V0, 9(S8)
9D00FA7C  2442FFC9   ADDIU V0, V0, -55
9D00FA80  304200FF   ANDI V0, V0, 255
9D00FA84  A3C20009   SB V0, 9(S8)
9D00FA88  0B403EA8   J 0x9D00FAA0
9D00FA8C  00000000   NOP
927:                     else
928:                         AsciiChars.v[1] -= '0';
9D00FA90  93C20009   LBU V0, 9(S8)
9D00FA94  2442FFD0   ADDIU V0, V0, -48
9D00FA98  304200FF   ANDI V0, V0, 255
9D00FA9C  A3C20009   SB V0, 9(S8)
929:                 
930:                     if(AsciiChars.v[0] > '9')
9D00FAA0  93C20008   LBU V0, 8(S8)
9D00FAA4  2C42003A   SLTIU V0, V0, 58
9D00FAA8  14400007   BNE V0, ZERO, 0x9D00FAC8
9D00FAAC  00000000   NOP
931:                         AsciiChars.v[0] -= 'A' - 10;
9D00FAB0  93C20008   LBU V0, 8(S8)
9D00FAB4  2442FFC9   ADDIU V0, V0, -55
9D00FAB8  304200FF   ANDI V0, V0, 255
9D00FABC  A3C20008   SB V0, 8(S8)
9D00FAC0  0B403EB6   J 0x9D00FAD8
9D00FAC4  00000000   NOP
932:                     else
933:                         AsciiChars.v[0] -= '0';
9D00FAC8  93C20008   LBU V0, 8(S8)
9D00FACC  2442FFD0   ADDIU V0, V0, -48
9D00FAD0  304200FF   ANDI V0, V0, 255
9D00FAD4  A3C20008   SB V0, 8(S8)
934:                 
935:                     // Concatenate
936:                     return (AsciiChars.v[1]<<4) |  AsciiChars.v[0];
9D00FAD8  93C20009   LBU V0, 9(S8)
9D00FADC  00021100   SLL V0, V0, 4
9D00FAE0  7C021C20   SEB V1, V0
9D00FAE4  93C20008   LBU V0, 8(S8)
9D00FAE8  7C021420   SEB V0, V0
9D00FAEC  00621025   OR V0, V1, V0
9D00FAF0  7C021420   SEB V0, V0
9D00FAF4  304200FF   ANDI V0, V0, 255
937:                 }
9D00FAF8  03C0E821   ADDU SP, S8, ZERO
9D00FAFC  8FBE0004   LW S8, 4(SP)
9D00FB00  27BD0008   ADDIU SP, SP, 8
9D00FB04  03E00008   JR RA
9D00FB08  00000000   NOP
938:                 
939:                 /*****************************************************************************
940:                   Function:
941:                     uint8_t btohexa_high(uint8_t b)
942:                 
943:                   Summary:
944:                     Converts the upper nibble of a binary value to a hexadecimal ASCII byte.
945:                 
946:                   Description:
947:                     Converts the upper nibble of a binary value to a hexadecimal ASCII byte.
948:                     For example, btohexa_high(0xAE) will return 'A'.
949:                 
950:                   Precondition:
951:                     None
952:                 
953:                   Parameters:
954:                     b - the byte to convert
955:                 
956:                   Returns:
957:                     The upper hexadecimal ASCII byte '0'-'9' or 'A'-'F'.
958:                   ***************************************************************************/
959:                 uint8_t btohexa_high(uint8_t b)
960:                 {
9D00FB0C  27BDFFF8   ADDIU SP, SP, -8
9D00FB10  AFBE0004   SW S8, 4(SP)
9D00FB14  03A0F021   ADDU S8, SP, ZERO
9D00FB18  00801021   ADDU V0, A0, ZERO
9D00FB1C  A3C20008   SB V0, 8(S8)
961:                     b >>= 4;
9D00FB20  93C20008   LBU V0, 8(S8)
9D00FB24  00021102   SRL V0, V0, 4
9D00FB28  A3C20008   SB V0, 8(S8)
962:                     return (b>0x9u) ? b+'A'-10:b+'0';
9D00FB2C  93C20008   LBU V0, 8(S8)
9D00FB30  2C42000A   SLTIU V0, V0, 10
9D00FB34  14400006   BNE V0, ZERO, 0x9D00FB50
9D00FB38  00000000   NOP
9D00FB3C  93C20008   LBU V0, 8(S8)
9D00FB40  24420037   ADDIU V0, V0, 55
9D00FB44  304200FF   ANDI V0, V0, 255
9D00FB48  0B403ED7   J 0x9D00FB5C
9D00FB4C  00000000   NOP
9D00FB50  93C20008   LBU V0, 8(S8)
9D00FB54  24420030   ADDIU V0, V0, 48
9D00FB58  304200FF   ANDI V0, V0, 255
963:                 }
9D00FB5C  03C0E821   ADDU SP, S8, ZERO
9D00FB60  8FBE0004   LW S8, 4(SP)
9D00FB64  27BD0008   ADDIU SP, SP, 8
9D00FB68  03E00008   JR RA
9D00FB6C  00000000   NOP
964:                 
965:                 /*****************************************************************************
966:                   Function:
967:                     uint8_t btohexa_high(uint8_t b)
968:                 
969:                   Summary:
970:                     Converts the lower nibble of a binary value to a hexadecimal ASCII byte.
971:                 
972:                   Description:
973:                     Converts the lower nibble of a binary value to a hexadecimal ASCII byte.
974:                     For example, btohexa_high(0xAE) will return 'E'.
975:                 
976:                   Precondition:
977:                     None
978:                 
979:                   Parameters:
980:                     b - the byte to convert
981:                 
982:                   Returns:
983:                     The lower hexadecimal ASCII byte '0'-'9' or 'A'-'F'.
984:                   ***************************************************************************/
985:                 uint8_t btohexa_low(uint8_t b)
986:                 {
9D00FB70  27BDFFF8   ADDIU SP, SP, -8
9D00FB74  AFBE0004   SW S8, 4(SP)
9D00FB78  03A0F021   ADDU S8, SP, ZERO
9D00FB7C  00801021   ADDU V0, A0, ZERO
9D00FB80  A3C20008   SB V0, 8(S8)
987:                     b &= 0x0F;
9D00FB84  93C20008   LBU V0, 8(S8)
9D00FB88  3042000F   ANDI V0, V0, 15
9D00FB8C  A3C20008   SB V0, 8(S8)
988:                     return (b>9u) ? b+'A'-10:b+'0';
9D00FB90  93C20008   LBU V0, 8(S8)
9D00FB94  2C42000A   SLTIU V0, V0, 10
9D00FB98  14400006   BNE V0, ZERO, 0x9D00FBB4
9D00FB9C  00000000   NOP
9D00FBA0  93C20008   LBU V0, 8(S8)
9D00FBA4  24420037   ADDIU V0, V0, 55
9D00FBA8  304200FF   ANDI V0, V0, 255
9D00FBAC  0B403EF0   J 0x9D00FBC0
9D00FBB0  00000000   NOP
9D00FBB4  93C20008   LBU V0, 8(S8)
9D00FBB8  24420030   ADDIU V0, V0, 48
9D00FBBC  304200FF   ANDI V0, V0, 255
989:                 }
9D00FBC0  03C0E821   ADDU SP, S8, ZERO
9D00FBC4  8FBE0004   LW S8, 4(SP)
9D00FBC8  27BD0008   ADDIU SP, SP, 8
9D00FBCC  03E00008   JR RA
9D00FBD0  00000000   NOP
990:                 
991:                 /*****************************************************************************
992:                   Function:
993:                     signed char stricmppgm2ram(uint8_t* a, ROM uint8_t* b)
994:                 
995:                   Summary:
996:                     Case-insensitive comparison of a string in RAM to a string in ROM.
997:                 
998:                   Description:
999:                     Performs a case-insensitive comparison of a string in RAM to a string
1000:                    in ROM.  This function performs identically to strcmppgm2ram, except that
1001:                    the comparison is not case-sensitive.
1002:                
1003:                  Precondition:
1004:                    None
1005:                
1006:                  Parameters:
1007:                    a - Pinter to tring in RAM
1008:                    b - Pointer to string in ROM
1009:                
1010:                  Return Values:
1011:                    \-1 - a < b
1012:                    0   - a = b
1013:                    1   - a > b
1014:                  ***************************************************************************/
1015:                signed char stricmppgm2ram(uint8_t* a, ROM uint8_t* b)
1016:                {
9D00FBD4  27BDFFF0   ADDIU SP, SP, -16
9D00FBD8  AFBE000C   SW S8, 12(SP)
9D00FBDC  03A0F021   ADDU S8, SP, ZERO
9D00FBE0  AFC40010   SW A0, 16(S8)
9D00FBE4  AFC50014   SW A1, 20(S8)
1017:                    uint8_t cA, cB;
1018:                
1019:                    // Load first two characters
1020:                    cA = *a;
9D00FBE8  8FC20010   LW V0, 16(S8)
9D00FBEC  90420000   LBU V0, 0(V0)
9D00FBF0  A3C20000   SB V0, 0(S8)
1021:                    cB = *b;
9D00FBF4  8FC20014   LW V0, 20(S8)
9D00FBF8  90420000   LBU V0, 0(V0)
9D00FBFC  A3C20001   SB V0, 1(S8)
1022:                
1023:                    // Loop until one string terminates
1024:                    while(cA != '\0' && cB != '\0')
9D00FC00  0B403F34   J 0x9D00FCD0
9D00FC04  00000000   NOP
9D00FCD0  93C20000   LBU V0, 0(S8)
9D00FCD4  10400004   BEQ V0, ZERO, 0x9D00FCE8
9D00FCD8  00000000   NOP
9D00FCDC  93C20001   LBU V0, 1(S8)
9D00FCE0  1440FFC9   BNE V0, ZERO, 0x9D00FC08
9D00FCE4  00000000   NOP
1025:                    {
1026:                        // Shift case if necessary
1027:                        if(cA >= 'a' && cA <= 'z')
9D00FC08  93C20000   LBU V0, 0(S8)
9D00FC0C  2C420061   SLTIU V0, V0, 97
9D00FC10  14400008   BNE V0, ZERO, 0x9D00FC34
9D00FC14  00000000   NOP
9D00FC18  93C20000   LBU V0, 0(S8)
9D00FC1C  2C42007B   SLTIU V0, V0, 123
9D00FC20  10400004   BEQ V0, ZERO, 0x9D00FC34
9D00FC24  00000000   NOP
1028:                            cA -= 'a' - 'A';
9D00FC28  93C20000   LBU V0, 0(S8)
9D00FC2C  2442FFE0   ADDIU V0, V0, -32
9D00FC30  A3C20000   SB V0, 0(S8)
1029:                        if(cB >= 'a' && cB <= 'z')
9D00FC34  93C20001   LBU V0, 1(S8)
9D00FC38  2C420061   SLTIU V0, V0, 97
9D00FC3C  14400008   BNE V0, ZERO, 0x9D00FC60
9D00FC40  00000000   NOP
9D00FC44  93C20001   LBU V0, 1(S8)
9D00FC48  2C42007B   SLTIU V0, V0, 123
9D00FC4C  10400004   BEQ V0, ZERO, 0x9D00FC60
9D00FC50  00000000   NOP
1030:                            cB -= 'a' - 'A';
9D00FC54  93C20001   LBU V0, 1(S8)
9D00FC58  2442FFE0   ADDIU V0, V0, -32
9D00FC5C  A3C20001   SB V0, 1(S8)
1031:                
1032:                        // Compare
1033:                        if(cA > cB)
9D00FC60  93C30000   LBU V1, 0(S8)
9D00FC64  93C20001   LBU V0, 1(S8)
9D00FC68  0043102B   SLTU V0, V0, V1
9D00FC6C  10400004   BEQ V0, ZERO, 0x9D00FC80
9D00FC70  00000000   NOP
1034:                            return 1;
9D00FC74  24020001   ADDIU V0, ZERO, 1
9D00FC78  0B403F4B   J 0x9D00FD2C
9D00FC7C  00000000   NOP
1035:                        if(cA < cB)
9D00FC80  93C30000   LBU V1, 0(S8)
9D00FC84  93C20001   LBU V0, 1(S8)
9D00FC88  0062102B   SLTU V0, V1, V0
9D00FC8C  10400004   BEQ V0, ZERO, 0x9D00FCA0
9D00FC90  00000000   NOP
1036:                            return -1;
9D00FC94  2402FFFF   ADDIU V0, ZERO, -1
9D00FC98  0B403F4B   J 0x9D00FD2C
9D00FC9C  00000000   NOP
1037:                
1038:                        // Characters matched, so continue
1039:                        a++;
9D00FCA0  8FC20010   LW V0, 16(S8)
9D00FCA4  24420001   ADDIU V0, V0, 1
9D00FCA8  AFC20010   SW V0, 16(S8)
1040:                        b++;
9D00FCAC  8FC20014   LW V0, 20(S8)
9D00FCB0  24420001   ADDIU V0, V0, 1
9D00FCB4  AFC20014   SW V0, 20(S8)
1041:                        cA = *a;
9D00FCB8  8FC20010   LW V0, 16(S8)
9D00FCBC  90420000   LBU V0, 0(V0)
9D00FCC0  A3C20000   SB V0, 0(S8)
1042:                        cB = *b;
9D00FCC4  8FC20014   LW V0, 20(S8)
9D00FCC8  90420000   LBU V0, 0(V0)
9D00FCCC  A3C20001   SB V0, 1(S8)
1043:                    }
1044:                
1045:                    // See if one string terminated first
1046:                    if(cA > cB)
9D00FCE8  93C30000   LBU V1, 0(S8)
9D00FCEC  93C20001   LBU V0, 1(S8)
9D00FCF0  0043102B   SLTU V0, V0, V1
9D00FCF4  10400004   BEQ V0, ZERO, 0x9D00FD08
9D00FCF8  00000000   NOP
1047:                        return 1;
9D00FCFC  24020001   ADDIU V0, ZERO, 1
9D00FD00  0B403F4B   J 0x9D00FD2C
9D00FD04  00000000   NOP
1048:                    if(cA < cB)
9D00FD08  93C30000   LBU V1, 0(S8)
9D00FD0C  93C20001   LBU V0, 1(S8)
9D00FD10  0062102B   SLTU V0, V1, V0
9D00FD14  10400004   BEQ V0, ZERO, 0x9D00FD28
9D00FD18  00000000   NOP
1049:                        return -1;
9D00FD1C  2402FFFF   ADDIU V0, ZERO, -1
9D00FD20  0B403F4B   J 0x9D00FD2C
9D00FD24  00000000   NOP
1050:                
1051:                    // Strings match
1052:                    return 0;
9D00FD28  00001021   ADDU V0, ZERO, ZERO
1053:                }
9D00FD2C  03C0E821   ADDU SP, S8, ZERO
9D00FD30  8FBE000C   LW S8, 12(SP)
9D00FD34  27BD0010   ADDIU SP, SP, 16
9D00FD38  03E00008   JR RA
9D00FD3C  00000000   NOP
1054:                
1055:                /*****************************************************************************
1056:                  Function:
1057:                    uint16_t swaps(uint16_t v)
1058:                
1059:                  Description:
1060:                    Swaps the endian-ness of a uint16_t.
1061:                
1062:                  Precondition:
1063:                    None
1064:                
1065:                  Parameters:
1066:                    v - the uint16_t to swap
1067:                
1068:                  Returns:
1069:                    The swapped version of v.
1070:                  ***************************************************************************/
1071:                uint16_t swaps(uint16_t v)
1072:                {
9D00FD40  27BDFFF0   ADDIU SP, SP, -16
9D00FD44  AFBE000C   SW S8, 12(SP)
9D00FD48  03A0F021   ADDU S8, SP, ZERO
9D00FD4C  00801021   ADDU V0, A0, ZERO
9D00FD50  A7C20010   SH V0, 16(S8)
1073:                    TCPIP_UINT16_VAL t;
1074:                    uint8_t b;
1075:                
1076:                    t.Val   = v;
9D00FD54  97C20010   LHU V0, 16(S8)
9D00FD58  A7C20004   SH V0, 4(S8)
1077:                    b       = t.v[1];
9D00FD5C  93C20005   LBU V0, 5(S8)
9D00FD60  A3C20000   SB V0, 0(S8)
1078:                    t.v[1]  = t.v[0];
9D00FD64  93C20004   LBU V0, 4(S8)
9D00FD68  A3C20005   SB V0, 5(S8)
1079:                    t.v[0]  = b;
9D00FD6C  93C20000   LBU V0, 0(S8)
9D00FD70  A3C20004   SB V0, 4(S8)
1080:                
1081:                    return t.Val;
9D00FD74  97C20004   LHU V0, 4(S8)
1082:                }
9D00FD78  03C0E821   ADDU SP, S8, ZERO
9D00FD7C  8FBE000C   LW S8, 12(SP)
9D00FD80  27BD0010   ADDIU SP, SP, 16
9D00FD84  03E00008   JR RA
9D00FD88  00000000   NOP
1083:                
1084:                /*****************************************************************************
1085:                  Function:
1086:                    uint32_t swapl(uint32_t v)
1087:                
1088:                  Description:
1089:                    Swaps the endian-ness of a uint32_t.
1090:                
1091:                  Precondition:
1092:                    None
1093:                
1094:                  Parameters:
1095:                    v - the uint32_t to swap
1096:                
1097:                  Returns:
1098:                    The swapped version of v.
1099:                  ***************************************************************************/
1100:                #if defined(__XC32)
1101:                uint32_t   __attribute__((nomips16)) swapl(uint32_t v)
1102:                #else
1103:                uint32_t swapl(uint32_t v)
1104:                #endif
1105:                {
9D00FD8C  27BDFFF8   ADDIU SP, SP, -8
9D00FD90  AFBE0004   SW S8, 4(SP)
9D00FD94  03A0F021   ADDU S8, SP, ZERO
9D00FD98  AFC40008   SW A0, 8(S8)
1106:                    // Swap bytes 0 and 3
1107:                    ((TCPIP_UINT32_VAL*)&v)->v[0] ^= ((TCPIP_UINT32_VAL*)&v)->v[3];
9D00FD9C  27C20008   ADDIU V0, S8, 8
9D00FDA0  27C30008   ADDIU V1, S8, 8
9D00FDA4  90640000   LBU A0, 0(V1)
9D00FDA8  27C30008   ADDIU V1, S8, 8
9D00FDAC  90630003   LBU V1, 3(V1)
9D00FDB0  00831826   XOR V1, A0, V1
9D00FDB4  306300FF   ANDI V1, V1, 255
9D00FDB8  A0430000   SB V1, 0(V0)
1108:                    ((TCPIP_UINT32_VAL*)&v)->v[3] ^= ((TCPIP_UINT32_VAL*)&v)->v[0];
9D00FDBC  27C20008   ADDIU V0, S8, 8
9D00FDC0  27C30008   ADDIU V1, S8, 8
9D00FDC4  90640003   LBU A0, 3(V1)
9D00FDC8  27C30008   ADDIU V1, S8, 8
9D00FDCC  90630000   LBU V1, 0(V1)
9D00FDD0  00831826   XOR V1, A0, V1
9D00FDD4  306300FF   ANDI V1, V1, 255
9D00FDD8  A0430003   SB V1, 3(V0)
1109:                    ((TCPIP_UINT32_VAL*)&v)->v[0] ^= ((TCPIP_UINT32_VAL*)&v)->v[3];
9D00FDDC  27C20008   ADDIU V0, S8, 8
9D00FDE0  27C30008   ADDIU V1, S8, 8
9D00FDE4  90640000   LBU A0, 0(V1)
9D00FDE8  27C30008   ADDIU V1, S8, 8
9D00FDEC  90630003   LBU V1, 3(V1)
9D00FDF0  00831826   XOR V1, A0, V1
9D00FDF4  306300FF   ANDI V1, V1, 255
9D00FDF8  A0430000   SB V1, 0(V0)
1110:                
1111:                    // Swap bytes 1 and 2
1112:                    ((TCPIP_UINT32_VAL*)&v)->v[1] ^= ((TCPIP_UINT32_VAL*)&v)->v[2];
9D00FDFC  27C20008   ADDIU V0, S8, 8
9D00FE00  27C30008   ADDIU V1, S8, 8
9D00FE04  90640001   LBU A0, 1(V1)
9D00FE08  27C30008   ADDIU V1, S8, 8
9D00FE0C  90630002   LBU V1, 2(V1)
9D00FE10  00831826   XOR V1, A0, V1
9D00FE14  306300FF   ANDI V1, V1, 255
9D00FE18  A0430001   SB V1, 1(V0)
1113:                    ((TCPIP_UINT32_VAL*)&v)->v[2] ^= ((TCPIP_UINT32_VAL*)&v)->v[1];
9D00FE1C  27C20008   ADDIU V0, S8, 8
9D00FE20  27C30008   ADDIU V1, S8, 8
9D00FE24  90640002   LBU A0, 2(V1)
9D00FE28  27C30008   ADDIU V1, S8, 8
9D00FE2C  90630001   LBU V1, 1(V1)
9D00FE30  00831826   XOR V1, A0, V1
9D00FE34  306300FF   ANDI V1, V1, 255
9D00FE38  A0430002   SB V1, 2(V0)
1114:                    ((TCPIP_UINT32_VAL*)&v)->v[1] ^= ((TCPIP_UINT32_VAL*)&v)->v[2];
9D00FE3C  27C20008   ADDIU V0, S8, 8
9D00FE40  27C30008   ADDIU V1, S8, 8
9D00FE44  90640001   LBU A0, 1(V1)
9D00FE48  27C30008   ADDIU V1, S8, 8
9D00FE4C  90630002   LBU V1, 2(V1)
9D00FE50  00831826   XOR V1, A0, V1
9D00FE54  306300FF   ANDI V1, V1, 255
9D00FE58  A0430001   SB V1, 1(V0)
1115:                
1116:                    return v;
9D00FE5C  8FC20008   LW V0, 8(S8)
1117:                }
9D00FE60  03C0E821   ADDU SP, S8, ZERO
9D00FE64  8FBE0004   LW S8, 4(SP)
9D00FE68  27BD0008   ADDIU SP, SP, 8
9D00FE6C  03E00008   JR RA
9D00FE70  00000000   NOP
1118:                
1119:                
1120:                /*****************************************************************************
1121:                  Function:
1122:                    uint16_t CalcIPChecksum(uint8_t* buffer, uint16_t count)
1123:                
1124:                  Summary:
1125:                    Calculates an IP checksum value.
1126:                
1127:                  Description:
1128:                    This function calculates an IP checksum over an array of input data.  The
1129:                    checksum is the 16-bit one's complement of one's complement sum of all
1130:                    words in the data (with zero-padding if an odd number of bytes are
1131:                    summed).  This checksum is defined in RFC 793.
1132:                
1133:                  Precondition:
1134:                    buffer is uint16_t aligned (even memory address) on 16- and 32-bit PICs.
1135:                
1136:                  Parameters:
1137:                    buffer - pointer to the data to be checksummed
1138:                    count  - number of bytes to be checksummed
1139:                
1140:                  Returns:
1141:                    The calculated checksum.
1142:                
1143:                  Internal:
1144:                    This function could be improved to do 32-bit sums on PIC32 platforms.
1145:                  ***************************************************************************/
1146:                uint16_t CalcIPChecksum(uint8_t* buffer, uint16_t count)
1147:                {
9D00FE74  27BDFFE8   ADDIU SP, SP, -24
9D00FE78  AFBE0014   SW S8, 20(SP)
9D00FE7C  03A0F021   ADDU S8, SP, ZERO
9D00FE80  AFC40018   SW A0, 24(S8)
9D00FE84  00A01021   ADDU V0, A1, ZERO
9D00FE88  A7C2001C   SH V0, 28(S8)
1148:                    uint16_t i;
1149:                    uint16_t *val;
1150:                    union
1151:                    {
1152:                        uint16_t w[2];
1153:                        uint32_t dw;
1154:                    } sum;
1155:                
1156:                    i = count >> 1;
9D00FE8C  97C2001C   LHU V0, 28(S8)
9D00FE90  00021042   SRL V0, V0, 1
9D00FE94  A7C20000   SH V0, 0(S8)
1157:                    val = (uint16_t*)buffer;
9D00FE98  8FC20018   LW V0, 24(S8)
9D00FE9C  AFC20004   SW V0, 4(S8)
1158:                
1159:                    // Calculate the sum of all words
1160:                    sum.dw = 0x00000000ul;
9D00FEA0  AFC00008   SW ZERO, 8(S8)
1161:                    while(i--)
9D00FEA4  0B403FB3   J 0x9D00FECC
9D00FEA8  00000000   NOP
9D00FECC  97C20000   LHU V0, 0(S8)
9D00FED0  0002102B   SLTU V0, ZERO, V0
9D00FED4  304200FF   ANDI V0, V0, 255
9D00FED8  97C30000   LHU V1, 0(S8)
9D00FEDC  2463FFFF   ADDIU V1, V1, -1
9D00FEE0  A7C30000   SH V1, 0(S8)
9D00FEE4  1440FFF1   BNE V0, ZERO, 0x9D00FEAC
9D00FEE8  00000000   NOP
1162:                        sum.dw += (uint32_t)*val++;
9D00FEAC  8FC30008   LW V1, 8(S8)
9D00FEB0  8FC20004   LW V0, 4(S8)
9D00FEB4  94420000   LHU V0, 0(V0)
9D00FEB8  00621021   ADDU V0, V1, V0
9D00FEBC  AFC20008   SW V0, 8(S8)
9D00FEC0  8FC20004   LW V0, 4(S8)
9D00FEC4  24420002   ADDIU V0, V0, 2
9D00FEC8  AFC20004   SW V0, 4(S8)
1163:                
1164:                    // Add in the sum of the remaining byte, if present
1165:                    if(count & 0x1)
9D00FEEC  97C2001C   LHU V0, 28(S8)
9D00FEF0  30420001   ANDI V0, V0, 1
9D00FEF4  304200FF   ANDI V0, V0, 255
9D00FEF8  10400006   BEQ V0, ZERO, 0x9D00FF14
9D00FEFC  00000000   NOP
1166:                        sum.dw += (uint32_t)*(uint8_t*)val;
9D00FF00  8FC30008   LW V1, 8(S8)
9D00FF04  8FC20004   LW V0, 4(S8)
9D00FF08  90420000   LBU V0, 0(V0)
9D00FF0C  00621021   ADDU V0, V1, V0
9D00FF10  AFC20008   SW V0, 8(S8)
1167:                
1168:                    // Do an end-around carry (one's complement arrithmatic)
1169:                    sum.dw = (uint32_t)sum.w[0] + (uint32_t)sum.w[1];
9D00FF14  97C20008   LHU V0, 8(S8)
9D00FF18  00401821   ADDU V1, V0, ZERO
9D00FF1C  97C2000A   LHU V0, 10(S8)
9D00FF20  00621021   ADDU V0, V1, V0
9D00FF24  AFC20008   SW V0, 8(S8)
1170:                
1171:                    // Do another end-around carry in case if the prior add
1172:                    // caused a carry out
1173:                    sum.w[0] += sum.w[1];
9D00FF28  97C30008   LHU V1, 8(S8)
9D00FF2C  97C2000A   LHU V0, 10(S8)
9D00FF30  00621021   ADDU V0, V1, V0
9D00FF34  3042FFFF   ANDI V0, V0, -1
9D00FF38  A7C20008   SH V0, 8(S8)
1174:                
1175:                    // Return the resulting checksum
1176:                    return ~sum.w[0];
9D00FF3C  97C20008   LHU V0, 8(S8)
9D00FF40  00021027   NOR V0, ZERO, V0
9D00FF44  3042FFFF   ANDI V0, V0, -1
1177:                }
9D00FF48  03C0E821   ADDU SP, S8, ZERO
9D00FF4C  8FBE0014   LW S8, 20(SP)
9D00FF50  27BD0018   ADDIU SP, SP, 24
9D00FF54  03E00008   JR RA
9D00FF58  00000000   NOP
1178:                
1179:                
1180:                /*****************************************************************************
1181:                  Function:
1182:                    char* strupr(char* s)
1183:                
1184:                  Summary:
1185:                    Converts a string to uppercase.
1186:                
1187:                  Description:
1188:                    This function converts strings to uppercase on platforms that do not
1189:                    already have this function defined.  All lower-case characters are
1190:                    converted, an characters not included in 'a'-'z' are left as-is.
1191:                
1192:                  Precondition:
1193:                    None
1194:                
1195:                  Parameters:
1196:                    s - the null-terminated string to be converted.
1197:                
1198:                  Returns:
1199:                    Pointer to the initial string.
1200:                  ***************************************************************************/
1201:                char* strupr(char* s)
1202:                {
9D00FF5C  27BDFFF0   ADDIU SP, SP, -16
9D00FF60  AFBE000C   SW S8, 12(SP)
9D00FF64  03A0F021   ADDU S8, SP, ZERO
9D00FF68  AFC40010   SW A0, 16(S8)
1203:                    char c;
1204:                    char *t;
1205:                
1206:                    t = s;
9D00FF6C  8FC20010   LW V0, 16(S8)
9D00FF70  AFC20000   SW V0, 0(S8)
1207:                    while( (c = *t) )
9D00FF74  0B403FF2   J 0x9D00FFC8
9D00FF78  00000000   NOP
9D00FFC8  8FC20000   LW V0, 0(S8)
9D00FFCC  90420000   LBU V0, 0(V0)
9D00FFD0  A3C20004   SB V0, 4(S8)
9D00FFD4  83C20004   LB V0, 4(S8)
9D00FFD8  1440FFE8   BNE V0, ZERO, 0x9D00FF7C
9D00FFDC  00000000   NOP
1208:                    {
1209:                        if(c >= 'a' && c <= 'z')
9D00FF7C  83C20004   LB V0, 4(S8)
9D00FF80  28420061   SLTI V0, V0, 97
9D00FF84  1440000D   BNE V0, ZERO, 0x9D00FFBC
9D00FF88  00000000   NOP
9D00FF8C  83C20004   LB V0, 4(S8)
9D00FF90  2842007B   SLTI V0, V0, 123
9D00FF94  10400009   BEQ V0, ZERO, 0x9D00FFBC
9D00FF98  00000000   NOP
1210:                        {
1211:                            *t -= ('a' - 'A');
9D00FF9C  8FC20000   LW V0, 0(S8)
9D00FFA0  80420000   LB V0, 0(V0)
9D00FFA4  304200FF   ANDI V0, V0, 255
9D00FFA8  2442FFE0   ADDIU V0, V0, -32
9D00FFAC  304200FF   ANDI V0, V0, 255
9D00FFB0  7C021C20   SEB V1, V0
9D00FFB4  8FC20000   LW V0, 0(S8)
9D00FFB8  A0430000   SB V1, 0(V0)
1212:                        }
1213:                        t++;
9D00FFBC  8FC20000   LW V0, 0(S8)
9D00FFC0  24420001   ADDIU V0, V0, 1
9D00FFC4  AFC20000   SW V0, 0(S8)
1214:                    }
1215:                    return s;
9D00FFE0  8FC20010   LW V0, 16(S8)
1216:                }
9D00FFE4  03C0E821   ADDU SP, S8, ZERO
9D00FFE8  8FBE000C   LW S8, 12(SP)
9D00FFEC  27BD0010   ADDIU SP, SP, 16
9D00FFF0  03E00008   JR RA
9D00FFF4  00000000   NOP
1217:                
1218:                #if defined(__XC8)
1219:                // Make this variable global for the following function.
1220:                // Hi-Tech PICC18 cannot access local function variables from inline asm.
1221:                TCPIP_UINT32_VAL toRotate;
1222:                #endif
1223:                
1224:                /*****************************************************************************
1225:                  Function:
1226:                    uint32_t leftRotateDWORD(uint32_t val, uint8_t bits)
1227:                
1228:                  Summary:
1229:                    Left-rotates a uint32_t.
1230:                
1231:                  Description:
1232:                    This function rotates the bits in a 32-bit uint32_t left by a specific
1233:                    number of bits.
1234:                
1235:                  Precondition:
1236:                    None
1237:                
1238:                  Parameters:
1239:                    val     - the uint32_t to be rotated
1240:                    bits    - the number of bits by which to shift
1241:                
1242:                  Returns:
1243:                    Rotated uint32_t value.
1244:                
1245:                  Remarks:
1246:                    This function is only implemented on 8-bit platforms for now.  The
1247:                    8-bit compilers generate excessive code for this function, while C30
1248:                    and C32 already generate compact code.  Those compilers are served
1249:                    by a macro defined in helpers.h.
1250:                  ***************************************************************************/
1251:                #if defined(__XC8)
1252:                uint32_t leftRotateDWORD(uint32_t val, uint8_t bits)
1253:                {
1254:                    uint8_t i, t;
1255:                    //TCPIP_UINT32_VAL toRotate;
1256:                    toRotate.Val = val;
1257:                
1258:                    for(i = bits; i >= 8u; i -= 8)
1259:                    {
1260:                        t = toRotate.v[3];
1261:                        toRotate.v[3] = toRotate.v[2];
1262:                        toRotate.v[2] = toRotate.v[1];
1263:                        toRotate.v[1] = toRotate.v[0];
1264:                        toRotate.v[0] = t;
1265:                    }
1266:                
1267:                
1268:                    for(; i != 0; i--)
1269:                    {
1270:                        asm("movlb (_toRotate)>>8");
1271:                        //asm("bcf _STATUS,0,C");
1272:                        asm("bcf 0xFD8,0,C");       // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS
1273:                        asm("btfsc (_toRotate)&0ffh+3,7,B");
1274:                        //asm("bsf _STATUS,0,C");
1275:                        asm("bsf 0xFD8,0,C");       // HI-TECH PICC-18 PRO 9.63PL1 doesn't define _STATUS
1276:                        asm("rlcf (_toRotate)&0ffh+0,F,B");
1277:                        asm("rlcf (_toRotate)&0ffh+1,F,B");
1278:                        asm("rlcf (_toRotate)&0ffh+2,F,B");
1279:                        asm("rlcf (_toRotate)&0ffh+3,F,B");
1280:                    }
1281:                
1282:                //    for(; i != 0u; i--)
1283:                //    {
1284:                //        _asm
1285:                //        movlb toRotate
1286:                //        bcf STATUS,0,0
1287:                //        btfsc toRotate+3,7,1
1288:                //        bsf STATUS,0,0
1289:                //        rlcf toRotate+0,1,1
1290:                //        rlcf toRotate+1,1,1
1291:                //        rlcf toRotate+2,1,1
1292:                //        rlcf toRotate+3,1,1
1293:                //        _endasm
1294:                //    }
1295:                
1296:                    return toRotate.Val;
1297:                }
1298:                #endif
1299:                
1300:                /*****************************************************************************
1301:                  Function:
1302:                    void FormatNetBIOSName(uint8_t Name[])
1303:                
1304:                  Summary:
1305:                    Formats a string to a valid NetBIOS name.
1306:                
1307:                  Description:
1308:                    This function formats a string to a valid NetBIOS name.  Names will be
1309:                    exactly 16 characters, as defined by the NetBIOS spec.  The 16th
1310:                    character will be a 0x00 byte, while the other 15 will be the
1311:                    provided string, padded with spaces as necessary.
1312:                
1313:                  Precondition:
1314:                    None
1315:                
1316:                  Parameters:
1317:                    Name - the string to format as a NetBIOS name.  This parameter must have
1318:                      at least 16 bytes allocated.
1319:                
1320:                  Returns:
1321:                    None
1322:                  ***************************************************************************/
1323:                void FormatNetBIOSName(uint8_t Name[])
1324:                {
9D00FFF8  27BDFFE0   ADDIU SP, SP, -32
9D00FFFC  AFBF001C   SW RA, 28(SP)
9D010000  AFBE0018   SW S8, 24(SP)
9D010004  03A0F021   ADDU S8, SP, ZERO
9D010008  AFC40020   SW A0, 32(S8)
1325:                    uint8_t i;
1326:                
1327:                    Name[15] = '\0';
9D01000C  8FC20020   LW V0, 32(S8)
9D010010  2442000F   ADDIU V0, V0, 15
9D010014  A0400000   SB ZERO, 0(V0)
1328:                    strupr((char*)Name);
9D010018  8FC20020   LW V0, 32(S8)
9D01001C  00402021   ADDU A0, V0, ZERO
9D010020  0F403FD7   JAL strupr
9D010024  00000000   NOP
1329:                    i = 0;
9D010028  A3C00010   SB ZERO, 16(S8)
1330:                    while(i < 15u)
9D01002C  0B404026   J 0x9D010098
9D010030  00000000   NOP
9D010098  93C20010   LBU V0, 16(S8)
9D01009C  2C42000F   SLTIU V0, V0, 15
9D0100A0  1440FFE4   BNE V0, ZERO, 0x9D010034
9D0100A4  00000000   NOP
1331:                    {
1332:                        if(Name[i] == '\0')
9D010034  93C20010   LBU V0, 16(S8)
9D010038  8FC30020   LW V1, 32(S8)
9D01003C  00621021   ADDU V0, V1, V0
9D010040  90420000   LBU V0, 0(V0)
9D010044  14400011   BNE V0, ZERO, 0x9D01008C
9D010048  00000000   NOP
1333:                        {
1334:                            while(i < 15u)
9D01004C  0B40401D   J 0x9D010074
9D010050  00000000   NOP
9D010074  93C20010   LBU V0, 16(S8)
9D010078  2C42000F   SLTIU V0, V0, 15
9D01007C  1440FFF5   BNE V0, ZERO, 0x9D010054
9D010080  00000000   NOP
1335:                            {
1336:                                Name[i++] = ' ';
9D010054  93C20010   LBU V0, 16(S8)
9D010058  8FC30020   LW V1, 32(S8)
9D01005C  00621021   ADDU V0, V1, V0
9D010060  24030020   ADDIU V1, ZERO, 32
9D010064  A0430000   SB V1, 0(V0)
9D010068  93C20010   LBU V0, 16(S8)
9D01006C  24420001   ADDIU V0, V0, 1
9D010070  A3C20010   SB V0, 16(S8)
1337:                            }
1338:                            break;
9D010084  0B40402A   J 0x9D0100A8
9D010088  00000000   NOP
1339:                        }
1340:                        i++;
9D01008C  93C20010   LBU V0, 16(S8)
9D010090  24420001   ADDIU V0, V0, 1
9D010094  A3C20010   SB V0, 16(S8)
1341:                    }
1342:                }
9D0100A8  03C0E821   ADDU SP, S8, ZERO
9D0100AC  8FBF001C   LW RA, 28(SP)
9D0100B0  8FBE0018   LW S8, 24(SP)
9D0100B4  27BD0020   ADDIU SP, SP, 32
9D0100B8  03E00008   JR RA
9D0100BC  00000000   NOP
1343:                
1344:                /*****************************************************************************
1345:                  Function:
1346:                    char * strnchr(const char *searchString, size_t count, char c)
1347:                
1348:                  Summary:
1349:                    Searches a string up to a specified number of characters for a specific
1350:                    character.
1351:                
1352:                  Description:
1353:                    Searches a string up to a specified number of characters for a specific
1354:                    character.  The string is searched forward and the first occurance
1355:                    location is returned.  If the search character is not present in the
1356:                    string, or if the maximum character count is reached first, then a NULL
1357:                    pointer is returned.
1358:                
1359:                  Precondition:
1360:                    None
1361:                
1362:                  Parameters:
1363:                    searchString - Pointer to a null terminated string to search.  If count is
1364:                        less than the string size, then the string need not be null terminated.
1365:                    count - Maximum number of characters to search before aborting.
1366:                    c - Character to search for
1367:                
1368:                  Returns:
1369:                    Pointer to the first occurance of the character c in the string
1370:                    searchString.  If the character is not found or the maximum count is
1371:                    reached, a NULL pointer is returned.
1372:                  ***************************************************************************/
1373:                char * strnchr(const char *searchString, size_t count, char c)
1374:                {
9D0100C0  27BDFFF0   ADDIU SP, SP, -16
9D0100C4  AFBE000C   SW S8, 12(SP)
9D0100C8  03A0F021   ADDU S8, SP, ZERO
9D0100CC  AFC40010   SW A0, 16(S8)
9D0100D0  AFC50014   SW A1, 20(S8)
9D0100D4  00C01021   ADDU V0, A2, ZERO
9D0100D8  A3C20018   SB V0, 24(S8)
1375:                    char c2;
1376:                
1377:                    while(count--)
9D0100DC  0B40404F   J 0x9D01013C
9D0100E0  00000000   NOP
9D01013C  8FC20014   LW V0, 20(S8)
9D010140  0002102B   SLTU V0, ZERO, V0
9D010144  304200FF   ANDI V0, V0, 255
9D010148  8FC30014   LW V1, 20(S8)
9D01014C  2463FFFF   ADDIU V1, V1, -1
9D010150  AFC30014   SW V1, 20(S8)
9D010154  1440FFE3   BNE V0, ZERO, 0x9D0100E4
9D010158  00000000   NOP
1378:                    {
1379:                        c2  = *searchString++;
9D0100E4  8FC20010   LW V0, 16(S8)
9D0100E8  90420000   LBU V0, 0(V0)
9D0100EC  A3C20000   SB V0, 0(S8)
9D0100F0  8FC20010   LW V0, 16(S8)
9D0100F4  24420001   ADDIU V0, V0, 1
9D0100F8  AFC20010   SW V0, 16(S8)
1380:                        if(c2 == 0u)
9D0100FC  83C20000   LB V0, 0(S8)
9D010100  14400004   BNE V0, ZERO, 0x9D010114
9D010104  00000000   NOP
1381:                            return NULL;
9D010108  00001021   ADDU V0, ZERO, ZERO
9D01010C  0B404058   J 0x9D010160
9D010110  00000000   NOP
1382:                        if(c2 == c)
9D010114  83C30000   LB V1, 0(S8)
9D010118  83C20018   LB V0, 24(S8)
9D01011C  14620007   BNE V1, V0, 0x9D01013C
9D010120  00000000   NOP
1383:                            return (char*)--searchString;
9D010124  8FC20010   LW V0, 16(S8)
9D010128  2442FFFF   ADDIU V0, V0, -1
9D01012C  AFC20010   SW V0, 16(S8)
9D010130  8FC20010   LW V0, 16(S8)
9D010134  0B404058   J 0x9D010160
9D010138  00000000   NOP
1384:                    }
1385:                    return NULL;
9D01015C  00001021   ADDU V0, ZERO, ZERO
1386:                }
9D010160  03C0E821   ADDU SP, S8, ZERO
9D010164  8FBE000C   LW S8, 12(SP)
9D010168  27BD0010   ADDIU SP, SP, 16
9D01016C  03E00008   JR RA
9D010170  00000000   NOP
1387:                
1388:                
1389:                /*****************************************************************************
1390:                  Function:
1391:                    char* strncpy_m(char* destStr, size_t destSize, int nStrings, ...)
1392:                
1393:                  Summary:
1394:                    Copies multiple strings to a destination
1395:                
1396:                  Description:
1397:                    Copies multiple strings to a destination
1398:                    but doesn't copy more than destSize characters.
1399:                    Useful where the destination is actually an array and an extra \0
1400:                    won't be appended to overflow the buffer
1401:                
1402:                  Precondition:
1403:                    - valid string pointers
1404:                    - destSize should be > 0
1405:                
1406:                  Parameters:
1407:                    destStr - Pointer to a string to be initialized with the multiple strings provided as arguments.
1408:                
1409:                    destSize    - the maximum size of the destStr field, that cannot be exceeded.
1410:                                  An \0 won't be appended if the resulting size is > destSize
1411:                
1412:                    nStrings    - number of string parameters to be copied into destStr
1413:                
1414:                    ...         - variable number of arguments
1415:                
1416:                
1417:                  Returns:
1418:                    Length of the destination string, terminating \0 (if exists) not included
1419:                  ***************************************************************************/
1420:                size_t strncpy_m(char* destStr, size_t destSize, int nStrings, ...)
1421:                {
9D010174  27BDFFD8   ADDIU SP, SP, -40
9D010178  AFBF0024   SW RA, 36(SP)
9D01017C  AFBE0020   SW S8, 32(SP)
9D010180  03A0F021   ADDU S8, SP, ZERO
9D010184  AFC40028   SW A0, 40(S8)
9D010188  AFC5002C   SW A1, 44(S8)
9D01018C  AFC70034   SW A3, 52(S8)
9D010190  AFC60030   SW A2, 48(S8)
1422:                    va_list     args;
1423:                    const char* str;
1424:                    char*       end;
1425:                    size_t      len;
1426:                
1427:                    destStr[0] = '\0';
9D010194  8FC20028   LW V0, 40(S8)
9D010198  A0400000   SB ZERO, 0(V0)
1428:                    end = destStr + destSize - 1;
9D01019C  8FC2002C   LW V0, 44(S8)
9D0101A0  2442FFFF   ADDIU V0, V0, -1
9D0101A4  8FC30028   LW V1, 40(S8)
9D0101A8  00621021   ADDU V0, V1, V0
9D0101AC  AFC20014   SW V0, 20(S8)
1429:                    *end = '\0';
9D0101B0  8FC20014   LW V0, 20(S8)
9D0101B4  A0400000   SB ZERO, 0(V0)
1430:                    len = 0;
9D0101B8  AFC00010   SW ZERO, 16(S8)
1431:                
1432:                    va_start( args, nStrings );
9D0101BC  27C20034   ADDIU V0, S8, 52
9D0101C0  AFC2001C   SW V0, 28(S8)
1433:                
1434:                    while(nStrings--)
9D0101C4  0B404091   J 0x9D010244
9D0101C8  00000000   NOP
9D010244  8FC20030   LW V0, 48(S8)
9D010248  0002102B   SLTU V0, ZERO, V0
9D01024C  304200FF   ANDI V0, V0, 255
9D010250  8FC30030   LW V1, 48(S8)
9D010254  2463FFFF   ADDIU V1, V1, -1
9D010258  AFC30030   SW V1, 48(S8)
9D01025C  1440FFDB   BNE V0, ZERO, 0x9D0101CC
9D010260  00000000   NOP
1435:                    {
1436:                        if(*end)
9D0101CC  8FC20014   LW V0, 20(S8)
9D0101D0  80420000   LB V0, 0(V0)
9D0101D4  10400005   BEQ V0, ZERO, 0x9D0101EC
9D0101D8  00000000   NOP
1437:                        {   // if already full don't calculate strlen outside the string area
1438:                            len = destSize;
9D0101DC  8FC2002C   LW V0, 44(S8)
9D0101E0  AFC20010   SW V0, 16(S8)
1439:                            break;
9D0101E4  0B404099   J 0x9D010264
9D0101E8  00000000   NOP
1440:                        }
1441:                
1442:                        str = va_arg(args, const char*);
9D0101EC  8FC2001C   LW V0, 28(S8)
9D0101F0  24430004   ADDIU V1, V0, 4
9D0101F4  AFC3001C   SW V1, 28(S8)
9D0101F8  8C420000   LW V0, 0(V0)
9D0101FC  AFC20018   SW V0, 24(S8)
1443:                        strncpy(destStr + len, str, destSize - len);
9D010200  8FC30028   LW V1, 40(S8)
9D010204  8FC20010   LW V0, 16(S8)
9D010208  00621821   ADDU V1, V1, V0
9D01020C  8FC4002C   LW A0, 44(S8)
9D010210  8FC20010   LW V0, 16(S8)
9D010214  00821023   SUBU V0, A0, V0
9D010218  00602021   ADDU A0, V1, ZERO
9D01021C  8FC50018   LW A1, 24(S8)
9D010220  00403021   ADDU A2, V0, ZERO
9D010224  0F406EAB   JAL strncpy
9D010228  00000000   NOP
1444:                        len += strlen(str);
9D01022C  8FC40018   LW A0, 24(S8)
9D010230  0F4067E2   JAL 0x9D019F88
9D010234  00000000   NOP
9D010238  8FC30010   LW V1, 16(S8)
9D01023C  00621021   ADDU V0, V1, V0
9D010240  AFC20010   SW V0, 16(S8)
1445:                    }
1446:                
1447:                    va_end( args );
1448:                
1449:                    return len;
9D010264  8FC20010   LW V0, 16(S8)
1450:                }
9D010268  03C0E821   ADDU SP, S8, ZERO
9D01026C  8FBF0024   LW RA, 36(SP)
9D010270  8FBE0020   LW S8, 32(SP)
9D010274  27BD0028   ADDIU SP, SP, 40
9D010278  03E00008   JR RA
9D01027C  00000000   NOP
1451:                
1452:                
1453:                /*****************************************************************************
1454:                  Function:
1455:                    uint8_t ExtractURLFields(uint8_t *vURL,
1456:                                          PROTOCOLS *protocol,
1457:                                          uint8_t *vUsername, uint16_t *wUsernameLen,
1458:                                          uint8_t *vPassword, uint16_t *wPasswordLen,
1459:                                          uint8_t *vHostname, uint16_t *wHostnameLen,
1460:                                          uint16_t *wPort,
1461:                                          uint8_t *vFilePath, uint16_t *wFilePathLen)
1462:                
1463:                  Summary:
1464:                    Extracts all parameters from an URL string (ex:
1465:                    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into
1466:                    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}.
1467:                
1468:                  Description:
1469:                    Extracts all parameters from an URL string (ex:
1470:                    "http://admin:passwd@www.microchip.com:8080/myfile.gif" is split into
1471:                    {PROTOCOL_HTTP, "admin", "passwd", "www.microchip.com", 8080, "/myfile.gif"}.
1472:                
1473:                    The URL string can be null terminated, or alternatively could be terminated
1474:                    by a carriage return or line feed.
1475:                
1476:                    If the protocol is unrecognized or the protocol is recognized but the URL
1477:                    is malformed, than an error is safely returned.  For more information on
1478:                    URL/URI interpretation see RFC 2396.
1479:                
1480:                  Precondition:
1481:                    This function is commented out by default to save code space because
1482:                    it is not used by any current stack features.  However, if you want to use
1483:                    it, go ahead and uncomment it.  It has been tested, so it (should) work
1484:                    correctly.
1485:                
1486:                  Parameters:
1487:                    vURL -  Pointer to null terminated URL to decode and extract from.  This
1488:                        parameter is required and needs to have the minimum RFC 1738 components
1489:                        in it (protocol and hostname).
1490:                
1491:                    protocol - Optional pointer to a PROTOCOLS enum to retrieve the decoded
1492:                        protocol type.  If this parameter is unneeded, specify a NULL pointer.
1493:                        The protocol is a required part of the URL, so it must always be
1494:                        present.  The protocol also determines what scheme all other parameters
1495:                        are decoded using, so the function will fail if an unrecognized
1496:                        protocol is provided.  The PROTOCOLS enum members show all of the
1497:                        currently supported protocols for this function.
1498:                
1499:                        <p>For the example URL provided in the function description,
1500:                        PROTOCOL_HTTP would be returned for this field.
1501:                
1502:                    vUsername - Optional pointer to a buffer to write the decoded username
1503:                        portion of the URL.  If the URL does not contain a username or a NULL
1504:                        pointer is supplied, then this field is ignored.
1505:                
1506:                        <p>For the example URL provided in the function description, "admin"
1507:                        would be returned for this field.
1508:                
1509:                    wUsernameLen -
1510:                        On call\: Optional pointer to a uint16_t specifying the maximum length of
1511:                        the vUsername buffer, including the null terminator character.
1512:                
1513:                        <p>Upon return\: If wUsernameLen and vUsername are non-NULL, the
1514:                        *wUsernameLen uint16_t is updated with the actual number of characters
1515:                        written to the vUsername buffer, including the null terminator
1516:                        character.  If vUsername is NULL but wUsernameLen is non-NULL, then no
1517:                        characters are copied, but *wUsernameLen will return the number of
1518:                        characters required to fit the full username string.  If wUsernameLen
1519:                        is NULL, then the username field in the URL, if present, is ignored and
1520:                        the vUsername pointer is not used.
1521:                
1522:                        <p>If zero characters were written, this indicates that the URL did not
1523:                        contain a username field.  If one character was written, this indicates
1524:                        that a username field was present, but was a zero character string
1525:                        (ex\: "").
1526:                
1527:                        <p>For the example URL provided in the function description, 6 (0x0006)
1528:                        would be returned for this field.
1529:                
1530:                    vPassword - Optional pointer to a buffer to write the decoded password
1531:                        portion of the URL.  If the URL does not contain a password or a NULL
1532:                        pointer is supplied, then this field is ignored.
1533:                
1534:                        <p>For the example URL provided in the function description, "passwd"
1535:                        would be returned for this field.
1536:                
1537:                    wPasswordLen -
1538:                        On call\: Optional pointer to a uint16_t specifying the maximum length of
1539:                        the vPassword buffer, including the null terminator character.
1540:                
1541:                        <p>Upon return\: If wPasswordLen and vPassword are non-NULL, the
1542:                        *wPasswordLen uint16_t is updated with the actual number of characters
1543:                        written to the vPassword buffer, including the null terminator
1544:                        character.  If vPassword is NULL but wPasswordLen is non-NULL, then no
1545:                        characters are copied, but *wPasswordLen will return the number of
1546:                        characters required to fit the full password string.  If wPasswordLen
1547:                        is NULL, then the password field in the URL, if present, is ignored and
1548:                        the vPassword pointer is not used.
1549:                
1550:                        <p>If zero characters were written, this indicates that the URL did not
1551:                        contain a password field.  If one character was written, this indicates
1552:                        that a password field was present, but was a zero character string
1553:                        (ex\: "").
1554:                
1555:                        <p>For the example URL provided in the function description, 7 (0x0007)
1556:                        would be returned for this field.
1557:                
1558:                    vHostname - Optional pointer to a buffer to write the decoded hostname
1559:                        portion of the URL.  All Internet URLs must contain a hostname or IP
1560:                        address, however, if a NULL pointer is supplied, then this field is
1561:                        ignored.
1562:                
1563:                        <p>For the example URL provided in the function description,
1564:                        "www.microchip.com" would be returned for this field.  If the URL was
1565:                        "http://192.168.0.1", then this field would be returned as
1566:                        "192.168.0.1".  The IP address would not be decoded to a uint32_t (use the
1567:                        StringToIPAddress() helper function to do this).
1568:                
1569:                    wHostnameLen -
1570:                        On call\: Optional pointer to a uint16_t specifying the maximum length of
1571:                        the vHostname buffer, including the null terminator character.
1572:                
1573:                        <p>Upon return\: If wHostnameLen and vHostname are non-NULL, the
1574:                        *wHostnameLen uint16_t is updated with the actual number of characters
1575:                        written to the vHostname buffer, including the null terminator
1576:                        character.  If vHostname is NULL but wHostnameLen is non-NULL, then no
1577:                        characters are copied, but *wHostnameLen will return the number of
1578:                        characters required to fit the full hostname string.  If wHostnameLen
1579:                        is NULL, then the hostname field in the URL, is ignored and the
1580:                        vHostname pointer is not used.
1581:                
1582:                        <p>For the example URL provided in the function description,
1583:                        18 (0x0012) would be returned for this field.  If the URL was
1584:                        "http://192.168.0.1", then this field would be returned as 12 (0x000C).
1585:                
1586:                    wPort - Optional pointer to a uint16_t specifying the TCP or UDP port that the
1587:                        server is listening on.  If the port field is absent from the URL, then
1588:                        this parameter will specify the default port for the protocol.  For
1589:                        example, "http://www.microchip.com" would result in 80 being return as
1590:                        the specified port.
1591:                
1592:                        <p>If the wPort pointer is NULL, then the port field in the URL
1593:                        is ignored, if present.
1594:                
1595:                    vFilePath - Optional pointer to a buffer to write the decoded file path
1596:                        portion of the URL.  If a NULL pointer is supplied, then this field is
1597:                        ignored.  If a file path is not present in the URL, then "/" will be
1598:                        returned in this field.
1599:                
1600:                        <p>For the example URL provided in the function description,
1601:                        "/myfile.gif" would be returned for this field.
1602:                
1603:                    wFilePathLen -
1604:                        On call\: Optional pointer to a uint16_t specifying the maximum length of
1605:                        the vFilePath buffer, including the null terminator character.
1606:                
1607:                        <p>Upon return\: If wFilePathLen and vFilePath are non-NULL, the
1608:                        *wFilePathLen uint16_t is updated with the actual number of characters
1609:                        written to the vFilePath buffer, including the null terminator
1610:                        character.  If vFilePath is NULL but wFilePathLen is non-NULL, then no
1611:                        characters are copied, but *wFilePathLen will return the number of
1612:                        characters required to fit the full file path string.  If wFilePathLen
1613:                        is NULL, then the file path field in the URL, if present, is ignored and
1614:                        the vFilePath pointer is not used.
1615:                
1616:                        <p>This function always returns "/" if no file path is present, so
1617:                        *wFilePathLen will also be at least 2 characters ('/' and null
1618:                        terminator) if the pointer is non-NULL.
1619:                
1620:                        <p>For the example URL provided in the function description, 12 (0x000C)
1621:                        would be returned for this field.
1622:                
1623:                  Returns:
1624:                    Zero on success.  Nonzero indicates an error code.  If a nonzero error code
1625:                    is returned, none of the returned buffers or pointer values should be
1626:                    treated as valid, but some of them may have been written to.  The following
1627:                    are all possible return values.
1628:                    <table>
1629:                        0   No error
1630:                        1   Protocol unknown (additional code needs to be added to
1631:                             ExtractURLFields() and the PROTOCOLS enum needs to be updated if
1632:                             you want to decode URLs of this protocol type.
1633:                        2   URL malformed. Illegal or unknown URL format encountered.
1634:                        3   Buffer too small.  One of the input buffer sizes is too small to
1635:                             contain the URL parameter.
1636:                    </table>
1637:                  ***************************************************************************/
1638:                #if 0
1639:                uint8_t ExtractURLFields(uint8_t *vURL, PROTOCOLS *protocol, uint8_t *vUsername, uint16_t *wUsernameLen, uint8_t *vPassword, uint16_t *wPasswordLen, uint8_t *vHostname, uint16_t *wHostnameLen, uint16_t *wPort, uint8_t *vFilePath, uint16_t *wFilePathLen)
1640:                {
1641:                    // These two arrays must exactly match up each other and the PROTOCOLS enum
1642:                    // elements.  The protocol name strings must also be specified in all
1643:                    // lowercase.
1644:                    static ROM char * ROM   vProtocolNames[] = {"http", "https", "mms", "rtsp"};
1645:                    static ROM uint16_t         wProtocolPorts[] = { 80,     443,     1755,  554};
1646:                    uint16_t w, w2;
1647:                    uint8_t i, j;
1648:                    PROTOCOLS prot;
1649:                    uint8_t *temp, *temp2;
1650:                    uint16_t wURLLen;
1651:                    uint16_t wLocalPort;
1652:                
1653:                
1654:                    // Calculate how long this URL is
1655:                    wURLLen = strlen((char*)vURL);
1656:                    temp = (uint8_t*)strnchr((char*)vURL, wURLLen, '\r');
1657:                    if(temp)
1658:                        wURLLen = temp - vURL;
1659:                    temp = (uint8_t*)strnchr((char*)vURL, wURLLen, '\n');
1660:                    if(temp)
1661:                        wURLLen = temp - vURL;
1662:                
1663:                
1664:                    // Parse starting protocol field
1665:                    // Find out how long the protocol name field is
1666:                    temp = (uint8_t*)strnchr((char*)vURL, wURLLen, ':');
1667:                    if(temp == NULL)
1668:                        return 2;
1669:                
1670:                    // Search protocol list to see if this is a recognized protocol
1671:                    for(prot = 0; (uint8_t)prot < sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]); prot++)
1672:                    {
1673:                        w = strlenpgm(vProtocolNames[prot]);
1674:                        if((uint16_t)(temp - vURL) == w)
1675:                        {
1676:                            w2 = 0;
1677:                            temp2 = vURL;
1678:                            while(w)
1679:                            {
1680:                                i = *temp2++;
1681:                                if((i >= 'A') && (i <= 'Z'))
1682:                                    i += 'a' - 'A';
1683:                                if(i != (uint8_t)vProtocolNames[prot][w2++])
1684:                                    break;
1685:                                w--;
1686:                            }
1687:                            if(w == 0u)
1688:                            {
1689:                                if(protocol)
1690:                                    *protocol = prot;
1691:                                break;
1692:                            }
1693:                        }
1694:                    }
1695:                
1696:                    // If we've search the whole list and didn't find a match, then
1697:                    // this protocol is unknown and this URL cannot be parsed.
1698:                    if((uint8_t)prot >= sizeof(wProtocolPorts)/sizeof(wProtocolPorts[0]))
1699:                        return 1;
1700:                
1701:                    w = temp - vURL + 1;
1702:                    vURL += w;
1703:                    wURLLen -= w;
1704:                
1705:                    // Protocols using the authority field all must have a double
1706:                    // slash "//" prefix
1707:                    if(wURLLen < 2u)
1708:                        return 2;
1709:                    for(j = 0; j < 2u; j++)
1710:                    {
1711:                        i = *vURL++;
1712:                        if(i != '/')
1713:                            return 2;
1714:                    }
1715:                    wURLLen -= 2;
1716:                
1717:                
1718:                    // Parse username and password fields
1719:                    // See if there is a @ sign, indicating that there is at
1720:                    // least a username and possibly a password in this URL
1721:                    temp = (uint8_t*)strnchr((char*)vURL, wURLLen, '@');
1722:                    if(temp == NULL)
1723:                    {
1724:                        if(wUsernameLen)
1725:                            *wUsernameLen = 0;
1726:                        if(wPasswordLen)
1727:                            *wPasswordLen = 0;
1728:                    }
1729:                    else
1730:                    {
1731:                        // If we get down here, there is a user name present, let's
1732:                        // see if a password is also present by searching for a
1733:                        // colon between the current string position and the @
1734:                        // symbol.
1735:                        temp2 = (uint8_t*)strnchr((char*)vURL, temp - vURL, ':');
1736:                
1737:                        // Calculate username length and password length, including
1738:                        // null terminator (if the field exists)
1739:                        if(temp2 == NULL)
1740:                        {
1741:                            w = temp - vURL + 1;    // Username
1742:                            w2 = 0;                 // Password
1743:                        }
1744:                        else
1745:                        {
1746:                            w = temp2 - vURL + 1;   // Username
1747:                            w2 = temp - temp2;      // Password
1748:                        }
1749:                
1750:                        if(wUsernameLen)
1751:                        {
1752:                            if(vUsername)
1753:                            {
1754:                                if(*wUsernameLen < w)
1755:                                    return 3;
1756:                                memcpy((void*)vUsername, (void*)vURL, w - 1);
1757:                                vUsername[w-1] = 0;
1758:                            }
1759:                            *wUsernameLen = w;
1760:                        }
1761:                
1762:                        if(wPasswordLen)
1763:                        {
1764:                            if(vPassword)
1765:                            {
1766:                                if(*wPasswordLen < w2)
1767:                                    return 3;
1768:                                if(w2)
1769:                                {
1770:                                    memcpy((void*)vPassword, (void*)temp2+1, w2 - 1);
1771:                                    vPassword[w2-1] = 0;
1772:                                }
1773:                            }
1774:                            *wPasswordLen = w2;
1775:                        }
1776:                
1777:                        vURL += w;
1778:                        wURLLen -= w;
1779:                        if(w2)
1780:                        {
1781:                            vURL += w2;
1782:                            wURLLen -= w2;
1783:                        }
1784:                    }
1785:                
1786:                
1787:                    // Parse hostname field
1788:                    // Find the length of the hostname, including NULL
1789:                    // terminator
1790:                    temp = (uint8_t*)strnchr((char*)vURL, wURLLen, ':');
1791:                    temp2 = (uint8_t*)strnchr((char*)vURL, wURLLen, '/');
1792:                    if(temp && temp2)
1793:                    {
1794:                        if(temp > temp2)
1795:                            temp = NULL;
1796:                    }
1797:                    if(temp == NULL)
1798:                    {
1799:                        temp = temp2;
1800:                        if(temp2 == NULL)
1801:                            temp = vURL + wURLLen;
1802:                    }
1803:                    w = temp - vURL + 1;
1804:                    if(wHostnameLen)
1805:                    {
1806:                        if(vHostname)
1807:                        {
1808:                            if(*wHostnameLen < w)
1809:                                return 3;
1810:                            memcpy((void*)vHostname, (void*)vURL, w - 1);
1811:                            vHostname[w-1] = 0;
1812:                        }
1813:                        *wHostnameLen = w;
1814:                    }
1815:                    vURL += w - 1;
1816:                    wURLLen -= w - 1;
1817:                
1818:                
1819:                    // Parse port field
1820:                    if(*vURL == ':')
1821:                    {
1822:                        vURL++;
1823:                        wURLLen--;
1824:                        wLocalPort = 0;
1825:                        w = wURLLen;
1826:                        temp = (uint8_t*)strnchr((char*)vURL, wURLLen, '/');
1827:                        if(temp != NULL)
1828:                            w = temp - vURL;
1829:                        w2 = w;
1830:                        if(wPort)
1831:                        {
1832:                            while(w--)
1833:                            {
1834:                                wLocalPort *= 10;
1835:                                wLocalPort += *vURL++ - '0';
1836:                            }
1837:                            *wPort = wLocalPort;
1838:                        }
1839:                        else
1840:                            vURL += w2;
1841:                        wURLLen -= w2;
1842:                    }
1843:                    else if(wPort)
1844:                        *wPort = wProtocolPorts[prot];
1845:                
1846:                
1847:                    // Parse file path field
1848:                    if(wFilePathLen)
1849:                    {
1850:                        w = ++wURLLen;
1851:                        if(wURLLen == 1u)
1852:                            w = 2;
1853:                        if(vFilePath)
1854:                        {
1855:                            if(*wFilePathLen < w)
1856:                                return 3;
1857:                            if(wURLLen == 1u)
1858:                                vFilePath[0] = '/';
1859:                            else
1860:                                memcpy((void*)vFilePath, (void*)vURL, wURLLen - 1);
1861:                            vFilePath[w - 1] = 0;
1862:                            *wFilePathLen = w;
1863:                            return 0;
1864:                        }
1865:                        *wFilePathLen = w;
1866:                    }
1867:                    return 0;
1868:                }
1869:                #endif
1870:                
1871:                
1872:                /*****************************************************************************
1873:                  Function:
1874:                    int16_t Replace(uint8_t *vExpression, ROM uint8_t *vFind, ROM uint8_t *vReplacement,
1875:                                  uint16_t wMaxLen, bool bSearchCaseInsensitive)
1876:                
1877:                  Summary:
1878:                    Replaces all instances of a particular substring with a new string
1879:                
1880:                  Description:
1881:                    Searches a string (vExpression) and replaces all instances of a particular
1882:                    substring (vFind) with a new string (vReplacement).  The start offset to
1883:                    being searching and a maximum number of replacements can be specified.  The
1884:                    search can be performed in a case sensitive or case insensitive manner.
1885:                
1886:                  Precondition:
1887:                    This function is commented out by default to save code space because
1888:                    it is not used by any current stack features.  However, if you want to use
1889:                    it, go ahead and uncomment it.  It has been tested, so it (should) work
1890:                    correctly.
1891:                
1892:                  Parameters:
1893:                    vExpression - Null terminated string to search and make replacements within.
1894:                    vFind - Null terminated string to search for.
1895:                    vReplacement - Null terminated string to replace all instances of vFind with.
1896:                    wMaxLen - Maximum length of the output vExpression string if string
1897:                        expansion is going to occur (replacement length is longer than find
1898:                        length).  If the replacements will cause this maximum string length to
1899:                        be exceeded, then no replacements will be made and a negative result
1900:                        will be returned, indicating failure.  If the replacement length is
1901:                        shorter or equal to the search length, then this parameter is ignored.
1902:                    bSearchCaseInsensitive - Boolean indicating if the search should be
1903:                        performed in a case insensitive manner.  Specify true for case
1904:                        insensitive searches (slower) or false for case sensitive
1905:                        searching (faster).
1906:                
1907:                  Remarks:
1908:                    If the replacement string length is shorter than or equal to the search
1909:                    string length and the search string occurs in multiple overlapping
1910:                    locations (ex\: expression is "aaa", find is "aa", and replacement is "bb")
1911:                    then the first find match occuring when searching from left to right will
1912:                    be replaced.  (ex\: output expression will be "bba").
1913:                
1914:                    However, if the replacement string length is longer than the search string
1915:                    length, the search will occur starting from the end of the string and
1916:                    proceed to the beginning (right to left searching).  In this case if the
1917:                    expression was "aaa", find was "aa", and replacement was "bbb", then the
1918:                    final output expression will be "abbb".
1919:                
1920:                  Returns:
1921:                    If zero or greater, indicates the count of how many replacements were made.
1922:                    If less than zero (negative result), indicates that wMaxLen was too small
1923:                    to make the necessary replacements.  In this case, no replacements were
1924:                    made.
1925:                  ***************************************************************************/
1926:                #if 0
1927:                int16_t Replace(uint8_t *vExpression, ROM uint8_t *vFind, ROM uint8_t *vReplacement, uint16_t wMaxLen, bool bSearchCaseInsensitive)
1928:                {
1929:                    uint16_t wExpressionLen, wFindLen, wFindLenMinusOne, wReplacementLen;
1930:                    uint16_t wFindCount, wReplacementsLeft;
1931:                    uint8_t i, j;
1932:                    uint8_t vFirstFindChar;
1933:                    uint16_t wBytesLeft;
1934:                    uint8_t *vDest;
1935:                    uint8_t *vExpressionCompare;
1936:                    ROM uint8_t *vFindCompare;
1937:                    uint16_t w;
1938:                
1939:                    wFindLen = strlenpgm((ROM char*)vFind);
1940:                    if(wFindLen == 0u)
1941:                        return 0;
1942:                
1943:                    wExpressionLen = strlen((char*)vExpression);
1944:                    wReplacementLen = strlenpgm((ROM char*)vReplacement);
1945:                
1946:                    wFindCount = 0;
1947:                    wFindLenMinusOne = wFindLen - 1;
1948:                    vFirstFindChar = *vFind++;
1949:                    if(bSearchCaseInsensitive)  // Convert to all lowercase if needed
1950:                        if((vFirstFindChar >= (uint8_t)'A') && (vFirstFindChar <= (uint8_t)'Z'))
1951:                            vFirstFindChar += 'a' - 'A';
1952:                
1953:                    // If the replacement string is the same length as the search string, then
1954:                    // we can immediately do the needed replacements inline and return.
1955:                    if(wFindLen == wReplacementLen)
1956:                    {
1957:                        for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
1958:                        {
1959:                            i = *vExpression++;
1960:                            if(bSearchCaseInsensitive)
1961:                            {
1962:                                if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
1963:                                    i += 'a' - 'A';
1964:                                if(i != vFirstFindChar)
1965:                                    continue;
1966:                                vExpressionCompare = vExpression;
1967:                                vFindCompare = vFind;
1968:                                w = wFindLenMinusOne;
1969:                                while(w)
1970:                                {
1971:                                    i = *vExpressionCompare++;
1972:                                    j = *vFindCompare++;
1973:                                    if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
1974:                                        i += 'a' - 'A';
1975:                                    if((j >= (uint8_t)'A') && (j <= (uint8_t)'Z'))
1976:                                        j += 'a' - 'A';
1977:                                    if(i != j)
1978:                                        break;
1979:                                    w--;
1980:                                }
1981:                                if(w)
1982:                                    continue;
1983:                            }
1984:                            else
1985:                            {
1986:                                if(i != vFirstFindChar)
1987:                                    continue;
1988:                                if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
1989:                                    continue;
1990:                            }
1991:                
1992:                            memcpypgm2ram((void*)vExpression-1, (ROM void*)vReplacement, wReplacementLen);
1993:                            wFindCount++;
1994:                            vExpression += wFindLenMinusOne;
1995:                            wBytesLeft -= wFindLenMinusOne;
1996:                        }
1997:                        return wFindCount;
1998:                    }
1999:                
2000:                
2001:                    // If the replacement string is shorter than the search string, then we can
2002:                    // search from left to right and move the string over as we find occurrences.
2003:                    if(wFindLen > wReplacementLen)
2004:                    {
2005:                        vDest = vExpression;
2006:                        for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
2007:                        {
2008:                            i = *vExpression++;
2009:                            *vDest++ = i;
2010:                            if(bSearchCaseInsensitive)
2011:                            {
2012:                                if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
2013:                                    i += 'a' - 'A';
2014:                                if(i != vFirstFindChar)
2015:                                    continue;
2016:                                vExpressionCompare = vExpression;
2017:                                vFindCompare = vFind;
2018:                                w = wFindLenMinusOne;
2019:                                while(w)
2020:                                {
2021:                                    i = *vExpressionCompare++;
2022:                                    j = *vFindCompare++;
2023:                                    if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
2024:                                        i += 'a' - 'A';
2025:                                    if((j >= (uint8_t)'A') && (j <= (uint8_t)'Z'))
2026:                                        j += 'a' - 'A';
2027:                                    if(i != j)
2028:                                        break;
2029:                                    w--;
2030:                                }
2031:                                if(w)
2032:                                    continue;
2033:                            }
2034:                            else
2035:                            {
2036:                                if(i != vFirstFindChar)
2037:                                    continue;
2038:                                if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2039:                                    continue;
2040:                            }
2041:                
2042:                            memcpypgm2ram((void*)vDest-1, (ROM void*)vReplacement, wReplacementLen);
2043:                            vDest += wReplacementLen-1;
2044:                            wFindCount++;
2045:                            vExpression += wFindLenMinusOne;
2046:                            wBytesLeft -= wFindLenMinusOne;
2047:                        }
2048:                        *vDest = 0x00;  // Write new null terminator since the string may have shrunk
2049:                        return wFindCount;
2050:                    }
2051:                
2052:                    // If the replacement string is longer than the search string, then we will
2053:                    // take a two pass approach.  On the first pass, we will merely count how
2054:                    // many replacements to make.  With this we can calculate how long the
2055:                    // final string is going to be.  On the second pass, we will search from
2056:                    // right to left and expand the string as needed.
2057:                
2058:                    // Pass 1: count how many occurrences of vFind are in vExpression
2059:                    for(wBytesLeft = wExpressionLen; wBytesLeft; wBytesLeft--)
2060:                    {
2061:                        i = *vExpression++;
2062:                        if(bSearchCaseInsensitive)
2063:                        {
2064:                            if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
2065:                                i += 'a' - 'A';
2066:                            if(i != vFirstFindChar)
2067:                                continue;
2068:                            vExpressionCompare = vExpression;
2069:                            vFindCompare = vFind;
2070:                            w = wFindLenMinusOne;
2071:                            while(w)
2072:                            {
2073:                                i = *vExpressionCompare++;
2074:                                j = *vFindCompare++;
2075:                                if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
2076:                                    i += 'a' - 'A';
2077:                                if((j >= (uint8_t)'A') && (j <= (uint8_t)'Z'))
2078:                                    j += 'a' - 'A';
2079:                                if(i != j)
2080:                                    break;
2081:                                w--;
2082:                            }
2083:                            if(w)
2084:                                continue;
2085:                        }
2086:                        else
2087:                        {
2088:                            if(i != vFirstFindChar)
2089:                                continue;
2090:                            if(memcmppgm2ram((void*)vExpression, (ROM void*)vFind, wFindLenMinusOne))
2091:                                continue;
2092:                        }
2093:                
2094:                        wFindCount++;
2095:                        vExpression += wFindLenMinusOne;
2096:                        wBytesLeft -= wFindLenMinusOne;
2097:                    }
2098:                
2099:                    // Return immediately if no replacements are needed
2100:                    if(wFindCount == 0u)
2101:                        return 0;
2102:                
2103:                    // Pass 2: make replacements and move string over
2104:                    vDest = vExpression + wFindCount * (wReplacementLen - wFindLen);
2105:                    if(vDest > vExpression - wExpressionLen + wMaxLen)
2106:                        return -1;
2107:                    *vDest-- = 0x00;    // Write new null terminator
2108:                    vExpression -= 1;
2109:                    vFind -= 1;
2110:                    vFirstFindChar = vFind[wFindLenMinusOne];
2111:                    if(bSearchCaseInsensitive)  // Convert to all lowercase if needed
2112:                        if((vFirstFindChar >= (uint8_t)'A') && (vFirstFindChar <= (uint8_t)'Z'))
2113:                            vFirstFindChar += 'a' - 'A';
2114:                    wReplacementsLeft = wFindCount;
2115:                    while(wReplacementsLeft)
2116:                    {
2117:                        i = *vExpression--;
2118:                        *vDest-- = i;
2119:                        if(bSearchCaseInsensitive)
2120:                        {
2121:                            if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
2122:                                i += 'a' - 'A';
2123:                            if(i != vFirstFindChar)
2124:                                continue;
2125:                            vExpressionCompare = vExpression;
2126:                            vFindCompare = &vFind[wFindLenMinusOne-1];
2127:                            w = wFindLenMinusOne;
2128:                            while(w)
2129:                            {
2130:                                i = *vExpressionCompare--;
2131:                                j = *vFindCompare--;
2132:                                if((i >= (uint8_t)'A') && (i <= (uint8_t)'Z'))
2133:                                    i += 'a' - 'A';
2134:                                if((j >= (uint8_t)'A') && (j <= (uint8_t)'Z'))
2135:                                    j += 'a' - 'A';
2136:                                if(i != j)
2137:                                    break;
2138:                                w--;
2139:                            }
2140:                            if(w)
2141:                                continue;
2142:                        }
2143:                        else
2144:                        {
2145:                            if(i != vFirstFindChar)
2146:                                continue;
2147:                            if(memcmppgm2ram((void*)vExpression-wFindLenMinusOne, (ROM void*)vFind, wFindLenMinusOne))
2148:                                continue;
2149:                        }
2150:                        memcpypgm2ram((void*)vDest-wReplacementLen+2, (ROM void*)vReplacement, wReplacementLen);
2151:                        vDest -= wReplacementLen-1;
2152:                
2153:                        vExpression -= wFindLenMinusOne;
2154:                        wBytesLeft -= wFindLenMinusOne;
2155:                        wReplacementsLeft--;
2156:                    }
2157:                    return wFindCount;
2158:                }
2159:                #endif
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/eth_pic32_int_mac.c  --------------------
1:                   /*********************************************************************
2:                    *
3:                    *     MAC Module (Microchip PIC32MX5-7) for Microchip TCP/IP Stack
4:                    *
5:                    *********************************************************************
6:                    * FileName:        ETHPIC32IntMac.c
7:                    * Dependencies:    see the include section below
8:                    *
9:                    * Processor:       PIC32MX
10:                   *
11:                   * Company:         Microchip Technology, Inc.
12:                   *
13:                   * Software License Agreement
14:                   *
15:                   * The software supplied herewith by Microchip Technology Incorporated
16:                   * (the ?Company?) for its PICmicro Microcontroller is intended and
17:                   * supplied to you, the Company?s customer, for use solely and
18:                   * exclusively on Microchip PICmicro Microcontroller products. The
19:                   * software is owned by the Company and/or its supplier, and is
20:                   * protected under applicable copyright laws. All rights are reserved.
21:                   * Any use in violation of the foregoing restrictions may subject the
22:                   * user to criminal sanctions under applicable laws, as well as to
23:                   * civil liability for the breach of the terms and conditions of this
24:                   * license.
25:                   *
26:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
27:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
28:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
29:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
30:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
31:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
32:                   *
33:                   * $Id: $
34:                   *
35:                   ********************************************************************/
36:                  #include <string.h>
37:                  
38:                  
39:                  #include "tcpip/tcpip.h"
40:                  #include "tcpip/mac.h"
41:                  
42:                  
43:                  // Compile only for PIC32MX with Ethernet MAC interface (must not have external ENCX24J600, ENC28J60, or MRF24WB0M hardware defined)
44:                  #if defined(__PIC32MX__) && defined(_ETH) && !defined(ENC100_INTERFACE_MODE) && !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS)
45:                  
46:                  // running on PIC32MX5-7 family with embedded ETHC
47:                  
48:                  #include <peripheral/eth.h>
49:                  
50:                  #include "tcpip/eth_pic32_ext_phy.h"
51:                  
52:                  /** D E F I N I T I O N S ****************************************************/
53:                  
54:                  
55:                  #define ETHER_IP    (0x00u)
56:                  #define ETHER_ARP   (0x06u)
57:                  
58:                  
59:                  #define	LINK_REFRESH_MS	100		// refresh link status time, ms
60:                  
61:                  typedef struct {
62:                      int txBusy; // busy flag
63:                      unsigned int dataBuff[(MAC_TX_BUFFER_SIZE + sizeof (ETHER_HEADER) + sizeof (int) - 1) / sizeof (int) ]; // actual data buffer
64:                  } sEthTxDcpt; // TX buffer descriptor
65:                  
66:                  /******************************************************************************
67:                   * Prototypes
68:                   ******************************************************************************/
69:                  static void _TxAckCallback(void* pPktBuff, int buffIx, void* fParam); // Eth tx buffer acnowledge function
70:                  //static int _LinkReconfigure(void); // link reconfiguration
71:                  
72:                  static void* _MacAllocCallback(size_t nitems, size_t size, void* param);
73:                  
74:                  
75:                  // TX buffers
76:                  static volatile sEthTxDcpt _TxDescriptors[EMAC_TX_DESCRIPTORS]; // the statically allocated TX buffers
77:                  static volatile sEthTxDcpt* _pTxCurrDcpt = 0; // the current TX buffer
78:                  static int _TxLastDcptIx = 0; // the last TX descriptor used
79:                  static unsigned short int _TxCurrSize = 0; // the current TX buffer size
80:                  
81:                  
82:                  // RX buffers
83:                  static unsigned char _RxBuffers[EMAC_RX_DESCRIPTORS][EMAC_RX_BUFF_SIZE]; // rx buffers for incoming data
84:                  static unsigned char* _pRxCurrBuff = 0; // the current RX buffer
85:                  static unsigned short int _RxCurrSize = 0; // the current RX buffer size
86:                  
87:                  
88:                  
89:                  // HTTP +SSL buffers
90:                  static unsigned char _HttpSSlBuffer[RESERVED_HTTP_MEMORY + RESERVED_SSL_MEMORY];
91:                  
92:                  
93:                  // general stuff
94:                  static unsigned char* _CurrWrPtr = 0; // the current write pointer
95:                  static unsigned char* _CurrRdPtr = 0; // the current read pointer
96:                  
97:                  
98:                  // timing and link status maintenance
99:                  static DWORD _linkUpdTick; // last tick value when the link update was started
100:                 static eEthLinkStat _linkPrev; // last value of the link status
101:                 static int _linkPresent; // if connection to the PHY properly detected
102:                 static int _linkNegotiation; // if an auto-negotiation is in effect
103:                 
104:                 // run time statistics
105:                 /*static*/ int _stackMgrRxOkPkts = 0;
106:                 /*static*/ int _stackMgrRxBadPkts = 0;
107:                 /*static*/ int _stackMgrInGetHdr = 0;
108:                 /*static*/ int _stackMgrRxDiscarded = 0;
109:                 /*static*/ int _stackMgrTxNotReady = 0;
110:                 
111:                 
112:                 /*
113:                  * interface functions
114:                  *
115:                  */
116:                 
117:                 /****************************************************************************
118:                  * Function:        MACInit
119:                  *
120:                  * PreCondition:    None
121:                  *
122:                  * Input:           None
123:                  *
124:                  * Output:          None
125:                  *
126:                  * Side Effects:    None
127:                  *
128:                  * Overview:        This function initializes the Eth controller, the MAC and the PHY. It should be called to be able to schedule
129:                  *                  any Eth transmit or receive operation.
130:                  *
131:                  * Note:            None
132:                  *****************************************************************************/
133:                 void MACInit(void)
134:                 {
9D011070  27BDFFA0   ADDIU SP, SP, -96
9D011074  AFBF005C   SW RA, 92(SP)
9D011078  AFBE0058   SW S8, 88(SP)
9D01107C  03A0F021   ADDU S8, SP, ZERO
135:                     union {
136:                         double align; // alignement
137:                         BYTE addr[6]; // address itself
138:                     } SysMACAddr; // aligned MAC address
139:                 
140:                     int ix;
141:                     eEthRes ethRes, phyInitRes;
142:                     BYTE useFactMACAddr[6] = {0x00, 0x04, 0xa3, 0x00, 0x00, 0x00}; // to check if factory programmed MAC address needed
9D011080  3C029D02   LUI V0, -25342
9D011084  8C43C384   LW V1, -15484(V0)
9D011088  AFC3003C   SW V1, 60(S8)
9D01108C  2442C384   ADDIU V0, V0, -15484
9D011090  94420004   LHU V0, 4(V0)
9D011094  A7C20040   SH V0, 64(S8)
143:                     BYTE unsetMACAddr[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00}; // not set MAC address
9D011098  A3C00044   SB ZERO, 68(S8)
9D01109C  A3C00045   SB ZERO, 69(S8)
9D0110A0  A3C00046   SB ZERO, 70(S8)
9D0110A4  A3C00047   SB ZERO, 71(S8)
9D0110A8  A3C00048   SB ZERO, 72(S8)
9D0110AC  A3C00049   SB ZERO, 73(S8)
144:                 
145:                     int initFail = 0;
9D0110B0  AFC00018   SW ZERO, 24(S8)
146:                 
147:                     _stackMgrRxBadPkts = _stackMgrRxOkPkts = _stackMgrInGetHdr = _stackMgrRxDiscarded = 0;
9D0110B4  AF808090   SW ZERO, -32624(GP)
9D0110B8  8F828090   LW V0, -32624(GP)
9D0110BC  AF82808C   SW V0, -32628(GP)
9D0110C0  8F82808C   LW V0, -32628(GP)
9D0110C4  AF828084   SW V0, -32636(GP)
9D0110C8  8F828084   LW V0, -32636(GP)
9D0110CC  AF828088   SW V0, -32632(GP)
148:                     _CurrWrPtr = _CurrRdPtr = 0;
9D0110D0  AF808070   SW ZERO, -32656(GP)
9D0110D4  8F828070   LW V0, -32656(GP)
9D0110D8  AF82806C   SW V0, -32660(GP)
149:                 
150:                     // set the TX/RX pointers
151:                     for (ix = 0; ix<sizeof (_TxDescriptors) / sizeof (*_TxDescriptors); ix++)
9D0110DC  AFC00010   SW ZERO, 16(S8)
9D0110E0  0B404449   J 0x9D011124
9D0110E4  00000000   NOP
9D011118  8FC20010   LW V0, 16(S8)
9D01111C  24420001   ADDIU V0, V0, 1
9D011120  AFC20010   SW V0, 16(S8)
9D011124  8FC20010   LW V0, 16(S8)
9D011128  2C420002   SLTIU V0, V0, 2
9D01112C  1440FFEE   BNE V0, ZERO, 0x9D0110E8
9D011130  00000000   NOP
152:                     {
153:                         _TxDescriptors[ix].txBusy = 0;
9D0110E8  3C05A000   LUI A1, -24576
9D0110EC  8FC40010   LW A0, 16(S8)
9D0110F0  00801821   ADDU V1, A0, ZERO
9D0110F4  00031140   SLL V0, V1, 5
9D0110F8  00401821   ADDU V1, V0, ZERO
9D0110FC  00031080   SLL V0, V1, 2
9D011100  00431023   SUBU V0, V0, V1
9D011104  00441023   SUBU V0, V0, A0
9D011108  00021100   SLL V0, V0, 4
9D01110C  24A3090C   ADDIU V1, A1, 2316
9D011110  00431021   ADDU V0, V0, V1
9D011114  AC400000   SW ZERO, 0(V0)
154:                     }
155:                     _pTxCurrDcpt = _TxDescriptors + 0;
9D011134  3C02A000   LUI V0, -24576
9D011138  2442090C   ADDIU V0, V0, 2316
9D01113C  AF828058   SW V0, -32680(GP)
156:                     _TxLastDcptIx = 0;
9D011140  AF80805C   SW ZERO, -32676(GP)
157:                     _TxCurrSize = 0;
9D011144  A7808060   SH ZERO, -32672(GP)
158:                 
159:                     _pRxCurrBuff = 0;
9D011148  AF808064   SW ZERO, -32668(GP)
160:                     _RxCurrSize = 0;
9D01114C  A7808068   SH ZERO, -32664(GP)
161:                 
162:                     _linkNegotiation = _linkPresent = 0;
9D011150  AF80807C   SW ZERO, -32644(GP)
9D011154  8F82807C   LW V0, -32644(GP)
9D011158  AF828080   SW V0, -32640(GP)
163:                     _linkPrev = ETH_LINK_ST_DOWN;
9D01115C  AF808078   SW ZERO, -32648(GP)
164:                 
165:                     while (1)
166:                     {
167:                         eEthLinkStat linkStat;
168:                         eEthOpenFlags oFlags, linkFlags;
169:                         eEthMacPauseType pauseType;
170:                         eEthPhyCfgFlags cfgFlags;
171:                 
172:                         #ifdef PHY_RMII
173:                             cfgFlags = ETH_PHY_CFG_RMII;
174:                         #else
175:                             cfgFlags = ETH_PHY_CFG_MII;
9D011160  AFC0001C   SW ZERO, 28(S8)
176:                         #endif
177:                 
178:                         #ifdef PHY_CONFIG_ALTERNATE
179:                             cfgFlags |= ETH_PHY_CFG_ALTERNATE;
180:                         #else
181:                             cfgFlags |= ETH_PHY_CFG_DEFAULT;
182:                         #endif
183:                 
184:                         pauseType = ETH_MAC_PAUSE_CPBL_MASK;
9D011164  2402000F   ADDIU V0, ZERO, 15
9D011168  AFC20020   SW V0, 32(S8)
185:                 
186:                         // start the initialization sequence
187:                         EthInit();
9D01116C  0F406C31   JAL EthInit
9D011170  00000000   NOP
188:                 
189:                         oFlags = 0;
9D011174  AFC00024   SW ZERO, 36(S8)
190:                         phyInitRes = EthPhyInit(oFlags, cfgFlags, &linkFlags);
9D011178  27C2004C   ADDIU V0, S8, 76
9D01117C  8FC40024   LW A0, 36(S8)
9D011180  8FC5001C   LW A1, 28(S8)
9D011184  00403021   ADDU A2, V0, ZERO
9D011188  0F40591D   JAL EthPhyInit
9D01118C  00000000   NOP
9D011190  AFC20028   SW V0, 40(S8)
191:                 
192:                         // let the auto-negotiation (if any) take place
193:                         // continue the initialization
194:                         EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
9D011194  3404C0FF   ORI A0, ZERO, -16129
9D011198  0F4070CF   JAL EthRxFiltersClr
9D01119C  00000000   NOP
195:                         EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT | ETH_FILT_RUNT_REJECT | 
9D0111A0  24040059   ADDIU A0, ZERO, 89
9D0111A4  0F4070CB   JAL EthRxFiltersSet
9D0111A8  00000000   NOP
196:                                 ETH_FILT_ME_UCAST_ACCEPT | // ETH_FILT_MCAST_ACCEPT |
197:                                 ETH_FILT_BCAST_ACCEPT);
198:                 
199:                         // set the MAC address
200:                         memcpy(SysMACAddr.addr, AppConfig.MyMACAddr.v, sizeof (SysMACAddr.addr));
9D0111AC  27C20034   ADDIU V0, S8, 52
9D0111B0  00402021   ADDU A0, V0, ZERO
9D0111B4  3C02A000   LUI V0, -24576
9D0111B8  24450905   ADDIU A1, V0, 2309
9D0111BC  24060006   ADDIU A2, ZERO, 6
9D0111C0  0F406788   JAL 0x9D019E20
9D0111C4  00000000   NOP
201:                         if (memcmp(SysMACAddr.addr, useFactMACAddr, sizeof (useFactMACAddr)) == 0 || memcmp(SysMACAddr.addr, unsetMACAddr, sizeof (unsetMACAddr)) == 0)
9D0111C8  27C30034   ADDIU V1, S8, 52
9D0111CC  27C2003C   ADDIU V0, S8, 60
9D0111D0  00602021   ADDU A0, V1, ZERO
9D0111D4  00402821   ADDU A1, V0, ZERO
9D0111D8  24060006   ADDIU A2, ZERO, 6
9D0111DC  0F406D65   JAL 0x9D01B594
9D0111E0  00000000   NOP
9D0111E4  1040000A   BEQ V0, ZERO, 0x9D011210
9D0111E8  00000000   NOP
9D0111EC  27C30034   ADDIU V1, S8, 52
9D0111F0  27C20044   ADDIU V0, S8, 68
9D0111F4  00602021   ADDU A0, V1, ZERO
9D0111F8  00402821   ADDU A1, V0, ZERO
9D0111FC  24060006   ADDIU A2, ZERO, 6
9D011200  0F406D65   JAL 0x9D01B594
9D011204  00000000   NOP
9D011208  14400021   BNE V0, ZERO, 0x9D011290
9D01120C  00000000   NOP
202:                         {
9D011288  0B4044A8   J 0x9D0112A0
9D01128C  00000000   NOP
203:                             // use the factory programmed address existent in the MAC
204:                             unsigned short* pS = (unsigned short*) SysMACAddr.addr;
9D011210  27C20034   ADDIU V0, S8, 52
9D011214  AFC2002C   SW V0, 44(S8)
205:                             *pS++ = EMACxSA2;
9D011218  3C02BF89   LUI V0, -16503
9D01121C  8C429320   LW V0, -27872(V0)
9D011220  3043FFFF   ANDI V1, V0, -1
9D011224  8FC2002C   LW V0, 44(S8)
9D011228  A4430000   SH V1, 0(V0)
9D01122C  8FC2002C   LW V0, 44(S8)
9D011230  24420002   ADDIU V0, V0, 2
9D011234  AFC2002C   SW V0, 44(S8)
206:                             *pS++ = EMACxSA1;
9D011238  3C02BF89   LUI V0, -16503
9D01123C  8C429310   LW V0, -27888(V0)
9D011240  3043FFFF   ANDI V1, V0, -1
9D011244  8FC2002C   LW V0, 44(S8)
9D011248  A4430000   SH V1, 0(V0)
9D01124C  8FC2002C   LW V0, 44(S8)
9D011250  24420002   ADDIU V0, V0, 2
9D011254  AFC2002C   SW V0, 44(S8)
207:                             *pS = EMACxSA0;
9D011258  3C02BF89   LUI V0, -16503
9D01125C  8C429300   LW V0, -27904(V0)
9D011260  3043FFFF   ANDI V1, V0, -1
9D011264  8FC2002C   LW V0, 44(S8)
9D011268  A4430000   SH V1, 0(V0)
208:                             memcpy(AppConfig.MyMACAddr.v, SysMACAddr.addr, sizeof (SysMACAddr.addr));
9D01126C  27C20034   ADDIU V0, S8, 52
9D011270  3C03A000   LUI V1, -24576
9D011274  24640905   ADDIU A0, V1, 2309
9D011278  00402821   ADDU A1, V0, ZERO
9D01127C  24060006   ADDIU A2, ZERO, 6
9D011280  0F406788   JAL 0x9D019E20
9D011284  00000000   NOP
209:                         }
210:                         else
211:                         {
212:                             // use the supplied address
213:                             EthMACSetAddress(SysMACAddr.addr);
9D011290  27C20034   ADDIU V0, S8, 52
9D011294  00402021   ADDU A0, V0, ZERO
9D011298  0F406EE8   JAL EthMACSetAddress
9D01129C  00000000   NOP
214:                         }
215:                 
216:                         if (EthDescriptorsPoolAdd(EMAC_TX_DESCRIPTORS, ETH_DCPT_TYPE_TX, _MacAllocCallback, 0) != EMAC_TX_DESCRIPTORS)
9D0112A0  24040002   ADDIU A0, ZERO, 2
9D0112A4  24050002   ADDIU A1, ZERO, 2
9D0112A8  3C029D01   LUI V0, -25343
9D0112AC  24461DB0   ADDIU A2, V0, 7600
9D0112B0  00003821   ADDU A3, ZERO, ZERO
9D0112B4  0F406936   JAL EthDescriptorsPoolAdd
9D0112B8  00000000   NOP
9D0112BC  00401821   ADDU V1, V0, ZERO
9D0112C0  24020002   ADDIU V0, ZERO, 2
9D0112C4  10620004   BEQ V1, V0, 0x9D0112D8
9D0112C8  00000000   NOP
217:                         {
218:                             initFail++;
9D0112CC  8FC20018   LW V0, 24(S8)
9D0112D0  24420001   ADDIU V0, V0, 1
9D0112D4  AFC20018   SW V0, 24(S8)
219:                         }
220:                 
221:                         if (EthDescriptorsPoolAdd(EMAC_RX_DESCRIPTORS, ETH_DCPT_TYPE_RX, _MacAllocCallback, 0) != EMAC_RX_DESCRIPTORS)
9D0112D8  24040008   ADDIU A0, ZERO, 8
9D0112DC  24050001   ADDIU A1, ZERO, 1
9D0112E0  3C029D01   LUI V0, -25343
9D0112E4  24461DB0   ADDIU A2, V0, 7600
9D0112E8  00003821   ADDU A3, ZERO, ZERO
9D0112EC  0F406936   JAL EthDescriptorsPoolAdd
9D0112F0  00000000   NOP
9D0112F4  00401821   ADDU V1, V0, ZERO
9D0112F8  24020008   ADDIU V0, ZERO, 8
9D0112FC  10620004   BEQ V1, V0, 0x9D011310
9D011300  00000000   NOP
222:                         {
223:                             initFail++;
9D011304  8FC20018   LW V0, 24(S8)
9D011308  24420001   ADDIU V0, V0, 1
9D01130C  AFC20018   SW V0, 24(S8)
224:                         }
225:                 
226:                         EthRxSetBufferSize(EMAC_RX_BUFF_SIZE);
9D011310  24040600   ADDIU A0, ZERO, 1536
9D011314  0F407009   JAL EthRxSetBufferSize
9D011318  00000000   NOP
227:                 
228:                         // set the RX buffers as permanent receive buffers
229:                         for (ix = 0, ethRes = ETH_RES_OK; ix < EMAC_RX_DESCRIPTORS && ethRes == ETH_RES_OK; ix++)
9D01131C  AFC00010   SW ZERO, 16(S8)
9D011320  AFC00014   SW ZERO, 20(S8)
9D011324  0B4044DD   J 0x9D011374
9D011328  00000000   NOP
9D011368  8FC20010   LW V0, 16(S8)
9D01136C  24420001   ADDIU V0, V0, 1
9D011370  AFC20010   SW V0, 16(S8)
9D011374  8FC20010   LW V0, 16(S8)
9D011378  28420008   SLTI V0, V0, 8
9D01137C  10400004   BEQ V0, ZERO, 0x9D011390
9D011380  00000000   NOP
9D011384  8FC20014   LW V0, 20(S8)
9D011388  1040FFE8   BEQ V0, ZERO, 0x9D01132C
9D01138C  00000000   NOP
230:                         {
231:                             void* pRxBuff = _RxBuffers[ix];
9D01132C  8FC20010   LW V0, 16(S8)
9D011330  00021240   SLL V0, V0, 9
9D011334  00021880   SLL V1, V0, 2
9D011338  00621823   SUBU V1, V1, V0
9D01133C  3C02A000   LUI V0, -24576
9D011340  244214EC   ADDIU V0, V0, 5356
9D011344  00621021   ADDU V0, V1, V0
9D011348  AFC20050   SW V0, 80(S8)
232:                             ethRes = EthRxBuffersAppend(&pRxBuff, 1, ETH_BUFF_FLAG_RX_STICKY);
9D01134C  27C20050   ADDIU V0, S8, 80
9D011350  00402021   ADDU A0, V0, ZERO
9D011354  24050001   ADDIU A1, ZERO, 1
9D011358  24060001   ADDIU A2, ZERO, 1
9D01135C  0F4062FA   JAL EthRxBuffersAppend
9D011360  00000000   NOP
9D011364  AFC20014   SW V0, 20(S8)
233:                         }
234:                 
235:                         if (ethRes != ETH_RES_OK)
9D011390  8FC20014   LW V0, 20(S8)
9D011394  10400004   BEQ V0, ZERO, 0x9D0113A8
9D011398  00000000   NOP
236:                         {
237:                             initFail++;
9D01139C  8FC20018   LW V0, 24(S8)
9D0113A0  24420001   ADDIU V0, V0, 1
9D0113A4  AFC20018   SW V0, 24(S8)
238:                         }
239:                 
240:                         // Update the MAC.
241:                         EthMACOpen(linkFlags, pauseType);
9D0113A8  8FC2004C   LW V0, 76(S8)
9D0113AC  00402021   ADDU A0, V0, ZERO
9D0113B0  8FC50020   LW A1, 32(S8)
9D0113B4  0F406C5E   JAL EthMACOpen
9D0113B8  00000000   NOP
242:                         linkStat = ETH_LINK_ST_UP;
9D0113BC  24020001   ADDIU V0, ZERO, 1
9D0113C0  AFC20030   SW V0, 48(S8)
243:                 
244:                         _linkUpdTick = TickGet(); // the last time we performed the link read
9D0113C4  0F405C42   JAL TickGet
9D0113C8  00000000   NOP
9D0113CC  AF828074   SW V0, -32652(GP)
245:                         _linkPrev = linkStat;
9D0113D0  8FC20030   LW V0, 48(S8)
9D0113D4  AF828078   SW V0, -32648(GP)
246:                 
247:                         break;
248:                     }
249:                 
250:                     //	return !initFail;	// at this point initFail gives some indication of any existent problems
251:                 }
9D0113D8  03C0E821   ADDU SP, S8, ZERO
9D0113DC  8FBF005C   LW RA, 92(SP)
9D0113E0  8FBE0058   LW S8, 88(SP)
9D0113E4  27BD0060   ADDIU SP, SP, 96
9D0113E8  03E00008   JR RA
9D0113EC  00000000   NOP
252:                 
253:                 /****************************************************************************
254:                  * Function:        MACIsLinked
255:                  *
256:                  * PreCondition:    None
257:                  *
258:                  * Input:           None
259:                  *
260:                  * Output:          TRUE if link is up
261:                  *                  FALSE otherwise
262:                  *
263:                  * Side Effects:    None
264:                  *
265:                  * Overview:        This function checks the link status
266:                  *
267:                  * Note:            None
268:                  *****************************************************************************/
269:                 bool MACIsLinked(void) {
9D0113F0  27BDFFF8   ADDIU SP, SP, -8
9D0113F4  AFBE0004   SW S8, 4(SP)
9D0113F8  03A0F021   ADDU S8, SP, ZERO
270:                     return (_linkPrev & ETH_LINK_ST_UP) != 0;
9D0113FC  8F828078   LW V0, -32648(GP)
9D011400  30420001   ANDI V0, V0, 1
9D011404  0002102B   SLTU V0, ZERO, V0
9D011408  304200FF   ANDI V0, V0, 255
271:                 }
9D01140C  03C0E821   ADDU SP, S8, ZERO
9D011410  8FBE0004   LW S8, 4(SP)
9D011414  27BD0008   ADDIU SP, SP, 8
9D011418  03E00008   JR RA
9D01141C  00000000   NOP
272:                 
273:                 /****************************************************************************
274:                  * Function:        MACGetTxBaseAddr
275:                  *
276:                  * PreCondition:    None
277:                  *
278:                  * Input:           None
279:                  *
280:                  * Output:          TX buffer base address
281:                  *
282:                  * Side Effects:    None
283:                  *
284:                  * Overview:        This function returns the address of the current TX buffer.
285:                  *
286:                  * Note:            The returned value could be 0 if currently there's no available TX buffer.
287:                  *****************************************************************************/
288:                 PTR_BASE MACGetTxBaseAddr(void) {
9D011420  27BDFFF8   ADDIU SP, SP, -8
9D011424  AFBE0004   SW S8, 4(SP)
9D011428  03A0F021   ADDU S8, SP, ZERO
289:                     return _pTxCurrDcpt ? (PTR_BASE) _pTxCurrDcpt->dataBuff : 0;
9D01142C  8F828058   LW V0, -32680(GP)
9D011430  10400005   BEQ V0, ZERO, 0x9D011448
9D011434  00000000   NOP
9D011438  8F828058   LW V0, -32680(GP)
9D01143C  24420004   ADDIU V0, V0, 4
9D011440  0B404513   J 0x9D01144C
9D011444  00000000   NOP
9D011448  00001021   ADDU V0, ZERO, ZERO
290:                 }
9D01144C  03C0E821   ADDU SP, S8, ZERO
9D011450  8FBE0004   LW S8, 4(SP)
9D011454  27BD0008   ADDIU SP, SP, 8
9D011458  03E00008   JR RA
9D01145C  00000000   NOP
291:                 
292:                 /****************************************************************************
293:                  * Function:        MACGetHttpBaseAddr
294:                  *
295:                  * PreCondition:    None
296:                  *
297:                  * Input:           None
298:                  *
299:                  * Output:          HTTP buffer base address
300:                  *
301:                  * Side Effects:    None
302:                  *
303:                  * Overview:        This function returns the address of the HTTP buffer.
304:                  *
305:                  * Note:            The HTTP buffer is a static one, always available.
306:                  *****************************************************************************/
307:                 PTR_BASE MACGetHttpBaseAddr(void) {
9D011460  27BDFFF8   ADDIU SP, SP, -8
9D011464  AFBE0004   SW S8, 4(SP)
9D011468  03A0F021   ADDU S8, SP, ZERO
308:                     return (PTR_BASE) _HttpSSlBuffer;
9D01146C  3C02A000   LUI V0, -24576
9D011470  244244EC   ADDIU V0, V0, 17644
309:                 }
9D011474  03C0E821   ADDU SP, S8, ZERO
9D011478  8FBE0004   LW S8, 4(SP)
9D01147C  27BD0008   ADDIU SP, SP, 8
9D011480  03E00008   JR RA
9D011484  00000000   NOP
310:                 
311:                 /****************************************************************************
312:                  * Function:        MACGetSslBaseAddr
313:                  *
314:                  * PreCondition:    None
315:                  *
316:                  * Input:           None
317:                  *
318:                  * Output:          SSL buffer base address
319:                  *
320:                  * Side Effects:    None
321:                  *
322:                  * Overview:        This function returns the address of the SSL buffer.
323:                  *
324:                  * Note:            The SSL buffer is a static one, always available.
325:                  *****************************************************************************/
326:                 PTR_BASE MACGetSslBaseAddr(void) {
9D011488  27BDFFF8   ADDIU SP, SP, -8
9D01148C  AFBE0004   SW S8, 4(SP)
9D011490  03A0F021   ADDU S8, SP, ZERO
327:                     return (PTR_BASE) (_HttpSSlBuffer + RESERVED_HTTP_MEMORY);
9D011494  3C02A000   LUI V0, -24576
9D011498  24424D3C   ADDIU V0, V0, 19772
328:                 }
9D01149C  03C0E821   ADDU SP, S8, ZERO
9D0114A0  8FBE0004   LW S8, 4(SP)
9D0114A4  27BD0008   ADDIU SP, SP, 8
9D0114A8  03E00008   JR RA
9D0114AC  00000000   NOP
329:                 
330:                 
331:                 /**************************
332:                  * TX functions
333:                  ***********************************************/
334:                 
335:                 /****************************************************************************
336:                  * Function:        MACSetWritePtr
337:                  *
338:                  * PreCondition:    None
339:                  *
340:                  * Input:           None
341:                  *
342:                  * Output:          old write pointer
343:                  *
344:                  * Side Effects:    None
345:                  *
346:                  * Overview:        This function sets the new write pointer.
347:                  *
348:                  * Note:            None
349:                  *****************************************************************************/
350:                 PTR_BASE MACSetWritePtr(PTR_BASE address) {
9D0114B0  27BDFFF0   ADDIU SP, SP, -16
9D0114B4  AFBE000C   SW S8, 12(SP)
9D0114B8  03A0F021   ADDU S8, SP, ZERO
9D0114BC  AFC40010   SW A0, 16(S8)
351:                     unsigned char* oldPtr;
352:                 
353:                     oldPtr = _CurrWrPtr;
9D0114C0  8F82806C   LW V0, -32660(GP)
9D0114C4  AFC20000   SW V0, 0(S8)
354:                     _CurrWrPtr = (unsigned char*) address;
9D0114C8  8FC20010   LW V0, 16(S8)
9D0114CC  AF82806C   SW V0, -32660(GP)
355:                     return (PTR_BASE) oldPtr;
9D0114D0  8FC20000   LW V0, 0(S8)
356:                 }
9D0114D4  03C0E821   ADDU SP, S8, ZERO
9D0114D8  8FBE000C   LW S8, 12(SP)
9D0114DC  27BD0010   ADDIU SP, SP, 16
9D0114E0  03E00008   JR RA
9D0114E4  00000000   NOP
357:                 
358:                 /******************************************************************************
359:                  * Function:        BOOL MACIsTxReady(void)
360:                  *
361:                  * PreCondition:    None
362:                  *
363:                  * Input:           None
364:                  *
365:                  * Output:          TRUE: If data can be inserted in the current TX buffer
366:                  *                  FALSE: there is no free TX buffer
367:                  *
368:                  * Side Effects:    None
369:                  *
370:                  * Overview:        Checks if there is an available current TX buffer
371:                  *
372:                  * Note:            None
373:                  *****************************************************************************/
374:                 bool MACIsTxReady(void) {
9D0114E8  27BDFFE0   ADDIU SP, SP, -32
9D0114EC  AFBF001C   SW RA, 28(SP)
9D0114F0  AFBE0018   SW S8, 24(SP)
9D0114F4  03A0F021   ADDU S8, SP, ZERO
375:                     int ix;
376:                 
377:                     EthTxAcknowledgeBuffer(0, _TxAckCallback, 0); // acknowledge everything
9D0114F8  00002021   ADDU A0, ZERO, ZERO
9D0114FC  3C029D01   LUI V0, -25343
9D011500  24451D70   ADDIU A1, V0, 7536
9D011504  00003021   ADDU A2, ZERO, ZERO
9D011508  0F406FF1   JAL EthTxAcknowledgeBuffer
9D01150C  00000000   NOP
378:                 
379:                     if (_pTxCurrDcpt == 0) {
9D011510  8F828058   LW V0, -32680(GP)
9D011514  14400059   BNE V0, ZERO, 0x9D01167C
9D011518  00000000   NOP
380:                         for (ix = _TxLastDcptIx + 1; ix<sizeof (_TxDescriptors) / sizeof (*_TxDescriptors); ix++) {
9D01151C  8F82805C   LW V0, -32676(GP)
9D011520  24420001   ADDIU V0, V0, 1
9D011524  AFC20010   SW V0, 16(S8)
9D011528  0B40456E   J 0x9D0115B8
9D01152C  00000000   NOP
9D0115AC  8FC20010   LW V0, 16(S8)
9D0115B0  24420001   ADDIU V0, V0, 1
9D0115B4  AFC20010   SW V0, 16(S8)
9D0115B8  8FC20010   LW V0, 16(S8)
9D0115BC  2C420002   SLTIU V0, V0, 2
9D0115C0  1440FFDB   BNE V0, ZERO, 0x9D011530
9D0115C4  00000000   NOP
381:                             if (_TxDescriptors[ix].txBusy == 0) { // found a non busy descriptor
9D011530  3C05A000   LUI A1, -24576
9D011534  8FC40010   LW A0, 16(S8)
9D011538  00801821   ADDU V1, A0, ZERO
9D01153C  00031140   SLL V0, V1, 5
9D011540  00401821   ADDU V1, V0, ZERO
9D011544  00031080   SLL V0, V1, 2
9D011548  00431023   SUBU V0, V0, V1
9D01154C  00441023   SUBU V0, V0, A0
9D011550  00021100   SLL V0, V0, 4
9D011554  24A3090C   ADDIU V1, A1, 2316
9D011558  00431021   ADDU V0, V0, V1
9D01155C  8C420000   LW V0, 0(V0)
9D011560  14400012   BNE V0, ZERO, 0x9D0115AC
9D011564  00000000   NOP
382:                                 _pTxCurrDcpt = _TxDescriptors + ix;
9D011568  8FC40010   LW A0, 16(S8)
9D01156C  00801821   ADDU V1, A0, ZERO
9D011570  00031140   SLL V0, V1, 5
9D011574  00401821   ADDU V1, V0, ZERO
9D011578  00031080   SLL V0, V1, 2
9D01157C  00431023   SUBU V0, V0, V1
9D011580  00441023   SUBU V0, V0, A0
9D011584  00021100   SLL V0, V0, 4
9D011588  00401821   ADDU V1, V0, ZERO
9D01158C  3C02A000   LUI V0, -24576
9D011590  2442090C   ADDIU V0, V0, 2316
9D011594  00621021   ADDU V0, V1, V0
9D011598  AF828058   SW V0, -32680(GP)
383:                                 _TxLastDcptIx = ix;
9D01159C  8FC20010   LW V0, 16(S8)
9D0115A0  AF82805C   SW V0, -32676(GP)
384:                                 break;
9D0115A4  0B404572   J 0x9D0115C8
9D0115A8  00000000   NOP
385:                             }
386:                         }
387:                         if (_pTxCurrDcpt == 0) {
9D0115C8  8F828058   LW V0, -32680(GP)
9D0115CC  1440002B   BNE V0, ZERO, 0x9D01167C
9D0115D0  00000000   NOP
388:                             for (ix = 0; ix < _TxLastDcptIx; ix++) {
9D0115D4  AFC00010   SW ZERO, 16(S8)
9D0115D8  0B40459A   J 0x9D011668
9D0115DC  00000000   NOP
9D01165C  8FC20010   LW V0, 16(S8)
9D011660  24420001   ADDIU V0, V0, 1
9D011664  AFC20010   SW V0, 16(S8)
9D011668  8F82805C   LW V0, -32676(GP)
9D01166C  8FC30010   LW V1, 16(S8)
9D011670  0062102A   SLT V0, V1, V0
9D011674  1440FFDA   BNE V0, ZERO, 0x9D0115E0
9D011678  00000000   NOP
389:                                 if (_TxDescriptors[ix].txBusy == 0) { // found a non busy descriptor
9D0115E0  3C05A000   LUI A1, -24576
9D0115E4  8FC40010   LW A0, 16(S8)
9D0115E8  00801821   ADDU V1, A0, ZERO
9D0115EC  00031140   SLL V0, V1, 5
9D0115F0  00401821   ADDU V1, V0, ZERO
9D0115F4  00031080   SLL V0, V1, 2
9D0115F8  00431023   SUBU V0, V0, V1
9D0115FC  00441023   SUBU V0, V0, A0
9D011600  00021100   SLL V0, V0, 4
9D011604  24A3090C   ADDIU V1, A1, 2316
9D011608  00431021   ADDU V0, V0, V1
9D01160C  8C420000   LW V0, 0(V0)
9D011610  14400012   BNE V0, ZERO, 0x9D01165C
9D011614  00000000   NOP
390:                                     _pTxCurrDcpt = _TxDescriptors + ix;
9D011618  8FC40010   LW A0, 16(S8)
9D01161C  00801821   ADDU V1, A0, ZERO
9D011620  00031140   SLL V0, V1, 5
9D011624  00401821   ADDU V1, V0, ZERO
9D011628  00031080   SLL V0, V1, 2
9D01162C  00431023   SUBU V0, V0, V1
9D011630  00441023   SUBU V0, V0, A0
9D011634  00021100   SLL V0, V0, 4
9D011638  00401821   ADDU V1, V0, ZERO
9D01163C  3C02A000   LUI V0, -24576
9D011640  2442090C   ADDIU V0, V0, 2316
9D011644  00621021   ADDU V0, V1, V0
9D011648  AF828058   SW V0, -32680(GP)
391:                                     _TxLastDcptIx = ix;
9D01164C  8FC20010   LW V0, 16(S8)
9D011650  AF82805C   SW V0, -32676(GP)
392:                                     break;
9D011654  0B40459F   J 0x9D01167C
9D011658  00000000   NOP
393:                                 }
394:                             }
395:                         }
396:                     }
397:                 
398:                 
399:                     if (_pTxCurrDcpt == 0) {
9D01167C  8F828058   LW V0, -32680(GP)
9D011680  14400004   BNE V0, ZERO, 0x9D011694
9D011684  00000000   NOP
400:                         _stackMgrTxNotReady++;
9D011688  8F828094   LW V0, -32620(GP)
9D01168C  24420001   ADDIU V0, V0, 1
9D011690  AF828094   SW V0, -32620(GP)
401:                     }
402:                 
403:                     return _pTxCurrDcpt != 0;
9D011694  8F828058   LW V0, -32680(GP)
9D011698  0002102B   SLTU V0, ZERO, V0
9D01169C  304200FF   ANDI V0, V0, 255
404:                 }
9D0116A0  03C0E821   ADDU SP, S8, ZERO
9D0116A4  8FBF001C   LW RA, 28(SP)
9D0116A8  8FBE0018   LW S8, 24(SP)
9D0116AC  27BD0020   ADDIU SP, SP, 32
9D0116B0  03E00008   JR RA
9D0116B4  00000000   NOP
405:                 
406:                 /******************************************************************************
407:                  * Function:        void MACPut(BYTE val)
408:                  *
409:                  * PreCondition:    None
410:                  *
411:                  * Input:           byte to be written
412:                  *
413:                  * Output:          None
414:                  *
415:                  * Side Effects:    None
416:                  *
417:                  * Overview:       Writes a byte to the current write location and increments the write pointer.
418:                  *
419:                  * Note:            None
420:                  *****************************************************************************/
421:                 void MACPut(BYTE val) {
9D0116B8  27BDFFF8   ADDIU SP, SP, -8
9D0116BC  AFBE0004   SW S8, 4(SP)
9D0116C0  03A0F021   ADDU S8, SP, ZERO
9D0116C4  00801021   ADDU V0, A0, ZERO
9D0116C8  A3C20008   SB V0, 8(S8)
422:                     *_CurrWrPtr++ = val;
9D0116CC  8F82806C   LW V0, -32660(GP)
9D0116D0  93C30008   LBU V1, 8(S8)
9D0116D4  A0430000   SB V1, 0(V0)
9D0116D8  24420001   ADDIU V0, V0, 1
9D0116DC  AF82806C   SW V0, -32660(GP)
423:                 }
9D0116E0  03C0E821   ADDU SP, S8, ZERO
9D0116E4  8FBE0004   LW S8, 4(SP)
9D0116E8  27BD0008   ADDIU SP, SP, 8
9D0116EC  03E00008   JR RA
9D0116F0  00000000   NOP
424:                 
425:                 /******************************************************************************
426:                  * Function:        void MACPutArray(BYTE* buff, WORD len)
427:                  *
428:                  * PreCondition:    None
429:                  *
430:                  * Input:           buff - buffer to be written
431:                  *                  len - buffer length
432:                  *
433:                  * Output:          None
434:                  *
435:                  * Side Effects:    None
436:                  *
437:                  * Overview:        Writes a buffer to the current write location and updates the write pointer.
438:                  *
439:                  * Note:            None
440:                  *****************************************************************************/
441:                 void MACPutArray(BYTE *buff, WORD len) {
9D0116F4  27BDFFE8   ADDIU SP, SP, -24
9D0116F8  AFBF0014   SW RA, 20(SP)
9D0116FC  AFBE0010   SW S8, 16(SP)
9D011700  03A0F021   ADDU S8, SP, ZERO
9D011704  AFC40018   SW A0, 24(S8)
9D011708  00A01021   ADDU V0, A1, ZERO
9D01170C  A7C2001C   SH V0, 28(S8)
442:                     memcpy(_CurrWrPtr, buff, len);
9D011710  8F83806C   LW V1, -32660(GP)
9D011714  97C2001C   LHU V0, 28(S8)
9D011718  00602021   ADDU A0, V1, ZERO
9D01171C  8FC50018   LW A1, 24(S8)
9D011720  00403021   ADDU A2, V0, ZERO
9D011724  0F406788   JAL 0x9D019E20
9D011728  00000000   NOP
443:                     _CurrWrPtr += len;
9D01172C  8F83806C   LW V1, -32660(GP)
9D011730  97C2001C   LHU V0, 28(S8)
9D011734  00621021   ADDU V0, V1, V0
9D011738  AF82806C   SW V0, -32660(GP)
444:                 }
9D01173C  03C0E821   ADDU SP, S8, ZERO
9D011740  8FBF0014   LW RA, 20(SP)
9D011744  8FBE0010   LW S8, 16(SP)
9D011748  27BD0018   ADDIU SP, SP, 24
9D01174C  03E00008   JR RA
9D011750  00000000   NOP
445:                 
446:                 /******************************************************************************
447:                  * Function:        void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen)
448:                  *
449:                  * PreCondition:    None
450:                  *
451:                  * Input:           remote - Pointer to memory which contains the destination MAC address (6 bytes)
452:                  *                  type - packet type: MAC_IP or ARP
453:                  *                  dataLen - ethernet frame payload
454:                  *
455:                  * Output:          None
456:                  *
457:                  * Side Effects:    None
458:                  *
459:                  * Overview:       Sets the write pointer at the beginning of the current TX buffer
460:                  *                 and sets the ETH header and the frame length. Updates the write pointer
461:                  *
462:                  * Note:            Assumes there is an available TX buffer, i.e. MACIsTxReady() returned !0
463:                  *****************************************************************************/
464:                 void MACPutHeader(MAC_ADDR *remote, BYTE type, WORD dataLen) {
9D011754  27BDFFE8   ADDIU SP, SP, -24
9D011758  AFBF0014   SW RA, 20(SP)
9D01175C  AFBE0010   SW S8, 16(SP)
9D011760  03A0F021   ADDU S8, SP, ZERO
9D011764  AFC40018   SW A0, 24(S8)
9D011768  00A01821   ADDU V1, A1, ZERO
9D01176C  00C01021   ADDU V0, A2, ZERO
9D011770  A3C3001C   SB V1, 28(S8)
9D011774  A7C20020   SH V0, 32(S8)
465:                     _TxCurrSize = dataLen + sizeof (ETHER_HEADER);
9D011778  97C20020   LHU V0, 32(S8)
9D01177C  2442000E   ADDIU V0, V0, 14
9D011780  3042FFFF   ANDI V0, V0, -1
9D011784  A7828060   SH V0, -32672(GP)
466:                     _CurrWrPtr = (unsigned char*) _pTxCurrDcpt->dataBuff; // point at the beg of the buffer
9D011788  8F828058   LW V0, -32680(GP)
9D01178C  24420004   ADDIU V0, V0, 4
9D011790  AF82806C   SW V0, -32660(GP)
467:                 
468:                 
469:                     memcpy(_CurrWrPtr, remote, sizeof (*remote));
9D011794  8F82806C   LW V0, -32660(GP)
9D011798  00402021   ADDU A0, V0, ZERO
9D01179C  8FC50018   LW A1, 24(S8)
9D0117A0  24060006   ADDIU A2, ZERO, 6
9D0117A4  0F406788   JAL 0x9D019E20
9D0117A8  00000000   NOP
470:                     _CurrWrPtr += sizeof (*remote);
9D0117AC  8F82806C   LW V0, -32660(GP)
9D0117B0  24420006   ADDIU V0, V0, 6
9D0117B4  AF82806C   SW V0, -32660(GP)
471:                     memcpy(_CurrWrPtr, &AppConfig.MyMACAddr, sizeof (AppConfig.MyMACAddr));
9D0117B8  8F82806C   LW V0, -32660(GP)
9D0117BC  00402021   ADDU A0, V0, ZERO
9D0117C0  3C02A000   LUI V0, -24576
9D0117C4  24450905   ADDIU A1, V0, 2309
9D0117C8  24060006   ADDIU A2, ZERO, 6
9D0117CC  0F406788   JAL 0x9D019E20
9D0117D0  00000000   NOP
472:                     _CurrWrPtr += sizeof (AppConfig.MyMACAddr);
9D0117D4  8F82806C   LW V0, -32660(GP)
9D0117D8  24420006   ADDIU V0, V0, 6
9D0117DC  AF82806C   SW V0, -32660(GP)
473:                 
474:                 
475:                     *_CurrWrPtr++ = 0x08;
9D0117E0  8F82806C   LW V0, -32660(GP)
9D0117E4  24030008   ADDIU V1, ZERO, 8
9D0117E8  A0430000   SB V1, 0(V0)
9D0117EC  24420001   ADDIU V0, V0, 1
9D0117F0  AF82806C   SW V0, -32660(GP)
476:                     *_CurrWrPtr++ = (type == MAC_IP) ? ETHER_IP : ETHER_ARP;
9D0117F4  8F82806C   LW V0, -32660(GP)
9D0117F8  93C3001C   LBU V1, 28(S8)
9D0117FC  14600004   BNE V1, ZERO, 0x9D011810
9D011800  00000000   NOP
9D011804  00001821   ADDU V1, ZERO, ZERO
9D011808  0B404605   J 0x9D011814
9D01180C  00000000   NOP
9D011810  24030006   ADDIU V1, ZERO, 6
9D011814  A0430000   SB V1, 0(V0)
9D011818  24420001   ADDIU V0, V0, 1
9D01181C  AF82806C   SW V0, -32660(GP)
477:                 
478:                 }
9D011820  03C0E821   ADDU SP, S8, ZERO
9D011824  8FBF0014   LW RA, 20(SP)
9D011828  8FBE0010   LW S8, 16(SP)
9D01182C  27BD0018   ADDIU SP, SP, 24
9D011830  03E00008   JR RA
9D011834  00000000   NOP
479:                 
480:                 void MACFlush(void) {
9D011838  27BDFFE8   ADDIU SP, SP, -24
9D01183C  AFBF0014   SW RA, 20(SP)
9D011840  AFBE0010   SW S8, 16(SP)
9D011844  03A0F021   ADDU S8, SP, ZERO
481:                     if (_pTxCurrDcpt && _TxCurrSize) { // there is a buffer to transmit
9D011848  8F828058   LW V0, -32680(GP)
9D01184C  10400010   BEQ V0, ZERO, 0x9D011890
9D011850  00000000   NOP
9D011854  97828060   LHU V0, -32672(GP)
9D011858  1040000D   BEQ V0, ZERO, 0x9D011890
9D01185C  00000000   NOP
482:                         _pTxCurrDcpt->txBusy = 1;
9D011860  8F828058   LW V0, -32680(GP)
9D011864  24030001   ADDIU V1, ZERO, 1
9D011868  AC430000   SW V1, 0(V0)
483:                         EthTxSendBuffer((void*) _pTxCurrDcpt->dataBuff, _TxCurrSize);
9D01186C  8F828058   LW V0, -32680(GP)
9D011870  24430004   ADDIU V1, V0, 4
9D011874  97828060   LHU V0, -32672(GP)
9D011878  00602021   ADDU A0, V1, ZERO
9D01187C  00402821   ADDU A1, V0, ZERO
9D011880  0F406C01   JAL EthTxSendBuffer
9D011884  00000000   NOP
484:                         // res should be ETH_RES_OK since we made sure we had a descriptor available
485:                         // by the call to MACIsTxReady and the number of the buffers matches the number of descriptors
486:                         _pTxCurrDcpt = 0;
9D011888  AF808058   SW ZERO, -32680(GP)
487:                         _TxCurrSize = 0;
9D01188C  A7808060   SH ZERO, -32672(GP)
488:                     }
489:                 }
9D011890  03C0E821   ADDU SP, S8, ZERO
9D011894  8FBF0014   LW RA, 20(SP)
9D011898  8FBE0010   LW S8, 16(SP)
9D01189C  27BD0018   ADDIU SP, SP, 24
9D0118A0  03E00008   JR RA
9D0118A4  00000000   NOP
490:                 
491:                 /**************************
492:                  * RX functions
493:                  ***********************************************/
494:                 
495:                 /******************************************************************************
496:                  * Function:        void MACDiscardRx(void)
497:                  *
498:                  * PreCondition:    None
499:                  *
500:                  * Input:           None
501:                  *
502:                  * Output:          None
503:                  *
504:                  * Side Effects:    None
505:                  *
506:                  * Overview:        Marks the last received packet (obtained using
507:                  *                  MACGetHeader())as being processed and frees the buffer
508:                  *                  memory associated with it.
509:                  *                  It acknowledges the ETHC.
510:                  *
511:                  * Note:            Is is safe to call this function multiple times between
512:                  *                  MACGetHeader() calls.  Extra packets won't be thrown away
513:                  *                  until MACGetHeader() makes it available.
514:                  *****************************************************************************/
515:                 void MACDiscardRx(void) {
9D0118A8  27BDFFE8   ADDIU SP, SP, -24
9D0118AC  AFBF0014   SW RA, 20(SP)
9D0118B0  AFBE0010   SW S8, 16(SP)
9D0118B4  03A0F021   ADDU S8, SP, ZERO
516:                     if (_pRxCurrBuff) { // an already existing packet
9D0118B8  8F828064   LW V0, -32668(GP)
9D0118BC  1040000C   BEQ V0, ZERO, 0x9D0118F0
9D0118C0  00000000   NOP
517:                         EthRxAcknowledgeBuffer(_pRxCurrBuff, 0, 0);
9D0118C4  8F828064   LW V0, -32668(GP)
9D0118C8  00402021   ADDU A0, V0, ZERO
9D0118CC  00002821   ADDU A1, ZERO, ZERO
9D0118D0  00003021   ADDU A2, ZERO, ZERO
9D0118D4  0F407082   JAL EthRxAcknowledgeBuffer
9D0118D8  00000000   NOP
518:                         _pRxCurrBuff = 0;
9D0118DC  AF808064   SW ZERO, -32668(GP)
519:                         _RxCurrSize = 0;
9D0118E0  A7808068   SH ZERO, -32664(GP)
520:                 
521:                         _stackMgrRxDiscarded++;
9D0118E4  8F828090   LW V0, -32624(GP)
9D0118E8  24420001   ADDIU V0, V0, 1
9D0118EC  AF828090   SW V0, -32624(GP)
522:                     }
523:                 }
9D0118F0  03C0E821   ADDU SP, S8, ZERO
9D0118F4  8FBF0014   LW RA, 20(SP)
9D0118F8  8FBE0010   LW S8, 16(SP)
9D0118FC  27BD0018   ADDIU SP, SP, 24
9D011900  03E00008   JR RA
9D011904  00000000   NOP
524:                 
525:                 /******************************************************************************
526:                  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type)
527:                  *
528:                  * PreCondition:    None
529:                  *
530:                  * Input:           *remote: Location to store the Source MAC address of the
531:                  *                           received frame.
532:                  *                  *type: Location of a BYTE to store the constant
533:                  *                         MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing
534:                  *                         the contents of the Ethernet type field.
535:                  *
536:                  * Output:          TRUE: If a packet was waiting in the RX buffer.  The
537:                  *                        remote, and type values are updated.
538:                  *                  FALSE: If a packet was not pending.  remote and type are
539:                  *                         not changed.
540:                  *
541:                  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already
542:                  *                  been called.
543:                  *
544:                  * Overview:        None
545:                  *
546:                  * Note:            Sets the read pointer at the beginning of the new packet
547:                  *****************************************************************************/
548:                 bool MACGetHeader(MAC_ADDR *remote, BYTE* type) {
9D011908  27BDFFD8   ADDIU SP, SP, -40
9D01190C  AFBF0024   SW RA, 36(SP)
9D011910  AFBE0020   SW S8, 32(SP)
9D011914  03A0F021   ADDU S8, SP, ZERO
9D011918  AFC40028   SW A0, 40(S8)
9D01191C  AFC5002C   SW A1, 44(S8)
549:                     void* pNewPkt;
550:                     const sEthRxPktStat* pRxPktStat;
551:                     eEthRes res;
552:                 
553:                     _stackMgrInGetHdr++;
9D011920  8F82808C   LW V0, -32628(GP)
9D011924  24420001   ADDIU V0, V0, 1
9D011928  AF82808C   SW V0, -32628(GP)
554:                 
555:                     MACDiscardRx(); // discard/acknowledge the old RX buffer, if any
9D01192C  0F40462A   JAL MACDiscardRx
9D011930  00000000   NOP
556:                 
557:                     res = EthRxGetBuffer(&pNewPkt, &pRxPktStat);
9D011934  27C30014   ADDIU V1, S8, 20
9D011938  27C20018   ADDIU V0, S8, 24
9D01193C  00602021   ADDU A0, V1, ZERO
9D011940  00402821   ADDU A1, V0, ZERO
9D011944  0F406F80   JAL EthRxGetBuffer
9D011948  00000000   NOP
9D01194C  AFC20010   SW V0, 16(S8)
558:                 
559:                     if (res == ETH_RES_OK) { // available packet; minimum check
9D011950  8FC20010   LW V0, 16(S8)
9D011954  14400039   BNE V0, ZERO, 0x9D011A3C
9D011958  00000000   NOP
560:                 
561:                         if (pRxPktStat->rxOk && !pRxPktStat->runtPkt && !pRxPktStat->crcError) { // valid packet;
9D01195C  8FC20018   LW V0, 24(S8)
9D011960  8C430004   LW V1, 4(V0)
9D011964  3C020080   LUI V0, 128
9D011968  00621024   AND V0, V1, V0
9D01196C  10400033   BEQ V0, ZERO, 0x9D011A3C
9D011970  00000000   NOP
9D011974  8FC20018   LW V0, 24(S8)
9D011978  8C430000   LW V1, 0(V0)
9D01197C  3C020100   LUI V0, 256
9D011980  00621024   AND V0, V1, V0
9D011984  1440002D   BNE V0, ZERO, 0x9D011A3C
9D011988  00000000   NOP
9D01198C  8FC20018   LW V0, 24(S8)
9D011990  8C430004   LW V1, 4(V0)
9D011994  3C020010   LUI V0, 16
9D011998  00621024   AND V0, V1, V0
9D01199C  14400027   BNE V0, ZERO, 0x9D011A3C
9D0119A0  00000000   NOP
562:                             TCPIP_UINT16_VAL newType;
563:                             _RxCurrSize = pRxPktStat->rxBytes;
9D0119A4  8FC20018   LW V0, 24(S8)
9D0119A8  94420004   LHU V0, 4(V0)
9D0119AC  A7828068   SH V0, -32664(GP)
564:                             _pRxCurrBuff = pNewPkt;
9D0119B0  8FC20014   LW V0, 20(S8)
9D0119B4  AF828064   SW V0, -32668(GP)
565:                             _CurrRdPtr = _pRxCurrBuff + sizeof (ETHER_HEADER); // skip the packet header
9D0119B8  8F828064   LW V0, -32668(GP)
9D0119BC  2442000E   ADDIU V0, V0, 14
9D0119C0  AF828070   SW V0, -32656(GP)
566:                             // set the packet type
567:                             memcpy(remote, &((ETHER_HEADER*) pNewPkt)->SourceMACAddr, sizeof (*remote));
9D0119C4  8FC20014   LW V0, 20(S8)
9D0119C8  24420006   ADDIU V0, V0, 6
9D0119CC  8FC40028   LW A0, 40(S8)
9D0119D0  00402821   ADDU A1, V0, ZERO
9D0119D4  24060006   ADDIU A2, ZERO, 6
9D0119D8  0F406788   JAL 0x9D019E20
9D0119DC  00000000   NOP
568:                             *type = MAC_UNKNOWN;
9D0119E0  8FC2002C   LW V0, 44(S8)
9D0119E4  2403FFFF   ADDIU V1, ZERO, -1
9D0119E8  A0430000   SB V1, 0(V0)
569:                             newType = ((ETHER_HEADER*) pNewPkt)->Type;
9D0119EC  8FC20014   LW V0, 20(S8)
9D0119F0  9442000C   LHU V0, 12(V0)
9D0119F4  A7C2001C   SH V0, 28(S8)
570:                             if (newType.v[0] == 0x08 && (newType.v[1] == ETHER_IP || newType.v[1] == ETHER_ARP)) {
9D0119F8  93C3001C   LBU V1, 28(S8)
9D0119FC  24020008   ADDIU V0, ZERO, 8
9D011A00  1462000B   BNE V1, V0, 0x9D011A30
9D011A04  00000000   NOP
9D011A08  93C2001D   LBU V0, 29(S8)
9D011A0C  10400005   BEQ V0, ZERO, 0x9D011A24
9D011A10  00000000   NOP
9D011A14  93C3001D   LBU V1, 29(S8)
9D011A18  24020006   ADDIU V0, ZERO, 6
9D011A1C  14620004   BNE V1, V0, 0x9D011A30
9D011A20  00000000   NOP
571:                                 *type = newType.v[1];
9D011A24  93C3001D   LBU V1, 29(S8)
9D011A28  8FC2002C   LW V0, 44(S8)
9D011A2C  A0430000   SB V1, 0(V0)
572:                             }
573:                 
574:                             _stackMgrRxOkPkts++;
9D011A30  8F828084   LW V0, -32636(GP)
9D011A34  24420001   ADDIU V0, V0, 1
9D011A38  AF828084   SW V0, -32636(GP)
575:                         }
576:                     }
577:                 
578:                     if (_pRxCurrBuff == 0 && pNewPkt) { // failed packet, discard
9D011A3C  8F828064   LW V0, -32668(GP)
9D011A40  1440000D   BNE V0, ZERO, 0x9D011A78
9D011A44  00000000   NOP
9D011A48  8FC20014   LW V0, 20(S8)
9D011A4C  1040000A   BEQ V0, ZERO, 0x9D011A78
9D011A50  00000000   NOP
579:                         EthRxAcknowledgeBuffer(pNewPkt, 0, 0);
9D011A54  8FC20014   LW V0, 20(S8)
9D011A58  00402021   ADDU A0, V0, ZERO
9D011A5C  00002821   ADDU A1, ZERO, ZERO
9D011A60  00003021   ADDU A2, ZERO, ZERO
9D011A64  0F407082   JAL EthRxAcknowledgeBuffer
9D011A68  00000000   NOP
580:                         _stackMgrRxBadPkts++;
9D011A6C  8F828088   LW V0, -32632(GP)
9D011A70  24420001   ADDIU V0, V0, 1
9D011A74  AF828088   SW V0, -32632(GP)
581:                     }
582:                 
583:                 
584:                     return _pRxCurrBuff != 0;
9D011A78  8F828064   LW V0, -32668(GP)
9D011A7C  0002102B   SLTU V0, ZERO, V0
9D011A80  304200FF   ANDI V0, V0, 255
585:                 }
9D011A84  03C0E821   ADDU SP, S8, ZERO
9D011A88  8FBF0024   LW RA, 36(SP)
9D011A8C  8FBE0020   LW S8, 32(SP)
9D011A90  27BD0028   ADDIU SP, SP, 40
9D011A94  03E00008   JR RA
9D011A98  00000000   NOP
586:                 
587:                 /******************************************************************************
588:                  * Function:        void MACSetReadPtrInRx(WORD offset)
589:                  *
590:                  * PreCondition:    A packet has been obtained by calling MACGetHeader() and
591:                  *                  getting a TRUE result.
592:                  *
593:                  * Input:           offset: WORD specifying how many bytes beyond the Ethernet
594:                  *                          header's type field to relocate the read pointer.
595:                  *
596:                  * Output:          None
597:                  *
598:                  * Side Effects:    None
599:                  *
600:                  * Overview:        The current read pointer is updated.  All calls to
601:                  *                  MACGet() and MACGetArray() will use these new values.
602:                  *
603:                  * Note:
604:                  ******************************************************************************/
605:                 void MACSetReadPtrInRx(WORD offset) {
9D011A9C  27BDFFF8   ADDIU SP, SP, -8
9D011AA0  AFBE0004   SW S8, 4(SP)
9D011AA4  03A0F021   ADDU S8, SP, ZERO
9D011AA8  00801021   ADDU V0, A0, ZERO
9D011AAC  A7C20008   SH V0, 8(S8)
606:                     _CurrRdPtr = _pRxCurrBuff + sizeof (ETHER_HEADER) + offset;
9D011AB0  8F838064   LW V1, -32668(GP)
9D011AB4  97C20008   LHU V0, 8(S8)
9D011AB8  2442000E   ADDIU V0, V0, 14
9D011ABC  00621021   ADDU V0, V1, V0
9D011AC0  AF828070   SW V0, -32656(GP)
607:                 }
9D011AC4  03C0E821   ADDU SP, S8, ZERO
9D011AC8  8FBE0004   LW S8, 4(SP)
9D011ACC  27BD0008   ADDIU SP, SP, 8
9D011AD0  03E00008   JR RA
9D011AD4  00000000   NOP
608:                 
609:                 /****************************************************************************
610:                  * Function:        MACSetReadPtr
611:                  *
612:                  * PreCondition:    None
613:                  *
614:                  * Input:           None
615:                  *
616:                  * Output:          old read pointer
617:                  *
618:                  * Side Effects:    None
619:                  *
620:                  * Overview:        This function sets the new read pointer value.
621:                  *
622:                  * Note:            None
623:                  *****************************************************************************/
624:                 PTR_BASE MACSetReadPtr(PTR_BASE address) {
9D011AD8  27BDFFF0   ADDIU SP, SP, -16
9D011ADC  AFBE000C   SW S8, 12(SP)
9D011AE0  03A0F021   ADDU S8, SP, ZERO
9D011AE4  AFC40010   SW A0, 16(S8)
625:                     unsigned char* oldPtr;
626:                 
627:                     oldPtr = _CurrRdPtr;
9D011AE8  8F828070   LW V0, -32656(GP)
9D011AEC  AFC20000   SW V0, 0(S8)
628:                     _CurrRdPtr = (unsigned char*) address;
9D011AF0  8FC20010   LW V0, 16(S8)
9D011AF4  AF828070   SW V0, -32656(GP)
629:                     return (PTR_BASE) oldPtr;
9D011AF8  8FC20000   LW V0, 0(S8)
630:                 }
9D011AFC  03C0E821   ADDU SP, S8, ZERO
9D011B00  8FBE000C   LW S8, 12(SP)
9D011B04  27BD0010   ADDIU SP, SP, 16
9D011B08  03E00008   JR RA
9D011B0C  00000000   NOP
631:                 
632:                 /******************************************************************************
633:                  * Function:        BYTE MACGet()
634:                  *
635:                  * PreCondition:    A valid packet should vahe been obtained or the read pointer properly set.
636:                  *
637:                  * Input:           None
638:                  *
639:                  * Output:          Byte read from the current read pointer location
640:                  *
641:                  * Side Effects:    None
642:                  *
643:                  * Overview:        MACGet returns the byte pointed to by the current read pointer location and
644:                  *                  increments the read pointer.
645:                  *
646:                  * Note:            None
647:                  *****************************************************************************/
648:                 BYTE MACGet(void) {
9D011B10  27BDFFF8   ADDIU SP, SP, -8
9D011B14  AFBE0004   SW S8, 4(SP)
9D011B18  03A0F021   ADDU S8, SP, ZERO
649:                     return *_CurrRdPtr++;
9D011B1C  8F828070   LW V0, -32656(GP)
9D011B20  90430000   LBU V1, 0(V0)
9D011B24  24420001   ADDIU V0, V0, 1
9D011B28  AF828070   SW V0, -32656(GP)
9D011B2C  00601021   ADDU V0, V1, ZERO
650:                 }
9D011B30  03C0E821   ADDU SP, S8, ZERO
9D011B34  8FBE0004   LW S8, 4(SP)
9D011B38  27BD0008   ADDIU SP, SP, 8
9D011B3C  03E00008   JR RA
9D011B40  00000000   NOP
651:                 
652:                 /******************************************************************************
653:                  * Function:        WORD MACGetArray(BYTE *address, WORD len)
654:                  *
655:                  * PreCondition:    A valid packet should vahe been obtained or the read pointer properly set.
656:                  *
657:                  * Input:           address: Pointer to storage location
658:                  *                  len:  Number of bytes to read from the data buffer.
659:                  *
660:                  * Output:          number of bytes copied to the data buffer.
661:                  *
662:                  * Side Effects:    None
663:                  *
664:                  * Overview:        Copies data in the supplied buffer.
665:                  *
666:                  * Note:            The read pointer is updated
667:                  *****************************************************************************/
668:                 WORD MACGetArray(BYTE *address, WORD len) {
9D011B44  27BDFFE8   ADDIU SP, SP, -24
9D011B48  AFBF0014   SW RA, 20(SP)
9D011B4C  AFBE0010   SW S8, 16(SP)
9D011B50  03A0F021   ADDU S8, SP, ZERO
9D011B54  AFC40018   SW A0, 24(S8)
9D011B58  00A01021   ADDU V0, A1, ZERO
9D011B5C  A7C2001C   SH V0, 28(S8)
669:                     if (address) {
9D011B60  8FC20018   LW V0, 24(S8)
9D011B64  10400008   BEQ V0, ZERO, 0x9D011B88
9D011B68  00000000   NOP
670:                         memcpy(address, _CurrRdPtr, len);
9D011B6C  8F838070   LW V1, -32656(GP)
9D011B70  97C2001C   LHU V0, 28(S8)
9D011B74  8FC40018   LW A0, 24(S8)
9D011B78  00602821   ADDU A1, V1, ZERO
9D011B7C  00403021   ADDU A2, V0, ZERO
9D011B80  0F406788   JAL 0x9D019E20
9D011B84  00000000   NOP
671:                     }
672:                 
673:                     _CurrRdPtr += len;
9D011B88  8F838070   LW V1, -32656(GP)
9D011B8C  97C2001C   LHU V0, 28(S8)
9D011B90  00621021   ADDU V0, V1, V0
9D011B94  AF828070   SW V0, -32656(GP)
674:                     return len;
9D011B98  97C2001C   LHU V0, 28(S8)
675:                 }
9D011B9C  03C0E821   ADDU SP, S8, ZERO
9D011BA0  8FBF0014   LW RA, 20(SP)
9D011BA4  8FBE0010   LW S8, 16(SP)
9D011BA8  27BD0018   ADDIU SP, SP, 24
9D011BAC  03E00008   JR RA
9D011BB0  00000000   NOP
676:                 
677:                 /******************************************************************************
678:                  * Function:        WORD MACGetFreeRxSize(void)
679:                  *
680:                  * PreCondition:    None
681:                  *
682:                  * Input:           None
683:                  *
684:                  * Output:          An estimate of how much RX buffer space is free at the present time.
685:                  *
686:                  * Side Effects:    None
687:                  *
688:                  * Overview:        None
689:                  *
690:                  * Note:            None
691:                  *****************************************************************************/
692:                 WORD MACGetFreeRxSize(void) {
9D011BB4  27BDFFF0   ADDIU SP, SP, -16
9D011BB8  AFBE000C   SW S8, 12(SP)
9D011BBC  03A0F021   ADDU S8, SP, ZERO
693:                     int avlblRxBuffs = sizeof (_RxBuffers) / sizeof (*_RxBuffers) - EthDescriptorsGetRxUnack(); // avlbl=allBuffs-unAck
9D011BCC  24030008   ADDIU V1, ZERO, 8
9D011BD0  00621023   SUBU V0, V1, V0
9D011BD4  AFC20000   SW V0, 0(S8)
694:                 
695:                     return avlblRxBuffs * (sizeof (_RxBuffers[0]) / sizeof (*_RxBuffers[0])); // avlbl* sizeof(buffer)
9D011BD8  8FC20000   LW V0, 0(S8)
9D011BDC  3042FFFF   ANDI V0, V0, -1
9D011BE0  00021240   SLL V0, V0, 9
9D011BE4  00021880   SLL V1, V0, 2
9D011BE8  00621023   SUBU V0, V1, V0
9D011BEC  3042FFFF   ANDI V0, V0, -1
696:                 }
9D011BF0  03C0E821   ADDU SP, S8, ZERO
9D011BF4  8FBE000C   LW S8, 12(SP)
9D011BF8  27BD0010   ADDIU SP, SP, 16
9D011BFC  03E00008   JR RA
9D011C00  00000000   NOP
697:                 
698:                 
699:                 /*****************************************************************************
700:                   Function:
701:                 
702:                 
703:                   Summary:
704:                         Asynchronously copies data from one address to another within the Ethernet memory.
705:                 
706:                   Description:
707:                 
708:                 
709:                   Precondition:
710:                         SPI bus must be initialized (done in MACInit()).
711:                 
712:                 
713:                   Returns:
714:                         None
715:                 
716:                   Remarks:
717:                         Call MACIsMemCopyDone() to see when the transfer is complete.
718:                 
719:                         Copying to a destination region that overlaps with the source address
720:                         is supported only if the destination start address is at a lower memory
721:                         address (closer to 0x0000) than the source pointer.  However, if they do
722:                         overlap there must be at least 2 bytes of non-overlap to ensure correct
723:                         results due to hardware DMA requirements.  For example, destAddr = 0;
724:                         sourceAddr = 1; is illegal while destAddr = 0; sourceAddr = 2; is fine.
725:                 
726:                         If a prior transfer is already in progress prior to calling this function,
727:                         this function will block until it can start this transfer.
728:                 
729:                         If a negative value is used for the sourceAddr or destAddr parameters,
730:                         then that pointer will get updated with the next address after the read or
731:                         write.
732:                  *****************************************************************************/
733:                 
734:                 /******************************************************************************
735:                  * Function:        void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len)
736:                  *
737:                  * PreCondition:    Read and write pointers properly set if using the current ponter values
738:                  *
739:                  * Input:           destAddr - Destination address in the memory to copy to.  If it equals -1,
740:                  *                     the current write pointer will be used.
741:                  *                  sourceAddr - Source address to read from.  If it equals -1,
742:                  *                     the current read pointer will be used.
743:                  *                  len - number of bytes to copy
744:                  *
745:                  * Output:          None
746:                  *
747:                  * Side Effects:    None
748:                  *
749:                  * Overview:        Copies data from one address to another within the Ethernet memory.
750:                  *                  Overlapped memory regions are allowed only if the destination start address
751:                  *                  is at a lower memory address than the source address.
752:                  *
753:                  * Note:            The addresses do not have to be aligned.
754:                  *****************************************************************************/
755:                 void MACMemCopyAsync(PTR_BASE destAddr, PTR_BASE sourceAddr, WORD len) {
9D011C04  27BDFFE0   ADDIU SP, SP, -32
9D011C08  AFBF001C   SW RA, 28(SP)
9D011C0C  AFBE0018   SW S8, 24(SP)
9D011C10  03A0F021   ADDU S8, SP, ZERO
9D011C14  AFC40020   SW A0, 32(S8)
9D011C18  AFC50024   SW A1, 36(S8)
9D011C1C  00C01021   ADDU V0, A2, ZERO
9D011C20  A7C20028   SH V0, 40(S8)
756:                     if (len) {
9D011C24  97C20028   LHU V0, 40(S8)
9D011C28  10400019   BEQ V0, ZERO, 0x9D011C90
9D011C2C  00000000   NOP
757:                         unsigned char *pDst, *pSrc;
758:                 
759:                         pDst = (destAddr == -1) ? _CurrWrPtr : (unsigned char*) destAddr;
9D011C30  8FC30020   LW V1, 32(S8)
9D011C34  2402FFFF   ADDIU V0, ZERO, -1
9D011C38  10620004   BEQ V1, V0, 0x9D011C4C
9D011C3C  00000000   NOP
9D011C40  8FC20020   LW V0, 32(S8)
9D011C44  0B404714   J 0x9D011C50
9D011C48  00000000   NOP
9D011C4C  8F82806C   LW V0, -32660(GP)
9D011C50  AFC20010   SW V0, 16(S8)
760:                         pSrc = (sourceAddr == -1) ? _CurrRdPtr : (unsigned char*) sourceAddr;
9D011C54  8FC30024   LW V1, 36(S8)
9D011C58  2402FFFF   ADDIU V0, ZERO, -1
9D011C5C  10620004   BEQ V1, V0, 0x9D011C70
9D011C60  00000000   NOP
9D011C64  8FC20024   LW V0, 36(S8)
9D011C68  0B40471D   J 0x9D011C74
9D011C6C  00000000   NOP
9D011C70  8F828070   LW V0, -32656(GP)
9D011C74  AFC20014   SW V0, 20(S8)
761:                 
762:                         memcpy(pDst, pSrc, len);
9D011C78  97C20028   LHU V0, 40(S8)
9D011C7C  8FC40010   LW A0, 16(S8)
9D011C80  8FC50014   LW A1, 20(S8)
9D011C84  00403021   ADDU A2, V0, ZERO
9D011C88  0F406788   JAL 0x9D019E20
9D011C8C  00000000   NOP
763:                 
764:                     }
765:                 }
9D011C90  03C0E821   ADDU SP, S8, ZERO
9D011C94  8FBF001C   LW RA, 28(SP)
9D011C98  8FBE0018   LW S8, 24(SP)
9D011C9C  27BD0020   ADDIU SP, SP, 32
9D011CA0  03E00008   JR RA
9D011CA4  00000000   NOP
766:                 
767:                 /******************************************************************************
768:                  * Function:        void MACIsMemCopyDone(void)
769:                  *
770:                  * PreCondition:    None
771:                  *
772:                  * Input:           None
773:                  *
774:                  * Output:          TRUE
775:                  *
776:                  * Side Effects:    None
777:                  *
778:                  * Overview:        Since there's no copy initiated by the DMA, the function returns always true for now.
779:                  *
780:                  * Note:            None
781:                  *****************************************************************************/
782:                 bool MACIsMemCopyDone(void) {
9D011CA8  27BDFFF8   ADDIU SP, SP, -8
9D011CAC  AFBE0004   SW S8, 4(SP)
9D011CB0  03A0F021   ADDU S8, SP, ZERO
783:                     return 1;
9D011CB4  24020001   ADDIU V0, ZERO, 1
784:                 }
9D011CB8  03C0E821   ADDU SP, S8, ZERO
9D011CBC  8FBE0004   LW S8, 4(SP)
9D011CC0  27BD0008   ADDIU SP, SP, 8
9D011CC4  03E00008   JR RA
9D011CC8  00000000   NOP
785:                 
786:                 /******************************************************************************
787:                  * Function:        WORD CalcIPBufferChecksum(WORD len)
788:                  *
789:                  * PreCondition:    Read buffer pointer set to starting of checksum data
790:                  *
791:                  * Input:           len: Total number of bytes to calculate the checksum over.
792:                  *
793:                  * Output:          16-bit checksum as defined by RFC 793
794:                  *
795:                  * Side Effects:    None
796:                  *
797:                  * Overview:        This function performs a checksum calculation of the buffer
798:                  *                  pointed by the current value of the read pointer.
799:                  *
800:                  * Note:            None
801:                  *****************************************************************************/
802:                 WORD CalcIPBufferChecksum(WORD len) {
9D011CCC  27BDFFE8   ADDIU SP, SP, -24
9D011CD0  AFBF0014   SW RA, 20(SP)
9D011CD4  AFBE0010   SW S8, 16(SP)
9D011CD8  03A0F021   ADDU S8, SP, ZERO
9D011CDC  00801021   ADDU V0, A0, ZERO
9D011CE0  A7C20018   SH V0, 24(S8)
803:                     return CalcIPChecksum(_CurrRdPtr, len);
9D011CE4  8F838070   LW V1, -32656(GP)
9D011CE8  97C20018   LHU V0, 24(S8)
9D011CEC  00602021   ADDU A0, V1, ZERO
9D011CF0  00402821   ADDU A1, V0, ZERO
9D011CF4  0F403F9D   JAL CalcIPChecksum
9D011CF8  00000000   NOP
804:                 }
9D011CFC  03C0E821   ADDU SP, S8, ZERO
9D011D00  8FBF0014   LW RA, 20(SP)
9D011D04  8FBE0010   LW S8, 16(SP)
9D011D08  27BD0018   ADDIU SP, SP, 24
9D011D0C  03E00008   JR RA
9D011D10  00000000   NOP
805:                 
806:                 /******************************************************************************
807:                  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len)
808:                  *
809:                  * PreCondition:    None
810:                  *
811:                  * Input:           offset  - Number of bytes beyond the beginning of the
812:                  *                          Ethernet data (first byte after the type field)
813:                  *                          where the checksum should begin
814:                  *                  len     - Total number of bytes to include in the checksum
815:                  *
816:                  * Output:          16-bit checksum as defined by RFC 793.
817:                  *
818:                  * Side Effects:    None
819:                  *
820:                  * Overview:        This function performs a checksum calculation in the current receive buffer.
821:                  *
822:                  * Note:            None
823:                  *****************************************************************************/
824:                 WORD MACCalcRxChecksum(WORD offset, WORD len) {
9D011D14  27BDFFE8   ADDIU SP, SP, -24
9D011D18  AFBF0014   SW RA, 20(SP)
9D011D1C  AFBE0010   SW S8, 16(SP)
9D011D20  03A0F021   ADDU S8, SP, ZERO
9D011D24  00801821   ADDU V1, A0, ZERO
9D011D28  00A01021   ADDU V0, A1, ZERO
9D011D2C  A7C30018   SH V1, 24(S8)
9D011D30  A7C2001C   SH V0, 28(S8)
825:                     return CalcIPChecksum(_pRxCurrBuff + sizeof (ETHER_HEADER) + offset, len);
9D011D34  8F838064   LW V1, -32668(GP)
9D011D38  97C20018   LHU V0, 24(S8)
9D011D3C  2442000E   ADDIU V0, V0, 14
9D011D40  00621821   ADDU V1, V1, V0
9D011D44  97C2001C   LHU V0, 28(S8)
9D011D48  00602021   ADDU A0, V1, ZERO
9D011D4C  00402821   ADDU A1, V0, ZERO
9D011D50  0F403F9D   JAL CalcIPChecksum
9D011D54  00000000   NOP
826:                 }
9D011D58  03C0E821   ADDU SP, S8, ZERO
9D011D5C  8FBF0014   LW RA, 20(SP)
9D011D60  8FBE0010   LW S8, 16(SP)
9D011D64  27BD0018   ADDIU SP, SP, 24
9D011D68  03E00008   JR RA
9D011D6C  00000000   NOP
827:                 
828:                 /******************************************************************************
829:                  * Function:        void SetRXHashTableEntry(MAC_ADDR DestMACAddr)
830:                  *
831:                  * PreCondition:    MACInit() should have been called.
832:                  *
833:                  * Input:           DestMACAddr: 6 byte group destination MAC address to allow
834:                  *                  through the Hash Table Filter.  If DestMACAddr
835:                  *                  is set to 00-00-00-00-00-00, then the hash
836:                  *                  table will be cleared of all entries and the
837:                  *                  filter will be disabled.
838:                  *
839:                  * Output:          Sets the appropriate bit in the ETHHT0/1 registers to allow
840:                  *                  packets sent to DestMACAddr to be received and enabled the
841:                  *                  Hash Table receive filter (if not already).
842:                  *
843:                  * Side Effects:    None
844:                  *
845:                  * Overview:        Calculates a CRC-32 using polynomial 0x4C11DB7 and then,
846:                  *                  using bits 28:23 of the CRC, sets the appropriate bit in
847:                  *                  the ETHHT0-ETHHT1 registers.
848:                  *
849:                  * Note:            This code is commented out to save code space on systems
850:                  *                  that do not need this function.  Change the
851:                  *                  "#if STACK_USE_ZEROCONF_MDNS_SD" line to "#if 1" to
852:                  *                  uncomment it, assuming you aren't using the Zeroconf module,
853:                  *                  which requires mutlicast support and enables this function
854:                  *                  automatically.
855:                  *
856:                  *                  There is no way to individually unset destination MAC
857:                  *                  addresses from the hash table since it is possible to have
858:                  *                  a hash collision and therefore multiple MAC addresses
859:                  *                  relying on the same hash table bit.  The stack would have
860:                  *                  to individually store each 6 byte MAC address to support
861:                  *                  this feature, which would waste a lot of RAM and be
862:                  *                  unnecessary in most applications.  As a simple compromise,
863:                  *                  you can call SetRXHashTableEntry() using a
864:                  *                  00-00-00-00-00-00 destination MAC address, which will clear
865:                  *                  the entire hash table and disable the hash table filter.
866:                  *                  This will allow you to then readd the necessary destination
867:                  *                  addresses.
868:                  *****************************************************************************/
869:                 #if defined(STACK_USE_ZEROCONF_MDNS_SD)
870:                 
871:                 void SetRXHashTableEntry(MAC_ADDR DestMACAddr) {
872:                     volatile unsigned int* pHTSet;
873:                     BYTE hVal;
874:                     int i, j;
875:                     DWORD_VAL crc = {0xFFFFFFFF};
876:                     BYTE nullMACAddr[6] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
877:                 
878:                     // Clear the Hash Table bits and disable the Hash Table Filter if a special
879:                     // 00-00-00-00-00-00 destination MAC address is provided.
880:                     if (memcmp(DestMACAddr.v, nullMACAddr, sizeof (nullMACAddr)) == 0) {
881:                         // Disable the Hash Table receive filter and clear the hash table
882:                         EthRxFiltersClr(ETH_FILT_HTBL_ACCEPT);
883:                         EthRxFiltersHTSet(0ull);
884:                         return;
885:                     }
886:                 
887:                 
888:                     // Calculate a CRC-32 over the 6 byte MAC address
889:                     // using polynomial 0x4C11DB7
890:                     for (i = 0; i < sizeof (MAC_ADDR); i++) {
891:                         BYTE crcnext;
892:                 
893:                         // shift in 8 bits
894:                         for (j = 0; j < 8; j++) {
895:                             crcnext = 0;
896:                             if (((BYTE_VAL*)&(crc.v[3]))->bits.b7)
897:                                 crcnext = 1;
898:                             crcnext ^= (((BYTE_VAL*) & DestMACAddr.v[i])->bits.b0);
899:                 
900:                             crc.Val <<= 1;
901:                             if (crcnext)
902:                                 crc.Val ^= 0x4C11DB7;
903:                             // next bit
904:                             DestMACAddr.v[i] >>= 1;
905:                         }
906:                     }
907:                 
908:                     // CRC-32 calculated, now extract bits 28:23
909:                     // Bit 28 defines what HT register is affected: ETHHT0 or ETHHT1
910:                     // Bits 27:23 define the bit offset within the ETHHT register
911:                     pHTSet = (crc.bits.b28) ? &ETHHT1SET : &ETHHT0SET;
912:                     hVal = (crc.Val >> 23)&0x1f;
913:                     *pHTSet = 1 << hVal;
914:                 
915:                     // Enable that the Hash Table receive filter
916:                     EthRxFiltersSet(ETH_FILT_HTBL_ACCEPT);
917:                 
918:                 }
919:                 #endif
920:                 
921:                 
922:                 
923:                 /**************************
924:                  * local functions and helpers
925:                  ***********************************************/
926:                 
927:                 /*********************************************************************
928:                  * Function:        void	_TxAckCallback(void* pPktBuff, int buffIx, void* fParam)
929:                  *
930:                  * PreCondition:    None
931:                  *
932:                  * Input:           pPktBuff - tx buffer to be acknowledged
933:                  *                  buffIx   - buffer index, when packet spans multiple buffers
934:                  *                  fParam   - optional parameter specified when EthTxAcknowledgeBuffer() called
935:                  *
936:                  * Output:          None
937:                  *
938:                  * Side Effects:    None
939:                  *
940:                  * Overview:        TX acknowledge call back function.
941:                  *                  Called by the Eth MAC when TX buffers are acknoledged (as a result of a call to EthTxAcknowledgeBuffer).
942:                  *
943:                  * Note:            None
944:                  ********************************************************************/
945:                 static void _TxAckCallback(void* pPktBuff, int buffIx, void* fParam) {
9D011D70  27BDFFF0   ADDIU SP, SP, -16
9D011D74  AFBE000C   SW S8, 12(SP)
9D011D78  03A0F021   ADDU S8, SP, ZERO
9D011D7C  AFC40010   SW A0, 16(S8)
9D011D80  AFC50014   SW A1, 20(S8)
9D011D84  AFC60018   SW A2, 24(S8)
946:                     volatile sEthTxDcpt* pDcpt;
947:                 
948:                     pDcpt = (sEthTxDcpt*) ((char*) pPktBuff - offsetof(sEthTxDcpt, dataBuff));
9D011D88  8FC20010   LW V0, 16(S8)
9D011D8C  2442FFFC   ADDIU V0, V0, -4
9D011D90  AFC20000   SW V0, 0(S8)
949:                 
950:                     pDcpt->txBusy = 0;
9D011D94  8FC20000   LW V0, 0(S8)
9D011D98  AC400000   SW ZERO, 0(V0)
951:                 
952:                 }
9D011D9C  03C0E821   ADDU SP, S8, ZERO
9D011DA0  8FBE000C   LW S8, 12(SP)
9D011DA4  27BD0010   ADDIU SP, SP, 16
9D011DA8  03E00008   JR RA
9D011DAC  00000000   NOP
953:                 
954:                 /*********************************************************************
955:                  * Function:        void* _MacAllocCallback( size_t nitems, size_t size, void* param )
956:                  *
957:                  * PreCondition:    None
958:                  *
959:                  * Input:           nitems - number of items to be allocated
960:                  *                  size   - size of each item
961:                  *                  param  - optional parameter specified when EthDescriptorsPoolAdd() called
962:                  *
963:                  * Output:          pointer to the allocated memory of NULL if allocation failed
964:                  *
965:                  * Side Effects:    None
966:                  *
967:                  * Overview:        Memory allocation callback.
968:                  *
969:                  * Note:            None
970:                  ********************************************************************/
971:                 static void* _MacAllocCallback(size_t nitems, size_t size, void* param) {
9D011DB0  27BDFFE8   ADDIU SP, SP, -24
9D011DB4  AFBF0014   SW RA, 20(SP)
9D011DB8  AFBE0010   SW S8, 16(SP)
9D011DBC  03A0F021   ADDU S8, SP, ZERO
9D011DC0  AFC40018   SW A0, 24(S8)
9D011DC4  AFC5001C   SW A1, 28(S8)
9D011DC8  AFC60020   SW A2, 32(S8)
972:                     return calloc(nitems, size);
9D011DCC  8FC40018   LW A0, 24(S8)
9D011DD0  8FC5001C   LW A1, 28(S8)
9D011DD4  0F406E7E   JAL calloc
9D011DD8  00000000   NOP
973:                 }
9D011DDC  03C0E821   ADDU SP, S8, ZERO
9D011DE0  8FBF0014   LW RA, 20(SP)
9D011DE4  8FBE0010   LW S8, 16(SP)
9D011DE8  27BD0018   ADDIU SP, SP, 24
9D011DEC  03E00008   JR RA
9D011DF0  00000000   NOP
974:                 
975:                 ///*********************************************************************
976:                 // * Function:        int	_LinkReconfigure(void)
977:                 // *
978:                 // * PreCondition:    None
979:                 // *
980:                 // * Input:           None
981:                 // *
982:                 // * Output:          TRUE if negotiation succeeded and MAC was updated
983:                 // *                  FALSE otherwise
984:                 // *
985:                 // * Side Effects:    None
986:                 // *
987:                 // * Overview:        Performs re-configuration after auto-negotiation performed.
988:                 // *
989:                 // * Note:            None
990:                 // ********************************************************************/
991:                 //static int _LinkReconfigure(void) {
992:                 //
993:                 //    eEthOpenFlags linkFlags;
994:                 //    eEthLinkStat linkStat;
995:                 //    eEthMacPauseType pauseType;
996:                 //    int success = 0;
997:                 //
998:                 //    linkStat = EthPhyGetNegotiationResult(&linkFlags, &pauseType);
999:                 //    if (linkStat & ETH_LINK_ST_UP) { // negotiation succeeded; properly update the MAC
1000:                //        linkFlags |= (EthPhyGetHwConfigFlags() & ETH_PHY_CFG_RMII) ? ETH_OPEN_RMII : ETH_OPEN_MII;
1001:                //        EthMACOpen(linkFlags, pauseType);
1002:                //        success = 1;
1003:                //    }
1004:                //
1005:                //    return success;
1006:                //}
1007:                
1008:                
1009:                
1010:                #endif	// defined(__PIC32MX__) && defined(_ETH)
1011:                
1012:                
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/eth_pic32_ext_phy.c  --------------------
1:                   /*********************************************************************
2:                    *
3:                    *     PHY external API implementation for Microchip TCP/IP Stack
4:                    *
5:                    *********************************************************************
6:                    * FileName:        ETHPIC32ExtPhy.c
7:                    * Dependencies:
8:                    * Processor:       PIC32
9:                    *
10:                   * Complier:        MPLAB C32
11:                   *                  MPLAB IDE
12:                   * Company:         Microchip Technology, Inc.
13:                   *
14:                   * Software License Agreement
15:                   *
16:                   * Copyright  2009 Microchip Technology Inc.  All rights reserved.
17:                   *
18:                   * Microchip licenses the Software for your use with Microchip microcontrollers
19:                   * and Microchip digital signal controllers pursuant to the terms of the
20:                   * Non-Exclusive Software License Agreement accompanying this Software.
21:                   *
22:                   * SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY
23:                   * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION,
24:                   * ANY WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS
25:                   * FOR A PARTICULAR PURPOSE.
26:                   * MICROCHIP AND ITS LICENSORS ASSUME NO RESPONSIBILITY FOR THE ACCURACY,
27:                   * RELIABILITY OR APPLICATION OF THE SOFTWARE AND DOCUMENTATION.
28:                   * IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED
29:                   * UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH
30:                   * OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
31:                   * DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL,
32:                   * SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS
33:                   * OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
34:                   * SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED
35:                   * TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
36:                   *
37:                   * $Id: $
38:                   ********************************************************************/
39:                  
40:                  
41:                  #include "system_config.h"
42:                  
43:                  // Compile only for PIC32MX with Ethernet MAC interface (must not have external ENCX24J600, ENC28J60, or MRF24WB0M hardware defined)
44:                  #if defined(__PIC32MX__) && defined(_ETH) && !defined(ENC100_INTERFACE_MODE) && !defined(ENC_CS_TRIS) && !defined(WF_CS_TRIS)
45:                  
46:                  #include "tcpip/eth_pic32_ext_phy.h"
47:                  
48:                  
49:                  // local definitions
50:                  //
51:                  #define	PROT_802_3	0x01	// IEEE 802.3 capability
52:                  #define	MAC_COMM_CPBL_MASK	(_BMSTAT_BASE10T_HDX_MASK|_BMSTAT_BASE10T_FDX_MASK|_BMSTAT_BASE100TX_HDX_MASK|_BMSTAT_BASE100TX_FDX_MASK)
53:                  // all comm capabilities our MAC supports
54:                  
55:                  
56:                  // local prototypes
57:                  //
58:                  static void _PhyInitIo(void);
59:                  
60:                  
61:                  /****************************************************************************
62:                   *                 interface functions
63:                   ****************************************************************************/
64:                  
65:                  /****************************************************************************
66:                   * Function:        EthPhyGetHwConfigFlags
67:                   *
68:                   * PreCondition:    - EthPhyInit should have been called.
69:                   *
70:                   * Input:           None
71:                   *
72:                   * Output:          a eEthPhyCfgFlags value
73:                   *
74:                   *
75:                   * Side Effects:    None
76:                   *
77:                   * Overview:        This function returns the current PHY hardware MII/RMII and ALTERNATE/DEFAULT configuration flags.
78:                   *
79:                   * Note:            None
80:                   *****************************************************************************/
81:                  eEthPhyCfgFlags __attribute__((weak)) EthPhyGetHwConfigFlags(void) {
9D016404  27BDFFF0   ADDIU SP, SP, -16
9D016408  AFBE000C   SW S8, 12(SP)
9D01640C  03A0F021   ADDU S8, SP, ZERO
82:                      eEthPhyCfgFlags hwFlags;
83:                      // the way the hw is configured
84:                      hwFlags = (DEVCFG3bits.FMIIEN != 0) ? ETH_PHY_CFG_MII : ETH_PHY_CFG_RMII;
9D016410  3C02BFC0   LUI V0, -16448
9D016414  8C432FF0   LW V1, 12272(V0)
9D016418  3C020100   LUI V0, 256
9D01641C  00621024   AND V0, V1, V0
9D016420  2C420001   SLTIU V0, V0, 1
9D016424  AFC20000   SW V0, 0(S8)
85:                      hwFlags |= (DEVCFG3bits.FETHIO != 0) ? ETH_PHY_CFG_DEFAULT : ETH_PHY_CFG_ALTERNATE;
9D016428  3C02BFC0   LUI V0, -16448
9D01642C  8C432FF0   LW V1, 12272(V0)
9D016430  3C020200   LUI V0, 512
9D016434  00621024   AND V0, V1, V0
9D016438  10400004   BEQ V0, ZERO, 0x9D01644C
9D01643C  00000000   NOP
9D016440  00001021   ADDU V0, ZERO, ZERO
9D016444  0B405914   J 0x9D016450
9D016448  00000000   NOP
9D01644C  24020002   ADDIU V0, ZERO, 2
9D016450  8FC30000   LW V1, 0(S8)
9D016454  00621025   OR V0, V1, V0
9D016458  AFC20000   SW V0, 0(S8)
86:                  
87:                      return hwFlags;
9D01645C  8FC20000   LW V0, 0(S8)
88:                  }
9D016460  03C0E821   ADDU SP, S8, ZERO
9D016464  8FBE000C   LW S8, 12(SP)
9D016468  27BD0010   ADDIU SP, SP, 16
9D01646C  03E00008   JR RA
9D016470  00000000   NOP
89:                  
90:                  /****************************************************************************
91:                   * Function:        EthPhyInit
92:                   *
93:                   * PreCondition:    - EthInit should have been called.
94:                   *
95:                   * Input:           oFlags - the requested open flags
96:                   *                  cFlags - PHY MII/RMII configuration flags
97:                   *                  pResFlags - address to store the initialization result
98:                   *
99:                   * Output:          ETH_RES_OK for success,
100:                  *                  an error code otherwise
101:                  *
102:                  *
103:                  * Side Effects:    None
104:                  *
105:                  * Overview:        This function initializes the PHY communication.
106:                  *                  It tries to detect the external PHY, to read the capabilties and find a match
107:                  *                  with the requested features.
108:                  *                  Then it programs the PHY accordingly.
109:                  *
110:                  * Note:            None
111:                  *****************************************************************************/
112:                 eEthRes __attribute__((weak)) EthPhyInit(eEthOpenFlags oFlags, eEthPhyCfgFlags cFlags, eEthOpenFlags* pResFlags) {
9D016474  27BDFFE0   ADDIU SP, SP, -32
9D016478  AFBF001C   SW RA, 28(SP)
9D01647C  AFBE0018   SW S8, 24(SP)
9D016480  03A0F021   ADDU S8, SP, ZERO
9D016484  AFC40020   SW A0, 32(S8)
9D016488  AFC50024   SW A1, 36(S8)
9D01648C  AFC60028   SW A2, 40(S8)
113:                     eEthPhyCfgFlags hwFlags, swFlags;
114:                 
115:                     // the way the hw is configured
116:                     hwFlags = EthPhyGetHwConfigFlags();
9D016490  0F405901   JAL EthPhyGetHwConfigFlags
9D016494  00000000   NOP
9D016498  AFC20010   SW V0, 16(S8)
117:                 
118:                     if (cFlags & ETH_PHY_CFG_AUTO)
9D01649C  8FC20024   LW V0, 36(S8)
9D0164A0  30420010   ANDI V0, V0, 16
9D0164A4  10400005   BEQ V0, ZERO, 0x9D0164BC
9D0164A8  00000000   NOP
119:                     {
120:                         cFlags = hwFlags;
9D0164AC  8FC20010   LW V0, 16(S8)
9D0164B0  AFC20024   SW V0, 36(S8)
9D0164B4  0B405939   J 0x9D0164E4
9D0164B8  00000000   NOP
121:                     }
122:                     else
123:                     {
124:                         // some minimal check against the way the hw is configured
125:                         swFlags = cFlags & (ETH_PHY_CFG_RMII | ETH_PHY_CFG_ALTERNATE);
9D0164BC  8FC20024   LW V0, 36(S8)
9D0164C0  30420003   ANDI V0, V0, 3
9D0164C4  AFC20014   SW V0, 20(S8)
126:                 
127:                         if ((swFlags ^ hwFlags) != 0) 
9D0164C8  8FC30014   LW V1, 20(S8)
9D0164CC  8FC20010   LW V0, 16(S8)
9D0164D0  10620004   BEQ V1, V0, 0x9D0164E4
9D0164D4  00000000   NOP
128:                         {
129:                             // hw-sw configuration mismatch MII/RMII, ALT/DEF config
130:                             return ETH_RES_CFG_ERR;
9D0164D8  2402000F   ADDIU V0, ZERO, 15
9D0164DC  0B40594F   J 0x9D01653C
9D0164E0  00000000   NOP
131:                         }
132:                     }
133:                 
134:                     _PhyInitIo(); // init IO pins
9D0164E4  0F405955   JAL 0x9D016554
9D0164E8  00000000   NOP
135:                 
136:                     EthMIIMConfig(GetSystemClock(), ETH_PHY_MIIM_CLK);
9D0164EC  3C0204C4   LUI V0, 1220
9D0164F0  3444B400   ORI A0, V0, -19456
9D0164F4  3C020098   LUI V0, 152
9D0164F8  34459680   ORI A1, V0, -27008
9D0164FC  0F406DF5   JAL EthMIIMConfig
9D016500  00000000   NOP
137:                 
138:                     // now update the open flags
139:                     // the upper layer needs to know the PHY set-up to further set-up the MAC.
140:                 
141:                     // clear the capabilities
142:                     oFlags &= ~(ETH_OPEN_AUTO | ETH_OPEN_FDUPLEX | ETH_OPEN_HDUPLEX | ETH_OPEN_100 | ETH_OPEN_10);
9D016504  8FC30020   LW V1, 32(S8)
9D016508  2402FFE0   ADDIU V0, ZERO, -32
9D01650C  00621024   AND V0, V1, V0
9D016510  AFC20020   SW V0, 32(S8)
143:                 
144:                     oFlags |= ETH_OPEN_100;
9D016514  8FC20020   LW V0, 32(S8)
9D016518  34420008   ORI V0, V0, 8
9D01651C  AFC20020   SW V0, 32(S8)
145:                     oFlags |= ETH_OPEN_FDUPLEX;
9D016520  8FC20020   LW V0, 32(S8)
9D016524  34420002   ORI V0, V0, 2
9D016528  AFC20020   SW V0, 32(S8)
146:                 
147:                     *pResFlags = oFlags; // upper layer needs to know the PHY set-up to further set-up the MAC.
9D01652C  8FC20028   LW V0, 40(S8)
9D016530  8FC30020   LW V1, 32(S8)
9D016534  AC430000   SW V1, 0(V0)
148:                 
149:                     return ETH_RES_OK;
9D016538  00001021   ADDU V0, ZERO, ZERO
150:                 }
9D01653C  03C0E821   ADDU SP, S8, ZERO
9D016540  8FBF001C   LW RA, 28(SP)
9D016544  8FBE0018   LW S8, 24(SP)
9D016548  27BD0020   ADDIU SP, SP, 32
9D01654C  03E00008   JR RA
9D016550  00000000   NOP
151:                 
152:                 
153:                 /****************************************************************************
154:                  *                 local functions
155:                  ****************************************************************************/
156:                 
157:                 /****************************************************************************
158:                  * Function:        _PhyInitIo
159:                  *
160:                  * PreCondition:    None
161:                  *
162:                  * Input:           None
163:                  *
164:                  * Output:          None
165:                  *
166:                  * Side Effects:    None
167:                  *
168:                  * Overview:        Helper to properly set the Eth i/o pins to digital pins.
169:                  *
170:                  * Note:            Even when the Eth device is turned on the analog shared pins have to be configured.
171:                  *****************************************************************************/
172:                 static void _PhyInitIo(void) {
9D016554  27BDFFE0   ADDIU SP, SP, -32
9D016558  AFBF001C   SW RA, 28(SP)
9D01655C  AFBE0018   SW S8, 24(SP)
9D016560  03A0F021   ADDU S8, SP, ZERO
173:                     __DEVCFG3bits_t bcfg3;
174:                 
175:                     bcfg3 = DEVCFG3bits;
9D016564  3C02BFC0   LUI V0, -16448
9D016568  8C422FF0   LW V0, 12272(V0)
9D01656C  AFC20010   SW V0, 16(S8)
176:                     if (bcfg3.FETHIO) { // default setting, both RMII and MII
9D016570  8FC30010   LW V1, 16(S8)
9D016574  3C020200   LUI V0, 512
9D016578  00621024   AND V0, V1, V0
9D01657C  10400050   BEQ V0, ZERO, 0x9D0166C0
9D016580  00000000   NOP
177:                         PORTSetPinsDigitalOut(_ETH_MDC_PORT, _ETH_MDC_BIT);
9D016584  00002021   ADDU A0, ZERO, ZERO
9D016588  34058000   ORI A1, ZERO, -32768
9D01658C  0F406F70   JAL PORTSetPinsDigitalOut
9D016590  00000000   NOP
178:                         PORTSetPinsDigitalIn(_ETH_MDIO_PORT, _ETH_MDIO_BIT);
9D016594  24040002   ADDIU A0, ZERO, 2
9D016598  24050002   ADDIU A1, ZERO, 2
9D01659C  0F406F60   JAL PORTSetPinsDigitalIn
9D0165A0  00000000   NOP
179:                 
180:                         PORTSetPinsDigitalOut(_ETH_TXEN_PORT, _ETH_TXEN_BIT);
9D0165A4  24040003   ADDIU A0, ZERO, 3
9D0165A8  24050020   ADDIU A1, ZERO, 32
9D0165AC  0F406F70   JAL PORTSetPinsDigitalOut
9D0165B0  00000000   NOP
181:                         PORTSetPinsDigitalOut(_ETH_TXD0_PORT, _ETH_TXD0_BIT);
9D0165B4  24040003   ADDIU A0, ZERO, 3
9D0165B8  24050040   ADDIU A1, ZERO, 64
9D0165BC  0F406F70   JAL PORTSetPinsDigitalOut
9D0165C0  00000000   NOP
182:                         PORTSetPinsDigitalOut(_ETH_TXD1_PORT, _ETH_TXD1_BIT);
9D0165C4  24040003   ADDIU A0, ZERO, 3
9D0165C8  24050080   ADDIU A1, ZERO, 128
9D0165CC  0F406F70   JAL PORTSetPinsDigitalOut
9D0165D0  00000000   NOP
183:                 
184:                 
185:                         PORTSetPinsDigitalIn(_ETH_RXCLK_PORT, _ETH_RXCLK_BIT);
9D0165D4  24040003   ADDIU A0, ZERO, 3
9D0165D8  24050008   ADDIU A1, ZERO, 8
9D0165DC  0F406F60   JAL PORTSetPinsDigitalIn
9D0165E0  00000000   NOP
186:                         PORTSetPinsDigitalIn(_ETH_RXDV_PORT, _ETH_RXDV_BIT);
9D0165E4  24040003   ADDIU A0, ZERO, 3
9D0165E8  24050004   ADDIU A1, ZERO, 4
9D0165EC  0F406F60   JAL PORTSetPinsDigitalIn
9D0165F0  00000000   NOP
187:                         PORTSetPinsDigitalIn(_ETH_RXD0_PORT, _ETH_RXD0_BIT);
9D0165F4  24040003   ADDIU A0, ZERO, 3
9D0165F8  24050002   ADDIU A1, ZERO, 2
9D0165FC  0F406F60   JAL PORTSetPinsDigitalIn
9D016600  00000000   NOP
188:                         PORTSetPinsDigitalIn(_ETH_RXD1_PORT, _ETH_RXD1_BIT);
9D016604  24040003   ADDIU A0, ZERO, 3
9D016608  24050001   ADDIU A1, ZERO, 1
9D01660C  0F406F60   JAL PORTSetPinsDigitalIn
9D016610  00000000   NOP
189:                         PORTSetPinsDigitalIn(_ETH_RXERR_PORT, _ETH_RXERR_BIT);
9D016614  24040003   ADDIU A0, ZERO, 3
9D016618  24050010   ADDIU A1, ZERO, 16
9D01661C  0F406F60   JAL PORTSetPinsDigitalIn
9D016620  00000000   NOP
190:                 
191:                 
192:                         if (bcfg3.FMIIEN) { // just MII
9D016624  8FC30010   LW V1, 16(S8)
9D016628  3C020100   LUI V0, 256
9D01662C  00621024   AND V0, V1, V0
9D016630  10400070   BEQ V0, ZERO, 0x9D0167F4
9D016634  00000000   NOP
193:                             PORTSetPinsDigitalIn(_ETH_TXCLK_PORT, _ETH_TXCLK_BIT);
9D016638  24040002   ADDIU A0, ZERO, 2
9D01663C  24050080   ADDIU A1, ZERO, 128
9D016640  0F406F60   JAL PORTSetPinsDigitalIn
9D016644  00000000   NOP
194:                             PORTSetPinsDigitalOut(_ETH_TXD2_PORT, _ETH_TXD2_BIT);
9D016648  24040002   ADDIU A0, ZERO, 2
9D01664C  24050200   ADDIU A1, ZERO, 512
9D016650  0F406F70   JAL PORTSetPinsDigitalOut
9D016654  00000000   NOP
195:                             PORTSetPinsDigitalOut(_ETH_TXD3_PORT, _ETH_TXD3_BIT);
9D016658  24040002   ADDIU A0, ZERO, 2
9D01665C  24050100   ADDIU A1, ZERO, 256
9D016660  0F406F70   JAL PORTSetPinsDigitalOut
9D016664  00000000   NOP
196:                             PORTSetPinsDigitalOut(_ETH_TXERR_PORT, _ETH_TXERR_BIT);
9D016668  24040002   ADDIU A0, ZERO, 2
9D01666C  24050040   ADDIU A1, ZERO, 64
9D016670  0F406F70   JAL PORTSetPinsDigitalOut
9D016674  00000000   NOP
197:                 
198:                             PORTSetPinsDigitalIn(_ETH_RXD2_PORT, _ETH_RXD2_BIT);
9D016678  24040004   ADDIU A0, ZERO, 4
9D01667C  24050002   ADDIU A1, ZERO, 2
9D016680  0F406F60   JAL PORTSetPinsDigitalIn
9D016684  00000000   NOP
199:                             PORTSetPinsDigitalIn(_ETH_RXD3_PORT, _ETH_RXD3_BIT);
9D016688  24040004   ADDIU A0, ZERO, 4
9D01668C  24050001   ADDIU A1, ZERO, 1
9D016690  0F406F60   JAL PORTSetPinsDigitalIn
9D016694  00000000   NOP
200:                             PORTSetPinsDigitalIn(_ETH_CRS_PORT, _ETH_CRS_BIT);
9D016698  24040002   ADDIU A0, ZERO, 2
9D01669C  24050800   ADDIU A1, ZERO, 2048
9D0166A0  0F406F60   JAL PORTSetPinsDigitalIn
9D0166A4  00000000   NOP
201:                             PORTSetPinsDigitalIn(_ETH_COL_PORT, _ETH_COL_BIT);
9D0166A8  24040002   ADDIU A0, ZERO, 2
9D0166AC  24050400   ADDIU A1, ZERO, 1024
9D0166B0  0F406F60   JAL PORTSetPinsDigitalIn
9D0166B4  00000000   NOP
9D0166B8  0B4059FD   J 0x9D0167F4
9D0166BC  00000000   NOP
202:                         }
203:                     } else { // alternate setting, both RMII and MII
204:                         PORTSetPinsDigitalOut(_ETH_ALT_MDC_PORT, _ETH_ALT_MDC_BIT);
9D0166C0  00002021   ADDU A0, ZERO, ZERO
9D0166C4  34058000   ORI A1, ZERO, -32768
9D0166C8  0F406F70   JAL PORTSetPinsDigitalOut
9D0166CC  00000000   NOP
205:                         PORTSetPinsDigitalIn(_ETH_ALT_MDIO_PORT, _ETH_ALT_MDIO_BIT);
9D0166D0  24040002   ADDIU A0, ZERO, 2
9D0166D4  24050002   ADDIU A1, ZERO, 2
9D0166D8  0F406F60   JAL PORTSetPinsDigitalIn
9D0166DC  00000000   NOP
206:                 
207:                         PORTSetPinsDigitalOut(_ETH_ALT_TXEN_PORT, _ETH_ALT_TXEN_BIT);
9D0166E0  24040002   ADDIU A0, ZERO, 2
9D0166E4  24050040   ADDIU A1, ZERO, 64
9D0166E8  0F406F70   JAL PORTSetPinsDigitalOut
9D0166EC  00000000   NOP
208:                         PORTSetPinsDigitalOut(_ETH_ALT_TXD0_PORT, _ETH_ALT_TXD0_BIT);
9D0166F0  24040004   ADDIU A0, ZERO, 4
9D0166F4  24050002   ADDIU A1, ZERO, 2
9D0166F8  0F406F70   JAL PORTSetPinsDigitalOut
9D0166FC  00000000   NOP
209:                         PORTSetPinsDigitalOut(_ETH_ALT_TXD1_PORT, _ETH_ALT_TXD1_BIT);
9D016700  24040004   ADDIU A0, ZERO, 4
9D016704  24050001   ADDIU A1, ZERO, 1
9D016708  0F406F70   JAL PORTSetPinsDigitalOut
9D01670C  00000000   NOP
210:                 
211:                 
212:                         PORTSetPinsDigitalIn(_ETH_ALT_RXCLK_PORT, _ETH_ALT_RXCLK_BIT);
9D016710  24040002   ADDIU A0, ZERO, 2
9D016714  24050800   ADDIU A1, ZERO, 2048
9D016718  0F406F60   JAL PORTSetPinsDigitalIn
9D01671C  00000000   NOP
213:                         PORTSetPinsDigitalIn(_ETH_ALT_RXDV_PORT, _ETH_ALT_RXDV_BIT);
9D016720  24040002   ADDIU A0, ZERO, 2
9D016724  24050400   ADDIU A1, ZERO, 1024
9D016728  0F406F60   JAL PORTSetPinsDigitalIn
9D01672C  00000000   NOP
214:                         PORTSetPinsDigitalIn(_ETH_ALT_RXD0_PORT, _ETH_ALT_RXD0_BIT);
9D016730  24040002   ADDIU A0, ZERO, 2
9D016734  24050200   ADDIU A1, ZERO, 512
9D016738  0F406F60   JAL PORTSetPinsDigitalIn
9D01673C  00000000   NOP
215:                         PORTSetPinsDigitalIn(_ETH_ALT_RXD1_PORT, _ETH_ALT_RXD1_BIT);
9D016740  24040002   ADDIU A0, ZERO, 2
9D016744  24050100   ADDIU A1, ZERO, 256
9D016748  0F406F60   JAL PORTSetPinsDigitalIn
9D01674C  00000000   NOP
216:                         PORTSetPinsDigitalIn(_ETH_ALT_RXERR_PORT, _ETH_ALT_RXERR_BIT);
9D016750  24040002   ADDIU A0, ZERO, 2
9D016754  24050080   ADDIU A1, ZERO, 128
9D016758  0F406F60   JAL PORTSetPinsDigitalIn
9D01675C  00000000   NOP
217:                 
218:                 
219:                         if (bcfg3.FMIIEN) { // just MII
9D016760  8FC30010   LW V1, 16(S8)
9D016764  3C020100   LUI V0, 256
9D016768  00621024   AND V0, V1, V0
9D01676C  10400021   BEQ V0, ZERO, 0x9D0167F4
9D016770  00000000   NOP
220:                             PORTSetPinsDigitalIn(_ETH_ALT_TXCLK_PORT, _ETH_ALT_TXCLK_BIT);
9D016774  24040002   ADDIU A0, ZERO, 2
9D016778  24050080   ADDIU A1, ZERO, 128
9D01677C  0F406F60   JAL PORTSetPinsDigitalIn
9D016780  00000000   NOP
221:                             PORTSetPinsDigitalOut(_ETH_ALT_TXD2_PORT, _ETH_ALT_TXD2_BIT);
9D016784  24040002   ADDIU A0, ZERO, 2
9D016788  24050200   ADDIU A1, ZERO, 512
9D01678C  0F406F70   JAL PORTSetPinsDigitalOut
9D016790  00000000   NOP
222:                             PORTSetPinsDigitalOut(_ETH_ALT_TXD3_PORT, _ETH_ALT_TXD3_BIT);
9D016794  24040002   ADDIU A0, ZERO, 2
9D016798  24050100   ADDIU A1, ZERO, 256
9D01679C  0F406F70   JAL PORTSetPinsDigitalOut
9D0167A0  00000000   NOP
223:                             PORTSetPinsDigitalOut(_ETH_ALT_TXERR_PORT, _ETH_ALT_TXERR_BIT);
9D0167A4  24040002   ADDIU A0, ZERO, 2
9D0167A8  24050040   ADDIU A1, ZERO, 64
9D0167AC  0F406F70   JAL PORTSetPinsDigitalOut
9D0167B0  00000000   NOP
224:                 
225:                             PORTSetPinsDigitalIn(_ETH_ALT_RXD2_PORT, _ETH_ALT_RXD2_BIT);
9D0167B4  24040004   ADDIU A0, ZERO, 4
9D0167B8  24050002   ADDIU A1, ZERO, 2
9D0167BC  0F406F60   JAL PORTSetPinsDigitalIn
9D0167C0  00000000   NOP
226:                             PORTSetPinsDigitalIn(_ETH_ALT_RXD3_PORT, _ETH_ALT_RXD3_BIT);
9D0167C4  24040004   ADDIU A0, ZERO, 4
9D0167C8  24050001   ADDIU A1, ZERO, 1
9D0167CC  0F406F60   JAL PORTSetPinsDigitalIn
9D0167D0  00000000   NOP
227:                             PORTSetPinsDigitalIn(_ETH_ALT_CRS_PORT, _ETH_ALT_CRS_BIT);
9D0167D4  24040002   ADDIU A0, ZERO, 2
9D0167D8  24050800   ADDIU A1, ZERO, 2048
9D0167DC  0F406F60   JAL PORTSetPinsDigitalIn
9D0167E0  00000000   NOP
228:                             PORTSetPinsDigitalIn(_ETH_ALT_COL_PORT, _ETH_ALT_COL_BIT);
9D0167E4  24040002   ADDIU A0, ZERO, 2
9D0167E8  24050400   ADDIU A1, ZERO, 1024
9D0167EC  0F406F60   JAL PORTSetPinsDigitalIn
9D0167F0  00000000   NOP
229:                         }
230:                     }
231:                 }
9D0167F4  03C0E821   ADDU SP, S8, ZERO
9D0167F8  8FBF001C   LW RA, 28(SP)
9D0167FC  8FBE0018   LW S8, 24(SP)
9D016800  27BD0020   ADDIU SP, SP, 32
9D016804  03E00008   JR RA
9D016808  00000000   NOP
232:                 
233:                 #endif	// defined(__PIC32MX__) && defined(_ETH)	// ETHC present
234:                 
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/delay.c  --------------------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       delay.c
7:                   
8:                     Summary:
9:                       
10:                  
11:                    Description:
12:                      General Delay rouines
13:                  
14:                   *******************************************************************************/
15:                  
16:                  //DOM-IGNORE-BEGIN
17:                  /*******************************************************************************
18:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
19:                  
20:                  Microchip licenses to you the right to use, modify, copy and distribute
21:                  Software only when embedded on a Microchip microcontroller or digital signal
22:                  controller that is integrated into your product or third party product
23:                  (pursuant to the sublicense terms in the accompanying license agreement).
24:                  
25:                  You should refer to the license agreement accompanying this Software for
26:                  additional information regarding your rights and obligations.
27:                  
28:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
29:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
30:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
31:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
32:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
33:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
34:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
35:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
36:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
37:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
38:                   *******************************************************************************/
39:                  //DOM-IGNORE-END
40:                  
41:                  #define __DELAY_C_
42:                  
43:                  #include "tcpip/tcpip.h"
44:                  
45:                  void DelayMs(uint16_t ms)
46:                  {
9D01AC98  27BDFFE0   ADDIU SP, SP, -32
9D01AC9C  AFBF001C   SW RA, 28(SP)
9D01ACA0  AFBE0018   SW S8, 24(SP)
9D01ACA4  03A0F021   ADDU S8, SP, ZERO
9D01ACA8  00801021   ADDU V0, A0, ZERO
9D01ACAC  A7C20020   SH V0, 32(S8)
47:                      unsigned char i;
48:                      while(ms--)
9D01ACB0  0B406B3D   J 0x9D01ACF4
9D01ACB4  00000000   NOP
9D01ACF4  97C20020   LHU V0, 32(S8)
9D01ACF8  0002102B   SLTU V0, ZERO, V0
9D01ACFC  304200FF   ANDI V0, V0, 255
9D01AD00  97C30020   LHU V1, 32(S8)
9D01AD04  2463FFFF   ADDIU V1, V1, -1
9D01AD08  A7C30020   SH V1, 32(S8)
9D01AD0C  1440FFEA   BNE V0, ZERO, 0x9D01ACB8
9D01AD10  00000000   NOP
49:                      {
50:                          i=4;
9D01ACB8  24020004   ADDIU V0, ZERO, 4
9D01ACBC  A3C20010   SB V0, 16(S8)
51:                          while(i--)
9D01ACC0  0B406B35   J 0x9D01ACD4
9D01ACC4  00000000   NOP
9D01ACD4  93C20010   LBU V0, 16(S8)
9D01ACD8  0002102B   SLTU V0, ZERO, V0
9D01ACDC  304200FF   ANDI V0, V0, 255
9D01ACE0  93C30010   LBU V1, 16(S8)
9D01ACE4  2463FFFF   ADDIU V1, V1, -1
9D01ACE8  A3C30010   SB V1, 16(S8)
9D01ACEC  1440FFF6   BNE V0, ZERO, 0x9D01ACC8
9D01ACF0  00000000   NOP
52:                          {
53:                              Delay10us(25);
9D01ACC8  24040019   ADDIU A0, ZERO, 25
9D01ACCC  0F406B4B   JAL Delay10us
9D01ACD0  00000000   NOP
54:                          }
55:                      }
56:                  }
9D01AD14  03C0E821   ADDU SP, S8, ZERO
9D01AD18  8FBF001C   LW RA, 28(SP)
9D01AD1C  8FBE0018   LW S8, 24(SP)
9D01AD20  27BD0020   ADDIU SP, SP, 32
9D01AD24  03E00008   JR RA
9D01AD28  00000000   NOP
57:                  
58:                  #if defined(__XC16) || defined(__XC32)
59:                  
60:                  void Delay10us(uint32_t dwCount)
61:                  {
9D01AD2C  27BDFFF0   ADDIU SP, SP, -16
9D01AD30  AFBE000C   SW S8, 12(SP)
9D01AD34  03A0F021   ADDU S8, SP, ZERO
9D01AD38  AFC40010   SW A0, 16(S8)
62:                      volatile uint32_t _dcnt;
63:                  
64:                      _dcnt = dwCount*((uint32_t)(0.00001/(1.0/GetInstructionClock())/10));
9D01AD3C  8FC20010   LW V0, 16(S8)
9D01AD40  00021100   SLL V0, V0, 4
9D01AD44  00021880   SLL V1, V0, 2
9D01AD48  00431021   ADDU V0, V0, V1
9D01AD4C  AFC20000   SW V0, 0(S8)
65:                      while(_dcnt--)
9D01AD50  0B406B59   J 0x9D01AD64
9D01AD54  00000000   NOP
9D01AD64  8FC20000   LW V0, 0(S8)
9D01AD68  0002182B   SLTU V1, ZERO, V0
9D01AD6C  306300FF   ANDI V1, V1, 255
9D01AD70  2442FFFF   ADDIU V0, V0, -1
9D01AD74  AFC20000   SW V0, 0(S8)
9D01AD78  1460FFF7   BNE V1, ZERO, 0x9D01AD58
9D01AD7C  00000000   NOP
66:                      {
67:                          #if defined(__XC32)
68:                              Nop();
9D01AD58  00000040   SSNOP
69:                              Nop();
9D01AD5C  00000040   SSNOP
70:                              Nop();
9D01AD60  00000040   SSNOP
71:                          #endif
72:                      }
73:                  }
9D01AD80  03C0E821   ADDU SP, S8, ZERO
9D01AD84  8FBE000C   LW S8, 12(SP)
9D01AD88  03E00008   JR RA
9D01AD8C  27BD0010   ADDIU SP, SP, 16
74:                  
75:                  #endif
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/custom_http_app.c  ----------------------
1:                   /*******************************************************************************
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       custom_http_app.c
7:                   
8:                     Summary:
9:                       Support for HTTP2 module in Microchip TCP/IP Stack
10:                      -Implements the application
11:                      -Reference: RFC 1002
12:                  
13:                   *******************************************************************************/
14:                  
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
18:                  
19:                  Microchip licenses to you the right to use, modify, copy and distribute
20:                  Software only when embedded on a Microchip microcontroller or digital signal
21:                  controller that is integrated into your product or third party product
22:                  (pursuant to the sublicense terms in the accompanying license agreement).
23:                  
24:                  You should refer to the license agreement accompanying this Software for
25:                  additional information regarding your rights and obligations.
26:                  
27:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
28:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
29:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
30:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
31:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
32:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
33:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
34:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
35:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
36:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
37:                   *******************************************************************************/
38:                  //DOM-IGNORE-END
39:                  
40:                  #include "system_config.h"
41:                  #include "tcpip/tcpip.h"
42:                  #include "coretime.h"
43:                  
44:                  extern APP_CONFIG AppConfig;
45:                  
46:                  
47:                  /****************************************************************************
48:                    Section:
49:                      Dynamic Variable Callback Functions
50:                    ***************************************************************************/
51:                  
52:                  void HTTPPrint_builddate()
53:                  {
9D013210  27BDFFE8   ADDIU SP, SP, -24
9D013214  AFBF0014   SW RA, 20(SP)
9D013218  AFBE0010   SW S8, 16(SP)
9D01321C  03A0F021   ADDU S8, SP, ZERO
54:                      switch (curHTTP.callbackPos)
9D013220  3C02A000   LUI V0, -24576
9D013224  244204A0   ADDIU V0, V0, 1184
9D013228  8C42000C   LW V0, 12(V0)
9D01322C  10400006   BEQ V0, ZERO, 0x9D013248
9D013230  00000000   NOP
9D013234  24030001   ADDIU V1, ZERO, 1
9D013238  10430017   BEQ V0, V1, 0x9D013298
9D01323C  00000000   NOP
9D013240  0B404CC6   J 0x9D013318
9D013244  00000000   NOP
55:                      {
56:                          case 0:
57:                          {
58:                              // Transmit "MMM DD YYYY"   (11 chars)
59:                              TCPPutROMString(sktHTTP,(ROM void*)__DATE__);
9D013248  93828159   LBU V0, -32423(GP)
9D01324C  00401821   ADDU V1, V0, ZERO
9D013250  3C02A000   LUI V0, -24576
9D013254  000318C0   SLL V1, V1, 3
9D013258  244208C8   ADDIU V0, V0, 2248
9D01325C  00621021   ADDU V0, V1, V0
9D013260  90420004   LBU V0, 4(V0)
9D013264  00401821   ADDU V1, V0, ZERO
9D013268  3C029D02   LUI V0, -25342
9D01326C  2442B394   ADDIU V0, V0, -19564
9D013270  00602021   ADDU A0, V1, ZERO
9D013274  00402821   ADDU A1, V0, ZERO
9D013278  0F4005F2   JAL TCPPutString
9D01327C  00000000   NOP
60:                              curHTTP.callbackPos = 1;
9D013280  3C02A000   LUI V0, -24576
9D013284  244204A0   ADDIU V0, V0, 1184
9D013288  24030001   ADDIU V1, ZERO, 1
9D01328C  AC43000C   SW V1, 12(V0)
61:                              break;
9D013290  0B404CC6   J 0x9D013318
9D013294  00000000   NOP
62:                          }
63:                          case 1:
64:                          {
65:                              // Transmit ", "            (2 chars)
66:                              TCPPutROMString(sktHTTP,", ");
9D013298  93828159   LBU V0, -32423(GP)
9D01329C  00401821   ADDU V1, V0, ZERO
9D0132A0  3C02A000   LUI V0, -24576
9D0132A4  000318C0   SLL V1, V1, 3
9D0132A8  244208C8   ADDIU V0, V0, 2248
9D0132AC  00621021   ADDU V0, V1, V0
9D0132B0  90420004   LBU V0, 4(V0)
9D0132B4  00401821   ADDU V1, V0, ZERO
9D0132B8  3C029D02   LUI V0, -25342
9D0132BC  2442B3A0   ADDIU V0, V0, -19552
9D0132C0  00602021   ADDU A0, V1, ZERO
9D0132C4  00402821   ADDU A1, V0, ZERO
9D0132C8  0F4005F2   JAL TCPPutString
9D0132CC  00000000   NOP
67:                  
68:                              // Transmit "HH:MM:SS"      (8 chars)
69:                              TCPPutROMString(sktHTTP,(ROM void*)__TIME__);
9D0132D0  93828159   LBU V0, -32423(GP)
9D0132D4  00401821   ADDU V1, V0, ZERO
9D0132D8  3C02A000   LUI V0, -24576
9D0132DC  000318C0   SLL V1, V1, 3
9D0132E0  244208C8   ADDIU V0, V0, 2248
9D0132E4  00621021   ADDU V0, V1, V0
9D0132E8  90420004   LBU V0, 4(V0)
9D0132EC  00401821   ADDU V1, V0, ZERO
9D0132F0  3C029D02   LUI V0, -25342
9D0132F4  2442B3A4   ADDIU V0, V0, -19548
9D0132F8  00602021   ADDU A0, V1, ZERO
9D0132FC  00402821   ADDU A1, V0, ZERO
9D013300  0F4005F2   JAL TCPPutString
9D013304  00000000   NOP
70:                              curHTTP.callbackPos = 0;
9D013308  3C02A000   LUI V0, -24576
9D01330C  244204A0   ADDIU V0, V0, 1184
9D013310  AC40000C   SW ZERO, 12(V0)
71:                              break;
9D013314  00000000   NOP
72:                          }
73:                      }
74:                  
75:                      return;
76:                  }
9D013318  03C0E821   ADDU SP, S8, ZERO
9D01331C  8FBF0014   LW RA, 20(SP)
9D013320  8FBE0010   LW S8, 16(SP)
9D013324  27BD0018   ADDIU SP, SP, 24
9D013328  03E00008   JR RA
9D01332C  00000000   NOP
77:                  
78:                  //==============================================================================
79:                  
80:                  void HTTPPrint_uptime()
81:                  {
9D013330  27BDFF80   ADDIU SP, SP, -128
9D013334  AFBF007C   SW RA, 124(SP)
9D013338  AFBE0078   SW S8, 120(SP)
9D01333C  03A0F021   ADDU S8, SP, ZERO
82:                      char msg[75];
83:                  
84:                      if (TCPIsPutReady(sktHTTP) < sizeof(msg))
9D013340  93828159   LBU V0, -32423(GP)
9D013344  00401821   ADDU V1, V0, ZERO
9D013348  3C02A000   LUI V0, -24576
9D01334C  000318C0   SLL V1, V1, 3
9D013350  244208C8   ADDIU V0, V0, 2248
9D013354  00621021   ADDU V0, V1, V0
9D013358  90420004   LBU V0, 4(V0)
9D01335C  00402021   ADDU A0, V0, ZERO
9D013360  0F400373   JAL TCPIsPutReady
9D013364  00000000   NOP
9D013368  2C42004B   SLTIU V0, V0, 75
9D01336C  10400007   BEQ V0, ZERO, 0x9D01338C
9D013370  00000000   NOP
85:                      {
86:                          curHTTP.callbackPos = 1;
9D013374  3C02A000   LUI V0, -24576
9D013378  244204A0   ADDIU V0, V0, 1184
9D01337C  24030001   ADDIU V1, ZERO, 1
9D013380  AC43000C   SW V1, 12(V0)
87:                          return;
9D013384  0B404DAE   J 0x9D0136B8
9D013388  00000000   NOP
88:                      }
89:                  
90:                      uint32_t seconds = CoreTime32sGet();
9D01338C  0F405A57   JAL CoreTime32sGet
9D013390  00000000   NOP
9D013394  AFC20018   SW V0, 24(S8)
91:                              
92:                      uint32_t days = seconds / 79800;
9D013398  8FC30018   LW V1, 24(S8)
9D01339C  3C020001   LUI V0, 1
9D0133A0  344237B8   ORI V0, V0, 14264
9D0133A4  0062001B   DIVU V1, V0
9D0133A8  004001F4   TEQ V0, ZERO
9D0133AC  00001810   MFHI V1, 0
9D0133B0  00001012   MFLO V0, 0
9D0133B4  AFC2001C   SW V0, 28(S8)
93:                      uint32_t hh = (seconds - (days * 79800)) / 3600;
9D0133B8  8FC4001C   LW A0, 28(S8)
9D0133BC  00801821   ADDU V1, A0, ZERO
9D0133C0  00031140   SLL V0, V1, 5
9D0133C4  00401821   ADDU V1, V0, ZERO
9D0133C8  00031080   SLL V0, V1, 2
9D0133CC  00431023   SUBU V0, V0, V1
9D0133D0  00441023   SUBU V0, V0, A0
9D0133D4  000218C0   SLL V1, V0, 3
9D0133D8  00621823   SUBU V1, V1, V0
9D0133DC  00031100   SLL V0, V1, 4
9D0133E0  00431023   SUBU V0, V0, V1
9D0133E4  000210C0   SLL V0, V0, 3
9D0133E8  8FC30018   LW V1, 24(S8)
9D0133EC  00621823   SUBU V1, V1, V0
9D0133F0  24020E10   ADDIU V0, ZERO, 3600
9D0133F4  0062001B   DIVU V1, V0
9D0133F8  004001F4   TEQ V0, ZERO
9D0133FC  00001810   MFHI V1, 0
9D013400  00001012   MFLO V0, 0
9D013404  AFC20020   SW V0, 32(S8)
94:                      uint32_t mm = (seconds - (days * 79800) - (hh * 3600)) / 60;
9D013408  8FC4001C   LW A0, 28(S8)
9D01340C  00801821   ADDU V1, A0, ZERO
9D013410  00031140   SLL V0, V1, 5
9D013414  00401821   ADDU V1, V0, ZERO
9D013418  00031080   SLL V0, V1, 2
9D01341C  00431023   SUBU V0, V0, V1
9D013420  00441023   SUBU V0, V0, A0
9D013424  000218C0   SLL V1, V0, 3
9D013428  00621823   SUBU V1, V1, V0
9D01342C  00031100   SLL V0, V1, 4
9D013430  00431023   SUBU V0, V0, V1
9D013434  000210C0   SLL V0, V0, 3
9D013438  8FC30018   LW V1, 24(S8)
9D01343C  00622023   SUBU A0, V1, V0
9D013440  8FC20020   LW V0, 32(S8)
9D013444  00401821   ADDU V1, V0, ZERO
9D013448  00031100   SLL V0, V1, 4
9D01344C  00401821   ADDU V1, V0, ZERO
9D013450  00031100   SLL V0, V1, 4
9D013454  00431023   SUBU V0, V0, V1
9D013458  00021900   SLL V1, V0, 4
9D01345C  00621023   SUBU V0, V1, V0
9D013460  00821823   SUBU V1, A0, V0
9D013464  2402003C   ADDIU V0, ZERO, 60
9D013468  0062001B   DIVU V1, V0
9D01346C  004001F4   TEQ V0, ZERO
9D013470  00001810   MFHI V1, 0
9D013474  00001012   MFLO V0, 0
9D013478  AFC20024   SW V0, 36(S8)
95:                      uint32_t ss = (seconds - (days * 79800) - (hh * 3600) - (mm * 60));
9D01347C  8FC4001C   LW A0, 28(S8)
9D013480  00801821   ADDU V1, A0, ZERO
9D013484  00031140   SLL V0, V1, 5
9D013488  00401821   ADDU V1, V0, ZERO
9D01348C  00031080   SLL V0, V1, 2
9D013490  00431023   SUBU V0, V0, V1
9D013494  00441023   SUBU V0, V0, A0
9D013498  000218C0   SLL V1, V0, 3
9D01349C  00621823   SUBU V1, V1, V0
9D0134A0  00031100   SLL V0, V1, 4
9D0134A4  00431023   SUBU V0, V0, V1
9D0134A8  000210C0   SLL V0, V0, 3
9D0134AC  8FC30018   LW V1, 24(S8)
9D0134B0  00622023   SUBU A0, V1, V0
9D0134B4  8FC20020   LW V0, 32(S8)
9D0134B8  00401821   ADDU V1, V0, ZERO
9D0134BC  00031100   SLL V0, V1, 4
9D0134C0  00401821   ADDU V1, V0, ZERO
9D0134C4  00031100   SLL V0, V1, 4
9D0134C8  00431023   SUBU V0, V0, V1
9D0134CC  00021900   SLL V1, V0, 4
9D0134D0  00621023   SUBU V0, V1, V0
9D0134D4  00821823   SUBU V1, A0, V0
9D0134D8  8FC20024   LW V0, 36(S8)
9D0134DC  00021080   SLL V0, V0, 2
9D0134E0  00022100   SLL A0, V0, 4
9D0134E4  00821023   SUBU V0, A0, V0
9D0134E8  00621023   SUBU V0, V1, V0
9D0134EC  AFC20028   SW V0, 40(S8)
96:                  
97:                      sprintf(msg, "%03u : %02u : %02u : %02u", days, hh, mm, ss);
9D0134F0  27C2002C   ADDIU V0, S8, 44
9D0134F4  8FC30024   LW V1, 36(S8)
9D0134F8  AFA30010   SW V1, 16(SP)
9D0134FC  8FC30028   LW V1, 40(S8)
9D013500  AFA30014   SW V1, 20(SP)
9D013504  00402021   ADDU A0, V0, ZERO
9D013508  3C029D02   LUI V0, -25342
9D01350C  2445B3B0   ADDIU A1, V0, -19536
9D013510  8FC6001C   LW A2, 28(S8)
9D013514  8FC70020   LW A3, 32(S8)
9D013518  0F406E4C   JAL _sprintf_cdnopuxX
9D01351C  00000000   NOP
98:                  
99:                      if (RCONbits.CMR)
9D013520  3C02BF81   LUI V0, -16511
9D013524  8C42F600   LW V0, -2560(V0)
9D013528  30420200   ANDI V0, V0, 512
9D01352C  1040000D   BEQ V0, ZERO, 0x9D013564
9D013530  00000000   NOP
100:                     {
101:                         strcat(msg, " + CMR");
9D013534  27C2002C   ADDIU V0, S8, 44
9D013538  00402021   ADDU A0, V0, ZERO
9D01353C  0F4067E2   JAL 0x9D019F88
9D013540  00000000   NOP
9D013544  27C3002C   ADDIU V1, S8, 44
9D013548  00621021   ADDU V0, V1, V0
9D01354C  00402021   ADDU A0, V0, ZERO
9D013550  3C029D02   LUI V0, -25342
9D013554  2445B3CC   ADDIU A1, V0, -19508
9D013558  24060007   ADDIU A2, ZERO, 7
9D01355C  0F406788   JAL 0x9D019E20
9D013560  00000000   NOP
102:                     }
103:                     if (RCONbits.EXTR)
9D013564  3C02BF81   LUI V0, -16511
9D013568  8C42F600   LW V0, -2560(V0)
9D01356C  30420080   ANDI V0, V0, 128
9D013570  1040000D   BEQ V0, ZERO, 0x9D0135A8
9D013574  00000000   NOP
104:                     {
105:                         strcat(msg, " + EXTR");
9D013578  27C2002C   ADDIU V0, S8, 44
9D01357C  00402021   ADDU A0, V0, ZERO
9D013580  0F4067E2   JAL 0x9D019F88
9D013584  00000000   NOP
9D013588  27C3002C   ADDIU V1, S8, 44
9D01358C  00621021   ADDU V0, V1, V0
9D013590  00402021   ADDU A0, V0, ZERO
9D013594  3C029D02   LUI V0, -25342
9D013598  2445B3D4   ADDIU A1, V0, -19500
9D01359C  24060008   ADDIU A2, ZERO, 8
9D0135A0  0F406788   JAL 0x9D019E20
9D0135A4  00000000   NOP
106:                     }
107:                     if (RCONbits.WDTO)
9D0135A8  3C02BF81   LUI V0, -16511
9D0135AC  8C42F600   LW V0, -2560(V0)
9D0135B0  30420010   ANDI V0, V0, 16
9D0135B4  1040000D   BEQ V0, ZERO, 0x9D0135EC
9D0135B8  00000000   NOP
108:                     {
109:                         strcat(msg, " + WDTO");
9D0135BC  27C2002C   ADDIU V0, S8, 44
9D0135C0  00402021   ADDU A0, V0, ZERO
9D0135C4  0F4067E2   JAL 0x9D019F88
9D0135C8  00000000   NOP
9D0135CC  27C3002C   ADDIU V1, S8, 44
9D0135D0  00621021   ADDU V0, V1, V0
9D0135D4  00402021   ADDU A0, V0, ZERO
9D0135D8  3C029D02   LUI V0, -25342
9D0135DC  2445B3DC   ADDIU A1, V0, -19492
9D0135E0  24060008   ADDIU A2, ZERO, 8
9D0135E4  0F406788   JAL 0x9D019E20
9D0135E8  00000000   NOP
110:                     }
111:                     if (RCONbits.BOR)
9D0135EC  3C02BF81   LUI V0, -16511
9D0135F0  8C42F600   LW V0, -2560(V0)
9D0135F4  30420002   ANDI V0, V0, 2
9D0135F8  1040000D   BEQ V0, ZERO, 0x9D013630
9D0135FC  00000000   NOP
112:                     {
113:                         strcat(msg, " + BOR");
9D013600  27C2002C   ADDIU V0, S8, 44
9D013604  00402021   ADDU A0, V0, ZERO
9D013608  0F4067E2   JAL 0x9D019F88
9D01360C  00000000   NOP
9D013610  27C3002C   ADDIU V1, S8, 44
9D013614  00621021   ADDU V0, V1, V0
9D013618  00402021   ADDU A0, V0, ZERO
9D01361C  3C029D02   LUI V0, -25342
9D013620  2445B3E4   ADDIU A1, V0, -19484
9D013624  24060007   ADDIU A2, ZERO, 7
9D013628  0F406788   JAL 0x9D019E20
9D01362C  00000000   NOP
114:                     }
115:                     if (RCONbits.POR)
9D013630  3C02BF81   LUI V0, -16511
9D013634  8C42F600   LW V0, -2560(V0)
9D013638  30420001   ANDI V0, V0, 1
9D01363C  1040000D   BEQ V0, ZERO, 0x9D013674
9D013640  00000000   NOP
116:                     {
117:                         strcat(msg, " + POR");
9D013644  27C2002C   ADDIU V0, S8, 44
9D013648  00402021   ADDU A0, V0, ZERO
9D01364C  0F4067E2   JAL 0x9D019F88
9D013650  00000000   NOP
9D013654  27C3002C   ADDIU V1, S8, 44
9D013658  00621021   ADDU V0, V1, V0
9D01365C  00402021   ADDU A0, V0, ZERO
9D013660  3C029D02   LUI V0, -25342
9D013664  2445B3EC   ADDIU A1, V0, -19476
9D013668  24060007   ADDIU A2, ZERO, 7
9D01366C  0F406788   JAL 0x9D019E20
9D013670  00000000   NOP
118:                     }
119:                 
120:                     TCPPutROMString(sktHTTP, msg);
9D013674  93828159   LBU V0, -32423(GP)
9D013678  00401821   ADDU V1, V0, ZERO
9D01367C  3C02A000   LUI V0, -24576
9D013680  000318C0   SLL V1, V1, 3
9D013684  244208C8   ADDIU V0, V0, 2248
9D013688  00621021   ADDU V0, V1, V0
9D01368C  90420004   LBU V0, 4(V0)
9D013690  00401821   ADDU V1, V0, ZERO
9D013694  27C2002C   ADDIU V0, S8, 44
9D013698  00602021   ADDU A0, V1, ZERO
9D01369C  00402821   ADDU A1, V0, ZERO
9D0136A0  0F4005F2   JAL TCPPutString
9D0136A4  00000000   NOP
121:                     curHTTP.callbackPos = 0;
9D0136A8  3C02A000   LUI V0, -24576
9D0136AC  244204A0   ADDIU V0, V0, 1184
9D0136B0  AC40000C   SW ZERO, 12(V0)
122:                 
123:                     return;
9D0136B4  00000000   NOP
124:                 }
9D0136B8  03C0E821   ADDU SP, S8, ZERO
9D0136BC  8FBF007C   LW RA, 124(SP)
9D0136C0  8FBE0078   LW S8, 120(SP)
9D0136C4  27BD0080   ADDIU SP, SP, 128
9D0136C8  03E00008   JR RA
9D0136CC  00000000   NOP
125:                 
126:                 //==============================================================================
127:                 
128:                 void HTTPPrint_feedback()
129:                 {
9D0136D0  27BDFFD8   ADDIU SP, SP, -40
9D0136D4  AFBF0024   SW RA, 36(SP)
9D0136D8  AFBE0020   SW S8, 32(SP)
9D0136DC  03A0F021   ADDU S8, SP, ZERO
130:                     char msg[16];
131:                 
132:                     if (TCPIsPutReady(sktHTTP) < sizeof(msg))
9D0136E0  93828159   LBU V0, -32423(GP)
9D0136E4  00401821   ADDU V1, V0, ZERO
9D0136E8  3C02A000   LUI V0, -24576
9D0136EC  000318C0   SLL V1, V1, 3
9D0136F0  244208C8   ADDIU V0, V0, 2248
9D0136F4  00621021   ADDU V0, V1, V0
9D0136F8  90420004   LBU V0, 4(V0)
9D0136FC  00402021   ADDU A0, V0, ZERO
9D013700  0F400373   JAL TCPIsPutReady
9D013704  00000000   NOP
9D013708  2C420010   SLTIU V0, V0, 16
9D01370C  10400007   BEQ V0, ZERO, 0x9D01372C
9D013710  00000000   NOP
133:                     {
134:                         curHTTP.callbackPos = 1;
9D013714  3C02A000   LUI V0, -24576
9D013718  244204A0   ADDIU V0, V0, 1184
9D01371C  24030001   ADDIU V1, ZERO, 1
9D013720  AC43000C   SW V1, 12(V0)
135:                         return;
9D013724  0B404DE3   J 0x9D01378C
9D013728  00000000   NOP
136:                     }
137:                 
138:                     sprintf(msg, "%u", 0);         // TODO: Provide actual feedback value.
9D01372C  27C20010   ADDIU V0, S8, 16
9D013730  00402021   ADDU A0, V0, ZERO
9D013734  3C029D02   LUI V0, -25342
9D013738  2445B3F4   ADDIU A1, V0, -19468
9D01373C  00003021   ADDU A2, ZERO, ZERO
9D013740  0F406E4C   JAL _sprintf_cdnopuxX
9D013744  00000000   NOP
139:                     TCPPutROMString(sktHTTP, msg);
9D013748  93828159   LBU V0, -32423(GP)
9D01374C  00401821   ADDU V1, V0, ZERO
9D013750  3C02A000   LUI V0, -24576
9D013754  000318C0   SLL V1, V1, 3
9D013758  244208C8   ADDIU V0, V0, 2248
9D01375C  00621021   ADDU V0, V1, V0
9D013760  90420004   LBU V0, 4(V0)
9D013764  00401821   ADDU V1, V0, ZERO
9D013768  27C20010   ADDIU V0, S8, 16
9D01376C  00602021   ADDU A0, V1, ZERO
9D013770  00402821   ADDU A1, V0, ZERO
9D013774  0F4005F2   JAL TCPPutString
9D013778  00000000   NOP
140:                     curHTTP.callbackPos = 0;
9D01377C  3C02A000   LUI V0, -24576
9D013780  244204A0   ADDIU V0, V0, 1184
9D013784  AC40000C   SW ZERO, 12(V0)
141:                 
142:                     return;
9D013788  00000000   NOP
143:                 }
9D01378C  03C0E821   ADDU SP, S8, ZERO
9D013790  8FBF0024   LW RA, 36(SP)
9D013794  8FBE0020   LW S8, 32(SP)
9D013798  27BD0028   ADDIU SP, SP, 40
9D01379C  03E00008   JR RA
9D0137A0  00000000   NOP
144:                 
145:                 /****************************************************************************
146:                   Section:
147:                     GET Form Handlers
148:                   ***************************************************************************/
149:                 
150:                 /*****************************************************************************
151:                   Function:
152:                     HTTP_IO_RESULT HTTPExecuteGet(void)
153:                 
154:                   Internal:
155:                     See documentation in the TCP/IP Stack API or HTTP2.h for details.
156:                   ***************************************************************************/
157:                 
158:                 HTTP_IO_RESULT HTTPExecuteGet(void)
159:                 {
9D0137A4  27BDFFC8   ADDIU SP, SP, -56
9D0137A8  AFBF0034   SW RA, 52(SP)
9D0137AC  AFBE0030   SW S8, 48(SP)
9D0137B0  03A0F021   ADDU S8, SP, ZERO
160:                     uint8_t *ptr;
161:                     uint8_t filename[20];
162:                 
163:                     // Load the file name
164:                     // Make sure uint8_t filename[] above is large enough for your longest name
165:                     MPFSGetFilename(curHTTP.file, filename, 20);
9D0137B4  3C02A000   LUI V0, -24576
9D0137B8  244204A0   ADDIU V0, V0, 1184
9D0137BC  90420018   LBU V0, 24(V0)
9D0137C0  00401821   ADDU V1, V0, ZERO
9D0137C4  27C2001C   ADDIU V0, S8, 28
9D0137C8  00602021   ADDU A0, V1, ZERO
9D0137CC  00402821   ADDU A1, V0, ZERO
9D0137D0  0F4037BC   JAL MPFSGetFilename
9D0137D4  24060014   ADDIU A2, ZERO, 20
166:                 
167:                     /******************************************/
168:                     // If it's the buttons.cgi file
169:                     /******************************************/
170:                     if (!memcmppgm2ram(filename, "buttons.cgi", 8))
9D0137D8  27C2001C   ADDIU V0, S8, 28
9D0137DC  00402021   ADDU A0, V0, ZERO
9D0137E0  3C029D02   LUI V0, -25342
9D0137E4  2445B3F8   ADDIU A1, V0, -19464
9D0137E8  0F406D65   JAL 0x9D01B594
9D0137EC  24060008   ADDIU A2, ZERO, 8
9D0137F0  1440001B   BNE V0, ZERO, 0x9D013860
9D0137F4  00000000   NOP
171:                     {
172:                         // Determine which button was pressed.
173:                         ptr = HTTPGetROMArg(curHTTP.data, (ROM uint8_t *) "button");
9D0137F8  3C029D02   LUI V0, -25342
9D0137FC  2442B404   ADDIU V0, V0, -19452
9D013800  3C03A000   LUI V1, -24576
9D013804  246404C4   ADDIU A0, V1, 1220
9D013808  0F402A2C   JAL HTTPGetArg
9D01380C  00402821   ADDU A1, V0, ZERO
9D013810  AFC20010   SW V0, 16(S8)
174:                 
175:                         if (strcmp((const char*)ptr, "sendCommand") == 0)
9D013814  8FC20010   LW V0, 16(S8)
9D013818  00402021   ADDU A0, V0, ZERO
9D01381C  3C029D02   LUI V0, -25342
9D013820  0F406A15   JAL 0x9D01A854
9D013824  2445B40C   ADDIU A1, V0, -19444
9D013828  1440000D   BNE V0, ZERO, 0x9D013860
9D01382C  00000000   NOP
176:                         {
177:                             uint8_t *cmdPtr;
178:                             cmdPtr = HTTPGetROMArg(curHTTP.data, (ROM uint8_t *)"cmdString");
9D013830  3C029D02   LUI V0, -25342
9D013834  2442B418   ADDIU V0, V0, -19432
9D013838  3C03A000   LUI V1, -24576
9D01383C  246404C4   ADDIU A0, V1, 1220
9D013840  0F402A2C   JAL HTTPGetArg
9D013844  00402821   ADDU A1, V0, ZERO
9D013848  AFC20014   SW V0, 20(S8)
179:                             
180:                             float val;
181:                             val = atof((char*)cmdPtr);
9D01384C  8FC20014   LW V0, 20(S8)
9D013850  0F407090   JAL atof
9D013854  00402021   ADDU A0, V0, ZERO
9D013858  AFC20018   SW V0, 24(S8)
182:                             
183:                             Nop();      // TODO: Process command data.
9D01385C  00000040   SSNOP
184:                         }
185:                     }
186:                 
187:                     return HTTP_IO_DONE;
9D013860  00001021   ADDU V0, ZERO, ZERO
188:                 }
9D013864  03C0E821   ADDU SP, S8, ZERO
9D013868  8FBF0034   LW RA, 52(SP)
9D01386C  8FBE0030   LW S8, 48(SP)
9D013870  03E00008   JR RA
9D013874  27BD0038   ADDIU SP, SP, 56
189:                 
190:                 /****************************************************************************
191:                   Section:
192:                 	POST Form Handlers
193:                   ***************************************************************************/
194:                 
195:                 /*****************************************************************************
196:                   Function:
197:                 	static HTTP_IO_RESULT HTTPPostSaveFMUConfig(void)
198:                 
199:                   Description:
200:                 	This function has four states.  The first reads a name from the data
201:                 	string returned as part of the POST request.  If a name cannot
202:                 	be found, it returns, asking for more data.  Otherwise, if the name
203:                 	is expected, it reads the associated value. If the name is not expected, 
204:                     the value is discarded and the next name parameter is read.
205:                 
206:                 	In the case where the expected string is never found, this function
207:                 	will eventually return HTTP_IO_NEED_DATA when no data is left.  In that
208:                 	case, the HTTP2 server will automatically trap the error and issue an
209:                 	Internal Server Error to the browser.
210:                 
211:                   Precondition:
212:                 	None
213:                 
214:                   Parameters:
215:                 	None
216:                 
217:                   Return Values:
218:                   	HTTP_IO_DONE - the parameter has been found and saved
219:                   	HTTP_IO_WAITING - the function is pausing to continue later
220:                   	HTTP_IO_NEED_DATA - data needed by this function has not yet arrived
221:                   ***************************************************************************/
222:                 
223:                 static HTTP_IO_RESULT HTTPPostSaveFMUConfig(void)
224:                 {
9D013878  27BDFBE8   ADDIU SP, SP, -1048
9D01387C  AFBF0414   SW RA, 1044(SP)
9D013880  AFBE0410   SW S8, 1040(SP)
9D013884  03A0F021   ADDU S8, SP, ZERO
225:                 static void* cDest;
226:                     char value[HTTP_MAX_DATA_LEN];
227:                 
228:                     #define SM_POST_CONFIG_READ_NAME		(0u)
229:                     #define SM_POST_CONFIG_READ_VALUE		(1u)
230:                     #define SM_POST_FORM_SUBMIT_TYPE        (2u)
231:                     
232:                     switch (curHTTP.smPost)
9D013888  3C02A000   LUI V0, -24576
9D01388C  244204A0   ADDIU V0, V0, 1184
9D013890  90420424   LBU V0, 1060(V0)
9D013894  24030001   ADDIU V1, ZERO, 1
9D013898  10430026   BEQ V0, V1, 0x9D013934
9D01389C  00000000   NOP
9D0138A0  24030002   ADDIU V1, ZERO, 2
9D0138A4  1043003C   BEQ V0, V1, 0x9D013998
9D0138A8  00000000   NOP
9D0138AC  14400049   BNE V0, ZERO, 0x9D0139D4
9D0138B0  00000000   NOP
233:                     {
234:                         // Find the name
235:                         case SM_POST_CONFIG_READ_NAME:
236:                         {
237:                             // Read a name
238:                             if (HTTPReadPostName(curHTTP.data, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
9D0138B4  3C02A000   LUI V0, -24576
9D0138B8  244404C4   ADDIU A0, V0, 1220
9D0138BC  24050400   ADDIU A1, ZERO, 1024
9D0138C0  0F402A60   JAL HTTPReadPostName
9D0138C4  00000000   NOP
9D0138C8  00401821   ADDU V1, V0, ZERO
9D0138CC  24020002   ADDIU V0, ZERO, 2
9D0138D0  14620004   BNE V1, V0, 0x9D0138E4
9D0138D4  00000000   NOP
239:                             {
240:                                 return HTTP_IO_NEED_DATA;
9D0138D8  24020001   ADDIU V0, ZERO, 1
9D0138DC  0B404E76   J 0x9D0139D8
9D0138E0  00000000   NOP
241:                             }
242:                 
243:                             // Submit Button Identifier
244:                             else if (!strcmppgm2ram((char*)curHTTP.data, (ROM char*)"formSubmitType"))
9D0138E4  3C02A000   LUI V0, -24576
9D0138E8  244204C4   ADDIU V0, V0, 1220
9D0138EC  00402021   ADDU A0, V0, ZERO
9D0138F0  3C029D02   LUI V0, -25342
9D0138F4  2445B424   ADDIU A1, V0, -19420
9D0138F8  0F406A15   JAL 0x9D01A854
9D0138FC  00000000   NOP
9D013900  14400007   BNE V0, ZERO, 0x9D013920
9D013904  00000000   NOP
245:                             {
246:                                 curHTTP.smPost = SM_POST_FORM_SUBMIT_TYPE;
9D013908  3C02A000   LUI V0, -24576
9D01390C  244204A0   ADDIU V0, V0, 1184
9D013910  24030002   ADDIU V1, ZERO, 2
9D013914  A0430424   SB V1, 1060(V0)
247:                                 break;
9D013918  0B404E75   J 0x9D0139D4
9D01391C  00000000   NOP
248:                             }
249:                 
250:                             // Unknown Configuration Name
251:                             else
252:                             {
253:                                 cDest = NULL;
9D013920  AF808098   SW ZERO, -32616(GP)
254:                             }
255:                 
256:                             curHTTP.smPost = SM_POST_CONFIG_READ_VALUE;
9D013924  3C02A000   LUI V0, -24576
9D013928  244204A0   ADDIU V0, V0, 1184
9D01392C  24030001   ADDIU V1, ZERO, 1
9D013930  A0430424   SB V1, 1060(V0)
257:                         }
258:                         case SM_POST_CONFIG_READ_VALUE:
259:                         {
260:                             // Read a value string.
261:                             if (HTTPReadPostValue((uint8_t*)value, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
9D013934  27C20010   ADDIU V0, S8, 16
9D013938  00402021   ADDU A0, V0, ZERO
9D01393C  24050400   ADDIU A1, ZERO, 1024
9D013940  0F402A7F   JAL HTTPReadPostValue
9D013944  00000000   NOP
9D013948  00401821   ADDU V1, V0, ZERO
9D01394C  24020002   ADDIU V0, ZERO, 2
9D013950  14620004   BNE V1, V0, 0x9D013964
9D013954  00000000   NOP
262:                             {
263:                                 return HTTP_IO_NEED_DATA;
9D013958  24020001   ADDIU V0, ZERO, 1
9D01395C  0B404E76   J 0x9D0139D8
9D013960  00000000   NOP
264:                             }
265:                 
266:                             // Look for a new name if this was an unexpected name/value.
267:                             // Value will be discarded.
268:                             if (!cDest)
9D013964  8F828098   LW V0, -32616(GP)
9D013968  14400006   BNE V0, ZERO, 0x9D013984
9D01396C  00000000   NOP
269:                             {
270:                                 curHTTP.smPost = SM_POST_CONFIG_READ_NAME;
9D013970  3C02A000   LUI V0, -24576
9D013974  244204A0   ADDIU V0, V0, 1184
9D013978  A0400424   SB ZERO, 1060(V0)
271:                                 break;
9D01397C  0B404E75   J 0x9D0139D4
9D013980  00000000   NOP
272:                             }
273:                 
274:                             // Store the values to RAM.
275:                             
276:                             
277:                             curHTTP.smPost = SM_POST_CONFIG_READ_NAME;
9D013984  3C02A000   LUI V0, -24576
9D013988  244204A0   ADDIU V0, V0, 1184
9D01398C  A0400424   SB ZERO, 1060(V0)
278:                             break;
9D013990  0B404E75   J 0x9D0139D4
9D013994  00000000   NOP
279:                         }
280:                         case SM_POST_FORM_SUBMIT_TYPE:
281:                         {
282:                             // Read a value string.
283:                             if (HTTPReadPostValue((uint8_t*)value, HTTP_MAX_DATA_LEN) == HTTP_READ_INCOMPLETE)
9D013998  27C20010   ADDIU V0, S8, 16
9D01399C  00402021   ADDU A0, V0, ZERO
9D0139A0  24050400   ADDIU A1, ZERO, 1024
9D0139A4  0F402A7F   JAL HTTPReadPostValue
9D0139A8  00000000   NOP
9D0139AC  00401821   ADDU V1, V0, ZERO
9D0139B0  24020002   ADDIU V0, ZERO, 2
9D0139B4  14620004   BNE V1, V0, 0x9D0139C8
9D0139B8  00000000   NOP
284:                             {
285:                                 return HTTP_IO_NEED_DATA;
9D0139BC  24020001   ADDIU V0, ZERO, 1
9D0139C0  0B404E76   J 0x9D0139D8
9D0139C4  00000000   NOP
286:                             }
287:                 
288:                             return HTTP_IO_DONE;
9D0139C8  00001021   ADDU V0, ZERO, ZERO
9D0139CC  0B404E76   J 0x9D0139D8
9D0139D0  00000000   NOP
289:                         }
290:                     }
291:                 
292:                     // Default assumes that we're returning for state machine convenience.
293:                     // Function will be called again later.
294:                     return HTTP_IO_WAITING;
9D0139D4  24020002   ADDIU V0, ZERO, 2
295:                 }
9D0139D8  03C0E821   ADDU SP, S8, ZERO
9D0139DC  8FBF0414   LW RA, 1044(SP)
9D0139E0  8FBE0410   LW S8, 1040(SP)
9D0139E4  27BD0418   ADDIU SP, SP, 1048
9D0139E8  03E00008   JR RA
9D0139EC  00000000   NOP
296:                 
297:                 /*****************************************************************************
298:                   Function:
299:                 	HTTP_IO_RESULT HTTPExecutePost(void)
300:                 
301:                   Internal:
302:                   	See documentation in the TCP/IP Stack API or HTTP2.h for details.
303:                   ***************************************************************************/
304:                 
305:                 HTTP_IO_RESULT HTTPExecutePost(void)
306:                 {
9D0139F0  27BDFFD0   ADDIU SP, SP, -48
9D0139F4  AFBF002C   SW RA, 44(SP)
9D0139F8  AFBE0028   SW S8, 40(SP)
9D0139FC  03A0F021   ADDU S8, SP, ZERO
307:                     // Resolve which function to use and pass along
308:                     BYTE filename[20];
309:                 
310:                     // Load the file name
311:                     // Make sure BYTE filename[] above is large enough for your longest name
312:                     MPFSGetFilename(curHTTP.file, filename, sizeof(filename));
9D013A00  3C02A000   LUI V0, -24576
9D013A04  244204A0   ADDIU V0, V0, 1184
9D013A08  90420018   LBU V0, 24(V0)
9D013A0C  00402021   ADDU A0, V0, ZERO
9D013A10  27C20010   ADDIU V0, S8, 16
9D013A14  00402821   ADDU A1, V0, ZERO
9D013A18  24060014   ADDIU A2, ZERO, 20
9D013A1C  0F4037BC   JAL MPFSGetFilename
9D013A20  00000000   NOP
313:                 
314:                     if(!memcmppgm2ram(filename, "config.htm", 10))
9D013A24  27C20010   ADDIU V0, S8, 16
9D013A28  00402021   ADDU A0, V0, ZERO
9D013A2C  3C029D02   LUI V0, -25342
9D013A30  2445B434   ADDIU A1, V0, -19404
9D013A34  2406000A   ADDIU A2, ZERO, 10
9D013A38  0F406D65   JAL 0x9D01B594
9D013A3C  00000000   NOP
9D013A40  14400005   BNE V0, ZERO, 0x9D013A58
9D013A44  00000000   NOP
315:                     {
316:                         return HTTPPostSaveFMUConfig();
9D013A48  0F404E1E   JAL 0x9D013878
9D013A4C  00000000   NOP
9D013A50  0B404E97   J 0x9D013A5C
9D013A54  00000000   NOP
317:                     }
318:                 
319:                     return HTTP_IO_DONE;
9D013A58  00001021   ADDU V0, ZERO, ZERO
320:                 }
9D013A5C  03C0E821   ADDU SP, S8, ZERO
9D013A60  8FBF002C   LW RA, 44(SP)
9D013A64  8FBE0028   LW S8, 40(SP)
9D013A68  27BD0030   ADDIU SP, SP, 48
9D013A6C  03E00008   JR RA
9D013A70  00000000   NOP
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/tcpip/arp.c  ----------------------------------
1:                   /**
2:                     Company:
3:                       Microchip Technology Inc.
4:                   
5:                     File Name:
6:                       arp.c
7:                   
8:                     Summary:
9:                       -Provides IP address to Ethernet MAC address translation
10:                      -Reference: RFC 826
11:                  
12:                    Description:
13:                      Address Resolution Protocol (ARP) Client and Server
14:                      Module for Microchip TCP/IP Stack
15:                  
16:                   */
17:                  
18:                  //DOM-IGNORE-BEGIN
19:                  /*******************************************************************************
20:                  Copyright (c) <2014> released Microchip Technology Inc.  All rights reserved.
21:                  
22:                  Microchip licenses to you the right to use, modify, copy and distribute
23:                  Software only when embedded on a Microchip microcontroller or digital signal
24:                  controller that is integrated into your product or third party product
25:                  (pursuant to the sublicense terms in the accompanying license agreement).
26:                  
27:                  You should refer to the license agreement accompanying this Software for
28:                  additional information regarding your rights and obligations.
29:                  
30:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
31:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
32:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
33:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
34:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
35:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
36:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
37:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
38:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
39:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
40:                   *******************************************************************************/
41:                  //DOM-IGNORE-END
42:                  
43:                  #define __ARP_C_
44:                  
45:                  #include "tcpip/tcpip.h"
46:                  
47:                  /****************************************************************************
48:                    Section:
49:                      Constants and Variables
50:                    ***************************************************************************/
51:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
52:                  //#define ARP_OPERATION_REQ       0x01u     // Operation code indicating an ARP Request
53:                  //#define ARP_OPERATION_RESP      0x02u     // Operation code indicating an ARP Response
54:                  
55:                  #define HW_ETHERNET             (0x0001u)   // ARP Hardware type as defined by IEEE 802.3
56:                  #define ARP_IP                  (0x0800u)   // ARP IP packet type as defined by IEEE 802.3
57:                  #endif
58:                  
59:                  #ifdef STACK_CLIENT_MODE
60:                  static NODE_INFO Cache;                     // Cache for one ARP response
61:                  #endif
62:                  
63:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
64:                  #define MAX_REG_APPS            2           // MAX num allowed registrations of Modules/Apps
65:                  static struct arp_app_callbacks reg_apps[MAX_REG_APPS]; // Call-Backs storage for MAX of two Modules/Apps
66:                  /*
67:                  // ARP packet structure
68:                  typedef struct __attribute__((aligned(2), packed))
69:                  {
70:                      uint16_t        HardwareType;
71:                      uint16_t        Protocol;
72:                      uint8_t        MACAddrLen;
73:                      uint8_t        ProtocolLen;
74:                      uint16_t        Operation;
75:                      MAC_ADDR    SenderMACAddr;
76:                      IP_ADDR     SenderIPAddr;
77:                      MAC_ADDR    TargetMACAddr;
78:                      IP_ADDR     TargetIPAddr;
79:                  } ARP_PACKET;
80:                  */
81:                  #endif
82:                  
83:                  /****************************************************************************
84:                    Section:
85:                      Helper Function Prototypes
86:                    ***************************************************************************/
87:                  static bool ARPPut(ARP_PACKET* packet);
88:                  
89:                  /****************************************************************************
90:                    Section:
91:                      Function Implementations
92:                    ***************************************************************************/
93:                  #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
94:                  /************ User Application APIs ****************************************/
95:                  
96:                  /*****************************************************************************
97:                    Function:
98:                      int8_t ARPRegisterCallbacks(struct arp_app_callbacks *app)
99:                  
100:                   Summary:
101:                     Registering callback with ARP module to get notified about certian events.
102:                 
103:                   Description:
104:                     This function allows end user application to register with callbacks, which
105:                     will be called by ARP module to give notification to user-application about
106:                     events occurred at ARP layer. For ex: when a ARP-packet is received, which is
107:                     conflicting with our own pair of addresses (MAC-Address and IP-address).
108:                     This is an extension for zeroconf protocol implementation (ZeroconfLL.c)
109:                 
110:                   Precondition:
111:                     None
112:                 
113:                   Parameters:
114:                     app - ARP-Application callbacks structure supplied by user-application
115:                 
116:                   Returns:
117:                     id > 0 - Returns non-negative value that represents the id of registration
118:                              The same id needs to be used in de-registration
119:                     -1     - When registered applications exceed MAX_REG_APPS and there is no
120:                              free slot for registration
121:                 
122:                   ***************************************************************************/
123:                 int8_t ARPRegisterCallbacks(struct arp_app_callbacks *app)
124:                 {
125:                     uint8_t i;
126:                     for(i=0; i<MAX_REG_APPS; i++)
127:                     {
128:                         if(!reg_apps[i].used)
129:                         {
130:                             reg_apps[i].ARPPkt_notify = app->ARPPkt_notify;
131:                             reg_apps[i].used = 1;
132:                             return (i+1); // Return Code. Should be used in deregister.
133:                         }
134:                     }
135:                     return -1; // No space for registration
136:                 }
137:                 
138:                 /*****************************************************************************
139:                   Function:
140:                     bool ARPDeRegisterCallbacks(int8_t reg_id)
141:                 
142:                   Summary:
143:                     De-Registering callbacks with ARP module that are registered previously.
144:                 
145:                   Description:
146:                     This function allows end user-application to de-register with callbacks,
147:                     which were registered previously.
148:                     This is called by user-application, when its no longer interested in
149:                     notifications from ARP-Module. This allows the other application to get
150:                     registered with ARP-module.
151:                 
152:                   Precondition:
153:                     None
154:                 
155:                   Parameters:
156:                     reg_id - Registration-id returned in ARPRegisterCallbacks call
157:                 
158:                   Returns:
159:                     true  - On success
160:                     false - Failure to indicate invalid reg_id
161:                   ***************************************************************************/
162:                 bool ARPDeRegisterCallbacks(int8_t reg_id)
163:                 {
164:                     if(reg_id <= 0 || reg_id > MAX_REG_APPS)
165:                         return false;
166:                 
167:                     reg_apps[reg_id-1].used = 0; // To indicate free slot for registration
168:                     return true;
169:                 }
170:                 
171:                 /*****************************************************************************
172:                   Function:
173:                     void ARPProcessRxPkt(ARP_PACKET* packet)
174:                 
175:                   Summary:
176:                     Processes Received-ARP packet (ARP request/Reply).
177:                 
178:                   Description:
179:                     This function is to pass-on the ARP-packet to registered application,
180:                     with the notification of Rx-ARP packet.
181:                 
182:                   Precondition:
183:                     ARP packet is received completely from MAC
184:                 
185:                   Parameters:
186:                     packet - Rx packet to be processed
187:                 
188:                   Returns:
189:                     None
190:                   ***************************************************************************/
191:                 void ARPProcessRxPkt(ARP_PACKET* packet)
192:                 {
193:                     uint8_t pass_on = 0; // Flag to indicate whether need to be forwarded
194:                     uint8_t i;
195:                 
196:                     // Probing Stage
197:                     if(AppConfig.MyIPAddr.Val == 0x00)
198:                     {
199:                         pass_on = 1; // Pass to Registered-Application for further processing
200:                         // putsUART("ARPProcessRxPkt: MyIPAddr=0  -> pass_on = 1 \r\n");
201:                     }
202:                     else if ((AppConfig.MyIPAddr.Val != 0x00) && (AppConfig.networkType == WF_SOFT_AP)) // SOFTAP_ZEROCONF_SUPPORT
203:                     {
204:                         //putsUART("ARPProcessRxPkt: MyIPAddr!=0 & SoftAP  -> pass_on = 1 \r\n");
205:                         pass_on = 1; // Pass to Registered-Application for further processing
206:                     }
207:                     else if(AppConfig.MyIPAddr.Val)
208:                     {
209:                         /* Late-conflict */
210:                         if(packet->SenderIPAddr.Val == AppConfig.MyIPAddr.Val)
211:                         {
212:                             pass_on = 1;
213:                             // putsUART("ARPProcessRxPkt: SenderIPAddr = MyIPAddr \r\n");
214:                         }
215:                     }
216:                 
217:                     if(pass_on)
218:                     {
219:                         for(i =0; i< MAX_REG_APPS; i++)
220:                         {
221:                             if(reg_apps[i].used)
222:                             {
223:                                  //putsUART("ARPProcessRxPkt: pass_on \r\n");
224:                                 reg_apps[i].ARPPkt_notify(packet->SenderIPAddr.Val,
225:                                                       packet->TargetIPAddr.Val,
226:                                                       &packet->SenderMACAddr,
227:                                                       &packet->TargetMACAddr,
228:                                                       packet->Operation);
229:                             }
230:                         }
231:                     }
232:                 }
233:                 #endif
234:                 
235:                 /*****************************************************************************
236:                   Function:
237:                     void ARPSendPkt(IP_ADDR* SrcIPAddr, IP_ADDR* DestIPAddr, int op_req )
238:                 
239:                   Summary:
240:                     Transmits an ARP request/Reply initated by Application or external module.
241:                 
242:                   Description:
243:                     This function transmits and ARP request/reply to determine the hardware
244:                     address of a given IP address (or) Announce self-address to all nodes in
245:                     network. Extended for zeroconf protocol.
246:                 
247:                   Precondition:
248:                     ARP packet is ready in the MAC buffer.
249:                 
250:                   Parameters:
251:                     SrcIPAddr - The Source IP-address
252:                     DestIPAddr - The Destination IP-Address
253:                     op_req     - Operation Request (ARP_REQ/ARP_RESP)
254:                 
255:                   Returns:
256:                     true - The ARP packet was generated properly
257:                     false - Not possible return value
258:                 
259:                   Remarks:
260:                     This API is to give control over AR-packet to external modules.
261:                   ***************************************************************************/
262:                 bool ARPSendPkt(uint32_t SrcIPAddr, uint32_t DestIPAddr, uint8_t op_req )
263:                 {
9D0149AC  27BDFFC8   ADDIU SP, SP, -56
9D0149B0  AFBF0034   SW RA, 52(SP)
9D0149B4  AFBE0030   SW S8, 48(SP)
9D0149B8  03A0F021   ADDU S8, SP, ZERO
9D0149BC  AFC40038   SW A0, 56(S8)
9D0149C0  AFC5003C   SW A1, 60(S8)
9D0149C4  00C01021   ADDU V0, A2, ZERO
9D0149C8  A3C20040   SB V0, 64(S8)
264:                     ARP_PACKET packet;
265:                 
266:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
267:                 #define KS_ARP_IP_MULTICAST_HACK y
268:                 #ifdef KS_ARP_IP_MULTICAST_HACK
269:                     TCPIP_UINT32_VAL *DestAddr = (TCPIP_UINT32_VAL *)&DestIPAddr;
270:                     if ((DestAddr->v[0] >= 224) &&(DestAddr->v[0] <= 239)) {
271:                         // "Resolve" the IP to MAC address mapping for
272:                         // IP multicast address range from 224.0.0.0 to 239.255.255.255
273:                 
274:                         Cache.MACAddr.v[0] = 0x01;
275:                         Cache.MACAddr.v[1] = 0x00;
276:                         Cache.MACAddr.v[2] = 0x5E;
277:                         Cache.MACAddr.v[3] = 0x7f & DestAddr->v[1];
278:                         Cache.MACAddr.v[4] = DestAddr->v[2];
279:                         Cache.MACAddr.v[5] = DestAddr->v[3];
280:                 
281:                         Cache.IPAddr.Val = DestAddr->Val;
282:                 
283:                         return true;
284:                     }
285:                 #endif
286:                 #endif
287:                 
288:                     packet.Operation = op_req;
9D0149CC  93C20040   LBU V0, 64(S8)
9D0149D0  3042FFFF   ANDI V0, V0, -1
9D0149D4  A7C20016   SH V0, 22(S8)
289:                     packet.TargetMACAddr.v[0]   = 0xff;
9D0149D8  2402FFFF   ADDIU V0, ZERO, -1
9D0149DC  A3C20022   SB V0, 34(S8)
290:                     packet.TargetMACAddr.v[1]   = 0xff;
9D0149E0  2402FFFF   ADDIU V0, ZERO, -1
9D0149E4  A3C20023   SB V0, 35(S8)
291:                     packet.TargetMACAddr.v[2]   = 0xff;
9D0149E8  2402FFFF   ADDIU V0, ZERO, -1
9D0149EC  A3C20024   SB V0, 36(S8)
292:                     packet.TargetMACAddr.v[3]   = 0xff;
9D0149F0  2402FFFF   ADDIU V0, ZERO, -1
9D0149F4  A3C20025   SB V0, 37(S8)
293:                     packet.TargetMACAddr.v[4]   = 0xff;
9D0149F8  2402FFFF   ADDIU V0, ZERO, -1
9D0149FC  A3C20026   SB V0, 38(S8)
294:                     packet.TargetMACAddr.v[5]   = 0xff;
9D014A00  2402FFFF   ADDIU V0, ZERO, -1
9D014A04  A3C20027   SB V0, 39(S8)
295:                 
296:                     packet.TargetIPAddr.Val = DestIPAddr;
9D014A08  8FC2003C   LW V0, 60(S8)
9D014A0C  AFC20028   SW V0, 40(S8)
297:                     packet.SenderIPAddr.Val = SrcIPAddr;
9D014A10  8FC20038   LW V0, 56(S8)
9D014A14  ABC20021   SWL V0, 33(S8)
9D014A18  BBC2001E   SWR V0, 30(S8)
298:                 
299:                     return ( ARPPut(&packet) );
9D014A1C  27C20010   ADDIU V0, S8, 16
9D014A20  00402021   ADDU A0, V0, ZERO
9D014A24  0F405291   JAL 0x9D014A44
9D014A28  00000000   NOP
300:                 }
9D014A2C  03C0E821   ADDU SP, S8, ZERO
9D014A30  8FBF0034   LW RA, 52(SP)
9D014A34  8FBE0030   LW S8, 48(SP)
9D014A38  27BD0038   ADDIU SP, SP, 56
9D014A3C  03E00008   JR RA
9D014A40  00000000   NOP
301:                 
302:                 /*****************************************************************************
303:                   Function:
304:                     static bool ARPPut(ARP_PACKET* packet)
305:                 
306:                   Description:
307:                     Writes an ARP packet to the MAC.
308:                 
309:                   Precondition:
310:                     None
311:                 
312:                   Parameters:
313:                     packet - A pointer to an ARP_PACKET structure with correct operation
314:                                 and target preconfigured.
315:                 
316:                   Return Values:
317:                     true - The ARP packet was generated properly
318:                     false - Not a possible return value
319:                   ***************************************************************************/
320:                 static bool ARPPut(ARP_PACKET* packet)
321:                 {
9D014A44  27BDFFE8   ADDIU SP, SP, -24
9D014A48  AFBF0014   SW RA, 20(SP)
9D014A4C  AFBE0010   SW S8, 16(SP)
9D014A50  03A0F021   ADDU S8, SP, ZERO
9D014A54  AFC40018   SW A0, 24(S8)
322:                     while(!MACIsTxReady());
9D014A58  00000000   NOP
9D014A5C  0F40453A   JAL MACIsTxReady
9D014A60  00000000   NOP
9D014A64  38420001   XORI V0, V0, 1
9D014A68  304200FF   ANDI V0, V0, 255
9D014A6C  1440FFFB   BNE V0, ZERO, 0x9D014A5C
9D014A70  00000000   NOP
323:                     MACSetWritePtr(BASE_TX_ADDR);
9D014A74  0F404508   JAL MACGetTxBaseAddr
9D014A78  00000000   NOP
9D014A7C  00402021   ADDU A0, V0, ZERO
9D014A80  0F40452C   JAL MACSetWritePtr
9D014A84  00000000   NOP
324:                 
325:                 
326:                     packet->HardwareType  = HW_ETHERNET;
9D014A88  8FC20018   LW V0, 24(S8)
9D014A8C  24030001   ADDIU V1, ZERO, 1
9D014A90  A4430000   SH V1, 0(V0)
327:                     packet->Protocol      = ARP_IP;
9D014A94  8FC20018   LW V0, 24(S8)
9D014A98  24030800   ADDIU V1, ZERO, 2048
9D014A9C  A4430002   SH V1, 2(V0)
328:                     packet->MACAddrLen    = sizeof(MAC_ADDR);
9D014AA0  8FC20018   LW V0, 24(S8)
9D014AA4  24030006   ADDIU V1, ZERO, 6
9D014AA8  A0430004   SB V1, 4(V0)
329:                     packet->ProtocolLen   = sizeof(IP_ADDR);
9D014AAC  8FC20018   LW V0, 24(S8)
9D014AB0  24030004   ADDIU V1, ZERO, 4
9D014AB4  A0430005   SB V1, 5(V0)
330:                 //    packet->SenderMACAddr = AppConfig.MyMACAddr;  // HI-TECH PICC-18 compiler can't handle this statement, use memcpy() as a workaround
331:                     memcpy(&packet->SenderMACAddr, (void*)&AppConfig.MyMACAddr, sizeof(packet->SenderMACAddr));
9D014AB8  8FC20018   LW V0, 24(S8)
9D014ABC  24420008   ADDIU V0, V0, 8
9D014AC0  00402021   ADDU A0, V0, ZERO
9D014AC4  3C02A000   LUI V0, -24576
9D014AC8  24450905   ADDIU A1, V0, 2309
9D014ACC  24060006   ADDIU A2, ZERO, 6
9D014AD0  0F406788   JAL 0x9D019E20
9D014AD4  00000000   NOP
332:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
333:                     //packet->SenderIPAddr  = AppConfig.MyIPAddr; /* Removed for ZCLL, SenderIPAddr should be filled in */
334:                 #else
335:                     packet->SenderIPAddr  = AppConfig.MyIPAddr;
9D014AD8  8FC20018   LW V0, 24(S8)
9D014ADC  3C03A000   LUI V1, -24576
9D014AE0  246408D8   ADDIU A0, V1, 2264
9D014AE4  88840003   LWL A0, 3(A0)
9D014AE8  00802821   ADDU A1, A0, ZERO
9D014AEC  986508D8   LWR A1, 2264(V1)
9D014AF0  00A01821   ADDU V1, A1, ZERO
9D014AF4  A8430011   SWL V1, 17(V0)
9D014AF8  B843000E   SWR V1, 14(V0)
336:                 #endif
337:                 
338:                     SwapARPPacket(packet);
9D014AFC  8FC40018   LW A0, 24(S8)
9D014B00  0F4053DE   JAL SwapARPPacket
9D014B04  00000000   NOP
339:                 
340:                     MACPutHeader(&packet->TargetMACAddr, MAC_ARP, sizeof(*packet));
9D014B08  8FC20018   LW V0, 24(S8)
9D014B0C  24420012   ADDIU V0, V0, 18
9D014B10  00402021   ADDU A0, V0, ZERO
9D014B14  24050006   ADDIU A1, ZERO, 6
9D014B18  2406001C   ADDIU A2, ZERO, 28
9D014B1C  0F4045D5   JAL MACPutHeader
9D014B20  00000000   NOP
341:                     MACPutArray((uint8_t*)packet, sizeof(*packet));
9D014B24  8FC20018   LW V0, 24(S8)
9D014B28  00402021   ADDU A0, V0, ZERO
9D014B2C  2405001C   ADDIU A1, ZERO, 28
9D014B30  0F4045BD   JAL MACPutArray
9D014B34  00000000   NOP
342:                     MACFlush();
9D014B38  0F40460E   JAL MACFlush
9D014B3C  00000000   NOP
343:                 
344:                     return true;
9D014B40  24020001   ADDIU V0, ZERO, 1
345:                 }
9D014B44  03C0E821   ADDU SP, S8, ZERO
9D014B48  8FBF0014   LW RA, 20(SP)
9D014B4C  8FBE0010   LW S8, 16(SP)
9D014B50  27BD0018   ADDIU SP, SP, 24
9D014B54  03E00008   JR RA
9D014B58  00000000   NOP
346:                 
347:                 
348:                 
349:                 /*****************************************************************************
350:                   Function:
351:                     void ARPInit(void)
352:                 
353:                   Summary:
354:                     Initializes the ARP module.
355:                 
356:                   Description:
357:                     Initializes the ARP module.  Call this function once at boot to
358:                     invalidate the cached lookup.
359:                 
360:                   Precondition:
361:                     None
362:                 
363:                   Parameters:
364:                     None
365:                 
366:                   Returns:
367:                     None
368:                 
369:                   Remarks:
370:                     This function is only required when the stack is a client, and therefore
371:                     is only enabled when STACK_CLIENT_MODE is enabled.
372:                   ***************************************************************************/
373:                 #ifdef STACK_CLIENT_MODE
374:                 void ARPInit(void)
375:                 {
9D014B5C  27BDFFF8   ADDIU SP, SP, -8
9D014B60  AFBE0004   SW S8, 4(SP)
9D014B64  03A0F021   ADDU S8, SP, ZERO
376:                     Cache.MACAddr.v[0] = 0xff;
9D014B68  3C02A001   LUI V0, -24575
9D014B6C  24428914   ADDIU V0, V0, -30444
9D014B70  2403FFFF   ADDIU V1, ZERO, -1
9D014B74  A0430004   SB V1, 4(V0)
377:                     Cache.MACAddr.v[1] = 0xff;
9D014B78  3C02A001   LUI V0, -24575
9D014B7C  24428914   ADDIU V0, V0, -30444
9D014B80  2403FFFF   ADDIU V1, ZERO, -1
9D014B84  A0430005   SB V1, 5(V0)
378:                     Cache.MACAddr.v[2] = 0xff;
9D014B88  3C02A001   LUI V0, -24575
9D014B8C  24428914   ADDIU V0, V0, -30444
9D014B90  2403FFFF   ADDIU V1, ZERO, -1
9D014B94  A0430006   SB V1, 6(V0)
379:                     Cache.MACAddr.v[3] = 0xff;
9D014B98  3C02A001   LUI V0, -24575
9D014B9C  24428914   ADDIU V0, V0, -30444
9D014BA0  2403FFFF   ADDIU V1, ZERO, -1
9D014BA4  A0430007   SB V1, 7(V0)
380:                     Cache.MACAddr.v[4] = 0xff;
9D014BA8  3C02A001   LUI V0, -24575
9D014BAC  24428914   ADDIU V0, V0, -30444
9D014BB0  2403FFFF   ADDIU V1, ZERO, -1
9D014BB4  A0430008   SB V1, 8(V0)
381:                     Cache.MACAddr.v[5] = 0xff;
9D014BB8  3C02A001   LUI V0, -24575
9D014BBC  24428914   ADDIU V0, V0, -30444
9D014BC0  2403FFFF   ADDIU V1, ZERO, -1
9D014BC4  A0430009   SB V1, 9(V0)
382:                 
383:                     Cache.IPAddr.Val = 0xfffffffful;
9D014BC8  3C02A001   LUI V0, -24575
9D014BCC  2403FFFF   ADDIU V1, ZERO, -1
9D014BD0  AC438914   SW V1, -30444(V0)
384:                 }
9D014BD4  03C0E821   ADDU SP, S8, ZERO
9D014BD8  8FBE0004   LW S8, 4(SP)
9D014BDC  27BD0008   ADDIU SP, SP, 8
9D014BE0  03E00008   JR RA
9D014BE4  00000000   NOP
385:                 #endif
386:                 
387:                 
388:                 
389:                 /*****************************************************************************
390:                   Function:
391:                     bool ARPProcess(void)
392:                 
393:                   Summary:
394:                     Processes an incoming ARP packet.
395:                 
396:                   Description:
397:                     Retrieves an ARP packet from the MAC buffer and determines if it is a
398:                     response to our request (in which case the ARP is resolved) or if it
399:                     is a request requiring our response (in which case we transmit one.)
400:                 
401:                   Precondition:
402:                     ARP packet is ready in the MAC buffer.
403:                 
404:                   Parameters:
405:                     None
406:                 
407:                   Return Values:
408:                     true - All processing of this ARP packet is complete.  Do not call
409:                             again until a new ARP packet is waiting in the RX buffer.
410:                     false - This function must be called again.  More time is needed to
411:                             send an ARP response.
412:                   ***************************************************************************/
413:                 bool ARPProcess(void)
414:                 {
9D014BE8  27BDFFC8   ADDIU SP, SP, -56
9D014BEC  AFBF0034   SW RA, 52(SP)
9D014BF0  AFBE0030   SW S8, 48(SP)
9D014BF4  03A0F021   ADDU S8, SP, ZERO
415:                     ARP_PACKET packet;
416:                     static NODE_INFO Target;
417:                     #if defined(STACK_USE_AUTO_IP)
418:                         uint8_t i;
419:                     #endif
420:                     static enum
421:                     {
422:                         SM_ARP_IDLE = 0,
423:                         SM_ARP_REPLY
424:                     } smARP = SM_ARP_IDLE;
425:                 
426:                     switch(smARP)
9D014BF8  8F82802C   LW V0, -32724(GP)
9D014BFC  10400006   BEQ V0, ZERO, 0x9D014C18
9D014C00  00000000   NOP
9D014C04  24030001   ADDIU V1, ZERO, 1
9D014C08  1043004A   BEQ V0, V1, 0x9D014D34
9D014C0C  00000000   NOP
9D014C10  0B405366   J 0x9D014D98
9D014C14  00000000   NOP
427:                     {
428:                         case SM_ARP_IDLE:
429:                             // Obtain the incoming ARP packet
430:                             MACGetArray((uint8_t*)&packet, sizeof(packet));
9D014C18  27C20010   ADDIU V0, S8, 16
9D014C1C  00402021   ADDU A0, V0, ZERO
9D014C20  2405001C   ADDIU A1, ZERO, 28
9D014C24  0F4046D1   JAL MACGetArray
9D014C28  00000000   NOP
431:                             MACDiscardRx();
9D014C2C  0F40462A   JAL MACDiscardRx
9D014C30  00000000   NOP
432:                             SwapARPPacket(&packet);
9D014C34  27C20010   ADDIU V0, S8, 16
9D014C38  00402021   ADDU A0, V0, ZERO
9D014C3C  0F4053DE   JAL SwapARPPacket
9D014C40  00000000   NOP
433:                 
434:                             // Validate the ARP packet
435:                             if ( packet.HardwareType != HW_ETHERNET     ||
9D014C44  97C30010   LHU V1, 16(S8)
9D014C48  24020001   ADDIU V0, ZERO, 1
9D014C4C  14620009   BNE V1, V0, 0x9D014C74
9D014C50  00000000   NOP
9D014C58  24020006   ADDIU V0, ZERO, 6
9D014C5C  14620005   BNE V1, V0, 0x9D014C74
9D014C60  00000000   NOP
436:                                  packet.MACAddrLen != sizeof(MAC_ADDR)  ||
9D014C54  93C30014   LBU V1, 20(S8)
9D014C68  24020004   ADDIU V0, ZERO, 4
9D014C6C  10620004   BEQ V1, V0, 0x9D014C80
9D014C70  00000000   NOP
437:                                  packet.ProtocolLen != sizeof(IP_ADDR) )
9D014C64  93C30015   LBU V1, 21(S8)
438:                             {
439:                                  return true;
9D014C74  24020001   ADDIU V0, ZERO, 1
9D014C78  0B405367   J 0x9D014D9C
9D014C7C  00000000   NOP
440:                             }
441:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
442:                             ARPProcessRxPkt(&packet);
443:                 #endif
444:                 
445:                 #ifdef STACK_USE_AUTO_IP
446:                             if (packet.SenderIPAddr.Val == AppConfig.MyIPAddr.Val)
447:                             {
448:                                 AutoIPConflict(0);
449:                                 return true;
450:                             }
451:                 #endif
452:                 
453:                             // Handle incoming ARP responses
454:                 #ifdef STACK_CLIENT_MODE
455:                             if(packet.Operation == ARP_OPERATION_RESP)
9D014C80  97C30016   LHU V1, 22(S8)
9D014C84  24020002   ADDIU V0, ZERO, 2
9D014C88  1462000E   BNE V1, V0, 0x9D014CC4
9D014C8C  00000000   NOP
456:                             {
457:                 /*                #if defined(STACK_USE_AUTO_IP)
458:                                 for (i = 0; i < NETWORK_INTERFACES; i++)
459:                                     if (AutoIPConfigIsInProgress(i))
460:                                         AutoIPConflict(i);
461:                                 #endif*/
462:                                 Cache.MACAddr = packet.SenderMACAddr;
9D014C90  3C02A001   LUI V0, -24575
9D014C94  24428914   ADDIU V0, V0, -30444
9D014C98  8FC30018   LW V1, 24(S8)
9D014C9C  AC430004   SW V1, 4(V0)
9D014CA0  97C3001C   LHU V1, 28(S8)
9D014CA4  A4430008   SH V1, 8(V0)
463:                                 Cache.IPAddr = packet.SenderIPAddr;
9D014CA8  3C02A001   LUI V0, -24575
9D014CAC  8BC30021   LWL V1, 33(S8)
9D014CB0  9BC3001E   LWR V1, 30(S8)
9D014CB4  AC438914   SW V1, -30444(V0)
464:                 
465:                                 //putsUART("ARPProcess: SM_ARP_IDLE: ARP_OPERATION_RESP  \r\n");
466:                                 return true;
9D014CB8  24020001   ADDIU V0, ZERO, 1
9D014CBC  0B405367   J 0x9D014D9C
9D014CC0  00000000   NOP
467:                             }
468:                 #endif
469:                 
470:                             // Handle incoming ARP requests for our MAC address
471:                             if(packet.Operation == ARP_OPERATION_REQ)
9D014CC4  97C30016   LHU V1, 22(S8)
9D014CC8  24020001   ADDIU V0, ZERO, 1
9D014CCC  14620019   BNE V1, V0, 0x9D014D34
9D014CD0  00000000   NOP
472:                             {
473:                                 if(packet.TargetIPAddr.Val != AppConfig.MyIPAddr.Val)
9D014CD4  8FC30028   LW V1, 40(S8)
9D014CD8  3C02A000   LUI V0, -24576
9D014CDC  244408D8   ADDIU A0, V0, 2264
9D014CE0  88840003   LWL A0, 3(A0)
9D014CE4  00802821   ADDU A1, A0, ZERO
9D014CE8  984508D8   LWR A1, 2264(V0)
9D014CEC  00A01021   ADDU V0, A1, ZERO
9D014CF0  10620004   BEQ V1, V0, 0x9D014D04
9D014CF4  00000000   NOP
474:                                 {
475:                                     return true;
9D014CF8  24020001   ADDIU V0, ZERO, 1
9D014CFC  0B405367   J 0x9D014D9C
9D014D00  00000000   NOP
476:                                 }
477:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
478:                                                /* Fix for Loop-Back suppression:
479:                                                 * For ZCLL-Claim packets, host should not respond.
480:                                                 * Check Sender's MAC-address with own MAC-address and
481:                                                 * if it is matched, response will not be sent back. This
482:                                                 * was leading to flooding of ARP-answeres */
483:                                                 if(!memcmp (&packet.SenderMACAddr, &AppConfig.MyMACAddr, 6))
484:                                                 {
485:                                                      putsUART("Loopback answer suppressed \r\n");
486:                                                      return true;
487:                                                 }
488:                 #endif
489:                                 #if defined(STACK_USE_AUTO_IP)
490:                                 for (i = 0; i < NETWORK_INTERFACES; i++)
491:                                     if (AutoIPConfigIsInProgress(i))
492:                                     {
493:                                         AutoIPConflict(i);
494:                                         return true;
495:                                     }
496:                                 #endif
497:                                 Target.IPAddr = packet.SenderIPAddr;
9D014D04  3C02A001   LUI V0, -24575
9D014D08  8BC30021   LWL V1, 33(S8)
9D014D0C  9BC3001E   LWR V1, 30(S8)
9D014D10  AC438920   SW V1, -30432(V0)
498:                                 Target.MACAddr = packet.SenderMACAddr;
9D014D14  3C02A001   LUI V0, -24575
9D014D18  24428920   ADDIU V0, V0, -30432
9D014D1C  8FC30018   LW V1, 24(S8)
9D014D20  AC430004   SW V1, 4(V0)
9D014D24  97C3001C   LHU V1, 28(S8)
9D014D28  A4430008   SH V1, 8(V0)
499:                 
500:                                 //putsUART("ARPProcess: SM_ARP_IDLE: ARP_OPERATION_REQ  \r\n");
501:                 
502:                                 smARP = SM_ARP_REPLY;
9D014D2C  24020001   ADDIU V0, ZERO, 1
9D014D30  AF82802C   SW V0, -32724(GP)
503:                             }
504:                             // Do not break.  If we get down here, we need to send a reply.
505:                 
506:                         case SM_ARP_REPLY:
507:                             packet.Operation        = ARP_OPERATION_RESP;
9D014D34  24020002   ADDIU V0, ZERO, 2
9D014D38  A7C20016   SH V0, 22(S8)
508:                             #if defined(STACK_USE_AUTO_IP)
509:                             if (AutoIPIsConfigured(0))
510:                             {
511:                                 packet.TargetMACAddr.v[0] = 0xFF;
512:                                 packet.TargetMACAddr.v[1] = 0xFF;
513:                                 packet.TargetMACAddr.v[2] = 0xFF;
514:                                 packet.TargetMACAddr.v[3] = 0xFF;
515:                                 packet.TargetMACAddr.v[4] = 0xFF;
516:                                 packet.TargetMACAddr.v[5] = 0xFF;
517:                             }
518:                             else
519:                             #endif
520:                                 packet.TargetMACAddr    = Target.MACAddr;
9D014D3C  3C02A001   LUI V0, -24575
9D014D40  24428920   ADDIU V0, V0, -30432
9D014D44  8C430004   LW V1, 4(V0)
9D014D48  ABC30025   SWL V1, 37(S8)
9D014D4C  BBC30022   SWR V1, 34(S8)
9D014D50  94420008   LHU V0, 8(V0)
9D014D54  A7C20026   SH V0, 38(S8)
521:                             packet.TargetIPAddr     = Target.IPAddr;
9D014D58  3C02A001   LUI V0, -24575
9D014D5C  8C428920   LW V0, -30432(V0)
9D014D60  AFC20028   SW V0, 40(S8)
522:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
523:                             packet.SenderIPAddr     = AppConfig.MyIPAddr;
524:                 #endif
525:                             //putsUART("ARPProcess: SM_ARP_REPLY  \r\n");
526:                 
527:                             // Send an ARP response to a previously received request
528:                             if(!ARPPut(&packet))
9D014D64  27C20010   ADDIU V0, S8, 16
9D014D68  00402021   ADDU A0, V0, ZERO
9D014D6C  0F405291   JAL 0x9D014A44
9D014D70  00000000   NOP
9D014D74  38420001   XORI V0, V0, 1
9D014D78  304200FF   ANDI V0, V0, 255
9D014D7C  10400004   BEQ V0, ZERO, 0x9D014D90
9D014D80  00000000   NOP
529:                             {
530:                                return false;
9D014D84  00001021   ADDU V0, ZERO, ZERO
9D014D88  0B405367   J 0x9D014D9C
9D014D8C  00000000   NOP
531:                             }
532:                 
533:                             // Begin listening for ARP requests again
534:                             smARP = SM_ARP_IDLE;
9D014D90  AF80802C   SW ZERO, -32724(GP)
535:                             break;
9D014D94  00000000   NOP
536:                     }
537:                 
538:                     return true;
9D014D98  24020001   ADDIU V0, ZERO, 1
539:                 }
9D014D9C  03C0E821   ADDU SP, S8, ZERO
9D014DA0  8FBF0034   LW RA, 52(SP)
9D014DA4  8FBE0030   LW S8, 48(SP)
9D014DA8  27BD0038   ADDIU SP, SP, 56
9D014DAC  03E00008   JR RA
9D014DB0  00000000   NOP
540:                 
541:                 /*****************************************************************************
542:                   Function:
543:                     void ARPResolve(IP_ADDR* IPAddr)
544:                 
545:                   Summary:
546:                     Transmits an ARP request to resolve an IP address.
547:                 
548:                   Description:
549:                     This function transmits and ARP request to determine the hardware
550:                     address of a given IP address.
551:                 
552:                   Precondition:
553:                     None
554:                 
555:                   Parameters:
556:                     IPAddr - The IP address to be resolved.  The address must be specified
557:                              in network byte order (big endian).
558:                 
559:                   Returns:
560:                     None
561:                 
562:                   Remarks:
563:                     This function is only required when the stack is a client, and therefore
564:                     is only enabled when STACK_CLIENT_MODE is enabled.
565:                 
566:                     To retrieve the ARP query result, call the ARPIsResolved() function.
567:                   ***************************************************************************/
568:                 #ifdef STACK_CLIENT_MODE
569:                 void ARPResolve(IP_ADDR* IPAddr)
570:                 {
9D014DB4  27BDFFC8   ADDIU SP, SP, -56
9D014DB8  AFBF0034   SW RA, 52(SP)
9D014DBC  AFBE0030   SW S8, 48(SP)
9D014DC0  03A0F021   ADDU S8, SP, ZERO
9D014DC4  AFC40038   SW A0, 56(S8)
571:                     ARP_PACKET packet;
572:                 
573:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
574:                 #define KS_ARP_IP_MULTICAST_HACK y
575:                 #ifdef KS_ARP_IP_MULTICAST_HACK
576:                     if ((IPAddr->v[0] >= 224) &&(IPAddr->v[0] <= 239))
577:                     {
578:                         // "Resolve" the IP to MAC address mapping for
579:                         // IP multicast address range from 224.0.0.0 to 239.255.255.255
580:                 
581:                         Cache.MACAddr.v[0] = 0x01;
582:                         Cache.MACAddr.v[1] = 0x00;
583:                         Cache.MACAddr.v[2] = 0x5E;
584:                         Cache.MACAddr.v[3] = 0x7f & IPAddr->v[1];
585:                         Cache.MACAddr.v[4] = IPAddr->v[2];
586:                         Cache.MACAddr.v[5] = IPAddr->v[3];
587:                 
588:                         Cache.IPAddr.Val = IPAddr->Val;
589:                 
590:                         return;
591:                     }
592:                 #endif
593:                 #endif
594:                 
595:                     packet.Operation            = ARP_OPERATION_REQ;
9D014DC8  24020001   ADDIU V0, ZERO, 1
9D014DCC  A7C20016   SH V0, 22(S8)
596:                     packet.TargetMACAddr.v[0]   = 0xff;
9D014DD0  2402FFFF   ADDIU V0, ZERO, -1
9D014DD4  A3C20022   SB V0, 34(S8)
597:                     packet.TargetMACAddr.v[1]   = 0xff;
9D014DD8  2402FFFF   ADDIU V0, ZERO, -1
9D014DDC  A3C20023   SB V0, 35(S8)
598:                     packet.TargetMACAddr.v[2]   = 0xff;
9D014DE0  2402FFFF   ADDIU V0, ZERO, -1
9D014DE4  A3C20024   SB V0, 36(S8)
599:                     packet.TargetMACAddr.v[3]   = 0xff;
9D014DE8  2402FFFF   ADDIU V0, ZERO, -1
9D014DEC  A3C20025   SB V0, 37(S8)
600:                     packet.TargetMACAddr.v[4]   = 0xff;
9D014DF0  2402FFFF   ADDIU V0, ZERO, -1
9D014DF4  A3C20026   SB V0, 38(S8)
601:                     packet.TargetMACAddr.v[5]   = 0xff;
9D014DF8  2402FFFF   ADDIU V0, ZERO, -1
9D014DFC  A3C20027   SB V0, 39(S8)
602:                 
603:                     //putsUART("ARPResolve() \r\n");
604:                 
605:                     // ARP query either the IP address directly (on our subnet), or do an ARP query for our Gateway if off of our subnet
606:                     packet.TargetIPAddr         = ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val) ? AppConfig.MyGateway : *IPAddr;
9D014E00  3C02A000   LUI V0, -24576
9D014E04  244308D8   ADDIU V1, V0, 2264
9D014E08  88630003   LWL V1, 3(V1)
9D014E0C  984308D8   LWR V1, 2264(V0)
9D014E10  8FC20038   LW V0, 56(S8)
9D014E14  8C420000   LW V0, 0(V0)
9D014E18  00621826   XOR V1, V1, V0
9D014E1C  3C02A000   LUI V0, -24576
9D014E20  244208D8   ADDIU V0, V0, 2264
9D014E24  88440007   LWL A0, 7(V0)
9D014E28  00802821   ADDU A1, A0, ZERO
9D014E2C  98450004   LWR A1, 4(V0)
9D014E30  00A01021   ADDU V0, A1, ZERO
9D014E34  00621024   AND V0, V1, V0
9D014E38  1040000A   BEQ V0, ZERO, 0x9D014E64
9D014E3C  00000000   NOP
9D014E40  3C02A000   LUI V0, -24576
9D014E44  244208D8   ADDIU V0, V0, 2264
9D014E48  8843000B   LWL V1, 11(V0)
9D014E4C  00602021   ADDU A0, V1, ZERO
9D014E50  98440008   LWR A0, 8(V0)
9D014E54  00801021   ADDU V0, A0, ZERO
9D014E58  AFC20028   SW V0, 40(S8)
9D014E5C  0B40539C   J 0x9D014E70
9D014E60  00000000   NOP
9D014E64  8FC20038   LW V0, 56(S8)
9D014E68  8C420000   LW V0, 0(V0)
9D014E6C  AFC20028   SW V0, 40(S8)
607:                 #ifdef STACK_USE_ZEROCONF_LINK_LOCAL
608:                     packet.SenderIPAddr         = AppConfig.MyIPAddr;
609:                 #endif
610:                 
611:                     ARPPut(&packet);
9D014E70  27C20010   ADDIU V0, S8, 16
9D014E74  00402021   ADDU A0, V0, ZERO
9D014E78  0F405291   JAL 0x9D014A44
9D014E7C  00000000   NOP
612:                 }
9D014E80  03C0E821   ADDU SP, S8, ZERO
9D014E84  8FBF0034   LW RA, 52(SP)
9D014E88  8FBE0030   LW S8, 48(SP)
9D014E8C  27BD0038   ADDIU SP, SP, 56
9D014E90  03E00008   JR RA
9D014E94  00000000   NOP
613:                 #endif
614:                 
615:                 
616:                 
617:                 
618:                 /*****************************************************************************
619:                   Function:
620:                     bool ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
621:                 
622:                   Summary:
623:                     Determines if an ARP request has been resolved yet.
624:                 
625:                   Description:
626:                     This function checks if an ARP request has been resolved yet, and if
627:                     so, stores the resolved MAC address in the pointer provided.
628:                 
629:                   Precondition:
630:                     ARP packet is ready in the MAC buffer.
631:                 
632:                   Parameters:
633:                     IPAddr - The IP address to be resolved.  This must match the IP address
634:                              provided to the ARPResolve() function call.
635:                     MACAddr - A buffer to store the corresponding MAC address retrieved from
636:                              the ARP query.
637:                 
638:                   Return Values:
639:                     true - The IP address has been resolved and MACAddr MAC address field
640:                            indicates the response.
641:                     false - The IP address is not yet resolved.  Try calling ARPIsResolved()
642:                            again at a later time.  If you don't get a response after a
643:                            application specific timeout period, you may want to call
644:                            ARPResolve() again to transmit another ARP query (in case if the
645:                            original query or response was lost on the network).  If you never
646:                            receive an ARP response, this may indicate that the IP address
647:                            isn't in use.
648:                 
649:                   Remarks:
650:                     This function is only required when the stack is a client, and therefore
651:                     is only enabled when STACK_CLIENT_MODE is enabled.
652:                   ***************************************************************************/
653:                 #ifdef STACK_CLIENT_MODE
654:                 bool ARPIsResolved(IP_ADDR* IPAddr, MAC_ADDR* MACAddr)
655:                 {
9D014E98  27BDFFF8   ADDIU SP, SP, -8
9D014E9C  AFBE0004   SW S8, 4(SP)
9D014EA0  03A0F021   ADDU S8, SP, ZERO
9D014EA4  AFC40008   SW A0, 8(S8)
9D014EA8  AFC5000C   SW A1, 12(S8)
656:                     if((Cache.IPAddr.Val == IPAddr->Val) ||
9D014EAC  3C02A001   LUI V0, -24575
9D014EB0  8C438914   LW V1, -30444(V0)
9D014EB4  8FC20008   LW V0, 8(S8)
9D014EB8  8C420000   LW V0, 0(V0)
9D014EBC  1062001B   BEQ V1, V0, 0x9D014F2C
9D014EC0  00000000   NOP
9D014EE4  1462001E   BNE V1, V0, 0x9D014F60
9D014EE8  00000000   NOP
657:                       ((Cache.IPAddr.Val == AppConfig.MyGateway.Val) && ((AppConfig.MyIPAddr.Val ^ IPAddr->Val) & AppConfig.MyMask.Val)))
9D014EC4  3C02A001   LUI V0, -24575
9D014EC8  8C438914   LW V1, -30444(V0)
9D014ECC  3C02A000   LUI V0, -24576
9D014ED0  244208D8   ADDIU V0, V0, 2264
9D014ED4  8844000B   LWL A0, 11(V0)
9D014ED8  00802821   ADDU A1, A0, ZERO
9D014EDC  98450008   LWR A1, 8(V0)
9D014EE0  00A01021   ADDU V0, A1, ZERO
9D014EEC  3C02A000   LUI V0, -24576
9D014EF0  244308D8   ADDIU V1, V0, 2264
9D014EF4  88630003   LWL V1, 3(V1)
9D014EF8  984308D8   LWR V1, 2264(V0)
9D014EFC  8FC20008   LW V0, 8(S8)
9D014F00  8C420000   LW V0, 0(V0)
9D014F04  00621826   XOR V1, V1, V0
9D014F08  3C02A000   LUI V0, -24576
9D014F0C  244208D8   ADDIU V0, V0, 2264
9D014F10  88440007   LWL A0, 7(V0)
9D014F14  00802821   ADDU A1, A0, ZERO
9D014F18  98450004   LWR A1, 4(V0)
9D014F1C  00A01021   ADDU V0, A1, ZERO
9D014F20  00621024   AND V0, V1, V0
9D014F24  1040000E   BEQ V0, ZERO, 0x9D014F60
9D014F28  00000000   NOP
658:                     {
659:                         *MACAddr = Cache.MACAddr;
9D014F2C  8FC2000C   LW V0, 12(S8)
9D014F30  3C03A001   LUI V1, -24575
9D014F34  24638914   ADDIU V1, V1, -30444
9D014F38  8C640004   LW A0, 4(V1)
9D014F3C  A8440003   SWL A0, 3(V0)
9D014F40  B8440000   SWR A0, 0(V0)
9D014F44  90640008   LBU A0, 8(V1)
9D014F48  A0440004   SB A0, 4(V0)
9D014F4C  90630009   LBU V1, 9(V1)
9D014F50  A0430005   SB V1, 5(V0)
660:                         //putsUART("ARPIsResolved  \r\n");
661:                         return true;
9D014F54  24020001   ADDIU V0, ZERO, 1
9D014F58  0B4053D9   J 0x9D014F64
9D014F5C  00000000   NOP
662:                     }
663:                 
664:                     //putsUART("ARPIs  NOT Resolved  \r\n");
665:                 
666:                     return false;
9D014F60  00001021   ADDU V0, ZERO, ZERO
667:                 }
9D014F64  03C0E821   ADDU SP, S8, ZERO
9D014F68  8FBE0004   LW S8, 4(SP)
9D014F6C  27BD0008   ADDIU SP, SP, 8
9D014F70  03E00008   JR RA
9D014F74  00000000   NOP
668:                 #endif
669:                 
670:                 
671:                 
672:                 /*****************************************************************************
673:                   Function:
674:                     void SwapARPPacket(ARP_PACKET* p)
675:                 
676:                   Description:
677:                     Swaps endian-ness of header information in an ARP packet.
678:                 
679:                   Precondition:
680:                     None
681:                 
682:                   Parameters:
683:                     p - The ARP packet to be swapped
684:                 
685:                   Returns:
686:                     None
687:                   ***************************************************************************/
688:                 void SwapARPPacket(ARP_PACKET* p)
689:                 {
9D014F78  27BDFFE8   ADDIU SP, SP, -24
9D014F7C  AFBF0014   SW RA, 20(SP)
9D014F80  AFBE0010   SW S8, 16(SP)
9D014F84  03A0F021   ADDU S8, SP, ZERO
9D014F88  AFC40018   SW A0, 24(S8)
690:                     p->HardwareType     = swaps(p->HardwareType);
9D014F8C  8FC20018   LW V0, 24(S8)
9D014F90  94420000   LHU V0, 0(V0)
9D014F94  00402021   ADDU A0, V0, ZERO
9D014F98  0F403F50   JAL swaps
9D014F9C  00000000   NOP
9D014FA0  00401821   ADDU V1, V0, ZERO
9D014FA4  8FC20018   LW V0, 24(S8)
9D014FA8  A4430000   SH V1, 0(V0)
691:                     p->Protocol         = swaps(p->Protocol);
9D014FAC  8FC20018   LW V0, 24(S8)
9D014FB0  94420002   LHU V0, 2(V0)
9D014FB4  00402021   ADDU A0, V0, ZERO
9D014FB8  0F403F50   JAL swaps
9D014FBC  00000000   NOP
9D014FC0  00401821   ADDU V1, V0, ZERO
9D014FC4  8FC20018   LW V0, 24(S8)
9D014FC8  A4430002   SH V1, 2(V0)
692:                     p->Operation        = swaps(p->Operation);
9D014FCC  8FC20018   LW V0, 24(S8)
9D014FD0  94420006   LHU V0, 6(V0)
9D014FD4  00402021   ADDU A0, V0, ZERO
9D014FD8  0F403F50   JAL swaps
9D014FDC  00000000   NOP
9D014FE0  00401821   ADDU V1, V0, ZERO
9D014FE4  8FC20018   LW V0, 24(S8)
9D014FE8  A4430006   SH V1, 6(V0)
693:                 }
9D014FEC  03C0E821   ADDU SP, S8, ZERO
9D014FF0  8FBF0014   LW RA, 20(SP)
9D014FF4  8FBE0010   LW S8, 16(SP)
9D014FF8  27BD0018   ADDIU SP, SP, 24
9D014FFC  03E00008   JR RA
9D015000  00000000   NOP
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/spi.c  ----------------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   spi.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include <sys/attribs.h>
9:                   #include "spi.h"
10:                  
11:                  
12:                  static SPI_XFER *spi2Xfer;              // Null if idle, else pointer to data.
13:                  static volatile unsigned int rxCount;   // Count of SPI bytes received.
14:                  static volatile unsigned int txCount;   // Count of SPI bytes transmitted.
15:                  
16:                  
17:                  //==============================================================================
18:                  
19:                  void SPITask()
20:                  {
9D016BEC  27BDFFF0   ADDIU SP, SP, -16
9D016BF0  AFBE000C   SW S8, 12(SP)
9D016BF4  03A0F021   ADDU S8, SP, ZERO
21:                      uint8_t data;
22:                      
23:                      static enum {
24:                          SM_IDLE,
25:                          SM_START,
26:                          SM_PROCESS,
27:                      } spiTaskState = SM_IDLE;
28:                  
29:                      switch (spiTaskState)
9D016BF8  8F8280BC   LW V0, -32580(GP)
9D016BFC  24030001   ADDIU V1, ZERO, 1
9D016C00  10430013   BEQ V0, V1, 0x9D016C50
9D016C04  00000000   NOP
9D016C08  2C430001   SLTIU V1, V0, 1
9D016C0C  14600006   BNE V1, ZERO, 0x9D016C28
9D016C10  00000000   NOP
9D016C14  24030002   ADDIU V1, ZERO, 2
9D016C18  10430028   BEQ V0, V1, 0x9D016CBC
9D016C1C  00000000   NOP
9D016C20  0B405B5C   J 0x9D016D70
9D016C24  00000000   NOP
30:                      {
31:                          case SM_IDLE:
32:                          {
33:                              if ((SPI2STATbits.SPIBUSY == 1) || (spi2Xfer == 0))
9D016C28  3C02BF80   LUI V0, -16512
9D016C2C  8C425A10   LW V0, 23056(V0)
9D016C30  30420800   ANDI V0, V0, 2048
9D016C34  1440004E   BNE V0, ZERO, 0x9D016D70
9D016C38  00000000   NOP
9D016C3C  8F8280B0   LW V0, -32592(GP)
9D016C40  1040004B   BEQ V0, ZERO, 0x9D016D70
9D016C44  00000000   NOP
34:                              {
35:                                  break;
36:                              }
37:                              spiTaskState = SM_START;
9D016C48  24020001   ADDIU V0, ZERO, 1
9D016C4C  AF8280BC   SW V0, -32580(GP)
38:                              // No break.
39:                          }
40:                          case SM_START:
41:                          {
42:                              // Disable SPI2 Interrupts.
43:                              IEC1CLR = _IEC1_SPI2EIE_MASK | _IEC1_SPI2RXIE_MASK |
9D016C50  3C02BF88   LUI V0, -16504
9D016C54  240300E0   ADDIU V1, ZERO, 224
9D016C58  AC431074   SW V1, 4212(V0)
44:                                      _IEC1_SPI2TXIE_MASK;
45:                  
46:                              while (SPI2STATbits.SPIRBE == 0)
9D016C5C  0B405B1B   J 0x9D016C6C
9D016C60  00000000   NOP
9D016C6C  3C02BF80   LUI V0, -16512
9D016C70  8C425A10   LW V0, 23056(V0)
9D016C74  30420020   ANDI V0, V0, 32
9D016C78  1040FFFA   BEQ V0, ZERO, 0x9D016C64
9D016C7C  00000000   NOP
47:                              {
48:                                  SPI2BUF;                        // Flush RX buffer.
9D016C64  3C02BF80   LUI V0, -16512
9D016C68  8C425A20   LW V0, 23072(V0)
49:                              }
50:                  
51:                              mSPI2_SS_SET();                     // Assert slave select.
9D016C80  3C02BF88   LUI V0, -16504
9D016C84  24030200   ADDIU V1, ZERO, 512
9D016C88  AC4361A4   SW V1, 24996(V0)
52:                              rxCount = 0;                        // Clear RX byte counter.
9D016C8C  AF8080B4   SW ZERO, -32588(GP)
53:                              txCount = 0;                        // Clear TX byte counter.
9D016C90  AF8080B8   SW ZERO, -32584(GP)
54:                  
55:                              // Clear SPI2 Interrupt flags.
56:                              IFS1CLR = _IFS1_SPI2EIF_MASK | _IFS1_SPI2RXIF_MASK |
9D016C94  3C02BF88   LUI V0, -16504
9D016C98  240300E0   ADDIU V1, ZERO, 224
9D016C9C  AC431044   SW V1, 4164(V0)
57:                                      _IFS1_SPI2TXIF_MASK;
58:                  
59:                              // Enable SPI2 Interrupts.
60:                              IEC1SET = _IEC1_SPI2EIE_MASK | _IEC1_SPI2RXIE_MASK |
9D016CA0  3C02BF88   LUI V0, -16504
9D016CA4  240300E0   ADDIU V1, ZERO, 224
9D016CA8  AC431078   SW V1, 4216(V0)
61:                                      _IEC1_SPI2TXIE_MASK;
62:                  
63:                              spiTaskState = SM_PROCESS;
9D016CAC  24020002   ADDIU V0, ZERO, 2
9D016CB0  AF8280BC   SW V0, -32580(GP)
64:                              break;
9D016CB4  0B405B5C   J 0x9D016D70
9D016CB8  00000000   NOP
65:                          }
66:                          case SM_PROCESS:
67:                          {
68:                              // Disable SPI2 Interrupts.
69:                              IEC1CLR = _IEC1_SPI2EIE_MASK | _IEC1_SPI2RXIE_MASK |
9D016CBC  3C02BF88   LUI V0, -16504
9D016CC0  240300E0   ADDIU V1, ZERO, 224
9D016CC4  AC431074   SW V1, 4212(V0)
70:                                      _IEC1_SPI2TXIE_MASK;
71:                  
72:                              // Unload RX buffer. --------------------------
73:                  
74:                              while (SPI2STATbits.SPIRBE == 0)
9D016CC8  0B405B44   J 0x9D016D10
9D016CCC  00000000   NOP
9D016D10  3C02BF80   LUI V0, -16512
9D016D14  8C425A10   LW V0, 23056(V0)
9D016D18  30420020   ANDI V0, V0, 32
9D016D1C  1040FFEC   BEQ V0, ZERO, 0x9D016CD0
9D016D20  00000000   NOP
75:                              {
76:                                  data = SPI2BUF;
9D016CD0  3C02BF80   LUI V0, -16512
9D016CD4  8C425A20   LW V0, 23072(V0)
9D016CD8  A3C20000   SB V0, 0(S8)
77:                                  if (spi2Xfer->rxBuf != 0)
9D016CDC  8F8280B0   LW V0, -32592(GP)
9D016CE0  8C420004   LW V0, 4(V0)
9D016CE4  10400007   BEQ V0, ZERO, 0x9D016D04
9D016CE8  00000000   NOP
78:                                  {
79:                                      spi2Xfer->rxBuf[rxCount] = data;
9D016CEC  8F8280B0   LW V0, -32592(GP)
9D016CF0  8C430004   LW V1, 4(V0)
9D016CF4  8F8280B4   LW V0, -32588(GP)
9D016CF8  00621021   ADDU V0, V1, V0
9D016CFC  93C30000   LBU V1, 0(S8)
9D016D00  A0430000   SB V1, 0(V0)
80:                                  }
81:                                  rxCount++;
9D016D04  8F8280B4   LW V0, -32588(GP)
9D016D08  24420001   ADDIU V0, V0, 1
9D016D0C  AF8280B4   SW V0, -32588(GP)
82:                              }
83:                  
84:                              // Load TX buffer. ----------------------------
85:                  
86:                              // (See SPI2 TX interrupt routine for transmit logic.)
87:                  
88:                              // Check if transfer is complete. -------------
89:                  
90:                              if (rxCount == spi2Xfer->length)
9D016D24  8F8280B0   LW V0, -32592(GP)
9D016D28  8C43000C   LW V1, 12(V0)
9D016D2C  8F8280B4   LW V0, -32588(GP)
9D016D30  1462000B   BNE V1, V0, 0x9D016D60
9D016D34  00000000   NOP
91:                              {
92:                                  mSPI2_SS_CLR();             // Deassert slave select.
9D016D38  3C02BF88   LUI V0, -16504
9D016D3C  24030200   ADDIU V1, ZERO, 512
9D016D40  AC4361A8   SW V1, 25000(V0)
93:                                  spi2Xfer->xferDone = 1;     // Set transfer done flag.
9D016D44  8F8280B0   LW V0, -32592(GP)
9D016D48  24030001   ADDIU V1, ZERO, 1
9D016D4C  AC430010   SW V1, 16(V0)
94:                                  spi2Xfer = 0;               // Clear data pointer.
9D016D50  AF8080B0   SW ZERO, -32592(GP)
95:                                  spiTaskState = SM_IDLE;
9D016D54  AF8080BC   SW ZERO, -32580(GP)
96:                              }
97:                              else
98:                              {
99:                                  // Enable SPI2 Interrupts.
100:                                 IEC1SET = _IEC1_SPI2EIE_MASK | _IEC1_SPI2RXIE_MASK |
9D016D60  3C02BF88   LUI V0, -16504
9D016D64  240300E0   ADDIU V1, ZERO, 224
9D016D68  AC431078   SW V1, 4216(V0)
101:                                         _IEC1_SPI2TXIE_MASK;
102:                             }
103:                             break;
9D016D58  0B405B5C   J 0x9D016D70
9D016D5C  00000000   NOP
9D016D6C  00000000   NOP
104:                         }
105:                     }
106:                 }
9D016D70  03C0E821   ADDU SP, S8, ZERO
9D016D74  8FBE000C   LW S8, 12(SP)
9D016D78  27BD0010   ADDIU SP, SP, 16
9D016D7C  03E00008   JR RA
9D016D80  00000000   NOP
107:                 
108:                 
109:                 //==============================================================================
110:                 
111:                 int SPIXfer(SPI_XFER *xfer)
112:                 {
9D016D84  27BDFFF0   ADDIU SP, SP, -16
9D016D88  AFBE000C   SW S8, 12(SP)
9D016D8C  03A0F021   ADDU S8, SP, ZERO
9D016D90  AFC40010   SW A0, 16(S8)
113:                     enum {
114:                         SUCCESS = 0,
115:                         FAILURE = 1,
116:                     } spiXferStatus = FAILURE;
9D016D94  24020001   ADDIU V0, ZERO, 1
9D016D98  AFC20000   SW V0, 0(S8)
117:                     
118:                     // Non-NULL data supplied ?
119:                     if (xfer != 0)
9D016D9C  8FC20010   LW V0, 16(S8)
9D016DA0  10400014   BEQ V0, ZERO, 0x9D016DF4
9D016DA4  00000000   NOP
120:                     {
121:                         // Process data based on SPI port.
122:                         switch (xfer->port)
9D016DA8  8FC20010   LW V0, 16(S8)
9D016DAC  8C430000   LW V1, 0(V0)
9D016DB0  24020002   ADDIU V0, ZERO, 2
9D016DB4  1462000B   BNE V1, V0, 0x9D016DE4
9D016DB8  00000000   NOP
123:                         {
124:                             case SPI_PORT_SPI2:
125:                             {
126:                                 // SPI2 is currently not transferring data ?
127:                                 if (spi2Xfer == 0)
9D016DBC  8F8280B0   LW V0, -32592(GP)
9D016DC0  1440000B   BNE V0, ZERO, 0x9D016DF0
9D016DC4  00000000   NOP
128:                                 {
129:                                     // Set up buffer for transfer.
130:                                     spi2Xfer = xfer;            // Copy data pointer.
9D016DC8  8FC20010   LW V0, 16(S8)
9D016DCC  AF8280B0   SW V0, -32592(GP)
131:                                     xfer->xferDone = 0;         // Clear transfer done flag.
9D016DD0  8FC20010   LW V0, 16(S8)
9D016DD4  AC400010   SW ZERO, 16(V0)
132:                                     spiXferStatus = SUCCESS;    // Success.
9D016DD8  AFC00000   SW ZERO, 0(S8)
133:                                 }
134:                                 break;
9D016DDC  0B405B7D   J 0x9D016DF4
9D016DE0  00000000   NOP
9D016DF0  00000000   NOP
135:                             }
136:                             default:
137:                             {
138:                                 // Unknown SPI port.
139:                                 break;
9D016DE4  00000000   NOP
9D016DE8  0B405B7D   J 0x9D016DF4
9D016DEC  00000000   NOP
140:                             }
141:                         }
142:                     }
143:                     
144:                     return spiXferStatus;
9D016DF4  8FC20000   LW V0, 0(S8)
145:                 }
9D016DF8  03C0E821   ADDU SP, S8, ZERO
9D016DFC  8FBE000C   LW S8, 12(SP)
9D016E00  27BD0010   ADDIU SP, SP, 16
9D016E04  03E00008   JR RA
9D016E08  00000000   NOP
146:                 
147:                 
148:                 //==============================================================================
149:                 
150:                 // SPI2 ISR
151:                 
152:                 void __ISR (_SPI_2_VECTOR, IPL7SRS) SPI2ISR(void)
153:                 {
9D016E0C  415DE800   RDPGPR SP, SP
9D016E10  401A7000   MFC0 K0, EPC
9D016E14  401B6000   MFC0 K1, Status
9D016E18  27BDFFE8   ADDIU SP, SP, -24
9D016E1C  AFBB0014   SW K1, 20(SP)
9D016E20  7C1B7844   INS K1, ZERO, 1, 15
9D016E24  377B1C00   ORI K1, K1, 7168
9D016E28  409B6000   MTC0 K1, Status
9D016E2C  AFBE000C   SW S8, 12(SP)
9D016E30  03A0F021   ADDU S8, SP, ZERO
154:                     uint8_t data;
155:                 
156:                     // SPI2 Error Interrupt -------------------------------
157:                 
158:                     if (IFS1bits.SPI2EIF == 1)
9D016E34  3C02BF88   LUI V0, -16504
9D016E38  8C421040   LW V0, 4160(V0)
9D016E3C  30420020   ANDI V0, V0, 32
9D016E40  10400004   BEQ V0, ZERO, 0x9D016E54
9D016E44  00000000   NOP
159:                     {
160:                         // TODO: Error handling. See FRMERREN, SPIROVEN, and SPITUREN bits
161:                         //       in the SPIxCON2 register.
162:                 
163:                         IFS1CLR = _IFS1_SPI2EIF_MASK;       // Clear error interrupt flag.
9D016E48  3C02BF88   LUI V0, -16504
9D016E4C  24030020   ADDIU V1, ZERO, 32
9D016E50  AC431044   SW V1, 4164(V0)
164:                     }
165:                 
166:                     // SPI2 RX Interrupt ----------------------------------
167:                 
168:                     if (IFS1bits.SPI2RXIF == 1)
9D016E54  3C02BF88   LUI V0, -16504
9D016E58  8C421040   LW V0, 4160(V0)
9D016E5C  30420040   ANDI V0, V0, 64
9D016E60  1040001B   BEQ V0, ZERO, 0x9D016ED0
9D016E64  00000000   NOP
169:                     {
170:                         // RX buffer is one-half or more full.
171:                         while (SPI2STATbits.SPIRBE == 0)
9D016E68  0B405BAC   J 0x9D016EB0
9D016E6C  00000000   NOP
9D016EB0  3C02BF80   LUI V0, -16512
9D016EB4  8C425A10   LW V0, 23056(V0)
9D016EB8  30420020   ANDI V0, V0, 32
9D016EBC  1040FFEC   BEQ V0, ZERO, 0x9D016E70
9D016EC0  00000000   NOP
172:                         {
173:                             // Unload RX buffer.
174:                             data = SPI2BUF;
9D016E70  3C02BF80   LUI V0, -16512
9D016E74  8C425A20   LW V0, 23072(V0)
9D016E78  A3C20000   SB V0, 0(S8)
175:                             if (spi2Xfer->rxBuf != 0)
9D016E7C  8F8280B0   LW V0, -32592(GP)
9D016E80  8C420004   LW V0, 4(V0)
9D016E84  10400007   BEQ V0, ZERO, 0x9D016EA4
9D016E88  00000000   NOP
176:                             {
177:                                 spi2Xfer->rxBuf[rxCount] = data;
9D016E8C  8F8280B0   LW V0, -32592(GP)
9D016E90  8C430004   LW V1, 4(V0)
9D016E94  8F8280B4   LW V0, -32588(GP)
9D016E98  00621021   ADDU V0, V1, V0
9D016E9C  93C30000   LBU V1, 0(S8)
9D016EA0  A0430000   SB V1, 0(V0)
178:                             }
179:                             rxCount++;
9D016EA4  8F8280B4   LW V0, -32588(GP)
9D016EA8  24420001   ADDIU V0, V0, 1
9D016EAC  AF8280B4   SW V0, -32588(GP)
180:                         }
181:                         IFS1CLR = _IFS1_SPI2RXIF_MASK;      // Clear RX interrupt flag.
9D016EC4  3C02BF88   LUI V0, -16504
9D016EC8  24030040   ADDIU V1, ZERO, 64
9D016ECC  AC431044   SW V1, 4164(V0)
182:                     }
183:                 
184:                     // SPI2 TX Interrupt ----------------------------------
185:                 
186:                     if (IFS1bits.SPI2TXIF == 1)
9D016ED0  3C02BF88   LUI V0, -16504
9D016ED4  8C421040   LW V0, 4160(V0)
9D016ED8  30420080   ANDI V0, V0, 128
9D016EDC  10400032   BEQ V0, ZERO, 0x9D016FA8
9D016EE0  00000000   NOP
187:                     {
188:                         // TX buffer is one-half or more empty.
189:                         while ((SPI2STATbits.SPITBF == 0) &&        // TX buffer not full, and
9D016EE4  0B405BCE   J 0x9D016F38
9D016EE8  00000000   NOP
9D016F38  3C02BF80   LUI V0, -16512
9D016F3C  8C425A10   LW V0, 23056(V0)
9D016F40  30420002   ANDI V0, V0, 2
9D016F44  1440000D   BNE V0, ZERO, 0x9D016F7C
9D016F48  00000000   NOP
9D016F58  0043102B   SLTU V0, V0, V1
9D016F5C  10400007   BEQ V0, ZERO, 0x9D016F7C
9D016F60  00000000   NOP
190:                                 (txCount < spi2Xfer->length) &&     // more TX bytes left, and
9D016F4C  8F8280B0   LW V0, -32592(GP)
9D016F50  8C43000C   LW V1, 12(V0)
9D016F54  8F8280B8   LW V0, -32584(GP)
9D016F70  2C420010   SLTIU V0, V0, 16
9D016F74  1440FFDD   BNE V0, ZERO, 0x9D016EEC
9D016F78  00000000   NOP
191:                                 ((txCount - rxCount) < 16))         // TX count not exceeding
9D016F64  8F8380B8   LW V1, -32584(GP)
9D016F68  8F8280B4   LW V0, -32588(GP)
9D016F6C  00621023   SUBU V0, V1, V0
192:                                                                     //   16 byte RX buffer.
193:                         {
194:                             // Load the TX buffer.
195:                             if (spi2Xfer->txBuf == 0)
9D016EEC  8F8280B0   LW V0, -32592(GP)
9D016EF0  8C420008   LW V0, 8(V0)
9D016EF4  14400005   BNE V0, ZERO, 0x9D016F0C
9D016EF8  00000000   NOP
196:                             {
197:                                 SPI2BUF = 0x00;
9D016EFC  3C02BF80   LUI V0, -16512
9D016F00  AC405A20   SW ZERO, 23072(V0)
9D016F04  0B405BCB   J 0x9D016F2C
9D016F08  00000000   NOP
198:                             }
199:                             else
200:                             {
201:                                 SPI2BUF = spi2Xfer->txBuf[txCount];
9D016F0C  8F8280B0   LW V0, -32592(GP)
9D016F10  8C430008   LW V1, 8(V0)
9D016F14  8F8280B8   LW V0, -32584(GP)
9D016F18  00621021   ADDU V0, V1, V0
9D016F1C  90420000   LBU V0, 0(V0)
9D016F20  00401821   ADDU V1, V0, ZERO
9D016F24  3C02BF80   LUI V0, -16512
9D016F28  AC435A20   SW V1, 23072(V0)
202:                             }
203:                             txCount++;
9D016F2C  8F8280B8   LW V0, -32584(GP)
9D016F30  24420001   ADDIU V0, V0, 1
9D016F34  AF8280B8   SW V0, -32584(GP)
204:                         }
205:                         if (txCount == spi2Xfer->length)
9D016F7C  8F8280B0   LW V0, -32592(GP)
9D016F80  8C43000C   LW V1, 12(V0)
9D016F84  8F8280B8   LW V0, -32584(GP)
9D016F88  14620004   BNE V1, V0, 0x9D016F9C
9D016F8C  00000000   NOP
206:                         {
207:                             // TX data is fully loaded.  Disable the SPI2 TX interrupt.
208:                             IEC1CLR = _IEC1_SPI2TXIE_MASK;
9D016F90  3C02BF88   LUI V0, -16504
9D016F94  24030080   ADDIU V1, ZERO, 128
9D016F98  AC431074   SW V1, 4212(V0)
209:                         }
210:                         IFS1CLR = _IFS1_SPI2TXIF_MASK;      // Clear TX interrupt flag.
9D016F9C  3C02BF88   LUI V0, -16504
9D016FA0  24030080   ADDIU V1, ZERO, 128
9D016FA4  AC431044   SW V1, 4164(V0)
211:                     }
212:                 }
9D016FA8  03C0E821   ADDU SP, S8, ZERO
9D016FAC  8FBE000C   LW S8, 12(SP)
9D016FB0  8FBB0014   LW K1, 20(SP)
9D016FB4  27BD0018   ADDIU SP, SP, 24
9D016FB8  41DDE800   WRPGPR SP, SP
9D016FBC  409B6000   MTC0 K1, Status
9D016FC0  42000018   ERET
213:                 
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/softspi.c  ------------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   softspi.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include "tcpip/tcpip.h"
9:                   #include "system.h"
10:                  #include "softspi.h"
11:                  
12:                  static volatile uint32_t spiTxBuf;
13:                  static volatile uint32_t *spiRxBuf;
14:                  static volatile int spiXferBits;
15:                  static volatile int *completeFlag;
16:                  
17:                  
18:                  //=============================================================================
19:                  
20:                  
21:                  int SoftSPIXfer(SOFTSPI_TRANSFER *xfer)
22:                  {
9D017720  27BDFFF8   ADDIU SP, SP, -8
9D017724  AFBE0004   SW S8, 4(SP)
9D017728  03A0F021   ADDU S8, SP, ZERO
9D01772C  AFC40008   SW A0, 8(S8)
23:                      // Sanitize the inputs. -----------------------------------------
24:                  
25:                      if ((xfer->numOfBits < 1) || (xfer->numOfBits > 32))
9D017730  8FC20008   LW V0, 8(S8)
9D017734  8C42000C   LW V0, 12(V0)
9D017738  18400006   BLEZ V0, 0x9D017754
9D01773C  00000000   NOP
9D017740  8FC20008   LW V0, 8(S8)
9D017744  8C42000C   LW V0, 12(V0)
9D017748  28420021   SLTI V0, V0, 33
9D01774C  14400004   BNE V0, ZERO, 0x9D017760
9D017750  00000000   NOP
26:                      {
27:                          // Invalid number of bits to transfer.
28:                          return -1;
9D017754  2402FFFF   ADDIU V0, ZERO, -1
9D017758  0B405E40   J 0x9D017900
9D01775C  00000000   NOP
29:                      }
30:                      if ((xfer->freq < 0) || (xfer->freq > (GetPeripheralClock() / 2)))
9D017760  8FC20008   LW V0, 8(S8)
9D017764  8C420010   LW V0, 16(V0)
9D017768  04400009   BLTZ V0, 0x9D017790
9D01776C  00000000   NOP
9D017770  8FC20008   LW V0, 8(S8)
9D017774  8C420010   LW V0, 16(V0)
9D017778  00401821   ADDU V1, V0, ZERO
9D01777C  3C020262   LUI V0, 610
9D017780  34425A01   ORI V0, V0, 23041
9D017784  0062102B   SLTU V0, V1, V0
9D017788  14400004   BNE V0, ZERO, 0x9D01779C
9D01778C  00000000   NOP
31:                      {
32:                          // Invalid SPI clock.
33:                          return -1;
9D017790  2402FFFF   ADDIU V0, ZERO, -1
9D017794  0B405E40   J 0x9D017900
9D017798  00000000   NOP
34:                      }
35:                  
36:                      // Take control of software SPI bus if it's available. ----------
37:                  
38:                      if (mT5GetIntEnable())
9D01779C  3C02BF88   LUI V0, -16504
9D0177A0  8C431060   LW V1, 4192(V0)
9D0177A4  3C020010   LUI V0, 16
9D0177A8  00621024   AND V0, V1, V0
9D0177AC  10400004   BEQ V0, ZERO, 0x9D0177C0
9D0177B0  00000000   NOP
39:                      {
40:                          return -1;              // Software SPI bus is busy.
9D0177B4  2402FFFF   ADDIU V0, ZERO, -1
9D0177B8  0B405E40   J 0x9D017900
9D0177BC  00000000   NOP
41:                      }
42:                  
43:                      // Assert slave select line for desired bus device.
44:                      switch (xfer->dev)
9D0177C0  8FC20008   LW V0, 8(S8)
9D0177C4  8C420000   LW V0, 0(V0)
9D0177C8  14400005   BNE V0, ZERO, 0x9D0177E0
9D0177CC  00000000   NOP
45:                      {
46:                          case SOFTSPI_KSZ8895:   // Micrel KSZ8895
47:                          {
48:                              mSetSpiSsLow_KSZ8895();
9D0177D0  3C02BF88   LUI V0, -16504
9D0177D4  24030080   ADDIU V1, ZERO, 128
9D0177D8  AC436064   SW V1, 24676(V0)
49:                              break;
9D0177DC  00000000   NOP
50:                          }
51:                      }
52:                  
53:                      // Configure the software SPI timer for desired clock frequency.
54:                      if (GetPeripheralClock() % (xfer->freq * 2))
9D0177E0  8FC20008   LW V0, 8(S8)
9D0177E4  8C420010   LW V0, 16(V0)
9D0177E8  00021040   SLL V0, V0, 1
9D0177EC  00401821   ADDU V1, V0, ZERO
9D0177F0  3C0204C4   LUI V0, 1220
9D0177F4  3442B400   ORI V0, V0, -19456
9D0177F8  0043001B   DIVU V0, V1
9D0177FC  006001F4   TEQ V1, ZERO
9D017800  00001010   MFHI V0, 0
9D017804  10400010   BEQ V0, ZERO, 0x9D017848
9D017808  00000000   NOP
55:                      {
56:                          // No perfect frequency divisor possible.
57:                          // Round up to next period number to be conservative.
58:                          WritePeriod5((GetPeripheralClock() / (xfer->freq * 2)) + 1);
9D01780C  8FC20008   LW V0, 8(S8)
9D017810  8C420010   LW V0, 16(V0)
9D017814  00021040   SLL V0, V0, 1
9D017818  00401821   ADDU V1, V0, ZERO
9D01781C  3C0204C4   LUI V0, 1220
9D017820  3442B400   ORI V0, V0, -19456
9D017824  0043001B   DIVU V0, V1
9D017828  006001F4   TEQ V1, ZERO
9D01782C  00001810   MFHI V1, 0
9D017830  00001012   MFLO V0, 0
9D017834  24430001   ADDIU V1, V0, 1
9D017838  3C02BF80   LUI V0, -16512
9D01783C  AC430E20   SW V1, 3616(V0)
9D017840  0B405E1F   J 0x9D01787C
9D017844  00000000   NOP
59:                      }
60:                      else
61:                      {
62:                          // Perfect frequency match.
63:                          WritePeriod5(GetPeripheralClock() / (xfer->freq * 2));
9D017848  8FC20008   LW V0, 8(S8)
9D01784C  8C420010   LW V0, 16(V0)
9D017850  00021040   SLL V0, V0, 1
9D017854  00401821   ADDU V1, V0, ZERO
9D017858  3C0204C4   LUI V0, 1220
9D01785C  3442B400   ORI V0, V0, -19456
9D017860  0043001B   DIVU V0, V1
9D017864  006001F4   TEQ V1, ZERO
9D017868  00001810   MFHI V1, 0
9D01786C  00001012   MFLO V0, 0
9D017870  00401821   ADDU V1, V0, ZERO
9D017874  3C02BF80   LUI V0, -16512
9D017878  AC430E20   SW V1, 3616(V0)
64:                      }
65:                  
66:                      // Clear the receive buffer.
67:                      if (xfer->rxBuf != 0)
9D01787C  8FC20008   LW V0, 8(S8)
9D017880  8C420008   LW V0, 8(V0)
9D017884  10400004   BEQ V0, ZERO, 0x9D017898
9D017888  00000000   NOP
68:                      {
69:                          *xfer->rxBuf = 0;
9D01788C  8FC20008   LW V0, 8(S8)
9D017890  8C420008   LW V0, 8(V0)
9D017894  AC400000   SW ZERO, 0(V0)
70:                      }
71:                  
72:                      // Set global buffer pointers and bit counter.
73:                      spiTxBuf = xfer->txDat;
9D017898  8FC20008   LW V0, 8(S8)
9D01789C  8C420004   LW V0, 4(V0)
9D0178A0  AF8280DC   SW V0, -32548(GP)
74:                      spiRxBuf = xfer->rxBuf;
9D0178A4  8FC20008   LW V0, 8(S8)
9D0178A8  8C420008   LW V0, 8(V0)
9D0178AC  AF8280E0   SW V0, -32544(GP)
75:                      spiXferBits = xfer->numOfBits;
9D0178B0  8FC20008   LW V0, 8(S8)
9D0178B4  8C42000C   LW V0, 12(V0)
9D0178B8  AF8280E4   SW V0, -32540(GP)
76:                      completeFlag = &xfer->xferDone;
9D0178BC  8FC20008   LW V0, 8(S8)
9D0178C0  24420014   ADDIU V0, V0, 20
9D0178C4  AF8280E8   SW V0, -32536(GP)
77:                  
78:                      // Clear the xferDone flag before initiating transfer.
79:                      xfer->xferDone = 0;
9D0178C8  8FC20008   LW V0, 8(S8)
9D0178CC  AC400014   SW ZERO, 20(V0)
80:                  
81:                      TMR5 = 0;
9D0178D0  3C02BF80   LUI V0, -16512
9D0178D4  AC400E10   SW ZERO, 3600(V0)
82:                      mT5ClearIntFlag();
9D0178D8  3C02BF88   LUI V0, -16504
9D0178DC  3C030010   LUI V1, 16
9D0178E0  AC431034   SW V1, 4148(V0)
83:                      mT5IntEnable(1);        // Initiate software SPI transfer.
9D0178E4  3C02BF88   LUI V0, -16504
9D0178E8  3C030010   LUI V1, 16
9D0178EC  AC431064   SW V1, 4196(V0)
9D0178F0  3C02BF88   LUI V0, -16504
9D0178F4  3C030010   LUI V1, 16
9D0178F8  AC431068   SW V1, 4200(V0)
84:                  
85:                      return 0;
9D0178FC  00001021   ADDU V0, ZERO, ZERO
86:                  }
9D017900  03C0E821   ADDU SP, S8, ZERO
9D017904  8FBE0004   LW S8, 4(SP)
9D017908  27BD0008   ADDIU SP, SP, 8
9D01790C  03E00008   JR RA
9D017910  00000000   NOP
87:                  
88:                  
89:                  //=============================================================================
90:                  
91:                  
92:                  // Timer 5 ISR
93:                  void __ISR (_TIMER_5_VECTOR, IPL7SRS) Timer5ISR(void)
94:                  {
9D017914  415DE800   RDPGPR SP, SP
9D017918  401A7000   MFC0 K0, EPC
9D01791C  401B6000   MFC0 K1, Status
9D017920  27BDFFF0   ADDIU SP, SP, -16
9D017924  AFBB000C   SW K1, 12(SP)
9D017928  7C1B7844   INS K1, ZERO, 1, 15
9D01792C  377B1C00   ORI K1, K1, 7168
9D017930  409B6000   MTC0 K1, Status
9D017934  AFBE0004   SW S8, 4(SP)
9D017938  03A0F021   ADDU S8, SP, ZERO
95:                      static int spiState = 0;
96:                  
97:                      if (spiState < (2 * spiXferBits))
9D01793C  8F8280E4   LW V0, -32540(GP)
9D017940  00021840   SLL V1, V0, 1
9D017944  8F8280EC   LW V0, -32532(GP)
9D017948  0043102A   SLT V0, V0, V1
9D01794C  1040003C   BEQ V0, ZERO, 0x9D017A40
9D017950  00000000   NOP
98:                      {
99:                          if ((spiState % 2) == 0)
9D017954  8F8280EC   LW V0, -32532(GP)
9D017958  30420001   ANDI V0, V0, 1
9D01795C  1440001B   BNE V0, ZERO, 0x9D0179CC
9D017960  00000000   NOP
100:                         {
101:                             // Even state.
102:                             mSetSpiClkLow();
9D017964  3C02BF88   LUI V0, -16504
9D017968  24030040   ADDIU V1, ZERO, 64
9D01796C  AC436064   SW V1, 24676(V0)
103:                             if ((spiTxBuf >> (spiXferBits - (spiState / 2) - 1)) & 0x0001)
9D017970  8F8380DC   LW V1, -32548(GP)
9D017974  8F8480E4   LW A0, -32540(GP)
9D017978  8F8280EC   LW V0, -32532(GP)
9D01797C  00022FC2   SRL A1, V0, 31
9D017980  00A21021   ADDU V0, A1, V0
9D017984  00021043   SRA V0, V0, 1
9D017988  00821023   SUBU V0, A0, V0
9D01798C  2442FFFF   ADDIU V0, V0, -1
9D017990  00431006   SRLV V0, V1, V0
9D017994  30420001   ANDI V0, V0, 1
9D017998  304200FF   ANDI V0, V0, 255
9D01799C  10400006   BEQ V0, ZERO, 0x9D0179B8
9D0179A0  00000000   NOP
104:                             {
105:                                 mSetSpiMosiHigh();
9D0179A4  3C02BF88   LUI V0, -16504
9D0179A8  24030200   ADDIU V1, ZERO, 512
9D0179AC  AC436068   SW V1, 24680(V0)
9D0179B0  0B405E8B   J 0x9D017A2C
9D0179B4  00000000   NOP
106:                             }
107:                             else
108:                             {
109:                                 mSetSpiMosiLow();
9D0179B8  3C02BF88   LUI V0, -16504
9D0179BC  24030200   ADDIU V1, ZERO, 512
9D0179C0  AC436064   SW V1, 24676(V0)
9D0179C4  0B405E8B   J 0x9D017A2C
9D0179C8  00000000   NOP
110:                             }
111:                         }
112:                         else
113:                         {
114:                             // Odd state.
115:                             mSetSpiClkHigh();
9D0179CC  3C02BF88   LUI V0, -16504
9D0179D0  24030040   ADDIU V1, ZERO, 64
9D0179D4  AC436068   SW V1, 24680(V0)
116:                             if (spiRxBuf != 0)
9D0179D8  8F8280E0   LW V0, -32544(GP)
9D0179DC  10400013   BEQ V0, ZERO, 0x9D017A2C
9D0179E0  00000000   NOP
117:                             {
118:                                 *spiRxBuf |=
9D0179E4  8F8380E0   LW V1, -32544(GP)
9D0179E8  8F8280E0   LW V0, -32544(GP)
9D0179EC  8C440000   LW A0, 0(V0)
9D017A24  00821025   OR V0, A0, V0
9D017A28  AC620000   SW V0, 0(V1)
119:                                         (mGetSpiMiso() << (spiXferBits - (spiState / 2) - 1));
9D0179F0  3C02BF88   LUI V0, -16504
9D0179F4  8C426050   LW V0, 24656(V0)
9D0179F8  7C420280   EXT V0, V0, 10, 1
9D0179FC  304200FF   ANDI V0, V0, 255
9D017A00  00402821   ADDU A1, V0, ZERO
9D017A04  8F8680E4   LW A2, -32540(GP)
9D017A08  8F8280EC   LW V0, -32532(GP)
9D017A0C  00023FC2   SRL A3, V0, 31
9D017A10  00E21021   ADDU V0, A3, V0
9D017A14  00021043   SRA V0, V0, 1
9D017A18  00C21023   SUBU V0, A2, V0
9D017A1C  2442FFFF   ADDIU V0, V0, -1
9D017A20  00451004   SLLV V0, A1, V0
120:                             }
121:                         }
122:                         spiState++;
9D017A2C  8F8280EC   LW V0, -32532(GP)
9D017A30  24420001   ADDIU V0, V0, 1
9D017A34  AF8280EC   SW V0, -32532(GP)
9D017A38  0B405E9F   J 0x9D017A7C
9D017A3C  00000000   NOP
123:                     }
124:                     else
125:                     {
126:                         mSetSpiClkHigh();
9D017A40  3C02BF88   LUI V0, -16504
9D017A44  24030040   ADDIU V1, ZERO, 64
9D017A48  AC436068   SW V1, 24680(V0)
127:                         spiState = 0;
9D017A4C  AF8080EC   SW ZERO, -32532(GP)
128:                         mT5IntEnable(0);            // Disable Timer 5 interrupts.
9D017A50  3C02BF88   LUI V0, -16504
9D017A54  3C030010   LUI V1, 16
9D017A58  AC431064   SW V1, 4196(V0)
9D017A5C  3C02BF88   LUI V0, -16504
9D017A60  AC401068   SW ZERO, 4200(V0)
129:                 
130:                         // De-assert slave select lines.
131:                         mSetSpiSsHigh_KSZ8895();
9D017A64  3C02BF88   LUI V0, -16504
9D017A68  24030080   ADDIU V1, ZERO, 128
9D017A6C  AC436068   SW V1, 24680(V0)
132:                 
133:                         // Set transfer complete flag.
134:                         *completeFlag = 1;
9D017A70  8F8280E8   LW V0, -32536(GP)
9D017A74  24030001   ADDIU V1, ZERO, 1
9D017A78  AC430000   SW V1, 0(V0)
135:                     }
136:                 
137:                     mT5ClearIntFlag();
9D017A7C  3C02BF88   LUI V0, -16504
9D017A80  3C030010   LUI V1, 16
9D017A84  AC431034   SW V1, 4148(V0)
138:                     return;
139:                 }
9D017A88  03C0E821   ADDU SP, S8, ZERO
9D017A8C  8FBE0004   LW S8, 4(SP)
9D017A90  8FBB000C   LW K1, 12(SP)
9D017A94  27BD0010   ADDIU SP, SP, 16
9D017A98  41DDE800   WRPGPR SP, SP
9D017A9C  409B6000   MTC0 K1, Status
9D017AA0  42000018   ERET
140:                 
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/pic32fmu.c  -----------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   pic32fmu.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include "spi.h"
9:                   #include "stdtypes.h"
10:                  #include "coretime.h"
11:                  #include "init.h"
12:                  #include "vn100.h"
13:                  #include "oemstar.h"
14:                  #include "fmucomm.h"
15:                  #include "uart.h"
16:                  
17:                  // Include all headers for any enabled TCPIP Stack functions
18:                  #include "tcpip/tcpip.h"
19:                  
20:                  // Declare AppConfig structure and some other supporting stack variables
21:                  APP_CONFIG AppConfig;
22:                  
23:                  
24:                  //==============================================================================
25:                  
26:                  int main()
27:                  {
9D01B6C0  27BDFFE8   ADDIU SP, SP, -24
9D01B6C4  AFBF0014   SW RA, 20(SP)
9D01B6C8  AFBE0010   SW S8, 16(SP)
9D01B6CC  03A0F021   ADDU S8, SP, ZERO
28:                      InitBoard();    // Initialize FMU processor and peripherals.
9D01B6D0  0F405574   JAL InitBoard
9D01B6D4  00000000   NOP
29:                      
30:                      // INTEnableSystemMultiVectoredInt();
31:                      asm volatile ("ei");
32:                      
33:                      UARTStartup();
9D01B6D8  0F404A83   JAL UARTStartup
9D01B6DC  41606020   EI ZERO
34:                      
35:                      for (;;)        // Main program loop.
36:                      {
37:                          WDTCONSET = _WDTCON_WDTCLR_MASK;        // Clear watchdog timer.
9D01B6E0  3C02BF80   LUI V0, -16512
9D01B6E4  24030001   ADDIU V1, ZERO, 1
38:                          LATFbits.LATF3 = CoreTime64sGet() % 2;  // Blink LED at 0.5Hz
9D01B6E8  0F405A20   JAL CoreTime64sGet
9D01B6EC  AC430008   SW V1, 8(V0)
9D01B6F0  304200FF   ANDI V0, V0, 255
9D01B6F4  30420001   ANDI V0, V0, 1
9D01B6F8  304200FF   ANDI V0, V0, 255
9D01B6FC  30420001   ANDI V0, V0, 1
9D01B700  30420001   ANDI V0, V0, 1
9D01B704  304400FF   ANDI A0, V0, 255
9D01B708  3C03BF88   LUI V1, -16504
9D01B70C  8C626160   LW V0, 24928(V1)
9D01B710  7C8218C4   INS V0, A0, 3, 1
39:                  
40:                          // Low-level communication tasks. ---------------------------
41:                          SPITask();
9D01B714  0F405AFB   JAL SPITask
9D01B718  AC626160   SW V0, 24928(V1)
42:                          UARTTask();  // NOTE: Task must occur before any function in software cycle which used received UART data.
9D01B71C  0F404A90   JAL UARTTask
9D01B720  00000000   NOP
43:                  
44:                          // This task reads UDP data for processing; therefore this task
45:                          // must be executed in the software cycle before any function
46:                          // which gets UDP data.
47:                          FMUCommTask();
9D01B724  0F405092   JAL FMUCommTask
9D01B728  00000000   NOP
48:                          
49:                          // Acquire sensor data. -------------------------------------
50:                          OEMStarTask();
9D01B72C  0F406392   JAL OEMStarTask
9D01B730  00000000   NOP
51:                          
52:                          // This task performs normal stack task including checking
53:                          // for incoming packet, type of packet and calling
54:                          // appropriate stack entity to process it.
55:                          StackTask();
9D01B734  0F406078   JAL StackTask
9D01B738  00000000   NOP
56:                  
57:                          // This tasks invokes each of the core stack application tasks.
58:                          StackApplications();
9D01B73C  0F406101   JAL StackApplications
9D01B740  00000000   NOP
59:                      }
9D01B744  0B406DB8   J 0x9D01B6E0
9D01B748  00000000   NOP
60:                  
61:                      return 0;
62:                  }
63:                  
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/oemstar.c  ------------------------------------
1:                   ////////////////////////////////////////////////////////////////////////////////
2:                   /// @file
3:                   /// @brief 
4:                   ////////////////////////////////////////////////////////////////////////////////
5:                   
6:                   // *****************************************************************************
7:                   // ************************** System Include Files *****************************
8:                   // *****************************************************************************
9:                   
10:                  // *****************************************************************************
11:                  // ************************** User Include Files *******************************
12:                  // *****************************************************************************
13:                  
14:                  #include <sys/attribs.h>
15:                  #include "oemstar.h"
16:                  #include "fmucomm.h"
17:                  #include "uart.h"
18:                  #include "coretime.h"
19:                  
20:                  // *****************************************************************************
21:                  // ************************** Defines ******************************************
22:                  // *****************************************************************************
23:                  
24:                  // *****************************************************************************
25:                  // ************************** Definitions **************************************
26:                  // *****************************************************************************
27:                  
28:                  static bool oemstar_rx_overflow_latch = false;
29:                  static bool oemstar_tx_overflow_latch = false;
30:                  static bool oemstar_tx_err_latch      = false;
31:                  
32:                  // *****************************************************************************
33:                  // ************************** Function Prototypes ******************************
34:                  // *****************************************************************************
35:                  
36:                  static void OEMStarCmdFwd( void );
37:                  static void OEMStarRspFwd( void );
38:                  
39:                  // *****************************************************************************
40:                  // ************************** Global Functions *********************************
41:                  // *****************************************************************************
42:                  
43:                  void OEMStarTask()
44:                  {
9D018E48  27BDFFE8   ADDIU SP, SP, -24
9D018E4C  AFBF0014   SW RA, 20(SP)
9D018E50  AFBE0010   SW S8, 16(SP)
9D018E54  03A0F021   ADDU S8, SP, ZERO
45:                      // Forward received Ethernet messages (i.e. Commands) to the GPS receiver.
46:                      OEMStarCmdFwd();
9D018E58  0F4063A0   JAL OEMStarCmdFwd
9D018E5C  00000000   NOP
47:                      
48:                      // Forward received GPS receiver messages (i.e. Responses and Logs) to the
49:                      // Ethernet.
50:                      OEMStarRspFwd();
9D018E60  0F4063D2   JAL OEMStarRspFwd
9D018E64  00000000   NOP
51:                  }
9D018E68  03C0E821   ADDU SP, S8, ZERO
9D018E6C  8FBF0014   LW RA, 20(SP)
9D018E70  8FBE0010   LW S8, 16(SP)
9D018E74  27BD0018   ADDIU SP, SP, 24
9D018E78  03E00008   JR RA
9D018E7C  00000000   NOP
52:                  
53:                  // *****************************************************************************
54:                  // ************************** Static Functions *********************************
55:                  // *****************************************************************************
56:                  
57:                  // Note: Only a single message can be transmitted at a time; that is, if an
58:                  // additional GPS command is received while a previous one is being forwarded
59:                  // over UART, the newly received GPS command will be ignored and the TX overflow
60:                  // flag will be set.
61:                  //
62:                  static void OEMStarCmdFwd( void )
63:                  {
9D018E80  27BDFFE0   ADDIU SP, SP, -32
9D018E84  AFBF001C   SW RA, 28(SP)
9D018E88  AFBE0018   SW S8, 24(SP)
9D018E8C  03A0F021   ADDU S8, SP, ZERO
64:                      static uint8_t       uart_tx_data[ 1024 ];
65:                      static UART_TX_BUF_S uart_tx_buf = { &uart_tx_data[ 0 ] , 0, true };
66:                      
67:                      bool setSuccess;
68:                      
69:                      const FMUCOMM_HOST_PKT* gps_cmd_pkt_p;
70:                      
71:                      gps_cmd_pkt_p = FMUCommGet( FMUCOMM_TYPE_GPS_CMD );
9D018E90  24040002   ADDIU A0, ZERO, 2
9D018E94  0F405151   JAL FMUCommGet
9D018E98  00000000   NOP
9D018E9C  AFC20010   SW V0, 16(S8)
72:                      
73:                      // GPS command packet received ?
74:                      if( gps_cmd_pkt_p->valid == true )
9D018EA0  8FC20010   LW V0, 16(S8)
9D018EA4  90420000   LBU V0, 0(V0)
9D018EA8  10400021   BEQ V0, ZERO, 0x9D018F30
9D018EAC  00000000   NOP
75:                      {
76:                          // UART already busy ?
77:                          if( uart_tx_buf.tx_done == false )
9D018EB0  9382801E   LBU V0, -32738(GP)
9D018EB4  38420001   XORI V0, V0, 1
9D018EB8  304200FF   ANDI V0, V0, 255
9D018EBC  10400005   BEQ V0, ZERO, 0x9D018ED4
9D018EC0  00000000   NOP
78:                          {
79:                              // Module transmitter buffer has overflow.  Identify loss of 
80:                              // transmitted data.
81:                              oemstar_tx_overflow_latch = true;
9D018EC4  24020001   ADDIU V0, ZERO, 1
9D018EC8  A38280A9   SB V0, -32599(GP)
9D018ECC  0B4063CC   J 0x9D018F30
9D018ED0  00000000   NOP
82:                          }
83:                          else
84:                          {
85:                              // Copy in module buffer the data to be transmitted.
86:                              //
87:                              // Note: this is performed rather using the buffered GPS Ethernet
88:                              // data directly as maintaining of Ethernet data is only guaranteed 
89:                              // for a single execution cycle.  Since the transmission rate of
90:                              // UART data is at a slower enough rate to not be completed in a 
91:                              // single software execution cycle, the data must be locally copied
92:                              // to guarantee integrity during transmission.
93:                              //
94:                              memcpy( &uart_tx_buf.data_p[ 0 ],
9D018ED4  8F848018   LW A0, -32744(GP)
9D018EE8  00602821   ADDU A1, V1, ZERO
9D018EEC  00403021   ADDU A2, V0, ZERO
9D018EF0  0F406788   JAL 0x9D019E20
9D018EF4  00000000   NOP
95:                                      &gps_cmd_pkt_p->pl_p[ 0 ],
9D018ED8  8FC20010   LW V0, 16(S8)
9D018EDC  8C43000C   LW V1, 12(V0)
96:                                      gps_cmd_pkt_p->wrap.length );
9D018EE0  8FC20010   LW V0, 16(S8)
9D018EE4  94420006   LHU V0, 6(V0)
97:                              
98:                              // Setup the length of the buffer data.
99:                              uart_tx_buf.data_len = gps_cmd_pkt_p->wrap.length;
9D018EF8  8FC20010   LW V0, 16(S8)
9D018EFC  94420006   LHU V0, 6(V0)
9D018F00  A782801C   SH V0, -32740(GP)
100:                             
101:                             // Queue the data for transmission.
102:                             setSuccess = UARTSet( &uart_tx_buf );
9D018F04  27848018   ADDIU A0, GP, -32744
9D018F08  0F404B17   JAL UARTSet
9D018F0C  00000000   NOP
9D018F10  A3C20014   SB V0, 20(S8)
103:                             
104:                             // Queuing of data unsuccessful ?
105:                             if( setSuccess == false )
9D018F14  93C20014   LBU V0, 20(S8)
9D018F18  38420001   XORI V0, V0, 1
9D018F1C  304200FF   ANDI V0, V0, 255
9D018F20  10400003   BEQ V0, ZERO, 0x9D018F30
9D018F24  00000000   NOP
106:                             {
107:                                 oemstar_tx_err_latch = true;
9D018F28  24020001   ADDIU V0, ZERO, 1
9D018F2C  A38280AA   SB V0, -32598(GP)
108:                             }
109:                         }
110:                     }
111:                 }
9D018F30  03C0E821   ADDU SP, S8, ZERO
9D018F34  8FBF001C   LW RA, 28(SP)
9D018F38  8FBE0018   LW S8, 24(SP)
9D018F3C  27BD0020   ADDIU SP, SP, 32
9D018F40  03E00008   JR RA
9D018F44  00000000   NOP
112:                 
113:                 static void OEMStarRspFwd( void )
114:                 {
9D018F48  27BDFFE0   ADDIU SP, SP, -32
9D018F4C  AFBF001C   SW RA, 28(SP)
9D018F50  AFBE0018   SW S8, 24(SP)
9D018F54  03A0F021   ADDU S8, SP, ZERO
115:                     struct
116:                     {
117:                         uint8_t  data[ 1024 ];
118:                         uint16_t data_len;
119:                     } static OEMStarRxBuf;
120:                     
121:                     static uint32_t rx_time_us;
122:                     
123:                     const UART_RX_BUF_S* uartRxBuf;
124:                           bool           setSuccess;
125:                     
126:                     // Get UART buffered data.
127:                     uartRxBuf = UARTGet();
9D018F58  0F404B01   JAL UARTGet
9D018F5C  00000000   NOP
9D018F60  AFC20010   SW V0, 16(S8)
128:                     
129:                     // UART data received ?
130:                     if( uartRxBuf->data_len != 0 )
9D018F64  8FC20010   LW V0, 16(S8)
9D018F68  94420008   LHU V0, 8(V0)
9D018F6C  10400024   BEQ V0, ZERO, 0x9D019000
9D018F70  00000000   NOP
131:                     {
132:                         // Record time data is received.
133:                         rx_time_us = CoreTime32usGet();
9D018F74  0F405A7C   JAL CoreTime32usGet
9D018F78  00000000   NOP
9D018F7C  AF8280AC   SW V0, -32596(GP)
134:                         
135:                         // Module buffer contains available space for UART data ?
136:                         if( ( 1024 - OEMStarRxBuf.data_len ) >= uartRxBuf->data_len )
9D018F80  3C02A000   LUI V0, -24576
9D018F84  24427E70   ADDIU V0, V0, 32368
9D018F88  94420400   LHU V0, 1024(V0)
9D018F8C  24030400   ADDIU V1, ZERO, 1024
9D018F90  00621823   SUBU V1, V1, V0
9D018F94  8FC20010   LW V0, 16(S8)
9D018F98  94420008   LHU V0, 8(V0)
9D018F9C  0062102A   SLT V0, V1, V0
9D018FA0  14400014   BNE V0, ZERO, 0x9D018FF4
9D018FA4  00000000   NOP
137:                         {
138:                             // Copy UART data into module buffer.
139:                             memcpy( &OEMStarRxBuf.data[ 0 ],
9D018FB4  3C04A000   LUI A0, -24576
9D018FB8  24847E70   ADDIU A0, A0, 32368
9D018FBC  00602821   ADDU A1, V1, ZERO
9D018FC0  0F406788   JAL 0x9D019E20
9D018FC4  00403021   ADDU A2, V0, ZERO
140:                                     &uartRxBuf->data[ 0 ],
9D018FA8  8FC30010   LW V1, 16(S8)
141:                                     uartRxBuf->data_len );
9D018FAC  8FC20010   LW V0, 16(S8)
9D018FB0  94420008   LHU V0, 8(V0)
142:                             
143:                             OEMStarRxBuf.data_len += uartRxBuf->data_len;
9D018FC8  3C02A000   LUI V0, -24576
9D018FCC  24427E70   ADDIU V0, V0, 32368
9D018FD0  94430400   LHU V1, 1024(V0)
9D018FD4  8FC20010   LW V0, 16(S8)
9D018FD8  94420008   LHU V0, 8(V0)
9D018FDC  00621021   ADDU V0, V1, V0
9D018FE0  3043FFFF   ANDI V1, V0, -1
9D018FE4  3C02A000   LUI V0, -24576
9D018FE8  24427E70   ADDIU V0, V0, 32368
9D018FEC  0B4063FF   J 0x9D018FFC
9D018FF0  A4430400   SH V1, 1024(V0)
144:                         }
145:                         else
146:                         {
147:                             // Module receiver buffer has overflow.  Identify loss of received
148:                             // data.
149:                             oemstar_rx_overflow_latch = true;
9D018FF4  24020001   ADDIU V0, ZERO, 1
9D018FF8  A38280A8   SB V0, -32600(GP)
150:                         }
151:                         
152:                         Nop();
9D018FFC  00000040   SSNOP
153:                     }
154:                     
155:                     // Module buffer contains data ?
156:                     if( OEMStarRxBuf.data_len != 0 )
9D019000  3C02A000   LUI V0, -24576
9D019004  24427E70   ADDIU V0, V0, 32368
9D019008  94420400   LHU V0, 1024(V0)
9D01900C  1040001E   BEQ V0, ZERO, 0x9D019088
9D019010  00000000   NOP
157:                     {
158:                         // No UART data received for 1ms, or module buffer is
159:                         // greater than 3/4 full ?
160:                         //
161:                         // Note: 1ms timeout derived from data transmission rate and hardware
162:                         // buffering configuration.
163:                         //  UART data byte:
164:                         //      - 1 start bit
165:                         //      - 8 data bits
166:                         //      - 1 stop bit
167:                         //  Hw configuration:
168:                         //      - 115200 nominal transfer rate.
169:                         //      - 6 byte deep buffer before servicing.
170:                         // Therefore, with 100% UART receiver utilization, the OEMStar 
171:                         // application module will receive fresh data every:
172:                         //  - (1/115200) * 10 * 6 = 0.52 ms.
173:                         // Additional margin is added to the timeout to treat non-ideal
174:                         // conditions.
175:                         //
176:                         // Note: An Ethernet packet is transmitted when the internal module
177:                         // buffer is 3/4 full.  This is performed so than internal storage does
178:                         // not overflow.  Segmenting of responses to Ethernet packets is 
179:                         // unlikely in this case.
180:                         //
181:                         if( ( CoreTime32usGet() - rx_time_us > 1000 ) ||
9D019014  0F405A7C   JAL CoreTime32usGet
9D019018  00000000   NOP
9D01901C  00401821   ADDU V1, V0, ZERO
9D019020  8F8280AC   LW V0, -32596(GP)
9D019024  00621023   SUBU V0, V1, V0
9D019028  2C4203E9   SLTIU V0, V0, 1001
9D01902C  10400007   BEQ V0, ZERO, 0x9D01904C
9D019030  00000000   NOP
9D019040  2C420301   SLTIU V0, V0, 769
9D019044  14400010   BNE V0, ZERO, 0x9D019088
9D019048  00000000   NOP
182:                             ( OEMStarRxBuf.data_len          > 768  ) )
9D019034  3C02A000   LUI V0, -24576
9D019038  24427E70   ADDIU V0, V0, 32368
9D01903C  94420400   LHU V0, 1024(V0)
183:                         {
184:                             // Queue Ethernet data for transmission.
185:                             setSuccess = FMUCommSet( FMUCOMM_TYPE_GPS_DATA, 
9D019058  24040002   ADDIU A0, ZERO, 2
9D01905C  3C03A000   LUI V1, -24576
9D019060  24657E70   ADDIU A1, V1, 32368
9D019064  0F4050DD   JAL FMUCommSet
9D019068  00403021   ADDU A2, V0, ZERO
9D01906C  A3C20014   SB V0, 20(S8)
186:                                                      &OEMStarRxBuf.data[ 0 ], 
187:                                                      OEMStarRxBuf.data_len );
9D01904C  3C02A000   LUI V0, -24576
9D019050  24427E70   ADDIU V0, V0, 32368
9D019054  94420400   LHU V0, 1024(V0)
188:                             
189:                             // Ethernet data queued successfully ?
190:                             if( setSuccess == true )
9D019070  93C20014   LBU V0, 20(S8)
9D019074  10400004   BEQ V0, ZERO, 0x9D019088
9D019078  00000000   NOP
191:                             {
192:                                 // Clear the module buffer length to reset buffer.
193:                                 OEMStarRxBuf.data_len = 0;
9D01907C  3C02A000   LUI V0, -24576
9D019080  24427E70   ADDIU V0, V0, 32368
9D019084  A4400400   SH ZERO, 1024(V0)
194:                             }
195:                         }
196:                     }
197:                     
198:                     Nop();
9D019088  00000040   SSNOP
199:                 }
9D01908C  03C0E821   ADDU SP, S8, ZERO
9D019090  8FBF001C   LW RA, 28(SP)
9D019094  8FBE0018   LW S8, 24(SP)
9D019098  03E00008   JR RA
9D01909C  27BD0020   ADDIU SP, SP, 32
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/ksz8895.c  ------------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   ksz8895.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include "tcpip/tcpip.h"
9:                   #include "ksz8895.h"
10:                  #include "softspi.h"
11:                  
12:                  
13:                  //==============================================================================
14:                  
15:                  int KSZ8895Init()
16:                  {
9D018434  27BDFFE0   ADDIU SP, SP, -32
9D018438  AFBF001C   SW RA, 28(SP)
9D01843C  AFBE0018   SW S8, 24(SP)
9D018440  03A0F021   ADDU S8, SP, ZERO
17:                      uint8_t readData;
18:                  
19:                      // Read chip family ID to verify SPI bus functionality. ---------
20:                      do {
21:                          // Read contents of register 0x00.
22:                          while (KSZ8895ReadReg(0x00, &readData) != 0);
9D018444  00000000   NOP
9D018448  0B406115   J 0x9D018454
9D01844C  00000000   NOP
9D018450  00000000   NOP
9D018454  00002021   ADDU A0, ZERO, ZERO
9D018458  27C20010   ADDIU V0, S8, 16
9D01845C  00402821   ADDU A1, V0, ZERO
9D018460  0F40613D   JAL KSZ8895ReadReg
9D018464  00000000   NOP
9D018468  1440FFFA   BNE V0, ZERO, 0x9D018454
9D01846C  00000000   NOP
23:                      }
24:                      while (readData != 0x95);
9D018470  93C30010   LBU V1, 16(S8)
9D018474  24020095   ADDIU V0, ZERO, 149
9D018478  1462FFF5   BNE V1, V0, 0x9D018450
9D01847C  00000000   NOP
25:                  
26:                      // Write/Read/Verify the start switch bit. ----------------------
27:                      do {
28:                          // Write "Start Switch" bit to register 0x01.
29:                          while (KSZ8895WriteReg(0x01, 0x01) != 0);
9D018480  00000000   NOP
9D018484  0B406124   J 0x9D018490
9D018488  00000000   NOP
9D01848C  00000000   NOP
9D018490  24040001   ADDIU A0, ZERO, 1
9D018494  24050001   ADDIU A1, ZERO, 1
9D018498  0F406179   JAL KSZ8895WriteReg
9D01849C  00000000   NOP
9D0184A0  1440FFFB   BNE V0, ZERO, 0x9D018490
9D0184A4  00000000   NOP
30:                          // Read contents of register 0x01.
31:                          while (KSZ8895ReadReg(0x01, &readData) != 0);
9D0184A8  00000000   NOP
9D0184AC  24040001   ADDIU A0, ZERO, 1
9D0184B0  27C20010   ADDIU V0, S8, 16
9D0184B4  00402821   ADDU A1, V0, ZERO
9D0184B8  0F40613D   JAL KSZ8895ReadReg
9D0184BC  00000000   NOP
9D0184C0  1440FFFA   BNE V0, ZERO, 0x9D0184AC
9D0184C4  00000000   NOP
32:                      }
33:                      while ((readData & 0x01) != 0x01);   // Verify "Start Switch" bit is set.
9D0184C8  93C20010   LBU V0, 16(S8)
9D0184CC  30420001   ANDI V0, V0, 1
9D0184D0  1040FFEE   BEQ V0, ZERO, 0x9D01848C
9D0184D4  00000000   NOP
34:                  
35:                      return 0;
9D0184D8  00001021   ADDU V0, ZERO, ZERO
36:                  }
9D0184DC  03C0E821   ADDU SP, S8, ZERO
9D0184E0  8FBF001C   LW RA, 28(SP)
9D0184E4  8FBE0018   LW S8, 24(SP)
9D0184E8  27BD0020   ADDIU SP, SP, 32
9D0184EC  03E00008   JR RA
9D0184F0  00000000   NOP
37:                  
38:                  //==============================================================================
39:                  
40:                  int KSZ8895ReadReg(uint8_t address, uint8_t *data)
41:                  {
9D0184F4  27BDFFB0   ADDIU SP, SP, -80
9D0184F8  AFBF004C   SW RA, 76(SP)
9D0184FC  AFBE0048   SW S8, 72(SP)
9D018500  03A0F021   ADDU S8, SP, ZERO
9D018504  00801021   ADDU V0, A0, ZERO
9D018508  AFC50054   SW A1, 84(S8)
9D01850C  A3C20050   SB V0, 80(S8)
42:                      uint32_t rxData;
43:                      
44:                      SOFTSPI_TRANSFER readCmd =
9D018520  AFC00010   SW ZERO, 16(S8)
9D018524  AFC00014   SW ZERO, 20(S8)
9D018528  AFC00018   SW ZERO, 24(S8)
9D01852C  AFC0001C   SW ZERO, 28(S8)
9D018530  AFC00020   SW ZERO, 32(S8)
9D018534  AFC00024   SW ZERO, 36(S8)
9D018538  AFC20014   SW V0, 20(S8)
9D01853C  27C20028   ADDIU V0, S8, 40
9D018540  AFC20018   SW V0, 24(S8)
9D018544  24020018   ADDIU V0, ZERO, 24
9D018548  AFC2001C   SW V0, 28(S8)
9D01854C  3402C350   ORI V0, ZERO, -15536
9D018550  AFC20020   SW V0, 32(S8)
9D018554  8FC70010   LW A3, 16(S8)
9D018558  8FC60014   LW A2, 20(S8)
9D01855C  8FC50018   LW A1, 24(S8)
9D018560  8FC4001C   LW A0, 28(S8)
9D018564  8FC30020   LW V1, 32(S8)
9D018568  8FC20024   LW V0, 36(S8)
9D01856C  AFC7002C   SW A3, 44(S8)
9D018570  AFC60030   SW A2, 48(S8)
9D018574  AFC50034   SW A1, 52(S8)
9D018578  AFC40038   SW A0, 56(S8)
9D01857C  AFC3003C   SW V1, 60(S8)
9D018580  AFC20040   SW V0, 64(S8)
45:                      {
46:                          .dev = SOFTSPI_KSZ8895,
47:                          .txDat = 0x00030000 | (((uint32_t)address) << 8),
9D018510  93C20050   LBU V0, 80(S8)
9D018514  00021A00   SLL V1, V0, 8
9D018518  3C020003   LUI V0, 3
9D01851C  00621025   OR V0, V1, V0
48:                          .rxBuf = &rxData,
49:                          .numOfBits = 24,
50:                          .freq = 50000,
51:                      };
52:                  
53:                      if (SoftSPIXfer(&readCmd) != 0)
9D018584  27C2002C   ADDIU V0, S8, 44
9D018588  00402021   ADDU A0, V0, ZERO
9D01858C  0F405DC8   JAL SoftSPIXfer
9D018590  00000000   NOP
9D018594  10400004   BEQ V0, ZERO, 0x9D0185A8
9D018598  00000000   NOP
54:                      {
55:                          return -1;
9D01859C  2402FFFF   ADDIU V0, ZERO, -1
9D0185A0  0B406173   J 0x9D0185CC
9D0185A4  00000000   NOP
56:                      }
57:                  
58:                      // TODO: Make this function non-blocking.
59:                  
60:                      while (!readCmd.xferDone);      // Wait for transfer to complete.
9D0185A8  00000000   NOP
9D0185AC  8FC20040   LW V0, 64(S8)
9D0185B0  1040FFFE   BEQ V0, ZERO, 0x9D0185AC
9D0185B4  00000000   NOP
61:                      *data = rxData & 0x000000FF;
9D0185B8  8FC20028   LW V0, 40(S8)
9D0185BC  304300FF   ANDI V1, V0, 255
9D0185C0  8FC20054   LW V0, 84(S8)
9D0185C4  A0430000   SB V1, 0(V0)
62:                  
63:                      return 0;
9D0185C8  00001021   ADDU V0, ZERO, ZERO
64:                  }
9D0185CC  03C0E821   ADDU SP, S8, ZERO
9D0185D0  8FBF004C   LW RA, 76(SP)
9D0185D4  8FBE0048   LW S8, 72(SP)
9D0185D8  27BD0050   ADDIU SP, SP, 80
9D0185DC  03E00008   JR RA
9D0185E0  00000000   NOP
65:                  
66:                  //==============================================================================
67:                  
68:                  int KSZ8895WriteReg(uint8_t address, uint8_t data)
69:                  {
9D0185E4  27BDFFB8   ADDIU SP, SP, -72
9D0185E8  AFBF0044   SW RA, 68(SP)
9D0185EC  AFBE0040   SW S8, 64(SP)
9D0185F0  03A0F021   ADDU S8, SP, ZERO
9D0185F4  00801821   ADDU V1, A0, ZERO
9D0185F8  00A01021   ADDU V0, A1, ZERO
9D0185FC  A3C30048   SB V1, 72(S8)
9D018600  A3C2004C   SB V0, 76(S8)
70:                      SOFTSPI_TRANSFER xfer =
9D01861C  AFC00010   SW ZERO, 16(S8)
9D018620  AFC20014   SW V0, 20(S8)
9D018624  AFC00018   SW ZERO, 24(S8)
9D018628  24020018   ADDIU V0, ZERO, 24
9D01862C  AFC2001C   SW V0, 28(S8)
9D018630  3402C350   ORI V0, ZERO, -15536
9D018634  AFC20020   SW V0, 32(S8)
9D018638  AFC00024   SW ZERO, 36(S8)
9D01863C  8FC70010   LW A3, 16(S8)
9D018640  8FC60014   LW A2, 20(S8)
9D018644  8FC50018   LW A1, 24(S8)
9D018648  8FC4001C   LW A0, 28(S8)
9D01864C  8FC30020   LW V1, 32(S8)
9D018650  8FC20024   LW V0, 36(S8)
9D018654  AFC70028   SW A3, 40(S8)
9D018658  AFC6002C   SW A2, 44(S8)
9D01865C  AFC50030   SW A1, 48(S8)
9D018660  AFC40034   SW A0, 52(S8)
9D018664  AFC30038   SW V1, 56(S8)
9D018668  AFC2003C   SW V0, 60(S8)
71:                      {
72:                          .dev = SOFTSPI_KSZ8895,
73:                          .txDat = 0x00020000 | (((uint32_t)address) << 8) | data,
9D018604  93C20048   LBU V0, 72(S8)
9D018608  00021A00   SLL V1, V0, 8
9D01860C  93C2004C   LBU V0, 76(S8)
9D018610  00621825   OR V1, V1, V0
9D018614  3C020002   LUI V0, 2
9D018618  00621025   OR V0, V1, V0
74:                          .rxBuf = 0,
75:                          .numOfBits = 24,
76:                          .freq = 50000,
77:                          .xferDone = 0
78:                      };
79:                  
80:                      return SoftSPIXfer(&xfer);
9D01866C  27C20028   ADDIU V0, S8, 40
9D018670  00402021   ADDU A0, V0, ZERO
9D018674  0F405DC8   JAL SoftSPIXfer
9D018678  00000000   NOP
81:                  }
9D01867C  03C0E821   ADDU SP, S8, ZERO
9D018680  8FBF0044   LW RA, 68(SP)
9D018684  8FBE0040   LW S8, 64(SP)
9D018688  27BD0048   ADDIU SP, SP, 72
9D01868C  03E00008   JR RA
9D018690  00000000   NOP
82:                  
83:                  //==============================================================================
84:                  
85:                  void KSZ8895Reset()
86:                  {
9D018694  27BDFFE8   ADDIU SP, SP, -24
9D018698  AFBF0014   SW RA, 20(SP)
9D01869C  AFBE0010   SW S8, 16(SP)
9D0186A0  03A0F021   ADDU S8, SP, ZERO
87:                      LATDbits.LATD5 = 0;     // Low
9D0186A4  3C03BF88   LUI V1, -16504
9D0186A8  8C6260E0   LW V0, 24800(V1)
9D0186AC  7C022944   INS V0, ZERO, 5, 1
9D0186B0  AC6260E0   SW V0, 24800(V1)
88:                      DelayMs(100);           // Allow time for capacitive load to switch.
9D0186B4  24040064   ADDIU A0, ZERO, 100
9D0186B8  0F406B26   JAL DelayMs
9D0186BC  00000000   NOP
89:                      LATDbits.LATD5 = 1;     // High
9D0186C0  3C03BF88   LUI V1, -16504
9D0186C4  8C6260E0   LW V0, 24800(V1)
9D0186C8  24040001   ADDIU A0, ZERO, 1
9D0186CC  7C822944   INS V0, A0, 5, 1
9D0186D0  AC6260E0   SW V0, 24800(V1)
90:                      DelayMs(300);           // Allow time for switch to power up.
9D0186D4  2404012C   ADDIU A0, ZERO, 300
9D0186D8  0F406B26   JAL DelayMs
9D0186DC  00000000   NOP
91:                  }
9D0186E0  03C0E821   ADDU SP, S8, ZERO
9D0186E4  8FBF0014   LW RA, 20(SP)
9D0186E8  8FBE0010   LW S8, 16(SP)
9D0186EC  27BD0018   ADDIU SP, SP, 24
9D0186F0  03E00008   JR RA
9D0186F4  00000000   NOP
92:                  
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/init.c  ---------------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   init.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include <sys/attribs.h>
9:                   #include "tcpip/tcpip.h"
10:                  #include "ksz8895.h"
11:                  #include "init.h"
12:                  #include "uart.h"
13:                  
14:                  
15:                  //==============================================================================
16:                  
17:                  static void InitCPU()
18:                  {
9D015004  27BDFFF8   ADDIU SP, SP, -8
9D015008  AFBE0004   SW S8, 4(SP)
9D01500C  03A0F021   ADDU S8, SP, ZERO
19:                      switch (DEVIDbits.VER)
9D015010  3C02BF81   LUI V0, -16511
9D015014  8C42F220   LW V0, -3552(V0)
9D015018  7C421F00   EXT V0, V0, 28, 4
20:                      {
21:                          case 0x0:
22:                          case 0x1:
23:                          case 0x2:
24:                          case 0x3:
25:                          {
26:                              // NOTE: See errata #43: CPU: Constant Data Access from Flash
27:                              break;
28:                          }
29:                          case 0x4:
30:                          case 0x5:
31:                          default:
32:                          {
33:                              break;
9D01501C  00000000   NOP
34:                          }
35:                      }
36:                  }
9D015020  03C0E821   ADDU SP, S8, ZERO
9D015024  8FBE0004   LW S8, 4(SP)
9D015028  27BD0008   ADDIU SP, SP, 8
9D01502C  03E00008   JR RA
9D015030  00000000   NOP
37:                  
38:                  //==============================================================================
39:                  
40:                  static void InitGPIO()
41:                  {
9D015034  27BDFFF8   ADDIU SP, SP, -8
9D015038  AFBE0004   SW S8, 4(SP)
9D01503C  03A0F021   ADDU S8, SP, ZERO
42:                      // Disable JTAG port.
43:                      DDPCONbits.JTAGEN = 0;
9D015040  3C03BF81   LUI V1, -16511
9D015044  8C62F200   LW V0, -3584(V1)
9D015048  7C0218C4   INS V0, ZERO, 3, 1
9D01504C  AC62F200   SW V0, -3584(V1)
44:                  
45:                      // Red Status LED (RF3)
46:                      TRISFbits.TRISF3 = 0;       // Output
9D015050  3C03BF88   LUI V1, -16504
9D015054  8C626140   LW V0, 24896(V1)
9D015058  7C0218C4   INS V0, ZERO, 3, 1
9D01505C  AC626140   SW V0, 24896(V1)
47:                      ODCFbits.ODCF3 = 1;         // Open Drain
9D015060  3C03BF88   LUI V1, -16504
9D015064  8C626170   LW V0, 24944(V1)
9D015068  24040001   ADDIU A0, ZERO, 1
9D01506C  7C8218C4   INS V0, A0, 3, 1
9D015070  AC626170   SW V0, 24944(V1)
48:                      LATFbits.LATF3 = 1;         // Off
9D015074  3C03BF88   LUI V1, -16504
9D015078  8C626160   LW V0, 24928(V1)
9D01507C  24040001   ADDIU A0, ZERO, 1
9D015080  7C8218C4   INS V0, A0, 3, 1
9D015084  AC626160   SW V0, 24928(V1)
49:                  
50:                      // SPI2 SS (RG9)
51:                      TRISGbits.TRISG9 = 0;       // Output
9D015088  3C03BF88   LUI V1, -16504
9D01508C  8C626180   LW V0, 24960(V1)
9D015090  7C024A44   INS V0, ZERO, 9, 1
9D015094  AC626180   SW V0, 24960(V1)
52:                      ODCGbits.ODCG9 = 0;         // Normal
9D015098  3C03BF88   LUI V1, -16504
9D01509C  8C6261B0   LW V0, 25008(V1)
9D0150A0  7C024A44   INS V0, ZERO, 9, 1
9D0150A4  AC6261B0   SW V0, 25008(V1)
53:                      LATGbits.LATG9 = 1;         // High
9D0150A8  3C03BF88   LUI V1, -16504
9D0150AC  8C6261A0   LW V0, 24992(V1)
9D0150B0  24040001   ADDIU A0, ZERO, 1
9D0150B4  7C824A44   INS V0, A0, 9, 1
9D0150B8  AC6261A0   SW V0, 24992(V1)
54:                      
55:                      //-----------------------------------------------------
56:                  
57:                      // Software SPI Bit-bang CLK (RB6)
58:                  
59:                      AD1PCFGbits.PCFG6 = 1;      // Analog input pin in digital mode.
9D0150BC  3C03BF81   LUI V1, -16511
9D0150C0  8C629060   LW V0, -28576(V1)
9D0150C4  24040001   ADDIU A0, ZERO, 1
9D0150C8  7C823184   INS V0, A0, 6, 1
9D0150CC  AC629060   SW V0, -28576(V1)
60:                      ODCBbits.ODCB6 = 0;         // Normal
9D0150D0  3C03BF88   LUI V1, -16504
9D0150D4  8C626070   LW V0, 24688(V1)
9D0150D8  7C023184   INS V0, ZERO, 6, 1
9D0150DC  AC626070   SW V0, 24688(V1)
61:                      TRISBbits.TRISB6 = 0;       // Output
9D0150E0  3C03BF88   LUI V1, -16504
9D0150E4  8C626040   LW V0, 24640(V1)
9D0150E8  7C023184   INS V0, ZERO, 6, 1
9D0150EC  AC626040   SW V0, 24640(V1)
62:                      LATBbits.LATB6 = 0;         // Logic Low
9D0150F0  3C03BF88   LUI V1, -16504
9D0150F4  8C626060   LW V0, 24672(V1)
9D0150F8  7C023184   INS V0, ZERO, 6, 1
9D0150FC  AC626060   SW V0, 24672(V1)
63:                      
64:                      // Software SPI Bit-bang MOSI (RB9)
65:                  
66:                      AD1PCFGbits.PCFG9 = 1;      // Analog input pin in digital mode.
9D015100  3C03BF81   LUI V1, -16511
9D015104  8C629060   LW V0, -28576(V1)
9D015108  24040001   ADDIU A0, ZERO, 1
9D01510C  7C824A44   INS V0, A0, 9, 1
9D015110  AC629060   SW V0, -28576(V1)
67:                      ODCBbits.ODCB9 = 0;         // Normal
9D015114  3C03BF88   LUI V1, -16504
9D015118  8C626070   LW V0, 24688(V1)
9D01511C  7C024A44   INS V0, ZERO, 9, 1
9D015120  AC626070   SW V0, 24688(V1)
68:                      TRISBbits.TRISB9 = 0;       // Output
9D015124  3C03BF88   LUI V1, -16504
9D015128  8C626040   LW V0, 24640(V1)
9D01512C  7C024A44   INS V0, ZERO, 9, 1
9D015130  AC626040   SW V0, 24640(V1)
69:                      LATBbits.LATB9 = 0;         // Logic Low
9D015134  3C03BF88   LUI V1, -16504
9D015138  8C626060   LW V0, 24672(V1)
9D01513C  7C024A44   INS V0, ZERO, 9, 1
9D015140  AC626060   SW V0, 24672(V1)
70:                      
71:                      // Software SPI Bit-bang MISO (RB10)
72:                  
73:                      AD1PCFGbits.PCFG10 = 1;     // Analog input pin in digital mode.
9D015144  3C03BF81   LUI V1, -16511
9D015148  8C629060   LW V0, -28576(V1)
9D01514C  24040001   ADDIU A0, ZERO, 1
9D015150  7C825284   INS V0, A0, 10, 1
9D015154  AC629060   SW V0, -28576(V1)
74:                      ODCBbits.ODCB10 = 0;        // Normal
9D015158  3C03BF88   LUI V1, -16504
9D01515C  8C626070   LW V0, 24688(V1)
9D015160  7C025284   INS V0, ZERO, 10, 1
9D015164  AC626070   SW V0, 24688(V1)
75:                      TRISBbits.TRISB10 = 1;      // Input
9D015168  3C03BF88   LUI V1, -16504
9D01516C  8C626040   LW V0, 24640(V1)
9D015170  24040001   ADDIU A0, ZERO, 1
9D015174  7C825284   INS V0, A0, 10, 1
9D015178  AC626040   SW V0, 24640(V1)
76:                      
77:                      // Software SPI Bit-bang !SS for Ethernet Switch (RB7)
78:                  
79:                      AD1PCFGbits.PCFG7 = 1;      // Analog input pin in digital mode.
9D01517C  3C03BF81   LUI V1, -16511
9D015180  8C629060   LW V0, -28576(V1)
9D015184  24040001   ADDIU A0, ZERO, 1
9D015188  7C8239C4   INS V0, A0, 7, 1
9D01518C  AC629060   SW V0, -28576(V1)
80:                      ODCBbits.ODCB7 = 0;         // Normal
9D015190  3C03BF88   LUI V1, -16504
9D015194  8C626070   LW V0, 24688(V1)
9D015198  7C0239C4   INS V0, ZERO, 7, 1
9D01519C  AC626070   SW V0, 24688(V1)
81:                      TRISBbits.TRISB7 = 0;       // Output
9D0151A0  3C03BF88   LUI V1, -16504
9D0151A4  8C626040   LW V0, 24640(V1)
9D0151A8  7C0239C4   INS V0, ZERO, 7, 1
9D0151AC  AC626040   SW V0, 24640(V1)
82:                      LATBbits.LATB7 = 1;         // Logic High
9D0151B0  3C03BF88   LUI V1, -16504
9D0151B4  8C626060   LW V0, 24672(V1)
9D0151B8  24040001   ADDIU A0, ZERO, 1
9D0151BC  7C8239C4   INS V0, A0, 7, 1
9D0151C0  AC626060   SW V0, 24672(V1)
83:                  }
9D0151C4  03C0E821   ADDU SP, S8, ZERO
9D0151C8  8FBE0004   LW S8, 4(SP)
9D0151CC  27BD0008   ADDIU SP, SP, 8
9D0151D0  03E00008   JR RA
9D0151D4  00000000   NOP
84:                  
85:                  //==============================================================================
86:                  
87:                  static void InitTMR()
88:                  {
9D0151D8  27BDFFF8   ADDIU SP, SP, -8
9D0151DC  AFBE0004   SW S8, 4(SP)
9D0151E0  03A0F021   ADDU S8, SP, ZERO
89:                      // Core Timer
90:                      IPC0bits.CTIP = 7;              // Set core timer interrupt priority.
9D0151E4  3C03BF88   LUI V1, -16504
9D0151E8  8C621090   LW V0, 4240(V1)
9D0151EC  24040007   ADDIU A0, ZERO, 7
9D0151F0  7C822084   INS V0, A0, 2, 3
9D0151F4  AC621090   SW V0, 4240(V1)
91:                      IPC0bits.CTIS = 0;              // Set core timer interrupt subpriority.
9D0151F8  3C03BF88   LUI V1, -16504
9D0151FC  8C621090   LW V0, 4240(V1)
9D015200  7C020804   INS V0, ZERO, 0, 2
9D015204  AC621090   SW V0, 4240(V1)
92:                      IFS0CLR = _IFS0_CTIF_MASK;      // Clear core timer interrupt flag.
9D015208  3C02BF88   LUI V0, -16504
9D01520C  24030001   ADDIU V1, ZERO, 1
9D015210  AC431034   SW V1, 4148(V0)
93:                      IEC0SET = _IEC0_CTIE_MASK;      // Enable CT interrupts.
9D015214  3C02BF88   LUI V0, -16504
9D015218  24030001   ADDIU V1, ZERO, 1
9D01521C  AC431068   SW V1, 4200(V0)
94:                      
95:                      //  Timer 5 (software SPI clock)
96:                      ConfigIntTimer5(T5_INT_OFF | T5_INT_PRIOR_7 | T5_INT_SUB_PRIOR_0);
9D015220  3C02BF88   LUI V0, -16504
9D015224  3C030010   LUI V1, 16
9D015228  AC431034   SW V1, 4148(V0)
9D01522C  3C02BF88   LUI V0, -16504
9D015230  2403001C   ADDIU V1, ZERO, 28
9D015234  AC4310E4   SW V1, 4324(V0)
9D015238  3C02BF88   LUI V0, -16504
9D01523C  2403001C   ADDIU V1, ZERO, 28
9D015240  AC4310E8   SW V1, 4328(V0)
9D015244  3C02BF88   LUI V0, -16504
9D015248  24030003   ADDIU V1, ZERO, 3
9D01524C  AC4310E4   SW V1, 4324(V0)
9D015250  3C02BF88   LUI V0, -16504
9D015254  AC4010E8   SW ZERO, 4328(V0)
9D015258  3C02BF88   LUI V0, -16504
9D01525C  3C030010   LUI V1, 16
9D015260  AC431064   SW V1, 4196(V0)
9D015264  3C02BF88   LUI V0, -16504
9D015268  AC401068   SW ZERO, 4200(V0)
97:                      OpenTimer5(T5_ON | T5_IDLE_CON | T5_PS_1_1, 800);       // 100 kHz
9D01526C  3C02BF80   LUI V0, -16512
9D015270  AC400E00   SW ZERO, 3584(V0)
9D015274  3C02BF80   LUI V0, -16512
9D015278  AC400E10   SW ZERO, 3600(V0)
9D01527C  3C02BF80   LUI V0, -16512
9D015280  24030320   ADDIU V1, ZERO, 800
9D015284  AC430E20   SW V1, 3616(V0)
9D015288  3C02BF80   LUI V0, -16512
9D01528C  34038000   ORI V1, ZERO, -32768
9D015290  AC430E08   SW V1, 3592(V0)
98:                  }
9D015294  03C0E821   ADDU SP, S8, ZERO
9D015298  8FBE0004   LW S8, 4(SP)
9D01529C  27BD0008   ADDIU SP, SP, 8
9D0152A0  03E00008   JR RA
9D0152A4  00000000   NOP
99:                  
100:                 //==============================================================================
101:                 
102:                 static void InitSPI()
103:                 {
9D0152A8  27BDFFF8   ADDIU SP, SP, -8
9D0152AC  AFBE0004   SW S8, 4(SP)
9D0152B0  03A0F021   ADDU S8, SP, ZERO
104:                     // SPI2
105:                 
106:                     SPI2CONCLR = 0xFFFFFFFF;
9D0152B4  3C02BF80   LUI V0, -16512
9D0152B8  2403FFFF   ADDIU V1, ZERO, -1
9D0152BC  AC435A04   SW V1, 23044(V0)
107:                 
108:                     SPI2CONSET = _SPI2CON_CKP_MASK;     // Clock idles high.
9D0152C0  3C02BF80   LUI V0, -16512
9D0152C4  24030040   ADDIU V1, ZERO, 64
9D0152C8  AC435A08   SW V1, 23048(V0)
109:                     SPI2CONSET = _SPI2CON_MSTEN_MASK;   // Master mode.
9D0152CC  3C02BF80   LUI V0, -16512
9D0152D0  24030020   ADDIU V1, ZERO, 32
9D0152D4  AC435A08   SW V1, 23048(V0)
110:                     SPI2CONSET = _SPI2CON_ENHBUF_MASK;  // Enhanced buffer mode.
9D0152D8  3C02BF80   LUI V0, -16512
9D0152DC  3C030001   LUI V1, 1
9D0152E0  AC435A08   SW V1, 23048(V0)
111:                 
112:                     SPI2BRG = 15;                       // 2.5 MHz SPI clock.
9D0152E4  3C02BF80   LUI V0, -16512
9D0152E8  2403000F   ADDIU V1, ZERO, 15
9D0152EC  AC435A30   SW V1, 23088(V0)
113:                 
114:                     SPI2CONbits.STXISEL = 0b10;         // TX interrupt when buffer is empty
9D0152F0  3C03BF80   LUI V1, -16512
9D0152F4  8C625A00   LW V0, 23040(V1)
9D0152F8  24040002   ADDIU A0, ZERO, 2
9D0152FC  7C821884   INS V0, A0, 2, 2
9D015300  AC625A00   SW V0, 23040(V1)
115:                                                         //   by one-half or more.
116:                 
117:                     SPI2CONbits.SRXISEL = 0b10;         // RX interrupt when buffer is full
9D015304  3C03BF80   LUI V1, -16512
9D015308  8C625A00   LW V0, 23040(V1)
9D01530C  24040002   ADDIU A0, ZERO, 2
9D015310  7C820804   INS V0, A0, 0, 2
9D015314  AC625A00   SW V0, 23040(V1)
118:                                                         //   by one-half or more.
119:                 
120:                     IPC7bits.SPI2IP = 7;                // Set SPI2 interrupt priority.
9D015318  3C03BF88   LUI V1, -16504
9D01531C  8C621100   LW V0, 4352(V1)
9D015320  24040007   ADDIU A0, ZERO, 7
9D015324  7C82E684   INS V0, A0, 26, 3
9D015328  AC621100   SW V0, 4352(V1)
121:                     IPC7bits.SPI2IS = 0;                // Set SPI2 interrupt subpriority.
9D01532C  3C03BF88   LUI V1, -16504
9D015330  8C621100   LW V0, 4352(V1)
9D015334  7C02CE04   INS V0, ZERO, 24, 2
9D015338  AC621100   SW V0, 4352(V1)
122:                 
123:                     IFS1CLR = _IFS1_SPI2EIF_MASK;       // Clear SPI2 error interrupt flag.
9D01533C  3C02BF88   LUI V0, -16504
9D015340  24030020   ADDIU V1, ZERO, 32
9D015344  AC431044   SW V1, 4164(V0)
124:                     IFS1CLR = _IFS1_SPI2RXIF_MASK;      // Clear SPI2 RX interrupt flag.
9D015348  3C02BF88   LUI V0, -16504
9D01534C  24030040   ADDIU V1, ZERO, 64
9D015350  AC431044   SW V1, 4164(V0)
125:                     IFS1CLR = _IFS1_SPI2TXIF_MASK;      // Clear SPI2 TX interrupt flag.
9D015354  3C02BF88   LUI V0, -16504
9D015358  24030080   ADDIU V1, ZERO, 128
9D01535C  AC431044   SW V1, 4164(V0)
126:                 
127:                     IEC1CLR = _IEC1_SPI2EIE_MASK;       // Disable SPI2 error interrupt.
9D015360  3C02BF88   LUI V0, -16504
9D015364  24030020   ADDIU V1, ZERO, 32
9D015368  AC431074   SW V1, 4212(V0)
128:                     IEC1CLR = _IEC1_SPI2RXIE_MASK;      // Disable SPI2 RX interrupt.
9D01536C  3C02BF88   LUI V0, -16504
9D015370  24030040   ADDIU V1, ZERO, 64
9D015374  AC431074   SW V1, 4212(V0)
129:                     IEC1CLR = _IEC1_SPI2TXIE_MASK;      // Disable SPI2 TX interrupt.
9D015378  3C02BF88   LUI V0, -16504
9D01537C  24030080   ADDIU V1, ZERO, 128
9D015380  AC431074   SW V1, 4212(V0)
130:                 
131:                     SPI2CONSET = _SPI2CON_ON_MASK;      // Enable SPI peripheral.
9D015384  3C02BF80   LUI V0, -16512
9D015388  34038000   ORI V1, ZERO, -32768
9D01538C  AC435A08   SW V1, 23048(V0)
132:                 }
9D015390  03C0E821   ADDU SP, S8, ZERO
9D015394  8FBE0004   LW S8, 4(SP)
9D015398  27BD0008   ADDIU SP, SP, 8
9D01539C  03E00008   JR RA
9D0153A0  00000000   NOP
133:                 
134:                 //==============================================================================
135:                 
136:                 static void InitINT()
137:                 {
9D0153A4  27BDFFF8   ADDIU SP, SP, -8
9D0153A8  AFBE0004   SW S8, 4(SP)
9D0153AC  03A0F021   ADDU S8, SP, ZERO
138:                     INTCONSET = _INTCON_MVEC_MASK;      // Enable multi-vectored mode.
9D0153B0  3C02BF88   LUI V0, -16504
9D0153B4  24031000   ADDIU V1, ZERO, 4096
9D0153B8  AC431008   SW V1, 4104(V0)
139:                     asm("ei");                          // Enable interrupts.
9D0153BC  41606020   EI ZERO
140:                 }
9D0153C0  03C0E821   ADDU SP, S8, ZERO
9D0153C4  8FBE0004   LW S8, 4(SP)
9D0153C8  03E00008   JR RA
9D0153CC  27BD0008   ADDIU SP, SP, 8
141:                 
142:                 //==============================================================================
143:                 
144:                 static void InitWDT()
145:                 {
9D0153D0  27BDFFF8   ADDIU SP, SP, -8
9D0153D4  AFBE0004   SW S8, 4(SP)
9D0153D8  03A0F021   ADDU S8, SP, ZERO
146:                     if ((RCONbits.POR == 1) && (RCONbits.BOR == 1))
9D0153DC  3C02BF81   LUI V0, -16511
9D0153E0  8C42F600   LW V0, -2560(V0)
9D0153E4  30420001   ANDI V0, V0, 1
9D0153E8  10400015   BEQ V0, ZERO, 0x9D015440
9D0153EC  00000000   NOP
9D0153F0  3C02BF81   LUI V0, -16511
9D0153F4  8C42F600   LW V0, -2560(V0)
9D0153F8  30420002   ANDI V0, V0, 2
9D0153FC  10400010   BEQ V0, ZERO, 0x9D015440
9D015400  00000000   NOP
147:                     {
148:                         // Initial power on detected.  Clear status bits.
149:                         RCONCLR = _RCON_CMR_MASK;
9D015404  3C02BF81   LUI V0, -16511
9D015408  24030200   ADDIU V1, ZERO, 512
9D01540C  AC43F604   SW V1, -2556(V0)
150:                         RCONCLR = _RCON_EXTR_MASK;
9D015410  3C02BF81   LUI V0, -16511
9D015414  24030080   ADDIU V1, ZERO, 128
9D015418  AC43F604   SW V1, -2556(V0)
151:                         RCONCLR = _RCON_WDTO_MASK;
9D01541C  3C02BF81   LUI V0, -16511
9D015420  24030010   ADDIU V1, ZERO, 16
9D015424  AC43F604   SW V1, -2556(V0)
152:                         RCONCLR = _RCON_BOR_MASK;
9D015428  3C02BF81   LUI V0, -16511
9D01542C  24030002   ADDIU V1, ZERO, 2
9D015430  AC43F604   SW V1, -2556(V0)
153:                         RCONCLR = _RCON_POR_MASK;
9D015434  3C02BF81   LUI V0, -16511
9D015438  24030001   ADDIU V1, ZERO, 1
9D01543C  AC43F604   SW V1, -2556(V0)
154:                     }
155:                 }
9D015440  03C0E821   ADDU SP, S8, ZERO
9D015444  8FBE0004   LW S8, 4(SP)
9D015448  27BD0008   ADDIU SP, SP, 8
9D01544C  03E00008   JR RA
9D015450  00000000   NOP
156:                 
157:                 //==============================================================================
158:                 
159:                 static void InitTCPIPStack()
160:                 {
9D015454  27BDFFE8   ADDIU SP, SP, -24
9D015458  AFBF0014   SW RA, 20(SP)
9D01545C  AFBE0010   SW S8, 16(SP)
9D015460  03A0F021   ADDU S8, SP, ZERO
161:                     static ROM uint8_t SerializedMACAddress[6] = 
162:                             {MY_DEFAULT_MAC_BYTE1, MY_DEFAULT_MAC_BYTE2, 
163:                              MY_DEFAULT_MAC_BYTE3, MY_DEFAULT_MAC_BYTE4, 
164:                              MY_DEFAULT_MAC_BYTE5, MY_DEFAULT_MAC_BYTE6};
165:                 
166:                     TickInit();
9D015464  0F405BF1   JAL TickInit
9D015468  00000000   NOP
167:                 
168:                     #if defined(STACK_USE_MPFS2)
169:                     MPFSInit();
9D01546C  0F4032A3   JAL MPFSInit
9D015470  00000000   NOP
170:                     #endif
171:                 
172:                     // Initialize Stack and application related NV variables into AppConfig.
173:                 
174:                     // Start out zeroing all AppConfig bytes to ensure all fields are
175:                     // deterministic for checksum generation
176:                     memset((void*)&AppConfig, 0x00, sizeof(AppConfig));    
9D015474  3C02A000   LUI V0, -24576
9D015478  244408D8   ADDIU A0, V0, 2264
9D01547C  00002821   ADDU A1, ZERO, ZERO
9D015480  24060033   ADDIU A2, ZERO, 51
9D015484  0F406D3B   JAL 0x9D01B4EC
9D015488  00000000   NOP
177:                     
178:                     AppConfig.Flags.bIsDHCPEnabled = false;
9D01548C  3C02A000   LUI V0, -24576
9D015490  244308D8   ADDIU V1, V0, 2264
9D015494  9062002C   LBU V0, 44(V1)
9D015498  7C023184   INS V0, ZERO, 6, 1
9D01549C  A062002C   SB V0, 44(V1)
179:                     AppConfig.Flags.bInConfigMode = true;
9D0154A0  3C02A000   LUI V0, -24576
9D0154A4  244308D8   ADDIU V1, V0, 2264
9D0154A8  9062002C   LBU V0, 44(V1)
9D0154AC  24040001   ADDIU A0, ZERO, 1
9D0154B0  7C8239C4   INS V0, A0, 7, 1
9D0154B4  A062002C   SB V0, 44(V1)
180:                     
181:                     // Use default MAC address of the module
182:                     memcpypgm2ram((void*)&AppConfig.MyMACAddr, 
9D0154B8  3C02A000   LUI V0, -24576
9D0154BC  24440905   ADDIU A0, V0, 2309
9D0154C0  3C029D02   LUI V0, -25342
9D0154C4  2445C2E8   ADDIU A1, V0, -15640
9D0154C8  24060006   ADDIU A2, ZERO, 6
9D0154CC  0F406788   JAL 0x9D019E20
9D0154D0  00000000   NOP
183:                             (ROM void*)SerializedMACAddress, sizeof(AppConfig.MyMACAddr));    
184:                 
185:                     AppConfig.MyIPAddr.Val = 
9D0154D4  3C02A000   LUI V0, -24576
9D0154D8  3C03828F   LUI V1, -32113
9D0154DC  3463A8C0   ORI V1, V1, -22336
9D0154E0  244408D8   ADDIU A0, V0, 2264
9D0154E4  A8830003   SWL V1, 3(A0)
9D0154E8  B84308D8   SWR V1, 2264(V0)
186:                             MY_DEFAULT_IP_ADDR_BYTE1 | 
187:                             MY_DEFAULT_IP_ADDR_BYTE2 << 8ul | 
188:                             MY_DEFAULT_IP_ADDR_BYTE3 << 16ul | 
189:                             MY_DEFAULT_IP_ADDR_BYTE4 << 24ul;
190:                     AppConfig.DefaultIPAddr.Val = AppConfig.MyIPAddr.Val;
9D0154EC  3C02A000   LUI V0, -24576
9D0154F0  244308D8   ADDIU V1, V0, 2264
9D0154F4  88630003   LWL V1, 3(V1)
9D0154F8  984308D8   LWR V1, 2264(V0)
9D0154FC  3C02A000   LUI V0, -24576
9D015500  244208D8   ADDIU V0, V0, 2264
9D015504  A8430017   SWL V1, 23(V0)
9D015508  B8430014   SWR V1, 20(V0)
191:                     AppConfig.MyMask.Val = 
9D01550C  3C02A000   LUI V0, -24576
9D015510  244208D8   ADDIU V0, V0, 2264
9D015514  3C0300FF   LUI V1, 255
9D015518  3463FFFF   ORI V1, V1, -1
9D01551C  A8430007   SWL V1, 7(V0)
9D015520  B8430004   SWR V1, 4(V0)
192:                             MY_DEFAULT_MASK_BYTE1 | 
193:                             MY_DEFAULT_MASK_BYTE2 << 8ul | 
194:                             MY_DEFAULT_MASK_BYTE3 << 16ul | 
195:                             MY_DEFAULT_MASK_BYTE4 << 24ul;
196:                     AppConfig.DefaultMask.Val = AppConfig.MyMask.Val;
9D015524  3C02A000   LUI V0, -24576
9D015528  244208D8   ADDIU V0, V0, 2264
9D01552C  88430007   LWL V1, 7(V0)
9D015530  98430004   LWR V1, 4(V0)
9D015534  3C02A000   LUI V0, -24576
9D015538  244208D8   ADDIU V0, V0, 2264
9D01553C  A843001B   SWL V1, 27(V0)
9D015540  B8430018   SWR V1, 24(V0)
197:                     AppConfig.MyGateway.Val = 
9D015544  3C02A000   LUI V0, -24576
9D015548  244208D8   ADDIU V0, V0, 2264
9D01554C  3C030101   LUI V1, 257
9D015550  3463FEA9   ORI V1, V1, -343
9D015554  A843000B   SWL V1, 11(V0)
9D015558  B8430008   SWR V1, 8(V0)
198:                             MY_DEFAULT_GATE_BYTE1 | 
199:                             MY_DEFAULT_GATE_BYTE2 << 8ul | 
200:                             MY_DEFAULT_GATE_BYTE3 << 16ul | 
201:                             MY_DEFAULT_GATE_BYTE4 << 24ul;
202:                     AppConfig.PrimaryDNSServer.Val = 
9D01555C  3C02A000   LUI V0, -24576
9D015560  244208D8   ADDIU V0, V0, 2264
9D015564  3C030101   LUI V1, 257
9D015568  3463FEA9   ORI V1, V1, -343
9D01556C  A843000F   SWL V1, 15(V0)
9D015570  B843000C   SWR V1, 12(V0)
203:                             MY_DEFAULT_PRIMARY_DNS_BYTE1 | 
204:                             MY_DEFAULT_PRIMARY_DNS_BYTE2 << 8ul | 
205:                             MY_DEFAULT_PRIMARY_DNS_BYTE3 << 16ul |
206:                             MY_DEFAULT_PRIMARY_DNS_BYTE4 << 24ul;
207:                     AppConfig.SecondaryDNSServer.Val = 
9D015574  3C02A000   LUI V0, -24576
9D015578  244208D8   ADDIU V0, V0, 2264
9D01557C  A8400013   SWL ZERO, 19(V0)
9D015580  B8400010   SWR ZERO, 16(V0)
208:                             MY_DEFAULT_SECONDARY_DNS_BYTE1 | 
209:                             MY_DEFAULT_SECONDARY_DNS_BYTE2 << 8ul |
210:                             MY_DEFAULT_SECONDARY_DNS_BYTE3 << 16ul |
211:                             MY_DEFAULT_SECONDARY_DNS_BYTE4 << 24ul;
212:                 
213:                     // Load the default NetBIOS Host Name
214:                     memcpypgm2ram(AppConfig.NetBIOSName, (ROM void*) MY_DEFAULT_HOST_NAME, 16);
9D015584  3C02A000   LUI V0, -24576
9D015588  244408F4   ADDIU A0, V0, 2292
9D01558C  3C029D02   LUI V0, -25342
9D015590  2445C2DC   ADDIU A1, V0, -15652
9D015594  24060010   ADDIU A2, ZERO, 16
9D015598  0F406788   JAL 0x9D019E20
9D01559C  00000000   NOP
215:                     FormatNetBIOSName(AppConfig.NetBIOSName);
9D0155A0  3C02A000   LUI V0, -24576
9D0155A4  244408F4   ADDIU A0, V0, 2292
9D0155A8  0F403FFE   JAL FormatNetBIOSName
9D0155AC  00000000   NOP
216:                 
217:                     // Initialize core stack layers (MAC, ARP, TCP, UDP) and
218:                     // application modules (HTTP, SNMP, etc.)
219:                     StackInit();
9D0155B0  0F406057   JAL StackInit
9D0155B4  00000000   NOP
220:                 
221:                     return;
222:                 }
9D0155B8  03C0E821   ADDU SP, S8, ZERO
9D0155BC  8FBF0014   LW RA, 20(SP)
9D0155C0  8FBE0010   LW S8, 16(SP)
9D0155C4  27BD0018   ADDIU SP, SP, 24
9D0155C8  03E00008   JR RA
9D0155CC  00000000   NOP
223:                 
224:                 //==============================================================================
225:                 
226:                 void InitBoard()
227:                 {
9D0155D0  27BDFFE8   ADDIU SP, SP, -24
9D0155D4  AFBF0014   SW RA, 20(SP)
9D0155D8  AFBE0010   SW S8, 16(SP)
9D0155DC  03A0F021   ADDU S8, SP, ZERO
228:                     // Initialize microcontroller peripherals.
229:                     InitCPU();
9D0155E0  0F405401   JAL 0x9D015004
9D0155E4  00000000   NOP
230:                     InitGPIO();
9D0155E8  0F40540D   JAL 0x9D015034
9D0155EC  00000000   NOP
231:                     InitTMR();
9D0155F0  0F405476   JAL 0x9D0151D8
9D0155F4  00000000   NOP
232:                     InitSPI();
9D0155F8  0F4054AA   JAL 0x9D0152A8
9D0155FC  00000000   NOP
233:                     InitINT();
9D015600  0F4054E9   JAL 0x9D0153A4
9D015604  00000000   NOP
234:                     UARTInit();
9D015608  0F404A3E   JAL UARTInit
9D01560C  00000000   NOP
235:                 
236:                     // Initialize external hardware peripherals.
237:                     KSZ8895Init();
9D015610  0F40610D   JAL KSZ8895Init
9D015614  00000000   NOP
238:                 
239:                     // Initialize software libraries.
240:                     InitTCPIPStack();
9D015618  0F405515   JAL 0x9D015454
9D01561C  00000000   NOP
241:                     
242:                     // Initialize watchdog timer.
243:                     InitWDT();
9D015620  0F4054F4   JAL 0x9D0153D0
9D015624  00000000   NOP
244:                 }
9D015628  03C0E821   ADDU SP, S8, ZERO
9D01562C  8FBF0014   LW RA, 20(SP)
9D015630  8FBE0010   LW S8, 16(SP)
9D015634  27BD0018   ADDIU SP, SP, 24
9D015638  03E00008   JR RA
9D01563C  00000000   NOP
245:                 
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/fmucomm.c  ------------------------------------
1:                   ////////////////////////////////////////////////////////////////////////////////
2:                   /// @file
3:                   /// @brief 
4:                   ////////////////////////////////////////////////////////////////////////////////
5:                   
6:                   // *****************************************************************************
7:                   // ************************** System Include Files *****************************
8:                   // *****************************************************************************
9:                   
10:                  // *****************************************************************************
11:                  // ************************** User Include Files *******************************
12:                  // *****************************************************************************
13:                  
14:                  #include <sys/attribs.h>
15:                  #include "fmucomm.h"
16:                  #include "tcpip/tcpip.h"
17:                  #include "util.h"
18:                  
19:                  // *****************************************************************************
20:                  // ************************** Defines ******************************************
21:                  // *****************************************************************************
22:                  
23:                  // The number of bytes for the packet wrapping (header and footer) information.
24:                  // This includes the fields:
25:                  //  - Header            3 bytes
26:                  //  - Packet Type       1 byte
27:                  //  - Payload Length    2 bytes
28:                  //  - CRC               2 bytes
29:                  //
30:                  #define FMUCOMM_WRAP_SIZE   8
31:                  
32:                  typedef struct
33:                  {
34:                      uint8_t           header0;
35:                      uint8_t           header1;
36:                      uint8_t           header2;
37:                      uint8_t           type;
38:                      uint16_t          length_lb;  // length - lower bound
39:                      uint16_t          length_ub;  // length - upper bound
40:                      
41:                  } FMUCOMM_RX_CFG;
42:                  
43:                  typedef struct
44:                  {
45:                      uint8_t header0;
46:                      uint8_t header1;
47:                      uint8_t header2;
48:                      uint8_t type;
49:                      
50:                  } FMUCOMM_TX_CFG;
51:                  
52:                  
53:                  // *****************************************************************************
54:                  // ************************** Definitions **************************************
55:                  // *****************************************************************************
56:                  
57:                  // Note: length lower-bound and upper-bound and required to be set to 
58:                  // correspond with packet buffer size definition; otherwise invalid array
59:                  // access can occur.
60:                  static const FMUCOMM_RX_CFG fmucomm_rx_cfg [ ] =
61:                  {
62:                      { 'U', 'M', 'N', 0x00, 16,   16 },  // FMUCOMM_TYPE_HOST_HEARTBEAT     
63:                      { 'U', 'M', 'N', 0x01,  3,   60 },  // FMUCOMM_TYPE_CTRL_SURFACE_CMD    
64:                      { 'U', 'M', 'N', 0x02,  1, 1024 },  // FMUCOMM_TYPE_GPS_CMD   
65:                      { 'U', 'M', 'N', 0x7F,  1, 1024 },  // FMUCOMM_TYPE_HOST_EXCEPTION 
66:                  };
67:                    
68:                  static const FMUCOMM_TX_CFG fmucomm_tx_cfg [ ] =
69:                  {
70:                      { 'U', 'M', 'N', 0x80 },  // FMUCOMM_TYPE_FMU_HEARTBEAT     
71:                      { 'U', 'M', 'N', 0x81 },  // FMUCOMM_TYPE_IMU_DATA          
72:                      { 'U', 'M', 'N', 0x82 },  // FMUCOMM_TYPE_GPS_DATA          
73:                      { 'U', 'M', 'N', 0x83 },  // FMUCOMM_TYPE_AIR_DATA          
74:                      { 'U', 'M', 'N', 0x84 },  // FMUCOMM_TYPE_CTRL_SURFACE_DATA 
75:                      { 'U', 'M', 'N', 0xFF },  // FMUCOMM_TYPE_FMU_EXCEPTION     
76:                  };
77:                  
78:                  // Client IP Address (192.168.143.11) in big-endian.
79:                  static const uint32_t   clientIPAddr = 0x0B8FA8C0;
80:                  static const UDP_PORT   clientPort   = 55455;
81:                  static       UDP_SOCKET clientSocket = INVALID_UDP_SOCKET;
82:                  
83:                  static const UDP_PORT   servertPort  = 55455;
84:                  static       UDP_SOCKET serverSocket = INVALID_UDP_SOCKET;
85:                  
86:                  
87:                  
88:                  static FMUCOMM_HOST_HEARTBEAT_PL   FMUCommHostHeartbeatPl;
89:                  static FMUCOMM_CTRL_SURFACE_CMD_PL FMUCommCtrlSurfaceCmdPl;
90:                  static FMUCOMM_HOST_GPS_CMD_PL     FMUCommHostGPSCmdPl;
91:                  static FMUCOMM_HOST_EXCEPTION_PL   FMUCommHostExeptionPl;
92:                  
93:                  static FMUCOMM_HOST_PKT FMUCommPkt[ FMUCOMM_RX_TYPE_MAX ] =
94:                  {
95:                      { false, { 0 }, &FMUCommHostHeartbeatPl.pl_u8[ 0 ]  },                      // FMUCOMM_TYPE_HOST_HEARTBEAT
96:                      { false, { 0 }, &FMUCommCtrlSurfaceCmdPl.pl_u8[ 0 ] },                      // FMUCOMM_TYPE_CTRL_SURFACE_CMD
97:                      { false, { 0 }, &FMUCommHostGPSCmdPl.pl_u8[ 0 ]     },                      // FMUCOMM_TYPE_GPS_CMD
98:                      { false, { 0 }, &FMUCommHostExeptionPl.pl_u8[ 0 ]   },                      // FMUCOMM_TYPE_HOST_EXCEPTION
99:                  };
100:                 
101:                 // *****************************************************************************
102:                 // ************************** Function Prototypes ******************************
103:                 // *****************************************************************************
104:                 
105:                 void FMUCommRead( void );
106:                 
107:                 // *****************************************************************************
108:                 // ************************** Global Functions *********************************
109:                 // *****************************************************************************
110:                 
111:                 void FMUCommTask()
112:                 {
9D014248  27BDFFE0   ADDIU SP, SP, -32
9D01424C  AFBF001C   SW RA, 28(SP)
9D014250  AFBE0018   SW S8, 24(SP)
9D014254  03A0F021   ADDU S8, SP, ZERO
113:                     static enum
114:                     {
115:                         SM_INIT,
116:                         SM_PROCESS,
117:                     } FMUCommTaskState = SM_INIT;
118:                 
119:                     switch (FMUCommTaskState)
9D014258  8F828100   LW V0, -32512(GP)
9D01425C  10400006   BEQ V0, ZERO, 0x9D014278
9D014260  00000000   NOP
9D014264  24030001   ADDIU V1, ZERO, 1
9D014268  10430024   BEQ V0, V1, 0x9D0142FC
9D01426C  00000000   NOP
9D014270  0B4050D7   J 0x9D01435C
9D014274  00000000   NOP
120:                     {
121:                         case SM_INIT:
122:                         {
123:                             // Open a client socket for transmission of UDP data.
124:                             clientSocket = UDPOpenEx( clientIPAddr,
9D014278  3C029D02   LUI V0, -25342
9D01427C  8C43BD38   LW V1, -17096(V0)
9D014280  3C029D02   LUI V0, -25342
9D014284  9442BD3C   LHU V0, -17092(V0)
9D014288  00602021   ADDU A0, V1, ZERO
9D01428C  24050003   ADDIU A1, ZERO, 3
9D014290  00003021   ADDU A2, ZERO, ZERO
9D014294  00403821   ADDU A3, V0, ZERO
9D014298  0F403870   JAL UDPOpenEx
9D01429C  00000000   NOP
9D0142A0  A3828020   SB V0, -32736(GP)
125:                                                       UDP_OPEN_IP_ADDRESS,
126:                                                       0,
127:                                                       clientPort );
128:                             
129:                             // Open a server socket for reception of UDP data.
130:                             serverSocket = UDPOpenEx( 0, 
9D0142A4  3C029D02   LUI V0, -25342
9D0142A8  9442BD3E   LHU V0, -17090(V0)
9D0142AC  00002021   ADDU A0, ZERO, ZERO
9D0142B0  00002821   ADDU A1, ZERO, ZERO
9D0142B4  00403021   ADDU A2, V0, ZERO
9D0142B8  00003821   ADDU A3, ZERO, ZERO
9D0142BC  0F403870   JAL UDPOpenEx
9D0142C0  00000000   NOP
9D0142C4  A3828021   SB V0, -32735(GP)
131:                                                       UDP_OPEN_SERVER,
132:                                                       servertPort,
133:                                                       0 );
134:                             
135:                             
136:                             // Sockets opened successfully ?
137:                             if( ( clientSocket != INVALID_UDP_SOCKET ) &&
9D0142C8  93838020   LBU V1, -32736(GP)
9D0142CC  240200FF   ADDIU V0, ZERO, 255
9D0142D0  1062001E   BEQ V1, V0, 0x9D01434C
9D0142D4  00000000   NOP
9D0142DC  240200FF   ADDIU V0, ZERO, 255
9D0142E0  1062001D   BEQ V1, V0, 0x9D014358
9D0142E4  00000000   NOP
138:                                 ( serverSocket != INVALID_UDP_SOCKET ) )
9D0142D8  93838021   LBU V1, -32735(GP)
139:                             {
140:                                 FMUCommTaskState++;
9D0142E8  8F828100   LW V0, -32512(GP)
9D0142EC  24420001   ADDIU V0, V0, 1
9D0142F0  AF828100   SW V0, -32512(GP)
141:                             }
142:                             
143:                             break;
9D0142F4  0B4050D7   J 0x9D01435C
9D0142F8  00000000   NOP
9D01434C  00000000   NOP
9D014350  0B4050D7   J 0x9D01435C
9D014354  00000000   NOP
9D014358  00000000   NOP
144:                         }
145:                         case SM_PROCESS:
146:                         {
147:                             FMUCOMM_RX_TYPE_E rx_idx;
148:                             
149:                             // Clear validity identifiers for all received messages.
150:                             //
151:                             // Note: validity flags are only set for one iteration of the 
152:                             // FMUCommTask.  Therefore, modules which use the received data
153:                             // must fully process the message or copy the message during
154:                             // an execution.
155:                             //
156:                             for( rx_idx = (FMUCOMM_RX_TYPE_E) 0;
9D0142FC  AFC00010   SW ZERO, 16(S8)
9D014300  0B4050CB   J 0x9D01432C
9D014304  00000000   NOP
9D01432C  8FC20010   LW V0, 16(S8)
9D014330  2C420004   SLTIU V0, V0, 4
9D014334  1440FFF4   BNE V0, ZERO, 0x9D014308
9D014338  00000000   NOP
157:                                  rx_idx < FMUCOMM_RX_TYPE_MAX;
158:                                  rx_idx++ )
9D014320  8FC20010   LW V0, 16(S8)
9D014324  24420001   ADDIU V0, V0, 1
9D014328  AFC20010   SW V0, 16(S8)
159:                             {
160:                                 FMUCommPkt[ rx_idx ].valid = false;
9D014308  3C02A001   LUI V0, -24575
9D01430C  8FC30010   LW V1, 16(S8)
9D014310  00031900   SLL V1, V1, 4
9D014314  24428838   ADDIU V0, V0, -30664
9D014318  00621021   ADDU V0, V1, V0
9D01431C  A0400000   SB ZERO, 0(V0)
161:                             }
162:                             
163:                             // Read UDP data and decode.
164:                             FMUCommRead();
9D01433C  0F40515F   JAL FMUCommRead
9D014340  00000000   NOP
9D014344  0B4050D7   J 0x9D01435C
9D014348  00000000   NOP
165:                         }
166:                     }
167:                 }
9D01435C  03C0E821   ADDU SP, S8, ZERO
9D014360  8FBF001C   LW RA, 28(SP)
9D014364  8FBE0018   LW S8, 24(SP)
9D014368  27BD0020   ADDIU SP, SP, 32
9D01436C  03E00008   JR RA
9D014370  00000000   NOP
168:                 
169:                 bool FMUCommSet( FMUCOMM_TX_TYPE_E pktType, uint8_t* pl_p, uint16_t plLen )
170:                 {
9D014374  27BDFFD8   ADDIU SP, SP, -40
9D014378  AFBF0024   SW RA, 36(SP)
9D01437C  AFBE0020   SW S8, 32(SP)
9D014380  03A0F021   ADDU S8, SP, ZERO
9D014384  AFC40028   SW A0, 40(S8)
9D014388  AFC5002C   SW A1, 44(S8)
9D01438C  00C01021   ADDU V0, A2, ZERO
9D014390  A7C20030   SH V0, 48(S8)
171:                           bool            setSuccess = false;
9D014394  A3C00010   SB ZERO, 16(S8)
172:                     const FMUCOMM_TX_CFG* pktCfg_p;
173:                           uint16_t        calcCRC;
174:                     
175:                     // FMU socket is open for communication ?
176:                     if( UDPIsOpened( clientSocket ) == true )
9D014398  93828020   LBU V0, -32736(GP)
9D01439C  00402021   ADDU A0, V0, ZERO
9D0143A0  0F4039C4   JAL UDPIsOpened
9D0143A4  00000000   NOP
9D0143A8  1040005F   BEQ V0, ZERO, 0x9D014528
9D0143AC  00000000   NOP
177:                     {
178:                         // Socket has space available ?
179:                         if( UDPIsPutReady( clientSocket ) >= ( plLen + FMUCOMM_WRAP_SIZE ) )
9D0143B0  93828020   LBU V0, -32736(GP)
9D0143B4  00402021   ADDU A0, V0, ZERO
9D0143B8  0F403A2F   JAL UDPIsPutReady
9D0143BC  00000000   NOP
9D0143C0  00401821   ADDU V1, V0, ZERO
9D0143C4  97C20030   LHU V0, 48(S8)
9D0143C8  24420008   ADDIU V0, V0, 8
9D0143CC  0062102A   SLT V0, V1, V0
9D0143D0  14400055   BNE V0, ZERO, 0x9D014528
9D0143D4  00000000   NOP
180:                         {
181:                             // Update returned annunciation to identify success.
182:                             setSuccess = true;
9D0143D8  24020001   ADDIU V0, ZERO, 1
9D0143DC  A3C20010   SB V0, 16(S8)
183:                             
184:                             // Index the selected packets configuration once - improves
185:                             // processing speed and reduces line length.
186:                             pktCfg_p = &fmucomm_tx_cfg[ pktType ];
9D0143E0  8FC20028   LW V0, 40(S8)
9D0143E4  00021880   SLL V1, V0, 2
9D0143E8  3C029D02   LUI V0, -25342
9D0143EC  2442BD20   ADDIU V0, V0, -17120
9D0143F0  00621021   ADDU V0, V1, V0
9D0143F4  AFC20014   SW V0, 20(S8)
187:                             
188:                             // Calculate CRC of the packet - includes the type, length, and
189:                             // payload.
190:                             //
191:                             // Note: the starting CRC value is '0', and the previous CRC value
192:                             // is used for the subsequent calculations.  This piece-wise
193:                             // calculation is necessary because packet fields are in non-
194:                             // contiguous memory locations.
195:                             //
196:                             calcCRC = utilCRC16( &pktCfg_p->type,    sizeof( pktCfg_p->type ), 0       );
9D0143F8  8FC20014   LW V0, 20(S8)
9D0143FC  24420003   ADDIU V0, V0, 3
9D014400  00402021   ADDU A0, V0, ZERO
9D014404  24050001   ADDIU A1, ZERO, 1
9D014408  00003021   ADDU A2, ZERO, ZERO
9D01440C  0F406A5D   JAL utilCRC16
9D014410  00000000   NOP
9D014414  A7C20018   SH V0, 24(S8)
197:                             calcCRC = utilCRC16( &plLen,             sizeof( plLen ),          calcCRC );
9D014418  97C20018   LHU V0, 24(S8)
9D01441C  27C30030   ADDIU V1, S8, 48
9D014420  00602021   ADDU A0, V1, ZERO
9D014424  24050002   ADDIU A1, ZERO, 2
9D014428  00403021   ADDU A2, V0, ZERO
9D01442C  0F406A5D   JAL utilCRC16
9D014430  00000000   NOP
9D014434  A7C20018   SH V0, 24(S8)
198:                             calcCRC = utilCRC16( (const void*) pl_p, plLen,                    calcCRC );
9D014438  97C20030   LHU V0, 48(S8)
9D01443C  00401821   ADDU V1, V0, ZERO
9D014440  97C20018   LHU V0, 24(S8)
9D014444  8FC4002C   LW A0, 44(S8)
9D014448  00602821   ADDU A1, V1, ZERO
9D01444C  00403021   ADDU A2, V0, ZERO
9D014450  0F406A5D   JAL utilCRC16
9D014454  00000000   NOP
9D014458  A7C20018   SH V0, 24(S8)
199:                             
200:                             // Queue the message for transmission. Content transmission order
201:                             // is:
202:                             //  - Header 0
203:                             //  - Header 1
204:                             //  - Header 2
205:                             //  - Payload Type
206:                             //  - Length (LSB)
207:                             //  - Length (MSB)
208:                             //  - Payload
209:                             //  - CRC (LSB)
210:                             //  - CRC (MSB)
211:                             //
212:                             // Note: Return value of UDP 'put' function is not checked since
213:                             // available buffer space has already been verified.
214:                             //
215:                             (void) UDPPut( pktCfg_p->header0 );
9D01445C  8FC20014   LW V0, 20(S8)
9D014460  90420000   LBU V0, 0(V0)
9D014464  00402021   ADDU A0, V0, ZERO
9D014468  0F403A54   JAL UDPPut
9D01446C  00000000   NOP
216:                             (void) UDPPut( pktCfg_p->header1 );
9D014470  8FC20014   LW V0, 20(S8)
9D014474  90420001   LBU V0, 1(V0)
9D014478  00402021   ADDU A0, V0, ZERO
9D01447C  0F403A54   JAL UDPPut
9D014480  00000000   NOP
217:                             (void) UDPPut( pktCfg_p->header2 );
9D014484  8FC20014   LW V0, 20(S8)
9D014488  90420002   LBU V0, 2(V0)
9D01448C  00402021   ADDU A0, V0, ZERO
9D014490  0F403A54   JAL UDPPut
9D014494  00000000   NOP
218:                             (void) UDPPut( pktCfg_p->type    );
9D014498  8FC20014   LW V0, 20(S8)
9D01449C  90420003   LBU V0, 3(V0)
9D0144A0  00402021   ADDU A0, V0, ZERO
9D0144A4  0F403A54   JAL UDPPut
9D0144A8  00000000   NOP
219:                             (void) UDPPut( (uint8_t) ( plLen >> 0 ) );
9D0144AC  97C20030   LHU V0, 48(S8)
9D0144B0  304200FF   ANDI V0, V0, 255
9D0144B4  00402021   ADDU A0, V0, ZERO
9D0144B8  0F403A54   JAL UDPPut
9D0144BC  00000000   NOP
220:                             (void) UDPPut( (uint8_t) ( plLen >> 8 ) );
9D0144C0  97C20030   LHU V0, 48(S8)
9D0144C4  00021202   SRL V0, V0, 8
9D0144C8  3042FFFF   ANDI V0, V0, -1
9D0144CC  304200FF   ANDI V0, V0, 255
9D0144D0  00402021   ADDU A0, V0, ZERO
9D0144D4  0F403A54   JAL UDPPut
9D0144D8  00000000   NOP
221:                             
222:                             (void) UDPPutArray( pl_p, plLen );
9D0144DC  97C20030   LHU V0, 48(S8)
9D0144E0  8FC4002C   LW A0, 44(S8)
9D0144E4  00402821   ADDU A1, V0, ZERO
9D0144E8  0F403A77   JAL UDPPutArray
9D0144EC  00000000   NOP
223:                             
224:                             (void) UDPPut( (uint8_t) ( calcCRC >> 0 ) );
9D0144F0  97C20018   LHU V0, 24(S8)
9D0144F4  304200FF   ANDI V0, V0, 255
9D0144F8  00402021   ADDU A0, V0, ZERO
9D0144FC  0F403A54   JAL UDPPut
9D014500  00000000   NOP
225:                             (void) UDPPut( (uint8_t) ( calcCRC >> 8 ) );
9D014504  97C20018   LHU V0, 24(S8)
9D014508  00021202   SRL V0, V0, 8
9D01450C  3042FFFF   ANDI V0, V0, -1
9D014510  304200FF   ANDI V0, V0, 255
9D014514  00402021   ADDU A0, V0, ZERO
9D014518  0F403A54   JAL UDPPut
9D01451C  00000000   NOP
226:                             
227:                             // Mark the UDP packet for transmission.
228:                             UDPFlush();
9D014520  0F403AB7   JAL UDPFlush
9D014524  00000000   NOP
229:                         }
230:                     }
231:                     
232:                     return setSuccess;
9D014528  93C20010   LBU V0, 16(S8)
233:                 }
9D01452C  03C0E821   ADDU SP, S8, ZERO
9D014530  8FBF0024   LW RA, 36(SP)
9D014534  8FBE0020   LW S8, 32(SP)
9D014538  27BD0028   ADDIU SP, SP, 40
9D01453C  03E00008   JR RA
9D014540  00000000   NOP
234:                 
235:                 const FMUCOMM_HOST_PKT* FMUCommGet( FMUCOMM_RX_TYPE_E pktType )
236:                 {
9D014544  27BDFFF8   ADDIU SP, SP, -8
9D014548  AFBE0004   SW S8, 4(SP)
9D01454C  03A0F021   ADDU S8, SP, ZERO
9D014550  AFC40008   SW A0, 8(S8)
237:                     return &FMUCommPkt[ pktType ];
9D014554  8FC20008   LW V0, 8(S8)
9D014558  00021900   SLL V1, V0, 4
9D01455C  3C02A001   LUI V0, -24575
9D014560  24428838   ADDIU V0, V0, -30664
9D014564  00621021   ADDU V0, V1, V0
238:                 }
9D014568  03C0E821   ADDU SP, S8, ZERO
9D01456C  8FBE0004   LW S8, 4(SP)
9D014570  27BD0008   ADDIU SP, SP, 8
9D014574  03E00008   JR RA
9D014578  00000000   NOP
239:                 
240:                 // *****************************************************************************
241:                 // ************************** Static Functions *********************************
242:                 // *****************************************************************************
243:                 
244:                 // Read and decode UDP data
245:                 //
246:                 // Note: Only a singe message type can be read per execution (e.g. a single
247:                 // Host-Heartbeat message).  If multiple message of the same type are received
248:                 // during a single execution the previous message will be overwritten with 
249:                 // the later message.
250:                 //
251:                 void FMUCommRead( void )
252:                 {
9D01457C  27BDFFD8   ADDIU SP, SP, -40
9D014580  AFBF0024   SW RA, 36(SP)
9D014584  AFBE0020   SW S8, 32(SP)
9D014588  03A0F021   ADDU S8, SP, ZERO
253:                     // State for UPD packet reception.
254:                     static enum
255:                     {
256:                         UDP_SM_HEADER_0,
257:                         UDP_SM_HEADER_1,
258:                         UDP_SM_HEADER_2,
259:                                 
260:                         UDP_SM_TYPE,
261:                         
262:                         UDP_SM_LENGTH_LSB,
263:                         UDP_SM_LENGTH_MSB,
264:                         
265:                         UDP_SM_PAYLOAD,
266:                         
267:                         UDP_SM_CRC_LSB,
268:                         UDP_SM_CRC_MSB,
269:                                  
270:                     } UDPState = UDP_SM_HEADER_0;
271:                     
272:                     static FMUCOMM_PKT_WRAP pkt_wrap;
273:                     
274:                     uint16_t udp_byte_cnt;
275:                     uint16_t udp_byte_idx;
276:                     
277:                     // FMU socket is open for reception ?
278:                     if( UDPIsOpened( serverSocket ) == true )
9D01458C  93828021   LBU V0, -32735(GP)
9D014590  00402021   ADDU A0, V0, ZERO
9D014594  0F4039C4   JAL UDPIsOpened
9D014598  00000000   NOP
9D01459C  104000FD   BEQ V0, ZERO, 0x9D014994
9D0145A0  00000000   NOP
279:                     {
280:                         udp_byte_cnt = UDPIsGetReady( serverSocket );
9D0145A4  93828021   LBU V0, -32735(GP)
9D0145A8  00402021   ADDU A0, V0, ZERO
9D0145AC  0F403B30   JAL UDPIsGetReady
9D0145B0  00000000   NOP
9D0145B4  A7C2001A   SH V0, 26(S8)
281:                         
282:                         // Socket has received a segment ?
283:                         if( udp_byte_cnt != 0 )
9D0145B8  97C2001A   LHU V0, 26(S8)
9D0145BC  104000F5   BEQ V0, ZERO, 0x9D014994
9D0145C0  00000000   NOP
284:                         {
285:                             // Increment through the received UDP bytes.
286:                             for( udp_byte_idx = 0;
9D0145C4  A7C00010   SH ZERO, 16(S8)
9D0145C8  0B405260   J 0x9D014980
9D0145CC  00000000   NOP
9D014980  97C30010   LHU V1, 16(S8)
9D014984  97C2001A   LHU V0, 26(S8)
9D014988  0062102B   SLTU V0, V1, V0
9D01498C  1440FF10   BNE V0, ZERO, 0x9D0145D0
9D014990  00000000   NOP
287:                                  udp_byte_idx < udp_byte_cnt;
288:                                  udp_byte_idx++ )
9D014974  97C20010   LHU V0, 16(S8)
9D014978  24420001   ADDIU V0, V0, 1
9D01497C  A7C20010   SH V0, 16(S8)
289:                             {
290:                                 //
291:                                 // Note: Return value of function 'UDPGet' is not checked since 
292:                                 // number of available bytes already identified.
293:                                 // 
294:                                 switch( UDPState )
9D0145D0  8F8280F0   LW V0, -32528(GP)
9D0145D4  2C430009   SLTIU V1, V0, 9
9D0145D8  106000E6   BEQ V1, ZERO, 0x9D014974
9D0145DC  00000000   NOP
9D0145E0  00021880   SLL V1, V0, 2
9D0145E4  3C029D01   LUI V0, -25343
9D0145E8  244245FC   ADDIU V0, V0, 17916
9D0145EC  00621021   ADDU V0, V1, V0
9D0145F0  8C420000   LW V0, 0(V0)
9D0145F4  00400008   JR V0
9D0145F8  00000000   NOP
295:                                 {
296:                                     case UDP_SM_HEADER_0:
297:                                     {
298:                                         (void) UDPGet( &pkt_wrap.header0 );
9D014620  278480F4   ADDIU A0, GP, -32524
9D014624  0F403B54   JAL UDPGet
9D014628  00000000   NOP
299:                                         
300:                                         // Byte matches Header_0 required value ?
301:                                         if( pkt_wrap.header0 == 'U' )
9D01462C  938380F4   LBU V1, -32524(GP)
9D014630  24020055   ADDIU V0, ZERO, 85
9D014634  146200CB   BNE V1, V0, 0x9D014964
9D014638  00000000   NOP
302:                                         {
303:                                             // Header_0 received, move to next state.
304:                                             UDPState++;
9D01463C  8F8280F0   LW V0, -32528(GP)
9D014640  24420001   ADDIU V0, V0, 1
9D014644  AF8280F0   SW V0, -32528(GP)
305:                                         }
306:                                         
307:                                         break;
9D014648  0B40525D   J 0x9D014974
9D01464C  00000000   NOP
9D014964  00000000   NOP
9D014968  0B40525D   J 0x9D014974
9D01496C  00000000   NOP
308:                                     }
309:                                     case UDP_SM_HEADER_1:
310:                                     {
311:                                         (void) UDPGet( &pkt_wrap.header1 );
9D014650  278480F5   ADDIU A0, GP, -32523
9D014654  0F403B54   JAL UDPGet
9D014658  00000000   NOP
312:                                         
313:                                         // Byte matches Header_1 required value ?
314:                                         if( pkt_wrap.header1 == 'M' )
9D01465C  938380F5   LBU V1, -32523(GP)
9D014660  2402004D   ADDIU V0, ZERO, 77
9D014664  14620006   BNE V1, V0, 0x9D014680
9D014668  00000000   NOP
315:                                         {
316:                                             // Header_1 received, move to next state.
317:                                             UDPState++;
9D01466C  8F8280F0   LW V0, -32528(GP)
9D014670  24420001   ADDIU V0, V0, 1
9D014674  AF8280F0   SW V0, -32528(GP)
318:                                         }
319:                                         else
320:                                         {
321:                                             // Packet format error, return to initial state.
322:                                             UDPState = UDP_SM_HEADER_0;
9D014680  AF8080F0   SW ZERO, -32528(GP)
323:                                         }
324:                                         
325:                                         break;
9D014678  0B40525D   J 0x9D014974
9D01467C  00000000   NOP
9D014684  0B40525D   J 0x9D014974
9D014688  00000000   NOP
326:                                     }
327:                                     case UDP_SM_HEADER_2:
328:                                     {
329:                                         (void) UDPGet( &pkt_wrap.header2 );
9D01468C  278480F6   ADDIU A0, GP, -32522
9D014690  0F403B54   JAL UDPGet
9D014694  00000000   NOP
330:                                         
331:                                         // Byte matches Header_2 required value ?
332:                                         if( pkt_wrap.header2 == 'N' )
9D014698  938380F6   LBU V1, -32522(GP)
9D01469C  2402004E   ADDIU V0, ZERO, 78
9D0146A0  14620006   BNE V1, V0, 0x9D0146BC
9D0146A4  00000000   NOP
333:                                         {
334:                                             // Header_2 received, move to next state.
335:                                             UDPState++;
9D0146A8  8F8280F0   LW V0, -32528(GP)
9D0146AC  24420001   ADDIU V0, V0, 1
9D0146B0  AF8280F0   SW V0, -32528(GP)
336:                                         }
337:                                         else
338:                                         {
339:                                             // Packet format error, return to initial state.
340:                                             UDPState = UDP_SM_HEADER_0;
9D0146BC  AF8080F0   SW ZERO, -32528(GP)
341:                                         }
342:                                         
343:                                         break;
9D0146B4  0B40525D   J 0x9D014974
9D0146B8  00000000   NOP
9D0146C0  0B40525D   J 0x9D014974
9D0146C4  00000000   NOP
344:                                     }
345:                                     case UDP_SM_TYPE:
346:                                     {
347:                                         FMUCOMM_RX_TYPE_E rx_cfg_idx;
348:                                         bool              type_valid = false;
9D0146C8  A3C00018   SB ZERO, 24(S8)
349:                                          
350:                                         (void) UDPGet( &pkt_wrap.type );
9D0146CC  278480F7   ADDIU A0, GP, -32521
9D0146D0  0F403B54   JAL UDPGet
9D0146D4  00000000   NOP
351:                                         
352:                                         for( rx_cfg_idx = 0;
9D0146D8  AFC00014   SW ZERO, 20(S8)
9D0146DC  0B4051C7   J 0x9D01471C
9D0146E0  00000000   NOP
9D01471C  8FC20014   LW V0, 20(S8)
9D014720  2C420004   SLTIU V0, V0, 4
9D014724  1440FFEF   BNE V0, ZERO, 0x9D0146E4
9D014728  00000000   NOP
353:                                              rx_cfg_idx < FMUCOMM_RX_TYPE_MAX;
354:                                              rx_cfg_idx++ )
9D014710  8FC20014   LW V0, 20(S8)
9D014714  24420001   ADDIU V0, V0, 1
9D014718  AFC20014   SW V0, 20(S8)
355:                                         {
356:                                             // Received UDP byte matches expected value ?
357:                                             if( pkt_wrap.type == fmucomm_rx_cfg[ rx_cfg_idx ].type )
9D0146E4  938380F7   LBU V1, -32521(GP)
9D0146E8  3C029D02   LUI V0, -25342
9D0146EC  8FC40014   LW A0, 20(S8)
9D0146F0  000420C0   SLL A0, A0, 3
9D0146F4  2442BD00   ADDIU V0, V0, -17152
9D0146F8  00821021   ADDU V0, A0, V0
9D0146FC  90420003   LBU V0, 3(V0)
9D014700  14620003   BNE V1, V0, 0x9D014710
9D014704  00000000   NOP
358:                                             {
359:                                                 type_valid = true;
9D014708  24020001   ADDIU V0, ZERO, 1
9D01470C  A3C20018   SB V0, 24(S8)
360:                                             }
361:                                         }
362:                                         
363:                                         // Receive message type was valid ?
364:                                         if( type_valid == true )
9D01472C  93C20018   LBU V0, 24(S8)
9D014730  10400006   BEQ V0, ZERO, 0x9D01474C
9D014734  00000000   NOP
365:                                         {
366:                                             UDPState++;
9D014738  8F8280F0   LW V0, -32528(GP)
9D01473C  24420001   ADDIU V0, V0, 1
9D014740  AF8280F0   SW V0, -32528(GP)
367:                                         }
368:                                         else
369:                                         {
370:                                             // Packet format error, return to initial state.
371:                                             UDPState = UDP_SM_HEADER_0;
9D01474C  AF8080F0   SW ZERO, -32528(GP)
372:                                         }
373:                 
374:                                         break;
9D014744  0B40525D   J 0x9D014974
9D014748  00000000   NOP
9D014750  0B40525D   J 0x9D014974
9D014754  00000000   NOP
375:                                     }
376:                                     case UDP_SM_LENGTH_LSB:
377:                                     {
378:                                         (void) UDPGet( &pkt_wrap.length_lsb );
9D014758  278480F8   ADDIU A0, GP, -32520
9D01475C  0F403B54   JAL UDPGet
9D014760  00000000   NOP
379:                                         
380:                                         UDPState++;
9D014764  8F8280F0   LW V0, -32528(GP)
9D014768  24420001   ADDIU V0, V0, 1
9D01476C  AF8280F0   SW V0, -32528(GP)
381:                                         
382:                                         break;
9D014770  0B40525D   J 0x9D014974
9D014774  00000000   NOP
383:                                     }
384:                                     case UDP_SM_LENGTH_MSB:
385:                                     {
386:                                         (void) UDPGet( &pkt_wrap.length_msb );
9D014778  278480F9   ADDIU A0, GP, -32519
9D01477C  0F403B54   JAL UDPGet
9D014780  00000000   NOP
387:                                         
388:                                         // Received length matches required value ?
389:                                         if( ( pkt_wrap.length >= fmucomm_rx_cfg[ pkt_wrap.type ].length_lb ) &&
9D014784  978380F8   LHU V1, -32520(GP)
9D014788  938280F7   LBU V0, -32521(GP)
9D01478C  00402021   ADDU A0, V0, ZERO
9D014790  3C029D02   LUI V0, -25342
9D014794  000420C0   SLL A0, A0, 3
9D014798  2442BD00   ADDIU V0, V0, -17152
9D01479C  00821021   ADDU V0, A0, V0
9D0147A0  94420004   LHU V0, 4(V0)
9D0147A4  0062102B   SLTU V0, V1, V0
9D0147A8  14400011   BNE V0, ZERO, 0x9D0147F0
9D0147AC  00000000   NOP
9D0147D0  0043102B   SLTU V0, V0, V1
9D0147D4  14400006   BNE V0, ZERO, 0x9D0147F0
9D0147D8  00000000   NOP
390:                                             ( pkt_wrap.length <= fmucomm_rx_cfg[ pkt_wrap.type ].length_ub ) )
9D0147B0  978380F8   LHU V1, -32520(GP)
9D0147B4  938280F7   LBU V0, -32521(GP)
9D0147B8  00402021   ADDU A0, V0, ZERO
9D0147BC  3C029D02   LUI V0, -25342
9D0147C0  000420C0   SLL A0, A0, 3
9D0147C4  2442BD00   ADDIU V0, V0, -17152
9D0147C8  00821021   ADDU V0, A0, V0
9D0147CC  94420006   LHU V0, 6(V0)
391:                                         {
392:                                             UDPState++;
9D0147DC  8F8280F0   LW V0, -32528(GP)
9D0147E0  24420001   ADDIU V0, V0, 1
9D0147E4  AF8280F0   SW V0, -32528(GP)
393:                                         }
394:                                         else
395:                                         {
396:                                             // Packet format error, return to initial state.
397:                                             UDPState = UDP_SM_HEADER_0;
9D0147F0  AF8080F0   SW ZERO, -32528(GP)
398:                                         }
399:                                         
400:                                         break;
9D0147E8  0B40525D   J 0x9D014974
9D0147EC  00000000   NOP
9D0147F4  0B40525D   J 0x9D014974
9D0147F8  00000000   NOP
401:                                     }
402:                                     case UDP_SM_PAYLOAD:
403:                                     {
404:                                         static uint16_t pl_idx = 0;
405:                                         
406:                                         // Read the next UPD byte into the applicable packet's 
407:                                         // payload allocation.
408:                                         (void) UDPGet( &FMUCommPkt[ pkt_wrap.type ].pl_p[ pl_idx ] );
9D0147FC  938280F7   LBU V0, -32521(GP)
9D014800  3C03A001   LUI V1, -24575
9D014804  24638838   ADDIU V1, V1, -30664
9D014808  00021100   SLL V0, V0, 4
9D01480C  00621021   ADDU V0, V1, V0
9D014810  8C43000C   LW V1, 12(V0)
9D014814  978280FC   LHU V0, -32516(GP)
9D014818  00621021   ADDU V0, V1, V0
9D01481C  00402021   ADDU A0, V0, ZERO
9D014820  0F403B54   JAL UDPGet
9D014824  00000000   NOP
409:                                         
410:                                         pl_idx++;
9D014828  978280FC   LHU V0, -32516(GP)
9D01482C  24420001   ADDIU V0, V0, 1
9D014830  3042FFFF   ANDI V0, V0, -1
9D014834  A78280FC   SH V0, -32516(GP)
411:                                         
412:                                         // Entire payload has been received ?
413:                                         if( pl_idx >= pkt_wrap.length )
9D014838  978380F8   LHU V1, -32520(GP)
9D01483C  978280FC   LHU V0, -32516(GP)
9D014840  0043102B   SLTU V0, V0, V1
9D014844  1440004A   BNE V0, ZERO, 0x9D014970
9D014848  00000000   NOP
414:                                         {
415:                                             // Re-initialize payload index for next
416:                                             // evaluation.
417:                                             pl_idx = 0;
9D01484C  A78080FC   SH ZERO, -32516(GP)
418:                                             
419:                                             UDPState++;
9D014850  8F8280F0   LW V0, -32528(GP)
9D014854  24420001   ADDIU V0, V0, 1
9D014858  AF8280F0   SW V0, -32528(GP)
420:                                         }
421:                                         
422:                                         break;
9D01485C  0B40525D   J 0x9D014974
9D014860  00000000   NOP
9D014970  00000000   NOP
423:                                     }
424:                                     case UDP_SM_CRC_LSB:
425:                                     {
426:                                         (void) UDPGet( &pkt_wrap.crc_lsb );
9D014864  278480FA   ADDIU A0, GP, -32518
9D014868  0F403B54   JAL UDPGet
9D01486C  00000000   NOP
427:                                         
428:                                         UDPState++;
9D014870  8F8280F0   LW V0, -32528(GP)
9D014874  24420001   ADDIU V0, V0, 1
9D014878  AF8280F0   SW V0, -32528(GP)
429:                                         
430:                                         break;
9D01487C  0B40525D   J 0x9D014974
9D014880  00000000   NOP
431:                                     }
432:                                     case UDP_SM_CRC_MSB:
433:                                     {
434:                                         uint16_t calcCRC;
435:                                         
436:                                         (void) UDPGet( &pkt_wrap.crc_msb );
9D014884  278480FB   ADDIU A0, GP, -32517
9D014888  0F403B54   JAL UDPGet
9D01488C  00000000   NOP
437:                                         
438:                                         // Calculate CRC of the packet - includes the type, length, and
439:                                         // payload.
440:                                         //
441:                                         // Note: the starting CRC value is '0', and the previous CRC value
442:                                         // is used for the subsequent calculations.  This piece-wise
443:                                         // calculation is necessary because packet fields are in non-
444:                                         // contiguous memory locations.
445:                                         //
446:                                         calcCRC = utilCRC16( &pkt_wrap.type,                         sizeof( pkt_wrap.type   ), 0       );
9D014890  278480F7   ADDIU A0, GP, -32521
9D014894  24050001   ADDIU A1, ZERO, 1
9D014898  00003021   ADDU A2, ZERO, ZERO
9D01489C  0F406A5D   JAL utilCRC16
9D0148A0  00000000   NOP
9D0148A4  A7C2001C   SH V0, 28(S8)
447:                                         calcCRC = utilCRC16( &pkt_wrap.length,                       sizeof( pkt_wrap.length ), calcCRC );
9D0148A8  97C2001C   LHU V0, 28(S8)
9D0148AC  278480F8   ADDIU A0, GP, -32520
9D0148B0  24050002   ADDIU A1, ZERO, 2
9D0148B4  00403021   ADDU A2, V0, ZERO
9D0148B8  0F406A5D   JAL utilCRC16
9D0148BC  00000000   NOP
9D0148C0  A7C2001C   SH V0, 28(S8)
448:                                         calcCRC = utilCRC16( &FMUCommPkt[ pkt_wrap.type ].pl_p[ 0 ], pkt_wrap.length,           calcCRC );
9D0148C4  938280F7   LBU V0, -32521(GP)
9D0148C8  3C03A001   LUI V1, -24575
9D0148CC  24638838   ADDIU V1, V1, -30664
9D0148D0  00021100   SLL V0, V0, 4
9D0148D4  00621021   ADDU V0, V1, V0
9D0148D8  8C44000C   LW A0, 12(V0)
9D0148DC  978280F8   LHU V0, -32520(GP)
9D0148E0  00401821   ADDU V1, V0, ZERO
9D0148E4  97C2001C   LHU V0, 28(S8)
9D0148E8  00602821   ADDU A1, V1, ZERO
9D0148EC  00403021   ADDU A2, V0, ZERO
9D0148F0  0F406A5D   JAL utilCRC16
9D0148F4  00000000   NOP
9D0148F8  A7C2001C   SH V0, 28(S8)
449:                                         
450:                                         // Calculated CRC matches that received ?
451:                                         if( calcCRC == pkt_wrap.crc )
9D0148FC  978280FA   LHU V0, -32518(GP)
9D014900  97C3001C   LHU V1, 28(S8)
9D014904  14620014   BNE V1, V0, 0x9D014958
9D014908  00000000   NOP
452:                                         {
453:                                             // Identify message as valid.
454:                                             FMUCommPkt[ pkt_wrap.type ].valid = true;
9D01490C  938280F7   LBU V0, -32521(GP)
9D014910  00401821   ADDU V1, V0, ZERO
9D014914  3C02A001   LUI V0, -24575
9D014918  00031900   SLL V1, V1, 4
9D01491C  24428838   ADDIU V0, V0, -30664
9D014920  00621021   ADDU V0, V1, V0
9D014924  24030001   ADDIU V1, ZERO, 1
9D014928  A0430000   SB V1, 0(V0)
455:                                             
456:                                             // Copy the wrapper field to the applicable message
457:                                             // for possible processing by accessed module.
458:                                             memcpy( &FMUCommPkt[ pkt_wrap.type ].wrap,
9D01492C  938280F7   LBU V0, -32521(GP)
9D014930  00021900   SLL V1, V0, 4
9D014934  3C02A001   LUI V0, -24575
9D014938  24428838   ADDIU V0, V0, -30664
9D01493C  00621021   ADDU V0, V1, V0
9D014940  24420002   ADDIU V0, V0, 2
9D014944  00402021   ADDU A0, V0, ZERO
9D014948  278580F4   ADDIU A1, GP, -32524
9D01494C  24060008   ADDIU A2, ZERO, 8
9D014950  0F406788   JAL 0x9D019E20
9D014954  00000000   NOP
459:                                                     &pkt_wrap,
460:                                                     sizeof( pkt_wrap ) );
461:                                         }
462:                                         
463:                                         // Entire message has been received, reset the state
464:                                         // machine for reception of next message.
465:                                         UDPState = UDP_SM_HEADER_0;
9D014958  AF8080F0   SW ZERO, -32528(GP)
466:                                         
467:                                         break;
9D01495C  0B40525D   J 0x9D014974
9D014960  00000000   NOP
468:                                     }
469:                                 }
470:                             }
471:                         }
472:                     }
473:                 }
9D014994  03C0E821   ADDU SP, S8, ZERO
9D014998  8FBF0024   LW RA, 36(SP)
9D01499C  8FBE0020   LW S8, 32(SP)
9D0149A0  27BD0028   ADDIU SP, SP, 40
9D0149A4  03E00008   JR RA
9D0149A8  00000000   NOP
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/exceptions.c  ---------------------------------
1:                   /*********************************************************************
2:                    *
3:                    *                  Generic Exception Handler
4:                    *
5:                    *********************************************************************
6:                    * FileName:        exceptions.c
7:                    * Dependencies:
8:                    *
9:                    * Processor:       PIC32
10:                   *
11:                   * Compiler:        MPLAB XC32
12:                   *                  MPLAB IDE
13:                   * Company:         Microchip Technology Inc.
14:                   *
15:                   * Software License Agreement
16:                   *
17:                   * The software supplied herewith by Microchip Technology Incorporated
18:                   * (the ?Company?) for its PIC32/PIC24 Microcontroller is intended
19:                   * and supplied to you, the Company?s customer, for use solely and
20:                   * exclusively on Microchip PIC32/PIC24 Microcontroller products.
21:                   * The software is owned by the Company and/or its supplier, and is
22:                   * protected under applicable copyright laws. All rights are reserved.
23:                   * Any use in violation of the foregoing restrictions may subject the
24:                   * user to criminal sanctions under applicable laws, as well as to
25:                   * civil liability for the breach of the terms and conditions of this
26:                   * license.
27:                   *
28:                   * THIS SOFTWARE IS PROVIDED IN AN ?AS IS? CONDITION. NO WARRANTIES,
29:                   * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
30:                   * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
31:                   * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
32:                   * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
33:                   * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
34:                   *
35:                   *
36:                   *
37:                   ********************************************************************/
38:                  
39:                  #include <xc.h>
40:                  
41:                  // declared static in case exception condition would prevent
42:                  // auto variable being created
43:                  static enum {
44:                  	EXCEP_IRQ = 0,			// interrupt
45:                  	EXCEP_AdEL = 4,			// address error exception (load or ifetch)
46:                  	EXCEP_AdES,				// address error exception (store)
47:                  	EXCEP_IBE,				// bus error (ifetch)
48:                  	EXCEP_DBE,				// bus error (load/store)
49:                  	EXCEP_Sys,				// syscall
50:                  	EXCEP_Bp,				// breakpoint
51:                  	EXCEP_RI,				// reserved instruction
52:                  	EXCEP_CpU,				// coprocessor unusable
53:                  	EXCEP_Overflow,			// arithmetic overflow
54:                  	EXCEP_Trap,				// trap (possible divide by zero)
55:                  	EXCEP_IS1 = 16,			// implementation specfic 1
56:                  	EXCEP_CEU,				// CorExtend Unuseable
57:                  	EXCEP_C2E				// coprocessor 2
58:                  } _excep_code;
59:                  
60:                  static unsigned int _excep_addr;
61:                  
62:                  // this function overrides the normal _weak_ generic handler
63:                  void _general_exception_handler(void)
64:                  {
9D01BF5C  27BDFFF8   ADDIU SP, SP, -8
9D01BF60  AFBE0004   SW S8, 4(SP)
9D01BF64  03A0F021   ADDU S8, SP, ZERO
65:                  	asm volatile("mfc0 %0,$13" : "=r" (_excep_code));
9D01BF68  40026800   MFC0 V0, Cause
9D01BF6C  AF828104   SW V0, -32508(GP)
66:                  	asm volatile("mfc0 %0,$14" : "=r" (_excep_addr));
9D01BF70  40027000   MFC0 V0, EPC
9D01BF74  AF828108   SW V0, -32504(GP)
67:                  
68:                  	_excep_code = (_excep_code & 0x0000007C) >> 2;
9D01BF78  8F828104   LW V0, -32508(GP)
9D01BF7C  3042007C   ANDI V0, V0, 124
9D01BF80  00021082   SRL V0, V0, 2
9D01BF84  AF828104   SW V0, -32508(GP)
69:                  	
70:                  	while (1) {
71:                  		// Examine _excep_code to identify the type of exception
72:                  		// Examine _excep_addr to find the address that caused the exception
73:                  	}
9D01BF88  0B406FE2   J 0x9D01BF88
9D01BF8C  00000000   NOP
74:                  }
---  c:/users/jon watson/documents/github/pic32-fmu.x/src/coretime.c  -----------------------------------
1:                   /*******************************************************************************
2:                   /
3:                   /   Filename:   coretime.c
4:                   /
5:                   *******************************************************************************/
6:                   
7:                   #include <xc.h>
8:                   #include <sys/attribs.h>
9:                   #include "coretime.h"
10:                  #include "stdtypes.h"
11:                  
12:                  
13:                  static volatile uint32_t coreTimeOverflow;  // Core timer overflow counter,
14:                                                              // used to provide 64-bit
15:                                                              // system time.
16:                  
17:                  
18:                  //==============================================================================
19:                  
20:                  uint64_t CoreTimeTicksGet()
21:                  {
9D01680C  27BDFFF0   ADDIU SP, SP, -16
9D016810  AFBE000C   SW S8, 12(SP)
9D016814  03A0F021   ADDU S8, SP, ZERO
22:                      UINT_64 ticks;
23:                  
24:                      do {
25:                          IEC0SET = _IEC0_CTIE_MASK;              // Enable CT interrupts.
9D016818  3C02BF88   LUI V0, -16504
9D01681C  24030001   ADDIU V1, ZERO, 1
9D016820  AC431068   SW V1, 4200(V0)
26:                          Nop();
9D016824  00000040   SSNOP
27:                          IEC0CLR = _IEC0_CTIE_MASK;              // Disable CT interrupts.
9D016828  3C02BF88   LUI V0, -16504
9D01682C  24030001   ADDIU V1, ZERO, 1
9D016830  AC431064   SW V1, 4196(V0)
28:                          ticks.dwords.dword0 = _mfc0(_CP0_COUNT,
9D016834  40024800   MFC0 V0, Count
9D016838  AFC20000   SW V0, 0(S8)
29:                                  _CP0_COUNT_SELECT);             // Fetch 32-bit CT register.
30:                          ticks.dwords.dword1 =
9D01683C  8F8280A4   LW V0, -32604(GP)
9D016840  AFC20004   SW V0, 4(S8)
31:                                  coreTimeOverflow;               // Fetch 32-bit CT overflow.
32:                      } while ((IFS0 & _IFS0_CTIF_MASK) != 0);
9D016844  3C02BF88   LUI V0, -16504
9D016848  8C421030   LW V0, 4144(V0)
9D01684C  30420001   ANDI V0, V0, 1
9D016850  304200FF   ANDI V0, V0, 255
9D016854  1440FFF0   BNE V0, ZERO, 0x9D016818
9D016858  00000000   NOP
33:                  
34:                      IEC0SET = _IEC0_CTIE_MASK;                  // Enable CT interrupts.
9D01685C  3C02BF88   LUI V0, -16504
9D016860  24030001   ADDIU V1, ZERO, 1
9D016864  AC431068   SW V1, 4200(V0)
35:                  
36:                      return ticks.val;
9D016868  8FC20000   LW V0, 0(S8)
9D01686C  8FC30004   LW V1, 4(S8)
37:                  }
9D016870  03C0E821   ADDU SP, S8, ZERO
9D016874  8FBE000C   LW S8, 12(SP)
9D016878  03E00008   JR RA
9D01687C  27BD0010   ADDIU SP, SP, 16
38:                  
39:                  //==============================================================================
40:                  
41:                  uint64_t CoreTime64sGet()
42:                  {
9D016880  27BDFFE8   ADDIU SP, SP, -24
9D016884  AFBF0014   SW RA, 20(SP)
9D016888  AFBE0010   SW S8, 16(SP)
9D01688C  03A0F021   ADDU S8, SP, ZERO
43:                      return CoreTimeTicksGet() / CORETIME_TICKS_PER_SECOND;
9D016890  0F405A03   JAL CoreTimeTicksGet
9D016894  00000000   NOP
9D016898  00402021   ADDU A0, V0, ZERO
9D01689C  00602821   ADDU A1, V1, ZERO
9D0168A0  3C060262   LUI A2, 610
9D0168A4  34C65A00   ORI A2, A2, 23040
9D0168A8  00003821   ADDU A3, ZERO, ZERO
9D0168AC  0F4056D8   JAL __udivdi3
9D0168B0  00000000   NOP
44:                  }
9D0168B4  03C0E821   ADDU SP, S8, ZERO
9D0168B8  8FBF0014   LW RA, 20(SP)
9D0168BC  8FBE0010   LW S8, 16(SP)
9D0168C0  27BD0018   ADDIU SP, SP, 24
9D0168C4  03E00008   JR RA
9D0168C8  00000000   NOP
45:                  
46:                  //==============================================================================
47:                  
48:                  uint64_t CoreTime64msGet()
49:                  {
9D0168CC  27BDFFE8   ADDIU SP, SP, -24
9D0168D0  AFBF0014   SW RA, 20(SP)
9D0168D4  AFBE0010   SW S8, 16(SP)
9D0168D8  03A0F021   ADDU S8, SP, ZERO
50:                      return CoreTimeTicksGet() / (CORETIME_TICKS_PER_SECOND / 1000);
9D0168DC  0F405A03   JAL CoreTimeTicksGet
9D0168E0  00000000   NOP
9D0168E4  00402021   ADDU A0, V0, ZERO
9D0168E8  00602821   ADDU A1, V1, ZERO
9D0168EC  34069C40   ORI A2, ZERO, -25536
9D0168F0  00003821   ADDU A3, ZERO, ZERO
9D0168F4  0F4056D8   JAL __udivdi3
9D0168F8  00000000   NOP
51:                  }
9D0168FC  03C0E821   ADDU SP, S8, ZERO
9D016900  8FBF0014   LW RA, 20(SP)
9D016904  8FBE0010   LW S8, 16(SP)
9D016908  27BD0018   ADDIU SP, SP, 24
9D01690C  03E00008   JR RA
9D016910  00000000   NOP
52:                  
53:                  //==============================================================================
54:                  
55:                  uint64_t CoreTime64usGet()
56:                  {
9D016914  27BDFFE8   ADDIU SP, SP, -24
9D016918  AFBF0014   SW RA, 20(SP)
9D01691C  AFBE0010   SW S8, 16(SP)
9D016920  03A0F021   ADDU S8, SP, ZERO
57:                      return CoreTimeTicksGet() / (CORETIME_TICKS_PER_SECOND / 1000000);
9D016924  0F405A03   JAL CoreTimeTicksGet
9D016928  00000000   NOP
9D01692C  00402021   ADDU A0, V0, ZERO
9D016930  00602821   ADDU A1, V1, ZERO
9D016934  24060028   ADDIU A2, ZERO, 40
9D016938  00003821   ADDU A3, ZERO, ZERO
9D01693C  0F4056D8   JAL __udivdi3
9D016940  00000000   NOP
58:                  }
9D016944  03C0E821   ADDU SP, S8, ZERO
9D016948  8FBF0014   LW RA, 20(SP)
9D01694C  8FBE0010   LW S8, 16(SP)
9D016950  27BD0018   ADDIU SP, SP, 24
9D016954  03E00008   JR RA
9D016958  00000000   NOP
59:                  
60:                  //==============================================================================
61:                  
62:                  uint32_t CoreTime32sGet()
63:                  {
9D01695C  27BDFFE8   ADDIU SP, SP, -24
9D016960  AFBF0014   SW RA, 20(SP)
9D016964  AFBE0010   SW S8, 16(SP)
9D016968  03A0F021   ADDU S8, SP, ZERO
64:                      return CoreTimeTicksGet() / CORETIME_TICKS_PER_SECOND;
9D01696C  0F405A03   JAL CoreTimeTicksGet
9D016970  00000000   NOP
9D016974  00402021   ADDU A0, V0, ZERO
9D016978  00602821   ADDU A1, V1, ZERO
9D01697C  3C060262   LUI A2, 610
9D016980  34C65A00   ORI A2, A2, 23040
9D016984  00003821   ADDU A3, ZERO, ZERO
9D016988  0F4056D8   JAL __udivdi3
9D01698C  00000000   NOP
65:                  }
9D016990  03C0E821   ADDU SP, S8, ZERO
9D016994  8FBF0014   LW RA, 20(SP)
9D016998  8FBE0010   LW S8, 16(SP)
9D01699C  27BD0018   ADDIU SP, SP, 24
9D0169A0  03E00008   JR RA
9D0169A4  00000000   NOP
66:                  
67:                  //==============================================================================
68:                  
69:                  uint32_t CoreTime32msGet()
70:                  {
9D0169A8  27BDFFE8   ADDIU SP, SP, -24
9D0169AC  AFBF0014   SW RA, 20(SP)
9D0169B0  AFBE0010   SW S8, 16(SP)
9D0169B4  03A0F021   ADDU S8, SP, ZERO
71:                      return CoreTimeTicksGet() / (CORETIME_TICKS_PER_SECOND / 1000);
9D0169B8  0F405A03   JAL CoreTimeTicksGet
9D0169BC  00000000   NOP
9D0169C0  00402021   ADDU A0, V0, ZERO
9D0169C4  00602821   ADDU A1, V1, ZERO
9D0169C8  34069C40   ORI A2, ZERO, -25536
9D0169CC  00003821   ADDU A3, ZERO, ZERO
9D0169D0  0F4056D8   JAL __udivdi3
9D0169D4  00000000   NOP
72:                  }
9D0169D8  03C0E821   ADDU SP, S8, ZERO
9D0169DC  8FBF0014   LW RA, 20(SP)
9D0169E0  8FBE0010   LW S8, 16(SP)
9D0169E4  27BD0018   ADDIU SP, SP, 24
9D0169E8  03E00008   JR RA
9D0169EC  00000000   NOP
73:                  
74:                  //==============================================================================
75:                  
76:                  uint32_t CoreTime32usGet()
77:                  {
9D0169F0  27BDFFE8   ADDIU SP, SP, -24
9D0169F4  AFBF0014   SW RA, 20(SP)
9D0169F8  AFBE0010   SW S8, 16(SP)
9D0169FC  03A0F021   ADDU S8, SP, ZERO
78:                      return CoreTimeTicksGet() / (CORETIME_TICKS_PER_SECOND / 1000000);
9D016A00  0F405A03   JAL CoreTimeTicksGet
9D016A04  00000000   NOP
9D016A08  00402021   ADDU A0, V0, ZERO
9D016A0C  00602821   ADDU A1, V1, ZERO
9D016A10  24060028   ADDIU A2, ZERO, 40
9D016A14  00003821   ADDU A3, ZERO, ZERO
9D016A18  0F4056D8   JAL __udivdi3
9D016A1C  00000000   NOP
79:                  }
9D016A20  03C0E821   ADDU SP, S8, ZERO
9D016A24  8FBF0014   LW RA, 20(SP)
9D016A28  8FBE0010   LW S8, 16(SP)
9D016A2C  27BD0018   ADDIU SP, SP, 24
9D016A30  03E00008   JR RA
9D016A34  00000000   NOP
80:                  
81:                  //==============================================================================
82:                  
83:                  void CoreTimeDelayUs(uint32_t us)
84:                  {
9D016A38  27BDFFD8   ADDIU SP, SP, -40
9D016A3C  AFBF0024   SW RA, 36(SP)
9D016A40  AFBE0020   SW S8, 32(SP)
9D016A44  AFB1001C   SW S1, 28(SP)
9D016A48  AFB00018   SW S0, 24(SP)
9D016A4C  03A0F021   ADDU S8, SP, ZERO
9D016A50  AFC40028   SW A0, 40(S8)
85:                      uint64_t microseconds = CoreTime64usGet() + us;
9D016A54  0F405A45   JAL CoreTime64usGet
9D016A58  00000000   NOP
9D016A5C  00402021   ADDU A0, V0, ZERO
9D016A60  00602821   ADDU A1, V1, ZERO
9D016A64  8FD00028   LW S0, 40(S8)
9D016A68  00008821   ADDU S1, ZERO, ZERO
9D016A6C  00901021   ADDU V0, A0, S0
9D016A70  0044302B   SLTU A2, V0, A0
9D016A74  00B11821   ADDU V1, A1, S1
9D016A78  00C32021   ADDU A0, A2, V1
9D016A7C  00801821   ADDU V1, A0, ZERO
9D016A80  AFC20010   SW V0, 16(S8)
9D016A84  AFC30014   SW V1, 20(S8)
86:                      while (CoreTime64usGet() < microseconds);
9D016A88  00000000   NOP
9D016A8C  0F405A45   JAL CoreTime64usGet
9D016A90  00000000   NOP
9D016A94  8FC40014   LW A0, 20(S8)
9D016A98  0064202B   SLTU A0, V1, A0
9D016A9C  1480FFFB   BNE A0, ZERO, 0x9D016A8C
9D016AA0  00000000   NOP
9D016AA4  8FC50014   LW A1, 20(S8)
9D016AA8  00602021   ADDU A0, V1, ZERO
9D016AAC  14A40005   BNE A1, A0, 0x9D016AC4
9D016AB0  00000000   NOP
9D016AB4  8FC40010   LW A0, 16(S8)
9D016AB8  0044102B   SLTU V0, V0, A0
9D016ABC  1440FFF3   BNE V0, ZERO, 0x9D016A8C
9D016AC0  00000000   NOP
87:                  }
9D016AC4  03C0E821   ADDU SP, S8, ZERO
9D016AC8  8FBF0024   LW RA, 36(SP)
9D016ACC  8FBE0020   LW S8, 32(SP)
9D016AD0  8FB1001C   LW S1, 28(SP)
9D016AD4  8FB00018   LW S0, 24(SP)
9D016AD8  27BD0028   ADDIU SP, SP, 40
9D016ADC  03E00008   JR RA
9D016AE0  00000000   NOP
88:                  
89:                  //==============================================================================
90:                  
91:                  void CoreTimeDelayMs(uint32_t ms)
92:                  {
9D016AE4  27BDFFD8   ADDIU SP, SP, -40
9D016AE8  AFBF0024   SW RA, 36(SP)
9D016AEC  AFBE0020   SW S8, 32(SP)
9D016AF0  AFB1001C   SW S1, 28(SP)
9D016AF4  AFB00018   SW S0, 24(SP)
9D016AF8  03A0F021   ADDU S8, SP, ZERO
9D016AFC  AFC40028   SW A0, 40(S8)
93:                      uint64_t milliseconds = CoreTime64msGet() + ms;
9D016B00  0F405A33   JAL CoreTime64msGet
9D016B04  00000000   NOP
9D016B08  00402021   ADDU A0, V0, ZERO
9D016B0C  00602821   ADDU A1, V1, ZERO
9D016B10  8FD00028   LW S0, 40(S8)
9D016B14  00008821   ADDU S1, ZERO, ZERO
9D016B18  00901021   ADDU V0, A0, S0
9D016B1C  0044302B   SLTU A2, V0, A0
9D016B20  00B11821   ADDU V1, A1, S1
9D016B24  00C32021   ADDU A0, A2, V1
9D016B28  00801821   ADDU V1, A0, ZERO
9D016B2C  AFC20010   SW V0, 16(S8)
9D016B30  AFC30014   SW V1, 20(S8)
94:                      while (CoreTime64msGet() < milliseconds);
9D016B34  00000000   NOP
9D016B38  0F405A33   JAL CoreTime64msGet
9D016B3C  00000000   NOP
9D016B40  8FC40014   LW A0, 20(S8)
9D016B44  0064202B   SLTU A0, V1, A0
9D016B48  1480FFFB   BNE A0, ZERO, 0x9D016B38
9D016B4C  00000000   NOP
9D016B50  8FC50014   LW A1, 20(S8)
9D016B54  00602021   ADDU A0, V1, ZERO
9D016B58  14A40005   BNE A1, A0, 0x9D016B70
9D016B5C  00000000   NOP
9D016B60  8FC40010   LW A0, 16(S8)
9D016B64  0044102B   SLTU V0, V0, A0
9D016B68  1440FFF3   BNE V0, ZERO, 0x9D016B38
9D016B6C  00000000   NOP
95:                  }
9D016B70  03C0E821   ADDU SP, S8, ZERO
9D016B74  8FBF0024   LW RA, 36(SP)
9D016B78  8FBE0020   LW S8, 32(SP)
9D016B7C  8FB1001C   LW S1, 28(SP)
9D016B80  8FB00018   LW S0, 24(SP)
9D016B84  27BD0028   ADDIU SP, SP, 40
9D016B88  03E00008   JR RA
9D016B8C  00000000   NOP
96:                  
97:                  //==============================================================================
98:                  
99:                  // Core Timer ISR
100:                 
101:                 void __ISR (_CORE_TIMER_VECTOR, IPL7SRS) CoreTimerISR(void)
102:                 {
9D016B90  415DE800   RDPGPR SP, SP
9D016B94  401A7000   MFC0 K0, EPC
9D016B98  401B6000   MFC0 K1, Status
9D016B9C  27BDFFF0   ADDIU SP, SP, -16
9D016BA0  AFBB000C   SW K1, 12(SP)
9D016BA4  7C1B7844   INS K1, ZERO, 1, 15
9D016BA8  377B1C00   ORI K1, K1, 7168
9D016BAC  409B6000   MTC0 K1, Status
9D016BB0  AFBE0004   SW S8, 4(SP)
9D016BB4  03A0F021   ADDU S8, SP, ZERO
103:                     coreTimeOverflow++;             // Increment core timer overflow count.
9D016BB8  8F8280A4   LW V0, -32604(GP)
9D016BBC  24420001   ADDIU V0, V0, 1
9D016BC0  AF8280A4   SW V0, -32604(GP)
104:                     IFS0CLR = _IFS0_CTIF_MASK;      // Clear core timer interrupt flag.
9D016BC4  3C02BF88   LUI V0, -16504
9D016BC8  24030001   ADDIU V1, ZERO, 1
9D016BCC  AC431034   SW V1, 4148(V0)
105:                 }
9D016BD0  03C0E821   ADDU SP, S8, ZERO
9D016BD4  8FBE0004   LW S8, 4(SP)
9D016BD8  8FBB000C   LW K1, 12(SP)
9D016BDC  27BD0010   ADDIU SP, SP, 16
9D016BE0  41DDE800   WRPGPR SP, SP
9D016BE4  409B6000   MTC0 K1, Status
9D016BE8  42000018   ERET
106:                 
---  c:/users/jon watson/documents/github/pic32-fmu.x/inc/tcpip/http_print.h  ---------------------------
1:                   /*****************************************************************************
2:                     AUTO-GENERATED CODE:  Microchip MPFS Generator version: 2.2.2
3:                   
4:                     Microchip TCP/IP Stack Application Demo
5:                   
6:                     Company:
7:                       Microchip Technology Inc.
8:                   
9:                     File Name:
10:                      http_print.h
11:                  
12:                    Summary:
13:                      This file is automatically generated by the MPFS Generator Utility.
14:                      ALL MODIFICATIONS WILL BE OVERWRITTEN BY THE MPFS GENERATOR.
15:                  
16:                    Description:
17:                      Provides callback headers and resolution for user's custom
18:                      HTTP Application.
19:                   *****************************************************************************/
20:                  
21:                  // DOM-IGNORE-BEGIN
22:                  /*****************************************************************************
23:                  Software License Agreement
24:                  Copyright(c) 2014 Microchip Technology Inc. All rights reserved.
25:                  Microchip licenses to you the right to use, modify, copy and distribute
26:                  Software only when embedded on a Microchip microcontroller or digital
27:                  signal controller that is integrated into your product or third party
28:                  product (pursuant to the sublicense terms in the accompanying license
29:                  agreement).
30:                  
31:                  You should refer to the license agreement accompanying this Software
32:                  for additional information regarding your rights and obligations.
33:                  
34:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
35:                  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY
36:                  OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR
37:                  PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR
38:                  OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION,
39:                  BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT
40:                  DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL,
41:                  INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA,
42:                  COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY
43:                  CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF),
44:                  OR OTHER SIMILAR COSTS.
45:                   *****************************************************************************/
46:                  // DOM-IGNORE-END
47:                  
48:                  #ifndef __HTTPPRINT_H_
49:                  #define __HTTPPRINT_H_
50:                  
51:                  /*****************************************************************************
52:                   * SECTION:  Includes
53:                   *****************************************************************************/
54:                  #include "tcpip/tcpip.h"
55:                  
56:                  /*****************************************************************************
57:                   * SECTION:  Global Variables
58:                   *****************************************************************************/
59:                  #if defined(STACK_USE_HTTP2_SERVER)
60:                  
61:                  extern HTTP_STUB httpStubs[MAX_HTTP_CONNECTIONS];
62:                  extern uint8_t curHTTPID;
63:                  
64:                  /*****************************************************************************
65:                   * SECTION:  Generated Function Prototypes
66:                   *****************************************************************************/
67:                  void HTTPPrint(uint32_t callbackID);
68:                  void HTTPPrint_builddate(void);
69:                  void HTTPPrint_uptime(void);
70:                  void HTTPPrint_feedback(void);
71:                  
72:                  /*****************************************************************************
73:                   * FUNCTION: HTTPPrint
74:                   *
75:                   * RETURNS:  None
76:                   *
77:                   * PARAMS:   callbackID
78:                   *****************************************************************************/
79:                  void HTTPPrint(uint32_t callbackID)
80:                  {
9D008424  27BDFFE8   ADDIU SP, SP, -24
9D008428  AFBF0014   SW RA, 20(SP)
9D00842C  AFBE0010   SW S8, 16(SP)
9D008430  03A0F021   ADDU S8, SP, ZERO
9D008434  AFC40018   SW A0, 24(S8)
81:                     switch(callbackID)
9D008438  8FC20018   LW V0, 24(S8)
9D00843C  24030001   ADDIU V1, ZERO, 1
9D008440  1043000D   BEQ V0, V1, 0x9D008478
9D008444  00000000   NOP
9D008448  2C430001   SLTIU V1, V0, 1
9D00844C  14600006   BNE V1, ZERO, 0x9D008468
9D008450  00000000   NOP
9D008454  24030002   ADDIU V1, ZERO, 2
9D008458  1043000B   BEQ V0, V1, 0x9D008488
9D00845C  00000000   NOP
9D008460  0B402126   J 0x9D008498
9D008464  00000000   NOP
82:                     {
83:                          case 0x00000000:
84:                  			HTTPPrint_builddate();
9D008468  0F404C84   JAL HTTPPrint_builddate
9D00846C  00000000   NOP
85:                  			break;
9D008470  0B402135   J 0x9D0084D4
9D008474  00000000   NOP
86:                          case 0x00000001:
87:                  			HTTPPrint_uptime();
9D008478  0F404CCC   JAL HTTPPrint_uptime
9D00847C  00000000   NOP
88:                  			break;
9D008480  0B402135   J 0x9D0084D4
9D008484  00000000   NOP
89:                          case 0x00000002:
90:                  			HTTPPrint_feedback();
9D008488  0F404DB4   JAL HTTPPrint_feedback
9D00848C  00000000   NOP
91:                  			break;
9D008490  0B402135   J 0x9D0084D4
9D008494  00000000   NOP
92:                         default:
93:                             // Output notification for undefined values
94:                             TCPPutROMArray(sktHTTP, (ROM uint8_t*)"!DEF", 4);
9D008498  93828159   LBU V0, -32423(GP)
9D00849C  00401821   ADDU V1, V0, ZERO
9D0084A0  3C02A000   LUI V0, -24576
9D0084A4  000318C0   SLL V1, V1, 3
9D0084A8  244208C8   ADDIU V0, V0, 2248
9D0084AC  00621021   ADDU V0, V1, V0
9D0084B0  90420004   LBU V0, 4(V0)
9D0084B4  00401821   ADDU V1, V0, ZERO
9D0084B8  3C029D01   LUI V0, -25343
9D0084BC  24425640   ADDIU V0, V0, 22080
9D0084C0  00602021   ADDU A0, V1, ZERO
9D0084C4  00402821   ADDU A1, V0, ZERO
9D0084C8  24060004   ADDIU A2, ZERO, 4
9D0084CC  0F4004D0   JAL TCPPutArray
9D0084D0  00000000   NOP
95:                     }
96:                  
97:                     return;
98:                  }
9D0084D4  03C0E821   ADDU SP, S8, ZERO
9D0084D8  8FBF0014   LW RA, 20(SP)
9D0084DC  8FBE0010   LW S8, 16(SP)
9D0084E0  27BD0018   ADDIU SP, SP, 24
9D0084E4  03E00008   JR RA
9D0084E8  00000000   NOP
99:                  
100:                 void HTTPPrint_(void)
101:                 {
9D0084EC  27BDFFE8   ADDIU SP, SP, -24
9D0084F0  AFBF0014   SW RA, 20(SP)
9D0084F4  AFBE0010   SW S8, 16(SP)
9D0084F8  03A0F021   ADDU S8, SP, ZERO
102:                    TCPPut(sktHTTP, '~');
9D0084FC  93828159   LBU V0, -32423(GP)
9D008500  00401821   ADDU V1, V0, ZERO
9D008504  3C02A000   LUI V0, -24576
9D008508  000318C0   SLL V1, V1, 3
9D00850C  244208C8   ADDIU V0, V0, 2248
9D008510  00621021   ADDU V0, V1, V0
9D008514  90420004   LBU V0, 4(V0)
9D008518  00402021   ADDU A0, V0, ZERO
9D00851C  2405007E   ADDIU A1, ZERO, 126
9D008520  0F4003F1   JAL TCPPut
9D008524  00000000   NOP
103:                    return;
104:                 }
9D008528  03C0E821   ADDU SP, S8, ZERO
9D00852C  8FBF0014   LW RA, 20(SP)
9D008530  8FBE0010   LW S8, 16(SP)
9D008534  27BD0018   ADDIU SP, SP, 24
9D008538  03E00008   JR RA
9D00853C  00000000   NOP
105:                 
106:                 #endif /*STACK_USE_HTTP2_SERVER*/
107:                 
108:                 #endif /*__HTTPPRINT_H_*/
---  c:/program files (x86)/microchip/xc32/v1.34/pic32mx/include/peripheral/eth.h  ----------------------
1:                   /*******************************************************************************
2:                     Ethernet Library Interface Definition
3:                   
4:                     Summary:
5:                       This file contains the Application Program Interface (API) definition  for
6:                       the Ethernet peripheral library.
7:                   
8:                     Description:
9:                       This library provides a low-level abstraction of the Ethernet module
10:                      on Microchip PIC32MX family microcontrollers with a convenient C language
11:                      interface.  It can be used to simplify low-level access to the module
12:                      without the necessity of interacting directly with the module's registers,
13:                      thus hiding differences from one microcontroller variant to another.
14:                  *******************************************************************************/
15:                  //DOM-IGNORE-BEGIN
16:                  /*******************************************************************************
17:                  FileName:       eth.h
18:                  Processor:      PIC32MX
19:                  Compiler:       Microchip MPLAB XC32 v1.00 or higher
20:                  
21:                  Copyright  2008-2009 released Microchip Technology Inc.  All rights
22:                  reserved.
23:                  
24:                  Microchip licenses to you the right to use, modify, copy and distribute
25:                  Software only when embedded on a Microchip microcontroller or digital signal
26:                  controller that is integrated into your product or third party product
27:                  (pursuant to the sublicense terms in the accompanying license agreement).
28:                  
29:                  You should refer to the license agreement accompanying this Software for
30:                  additional information regarding your rights and obligations.
31:                  
32:                  SOFTWARE AND DOCUMENTATION ARE PROVIDED ?AS IS? WITHOUT WARRANTY OF ANY KIND,
33:                  EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
34:                  MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
35:                  IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
36:                  CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
37:                  OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
38:                  INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
39:                  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
40:                  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
41:                  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
42:                  *******************************************************************************/
43:                  //DOM-IGNORE-END
44:                  
45:                  
46:                  #ifndef _ETH_H_
47:                  #define _ETH_H_
48:                  
49:                  #include <stdlib.h>
50:                  #include <xc.h>
51:                  
52:                  /*
53:                  *  WARNING: All the Peripheral Library (PLIB) functions, including those in this file,
54:                  *  will be removed from future releases of MPLAB XC32 C/C++ Compiler.
55:                  *  Please refer to the MPLAB Harmony Libraries for new projects.  For legacy support,
56:                  *  these PLIB Libraries will be available for download from: www.microchip.com/pic32_peripheral_lib
57:                  */
58:                  #ifndef _SUPPRESS_PLIB_WARNING
59:                    #warning The PLIB functions and macros in this file will be removed from the MPLAB XC32 C/C++ Compiler in future releases
60:                  #endif
61:                  
62:                  
63:                  #ifdef _ETH // The Ethernet device is present
64:                  
65:                  
66:                  // *****************************************************************************
67:                  // *****************************************************************************
68:                  // Section: Constants & Data Types
69:                  // *****************************************************************************
70:                  // *****************************************************************************
71:                  
72:                  // *****************************************************************************
73:                  /* Ethernet Operation Result Codes
74:                  
75:                    Summary:
76:                      Defines the possible results of Ethernet operations that can succeed or fail
77:                  
78:                    Description:
79:                      This enumeration defines the possible results of any of the Ethernet library operations
80:                      that have the possibilty of failing.  This result should be checked to
81:                      ensure that the operation achieved the desired result.
82:                  */
83:                  typedef enum
84:                  {
85:                      // Everything ok
86:                      ETH_RES_OK,
87:                  
88:                      // Ethernet RX, TX, acknowledge packets:
89:                  
90:                      // No such packet exist
91:                      ETH_RES_NO_PACKET,
92:                  
93:                      // Packet is queued (not transmitted or received and not processed)
94:                      ETH_RES_PACKET_QUEUED,
95:                  
96:                      // Ethernet buffers, descriptors errors:
97:                  
98:                      // Some memory allocation failed
99:                      ETH_RES_OUT_OF_MEMORY,
100:                 
101:                     // Not enough descriptors available
102:                     ETH_RES_NO_DESCRIPTORS,
103:                 
104:                     // We don't support user space buffers.
105:                     ETH_RES_USPACE_ERR,
106:                 
107:                     // The size of the receive buffers too small
108:                     ETH_RES_RX_SIZE_ERR,
109:                 
110:                     // A received packet spans more buffers/descriptors than supplied
111:                     ETH_RES_RX_PKT_SPLIT_ERR,
112:                 
113:                     // Negotiation errors:
114:                 
115:                     // No negotiation support
116:                     ETH_RES_NEGOTIATION_UNABLE,
117:                 
118:                     // No negotiation active
119:                     ETH_RES_NEGOTIATION_INACTIVE,
120:                 
121:                     // Negotiation not started yet
122:                     ETH_RES_NEGOTIATION_NOT_STARTED,
123:                 
124:                     // Negotiation active
125:                     ETH_RES_NEGOTIATION_ACTIVE,
126:                 
127:                     // Link down after negotiation, negotiation failed
128:                     ETH_RES_NEGOTIATION_LINKDOWN,
129:                 
130:                     // PHY errors:
131:                 
132:                     // No Phy was detected or it failed to respond to reset command
133:                     ETH_RES_DTCT_ERR,
134:                 
135:                     // No match between the capabilities: the Phy supported and the open
136:                     // requested ones
137:                     ETH_RES_CPBL_ERR,
138:                 
139:                     // Hardware configuration doesn't match the requested open mode
140:                     ETH_RES_CFG_ERR,
141:                 
142:                 } eEthRes;
143:                 
144:                 
145:                 // *****************************************************************************
146:                 /* Ethernet Open Configuration Settings
147:                 
148:                   Summary:
149:                     Supported open configuration flags for the Ethernet module (EthMACOpen).
150:                 
151:                   Description:
152:                     This enumeration defines the various configuration options for the Ethernet
153:                     module.  These values can be OR-ed together to create a configuration mask
154:                     passed to the EthMACOpen routine.
155:                 
156:                   Remarks:
157:                     When Auto negotiation is specified:
158:                         - If multiple capability flags are set (ETH_OPEN_FDUPLEX,
159:                           ETH_OPEN_HDUPLEX, ETH_OPEN_100, ETH_OPEN_10 ) they are all advertised
160:                           as this link side capabilities.
161:                         - If no setting is passed, the lowest one is taken, i.e.
162:                           ETH_OPEN_HDUPLEX and ETH_OPEN_10.
163:                         - Auto-MDIX requires Auto-Negotiation; ETH_OPEN_MDIX_NORM or
164:                           ETH_OPEN_MDIX_SWAP setting irrelevant.
165:                 
166:                     When No Auto negotiation is specified:
167:                         - If multiple settings, the highest priority setting is taken, i.e.
168:                           ETH_OPEN_FDUPLEX over ETH_OPEN_HDUPLEX and ETH_OPEN_100 over
169:                           ETH_OPEN_10.
170:                         - If no setting, the lowest setting is taken, i.e. ETH_OPEN_HDUPLEX and
171:                           ETH_OPEN_10.
172:                         - The MDIX is set based on the ETH_OPEN_MDIX_NORM/ETH_OPEN_MDIX_SWAP
173:                           setting.
174:                 */
175:                 typedef enum
176:                 {
177:                     // Link capabilities flags:
178:                 
179:                     // Use auto negotiation. set the following flags to specify your choices
180:                     ETH_OPEN_AUTO
181:                         /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
182:                 
183:                     // Use full duplex or full duplex negotiation capability needed
184:                     ETH_OPEN_FDUPLEX
185:                         /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
186:                 
187:                     // Use half duplex or half duplex negotiation capability needed
188:                     ETH_OPEN_HDUPLEX
189:                         /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
190:                 
191:                     // Use 100MBps or 100MBps negotiation capability needed
192:                     ETH_OPEN_100
193:                         /*DOM-IGNORE-BEGIN*/ = 0x8 /*DOM-IGNORE-END*/,
194:                 
195:                     // Use 10MBps or 10MBps negotiation capability needed
196:                     ETH_OPEN_10
197:                         /*DOM-IGNORE-BEGIN*/ = 0x10 /*DOM-IGNORE-END*/,
198:                 
199:                     // MAC flags:
200:                 
201:                     // Allow huge packets RX/TX
202:                     ETH_OPEN_HUGE_PKTS
203:                         /*DOM-IGNORE-BEGIN*/ = 0x20 /*DOM-IGNORE-END*/,
204:                 
205:                     // Loopbacked at the MAC level
206:                     ETH_OPEN_MAC_LOOPBACK
207:                         /*DOM-IGNORE-BEGIN*/ = 0x40 /*DOM-IGNORE-END*/,
208:                 
209:                     // When PHY is loopback-ed, negotiation will be disabled!
210:                     ETH_OPEN_PHY_LOOPBACK
211:                         /*DOM-IGNORE-BEGIN*/ = 0x80 /*DOM-IGNORE-END*/,
212:                 
213:                     // MDIX flags:
214:                 
215:                     // Use Auto MDIX
216:                     ETH_OPEN_MDIX_AUTO
217:                         /*DOM-IGNORE-BEGIN*/ = 0x100 /*DOM-IGNORE-END*/,
218:                 
219:                     // Use normal MDIX when Auto MDIX disabled
220:                     ETH_OPEN_MDIX_NORM
221:                         /*DOM-IGNORE-BEGIN*/ = 0x0 /*DOM-IGNORE-END*/,
222:                 
223:                     // Use swapped MDIX when Auto MDIX disabled
224:                     ETH_OPEN_MDIX_SWAP
225:                         /*DOM-IGNORE-BEGIN*/ = 0x200 /*DOM-IGNORE-END*/,
226:                 
227:                     // MII/RMII flags:
228:                 
229:                     // RMII connection
230:                     ETH_OPEN_RMII
231:                         /*DOM-IGNORE-BEGIN*/ = 0x400 /*DOM-IGNORE-END*/,
232:                 
233:                     // MII connection
234:                     ETH_OPEN_MII
235:                         /*DOM-IGNORE-BEGIN*/ = 0x000 /*DOM-IGNORE-END*/,
236:                 
237:                 
238:                     // All capabilities default
239:                     ETH_OPEN_DEFAULT = (ETH_OPEN_AUTO|ETH_OPEN_FDUPLEX|ETH_OPEN_HDUPLEX|
240:                                         ETH_OPEN_100|ETH_OPEN_10|ETH_OPEN_MDIX_AUTO)
241:                 
242:                 } eEthOpenFlags;
243:                 
244:                 
245:                 // *****************************************************************************
246:                 /* Ethernet Link Status Codes
247:                 
248:                   Summary:
249:                     Defines the possible status flags of Ethernet link.
250:                 
251:                   Description:
252:                     This enumeration defines the flags describing the status of the Ethernet
253:                     link.
254:                 
255:                   Remarks:
256:                     Multiple flags can be set
257:                 */
258:                 typedef enum
259:                 {
260:                     // No connection to the LinkPartner
261:                     ETH_LINK_ST_DOWN
262:                         /*DOM-IGNORE-BEGIN*/ = 0x0 /*DOM-IGNORE-END*/,
263:                 
264:                     // Link is up
265:                     ETH_LINK_ST_UP
266:                         /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
267:                 
268:                     // LP non negotiation able
269:                     ETH_LINK_ST_LP_NEG_UNABLE
270:                         /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
271:                 
272:                     // LP fault during negotiation
273:                     ETH_LINK_ST_REMOTE_FAULT
274:                         /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
275:                 
276:                     // Parallel Detection Fault encountered (when ETH_LINK_ST_LP_NEG_UNABLE)
277:                     ETH_LINK_ST_PDF
278:                         /*DOM-IGNORE-BEGIN*/ = 0x8 /*DOM-IGNORE-END*/,
279:                 
280:                     // LP supports symmetric pause
281:                     ETH_LINK_ST_LP_PAUSE
282:                         /*DOM-IGNORE-BEGIN*/ = 0x10 /*DOM-IGNORE-END*/,
283:                 
284:                     // LP supports asymmetric TX/RX pause operation
285:                     ETH_LINK_ST_LP_ASM_DIR
286:                         /*DOM-IGNORE-BEGIN*/ = 0x20 /*DOM-IGNORE-END*/,
287:                 
288:                     // LP not there
289:                     ETH_LINK_ST_NEG_TMO
290:                         /*DOM-IGNORE-BEGIN*/ = 0x1000 /*DOM-IGNORE-END*/,
291:                 
292:                     // An unexpected fatal error occurred during the negotiation
293:                     ETH_LINK_ST_NEG_FATAL_ERR
294:                         /*DOM-IGNORE-BEGIN*/ = 0x2000 /*DOM-IGNORE-END*/,
295:                 
296:                 } eEthLinkStat;
297:                 
298:                 
299:                 // *****************************************************************************
300:                 /* Ethernet Controller Status Codes
301:                 
302:                   Summary:
303:                     Defines the possible status codes of Ethernet controller.
304:                 
305:                   Description:
306:                     This enumeration defines the flags describing the status of the Ethernet
307:                     controller.
308:                 */
309:                 typedef enum
310:                 {
311:                     // A packet is currently received
312:                     ETH_ST_RXBUSY   /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
313:                 
314:                     // A packet is currently transmitted
315:                     ETH_ST_TXBUSY   /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
316:                 
317:                     // Module is on or completing a transaction
318:                     ETH_ST_BUSY     /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
319:                 
320:                 } eEthStat;
321:                 
322:                 
323:                 // *****************************************************************************
324:                 /* Ethernet Module Disable
325:                 
326:                   Summary:
327:                     Defines the possible disable codes of Ethernet controller "EthClose" call.
328:                 
329:                   Description:
330:                     This enumeration defines the close capabilities of the Ethernet module.
331:                 */
332:                 typedef enum
333:                 {
334:                     // Wait for the current TX/RX op to finish
335:                     ETH_CLOSE_GRACEFUL  /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
336:                 
337:                     // Default close options
338:                     ETH_CLOSE_DEFAULT = (0)
339:                 
340:                 } eEthCloseFlags;
341:                 
342:                 
343:                 // *****************************************************************************
344:                 /* Ethernet MAC Pause Types
345:                 
346:                   Summary:
347:                     Defines the possible Ethernet MAC pause types.
348:                 
349:                   Description:
350:                     This enumeration defines the Ethernet MAC's pause capabilities.
351:                 */
352:                 typedef enum
353:                 {
354:                     // No PAUSE capabilities
355:                     ETH_MAC_PAUSE_TYPE_NONE     /*DOM-IGNORE-BEGIN*/ = 0x0 /*DOM-IGNORE-END*/,
356:                 
357:                     // Supports symmetric PAUSE
358:                     ETH_MAC_PAUSE_TYPE_PAUSE    /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
359:                 
360:                     // Supports ASM_DIR
361:                     ETH_MAC_PAUSE_TYPE_ASM_DIR  /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
362:                 
363:                     // The previous two values converted to TX/RX capabilities:
364:                 
365:                     // Enable MAC TX pause support
366:                     ETH_MAC_PAUSE_TYPE_EN_TX    /*DOM-IGNORE-BEGIN*/ = 0x4 /*DOM-IGNORE-END*/,
367:                 
368:                     // Enable MAC RX pause support
369:                     ETH_MAC_PAUSE_TYPE_EN_RX    /*DOM-IGNORE-BEGIN*/ = 0x8 /*DOM-IGNORE-END*/,
370:                 
371:                     // All types of pause
372:                     ETH_MAC_PAUSE_ALL       = (ETH_MAC_PAUSE_TYPE_PAUSE|ETH_MAC_PAUSE_TYPE_ASM_DIR|
373:                                            ETH_MAC_PAUSE_TYPE_EN_TX|ETH_MAC_PAUSE_TYPE_EN_RX),
374:                 
375:                     // All pause capabilities our MAC supports
376:                     ETH_MAC_PAUSE_CPBL_MASK = ETH_MAC_PAUSE_ALL
377:                 
378:                 } eEthMacPauseType;
379:                 
380:                 
381:                 // *****************************************************************************
382:                 // *****************************************************************************
383:                 // Section: Ethernet Peripheral Library Interface Routines
384:                 // *****************************************************************************
385:                 // *****************************************************************************
386:                 
387:                 // Section:  Open and Configuration Functions
388:                 
389:                 /*******************************************************************************
390:                   Function:
391:                     eEthRes EthInit ( void )
392:                 
393:                   Summary:
394:                     Ethernet initialization routine
395:                 
396:                   Description:
397:                     This function performs the initialization of the Ethernet Controller.
398:                 
399:                   Precondition:
400:                     None.
401:                 
402:                   Parameters:
403:                     None.
404:                 
405:                   Returns:
406:                     ETH_RES_OK
407:                 
408:                   Example:
409:                     <code>
410:                     EthInit();
411:                     </code>
412:                 
413:                   Remarks:
414:                     This function should be called before the EthMACOpen() routine.
415:                  *****************************************************************************/
416:                 
417:                 eEthRes EthInit ( void );
418:                 
419:                 
420:                 /*******************************************************************************
421:                   Function:
422:                     eEthRes EthClose( eEthCloseFlags cFlags )
423:                 
424:                   Summary:
425:                     Aborts any transactions and disables the Ethernet controller
426:                 
427:                   Description:
428:                     This function performs an abort of any current Ethernet transactions, disables
429:                     the Ethernet controller and interrupts.  It should be called after the PHY
430:                     close/reset procedure.
431:                 
432:                   Precondition:
433:                     None.
434:                 
435:                   Parameters:
436:                     cFlags      - closing flags
437:                 
438:                   Returns:
439:                     ETH_RES_OK
440:                 
441:                   Example:
442:                     <code>
443:                     EthClose(ETH_CLOSE_DEFAULT);
444:                     </code>
445:                 
446:                   Remarks:
447:                     It does not free any allocated memory.
448:                  *****************************************************************************/
449:                 
450:                 eEthRes EthClose ( eEthCloseFlags cFlags );
451:                 
452:                 
453:                 /*******************************************************************************
454:                   Function:
455:                     void EthMACOpen( eEthOpenFlags oFlags, eEthMacPauseType pauseType )
456:                 
457:                   Summary:
458:                     Initializes and configures the Ethernet MAC.
459:                 
460:                   Description:
461:                     This function performs the open and configuration of the Ethernet MAC.  It needs
462:                     to be called after the EthInit() was called and the PHY initialized.
463:                 
464:                 
465:                   Precondition:
466:                     EthInit must have been called.
467:                 
468:                   Parameters:
469:                     oFlags      - Open flags
470:                     pauseType   - Pause type to be supported by the MAC
471:                 
472:                 
473:                   Returns:
474:                     Ethernet operation result code.
475:                 
476:                   Example:
477:                     <code>
478:                     // Enable loopback at the MAC level
479:                     oFlags    = ETH_OPEN_FDUPLEX|ETH_OPEN_100|ETH_OPEN_HUGE_PKTS|ETH_OPEN_MAC_LOOPBACK;
480:                     // Use both TX and RX pause type for Full Duplex
481:                     pauseType = ETH_MAC_PAUSE_ALL;
482:                 
483:                     // Start the initialization sequence
484:                     EthInit();
485:                 
486:                     // Open and configure the MAC.
487:                     //
488:                     // Since we're not connected to an external PHY there's no negotiation
489:                     // going on and we know all our opening flags
490:                     EthMACOpen(oFlags, pauseType);
491:                     </code>
492:                 
493:                   Remarks:
494:                     If no auto-negotiation is performed, the EthMACOpen() could be called
495:                     immediately after EthInit() and PHY initialization.  Otherwise the open
496:                     flags and the pause type should be the ones obtained as a result of the
497:                     PHY negotiation procedure!
498:                  *****************************************************************************/
499:                 
500:                 void EthMACOpen ( eEthOpenFlags oFlags, eEthMacPauseType pauseType );
501:                 
502:                 
503:                 /*******************************************************************************
504:                   Function:
505:                     void EthMACSetAddress ( unsigned char bAddress[6] )
506:                 
507:                   Summary:
508:                     Sets the MAC address
509:                 
510:                   Description:
511:                     This function sets the MAC address.
512:                 
513:                   Precondition:
514:                     None.
515:                 
516:                   Parameters:
517:                     bAddress    - standard MAC address, 6 bytes, Network order!
518:                 
519:                   Returns:
520:                     None.
521:                 
522:                   Example:
523:                     <code>
524:                     unsigned char hostAddress[6]= { 0x00, 0x04, 0xa3, 0x00, 0x00, 0x02};
525:                 
526:                     EthMACSetAddress(hostAddress);
527:                     </code>
528:                 
529:                   Remarks:
530:                     The default MAC address is loaded by the device at reset from the
531:                     factory pre-programmed unique MAC address value.
532:                  *****************************************************************************/
533:                 
534:                 void EthMACSetAddress ( unsigned char bAddress[6] );
535:                 
536:                 
537:                 /*******************************************************************************
538:                   Function:
539:                     void EthMACGetAddress ( unsigned char bAddress[6] )
540:                 
541:                   Summary:
542:                     Returns the current MAC address
543:                 
544:                   Description:
545:                     This function returns the current MAC address.
546:                 
547:                   Precondition:
548:                     None.
549:                 
550:                   Parameters:
551:                     bAddress    - Address to store a standard MAC address, 6 bytes, Network
552:                                   order!
553:                 
554:                   Returns:
555:                     None.
556:                 
557:                   Example:
558:                     <code>
559:                     unsigned char currentMacAddress;
560:                 
561:                     EthMACGetAddress(&currentMacAddress);
562:                     </code>
563:                 
564:                   Remarks:
565:                  *****************************************************************************/
566:                 
567:                 void EthMACGetAddress ( unsigned char bAddress[6] );
568:                 
569:                 
570:                 /*******************************************************************************
571:                   Function:
572:                     void EthMACSetMaxFrame ( unsigned short maxFrmSz )
573:                 
574:                   Summary:
575:                     Sets the MAC maximum frame size
576:                 
577:                   Description:
578:                     This function sets the MAC maximum frame size.
579:                 
580:                   Precondition:
581:                     Should be called after EthInit().
582:                 
583:                   Parameters:
584:                     maxFrmSz    - Maximum frame for the MAC to transmit or receive.
585:                 
586:                   Returns:
587:                     None.
588:                 
589:                   Example:
590:                     <code>
591:                     EthMACSetMaxFrame(0x800);
592:                     </code>
593:                 
594:                   Remarks:
595:                     The default MAC frame size (0x600) is set by the EthInit() call.
596:                  *****************************************************************************/
597:                 
598:                 void EthMACSetMaxFrame ( unsigned short maxFrmSz );
599:                 
600:                 
601:                 // Section: Descriptors and Buffers Functions
602:                 
603:                 
604:                 // *****************************************************************************
605:                 /* Ethernet Descriptor Allocation Function Pointer
606:                 
607:                   Function:
608:                     void* <FunctionName> ( size_t nitems, size_t size, void* param )
609:                 
610:                   Summary:
611:                     Pointer to a function that allocates the requested memory and returns a
612:                     pointer to it.
613:                 
614:                   Description:
615:                     Pointer to a function that allocates enough memory for "nitems" each of
616:                     "size" bytes in length (total memory requested is nitems*size).
617:                     The allocated space should be initialized to zero.
618:                 
619:                   Precondition:
620:                     None
621:                 
622:                   Parameters:
623:                     nitems      - number of items to be allocated
624:                     size        - size of each item, in bytes
625:                     param       - extra parameter that will be used by the function call
626:                 
627:                   Returns:
628:                     On success  - A pointer to the requested space.
629:                     On failure  = A null pointer.
630:                 
631:                   Remarks:
632:                     This function will be invoked for allocation of descriptors only.
633:                     Therefore, the size parameter will be the one returned by
634:                     EthDescriptorsGetSize();
635:                 */
636:                 
637:                 typedef void* ( *pEthDcptAlloc )( size_t nitems, size_t size, void* param );
638:                 
639:                 
640:                 // *****************************************************************************
641:                 /* Ethernet Descriptor Free Function
642:                 
643:                   Function:
644:                     void <FunctionName> ( void* ptr, void* param )
645:                 
646:                   Summary:
647:                     Pointer to a function that deallocates the memory previously allocated by a
648:                     pEthDcptAlloc function.
649:                 
650:                   Description:
651:                     Pointer to a function that deallocates the memory previously allocated by a
652:                     pEthDcptAlloc function.
653:                 
654:                   Precondition:
655:                     The pEthDcptAlloc would have been previously called.
656:                 
657:                   Parameters:
658:                     ptr         - Points to the space that was previously allocated with a
659:                                   pEthDcptAlloc function.
660:                     param       - extra parameter that will be used by the function call
661:                 
662:                   Returns:
663:                     None.
664:                 
665:                   Remarks:
666:                     None.
667:                 */
668:                 
669:                 typedef void ( *pEthDcptFree ) ( void* ptr, void* param );
670:                 
671:                 
672:                 // *****************************************************************************
673:                 /* Ethernet Descriptor Types
674:                 
675:                   Summary:
676:                     Enumeration defining the Ethernet descriptor types.
677:                 
678:                   Description:
679:                     This enumeration defines the Ethernet descriptor types.
680:                 
681:                   Remarks:
682:                     Most descriptor operations support just one type, but multiple flags can be
683:                     set.
684:                 */
685:                 
686:                 typedef enum
687:                 {
688:                     // TX descriptor
689:                     ETH_DCPT_TYPE_RX    /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
690:                 
691:                     // RX descriptor
692:                     ETH_DCPT_TYPE_TX    /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
693:                 
694:                     // All (both) types.  Some descriptor operations support multiple types.
695:                     ETH_DCPT_TYPE_ALL   = (ETH_DCPT_TYPE_RX|ETH_DCPT_TYPE_TX)
696:                 
697:                 }eEthDcptType;      // descriptor types
698:                 
699:                 
700:                 
701:                 // *****************************************************************************
702:                 /* Ethernet Descriptor Query Structure
703:                 
704:                   Summary:
705:                     Structure used for a query of the Ethernet descriptors
706:                 
707:                   Description:
708:                     This structure holds a snapshot of the current status of RX/TX descriptors.
709:                 */
710:                 
711:                 typedef struct
712:                 {
713:                     // The number of idle (unused) descriptors available in the TX/RX pool of descriptors.
714:                     int dIdle;
715:                 
716:                     // The number of descriptors not acknowledged
717:                     // Provides the number of descriptors that have valid transmitted/received packets
718:                     // but haven't been acknowledged
719:                     int dUnack;
720:                 
721:                     // The number of queued descriptors
722:                     // Provides the number of descriptors that are just
723:                     // queued for transmission (but not transmitted yet) or
724:                     // receiving (but without a valid load).
725:                     int dQueued;
726:                 
727:                 }sEthDcptQuery;
728:                 
729:                 
730:                 // *****************************************************************************
731:                 /*  Buffer Flags
732:                 
733:                   Summary:
734:                     Flags for buffer attributes.
735:                 
736:                   Description:
737:                     Some buffers can have special attributes, as defined by this enumeration.
738:                 */
739:                 
740:                 typedef enum
741:                 {
742:                     // The receive buffer is sticky, going to be used across multiple RX
743:                     // operations once it's acknowledged
744:                     ETH_BUFF_FLAG_RX_STICKY /*DOM-IGNORE-BEGIN*/ = 0x1 /*DOM-IGNORE-END*/,
745:                 
746:                     // The receive descriptor associated to this buffer should not be
747:                     // automatically acknowledged when EthRxAcknowledgeBuffer/EthRxAcknowledgePacket
748:                     // is called.
749:                     // User is responsible for specifically calling EthAckRxDcpt() to acknowledge
750:                     // the RX descriptor
751:                     ETH_BUFF_FLAG_RX_UNACK /*DOM-IGNORE-BEGIN*/ = 0x2 /*DOM-IGNORE-END*/,
752:                 } eEthBuffFlags;
753:                 
754:                 
755:                 /*******************************************************************************
756:                   Function:
757:                     int EthDescriptorsPoolAdd ( int nDescriptors, eEthDcptType dType,
758:                                             pEthDcptAlloc fAlloc, void* fParam )
759:                 
760:                   Summary:
761:                     Adds transmit & receive descriptors to the pool.
762:                 
763:                   Description:
764:                     This function adds the specified number of transmit/receive descriptors to
765:                     the pool of descriptors.  These descriptors are used whenever a new
766:                     transmission or a reception is initiated.  The needed memory per descriptor
767:                     is returned by EthDescriptorsGetSize.   Descriptors can be freed with
768:                     EthDescriptorsPoolRemove.
769:                 
770:                   Precondition:
771:                     EthInit should have been called.
772:                 
773:                   Parameters:
774:                     nDescriptors    - Number of descriptors to be added
775:                 
776:                     dType           - TX/RX descriptors requested
777:                 
778:                     fAlloc          - Function to be called to allocate the needed memory
779:                 
780:                     fParam          - parameter to be used when fAlloc is called
781:                 
782:                   Returns:
783:                     The number of descriptors successfully created.
784:                 
785:                   Example:
786:                     <code>
787:                     if( EthDescriptorsPoolAdd(txDcptNo, ETH_DCPT_TYPE_TX, fMemAlloc, &myInstanceData) != txDcptNo )
788:                     {
789:                         // Handle allocation error
790:                     }
791:                     </code>
792:                 
793:                   Remarks:
794:                     The number of created descriptors is different from the number of
795:                     requested ones only if the memory allocation failed.
796:                 
797:                     The first time the specific pool is initialized an extra descriptor is added to the pool
798:                     so that the actual memory requested will be (nDescriptors+1)*EthDescriptorsGetSize().
799:                 
800:                     fAlloc should not be NULL.
801:                 
802:                     The complete clean-up is done by EthDescriptorsPoolCleanUp();
803:                 
804:                     ETH_DCPT_TYPE_ALL use is invalid. A proper descriptor type (RX or TX) has
805:                     to be used.
806:                  *****************************************************************************/
807:                 
808:                 int EthDescriptorsPoolAdd ( int nDescriptors, eEthDcptType dType, pEthDcptAlloc fAlloc, void* fParam );
809:                 
810:                 
811:                 /*******************************************************************************
812:                   Function:
813:                     int EthDescriptorsPoolRemove ( int nDescriptors, eEthDcptType dType,
814:                                                pEthDcptFree fFree, void* fParam )
815:                 
816:                   Summary:
817:                     Tries to remove the specified number of descriptors from the pool.
818:                 
819:                   Description:
820:                     This function tries to remove the specified number of descriptors from the
821:                     pool of transmit/receive descriptors.  These descriptors that are NOT used
822:                     at the time of call can be freed (i.e. the TX descriptors not queued for a
823:                     transmission or the not busy RX descriptors).
824:                 
825:                   Precondition:
826:                     EthInit should have been called.
827:                 
828:                   Parameters:
829:                     nDescriptors    - Number of descriptors to be removed
830:                     dType           - TX/RX descriptors requested
831:                     fFree           - Function to release the the memory
832:                     fParam          - parameter to be used when fFree is called
833:                 
834:                 
835:                   Returns:
836:                     The number of descriptors removed.
837:                 
838:                   Example:
839:                     <code>
840:                     if ( EthDescriptorsPoolRemove(txDcptNo, ETH_DCPT_TYPE_TX, ffree, 0) != txDcptNo)
841:                     {
842:                         // Handle de-allocation error.
843:                     }
844:                     </code>
845:                 
846:                   Remarks:
847:                     If fFree is NULL then the descriptors are removed from the specified pool but no de-allocation
848:                     function is called.
849:                     The allocation/deallocation memory functions should be consistent.
850:                 
851:                     The complete clean-up is done by EthDescriptorsPoolCleanUp.
852:                 
853:                     ETH_DCPT_TYPE_ALL use is invalid. A proper descriptor type (RX or TX) has
854:                     to be used.
855:                  *****************************************************************************/
856:                 
857:                 int EthDescriptorsPoolRemove ( int nDescriptors, eEthDcptType dType, pEthDcptFree fFree, void* fParam );
858:                 
859:                 
860:                 /*******************************************************************************
861:                   Function:
862:                     void EthDescriptorsPoolCleanUp ( eEthDcptType dType, pEthDcptFree fFree, void* fParam )
863:                 
864:                   Summary:
865:                     Removes all the specified descriptors from the pool.
866:                 
867:                   Description:
868:                     This function performs descriptors clean-up and removes all the specified
869:                     descriptors from the pool of transmit/receive descriptors.
870:                 
871:                   Precondition:
872:                     EthClose should have been called.
873:                 
874:                   Parameters:
875:                     dType        - TX/RX/All descriptors requested
876:                     fFree        - Function to release the the memory
877:                     fParam       - parameter to be used when fFree is called
878:                 
879:                   Returns:
880:                     None.
881:                 
882:                   Example:
883:                     <code>
884:                     EthDescriptorsPoolCleanUp(ETH_DCPT_TYPE_ALL, fFree, &myInstanceData);
885:                     </code>
886:                 
887:                   Remarks:
888:                     If fFree is NULL then the descriptors are removed from the pools but no de-allocation
889:                     function is called.
890:                     The allocation/deallocation memory functions should be consistent.
891:                 
892:                     It does not free the memory allocated for the application supplied "sticky"
893:                     buffers.  It is the calling application responsibility.
894:                 
895:                     EthClose should have been called or no TX/RX activity should be enabled at
896:                     the time this function is called.
897:                 
898:                     If ETH_DCPT_TYPE_ALL is supplied the function will perform the clean-up of
899:                     both types of descriptors.
900:                  *****************************************************************************/
901:                 
902:                 void EthDescriptorsPoolCleanUp ( eEthDcptType dType, pEthDcptFree fFree, void* fParam );
903:                 
904:                 
905:                 /*******************************************************************************
906:                   Function:
907:                     int EthDescriptorsGetSize ( eEthDcptType dType )
908:                 
909:                   Summary:
910:                     Returns the number of bytes needed for the storage of a descriptor.
911:                 
912:                   Description:
913:                     This function returns the number of bytes needed for the storage of a
914:                     descriptor in the transmit/receive engine.
915:                 
916:                   Precondition:
917:                     None.
918:                 
919:                   Parameters:
920:                     dType       - TX/RX/All descriptors requested
921:                 
922:                   Returns:
923:                     The size of a descriptor.
924:                 
925:                   Example:
926:                     <code>
927:                     maxSize = EthDescriptorsGetSize(ETH_DCPT_TYPE_ALL);
928:                     </code>
929:                 
930:                   Remarks:
931:                     If ETH_DCPT_TYPE_ALL supplied the function will return them size that
932:                     accommodates both descriptors (maximum of the two values).
933:                  *****************************************************************************/
934:                 
935:                 int EthDescriptorsGetSize ( eEthDcptType dType );
936:                 
937:                 
938:                 /*******************************************************************************
939:                   Function:
940:                     void EthDescriptorsQuery ( eEthDcptType dType, sEthDcptQuery *pQuery )
941:                 
942:                   Summary:
943:                     Takes a snapshot of the current status of RX/TX descriptors.
944:                 
945:                   Description:
946:                     This function takes a snapshot of the current status of RX/TX descriptors
947:                     and provides the query result.
948:                 
949:                   Precondition:
950:                 
951:                   Parameters:
952:                     dType       - TX/RX descriptors requested
953:                 
954:                     pQuery      - Address to store the result of the query
955:                 
956:                                   See the sEthDcptQuery for details.
957:                 
958:                   Returns:
959:                     None.
960:                 
961:                   Example:
962:                     <code>
963:                     sEthDcptQuery queryResult;
964:                 
965:                     EthDescriptorsQuery(ETH_DCPT_TYPE_RX, &queryResult);
966:                     </code>
967:                 
968:                   Remarks:
969:                     The returned numbers are info only. They can dynamically change.
970:                 
971:                     No protection against interrupts, multithreading, etc.
972:                 
973:                     ETH_DCPT_TYPE_ALL use is invalid. A proper descriptor type (RX or TX) has
974:                     to be used.
975:                 
976:                     Whenever the automatic flow control is turned on, the reception will come
977:                     to a halt once the number of unacknowledged RX descriptors (dUnack for
978:                     query using ETH_DCPT_TYPE_RX) reaches 256.  Also the number of currently
979:                     received and unacknowledged descriptors control the behavior of the
980:                     automatic flow control.  See EthFCEnable for details.
981:                  *****************************************************************************/
982:                 
983:                 void EthDescriptorsQuery ( eEthDcptType dType, sEthDcptQuery *pQuery );
984:                 
985:                 
986:                 /*******************************************************************************
987:                   Function:
988:                     int EthDescriptorsGetRxUnack( void )
989:                 
990:                   Summary:
991:                     Provides the number of RX descriptors that are properly received and not
992:                     acknowledged.
993:                 
994:                   Description:
995:                     This function returns the number of RX descriptors that have been properly
996:                     received by the receive engine and not acknowledged.
997:                     These descriptors have to be acknowledged by software by calling
998:                     EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
999:                 
1000:                  Precondition:
1001:                    EthInit should have been called.
1002:                
1003:                  Parameters:
1004:                    None.
1005:                
1006:                  Returns:
1007:                    The number of RX descriptors that are currently unacknowledged.
1008:                
1009:                  Example:
1010:                    <code>
1011:                    if ( EthDescriptorsGetRxUnack()) >= 256 )
1012:                    {
1013:                        // Handle RX halt
1014:                    }
1015:                    </code>
1016:                
1017:                  Remarks:
1018:                    Fast shortcut for getting the number of un-acknowledged RX descriptors.
1019:                
1020:                    Whenever the automatic flow control is turned on, the reception will come
1021:                    to a halt once this number reaches 256.  The number of currently received
1022:                    descriptors control the behavior of the automatic flow control.  See
1023:                    EthFCEnable for details.
1024:                 *****************************************************************************/
1025:                
1026:                int EthDescriptorsGetRxUnack ( void );
1027:                
1028:                // DOM-IGNORE-BEGIN
1029:                extern __inline__ int __attribute__((always_inline)) EthDescriptorsGetRxUnack( void )
1030:                {
1031:                    return ETHSTATbits.BUFCNT;
9D011BC0  3C02BF89   LUI V0, -16503
9D011BC4  904290E2   LBU V0, -28446(V0)
9D011BC8  304200FF   ANDI V0, V0, 255
1032:                }
1033:                // DOM-IGNORE-END
1034:                
1035:                
1036:                /*******************************************************************************
1037:                  Function:
1038:                    void* EthDescriptorGetBuffer ( void *pDcpt )
1039:                
1040:                  Summary:
1041:                    Returns the associated descriptor buffer.
1042:                
1043:                  Description:
1044:                    This function returns the buffer currently associated with the specified descriptor.
1045:                
1046:                  Precondition:
1047:                
1048:                  Parameters:
1049:                    pDcpt       - Pointer to a Ethernet Descriptor
1050:                
1051:                
1052:                  Returns:
1053:                    The address of the buffer associated with this descriptor or NULL if no such descriptor/buffer
1054:                    exists.
1055:                
1056:                  Example:
1057:                    <code>
1058:                
1059:                    EthDescriptorsPoolRemove ( 1, ETH_DCPT_TYPE_RX, myRxFreeFnc, 0 );
1060:                
1061:                    void myRxFreeFnc( void* ptr, void* param)
1062:                    {
1063:                        void* pBuff = EthDescriptorGetBuffer(ptr);
1064:                        if(pBuff)
1065:                        {
1066:                            // De-allocate the associated buffer
1067:                        }
1068:                    }
1069:                
1070:                    </code>
1071:                
1072:                  Remarks:
1073:                    The function is a helper that returns the buffer associated with a descriptor.
1074:                    It can be used to perform the queued RX/TX buffers clean-up since this list is
1075:                    maintained by the Ethernet library anyway.
1076:                
1077:                    The pointer for a descriptor is returned by one of the
1078:                    EthDescriptorsPoolRemove() or EthDescriptorsPoolCleanUp() calls as the
1079:                    first parameter of the fFree function.
1080:                
1081:                    No protection against interrupts, multithreading, etc.
1082:                
1083:                 *****************************************************************************/
1084:                
1085:                void*      EthDescriptorGetBuffer ( void *pDcpt );
1086:                
1087:                
1088:                
1089:                /*******************************************************************************
1090:                  Function:
1091:                    eEthRes EthRxBuffersAppend ( void *ppBuff[], int nBuffs,
1092:                                                 eEthBuffFlags rxFlags )
1093:                
1094:                  Summary:
1095:                    Supplies buffers to the receiving process and enables the receiving part of
1096:                    the controller.
1097:                
1098:                  Description:
1099:                    This function supplies buffers to the receiving process and enables the
1100:                    receiving part of the controller.  As soon as the controller starts
1101:                    receiving data packets these will be stored into memory at the addresses
1102:                    specified by these buffers.  A received packet can consist of multiple
1103:                    buffers, split across buffers with the SAME size, as specified in the
1104:                    EthRxSetBufferSize.  Each buffer needs an associated receive descriptor.
1105:                    Therefore, the number of needed receive descriptors should be available for
1106:                    this function to succeed.  Once a receive operation is scheduled,
1107:                    EthRxGetPacket() can be called to get the received packet.
1108:                
1109:                  Precondition:
1110:                    EthInit, EthDescriptorsPoolAdd, EthRxSetBufferSize should have been called.
1111:                    Each buffer supplied should be >= EthRxSetBufferSize().
1112:                
1113:                  Parameters:
1114:                    ppBuff      - Pointer to an array of buffers (could be NULL terminated) to
1115:                                  be appended to the receiving process
1116:                
1117:                    nBuffs      - Number of buffers supplied (or 0 if ppBuff is NULL
1118:                                  terminated)
1119:                
1120:                    rxFlags     - Flags applied to all RX buffers passed
1121:                
1122:                  Returns:
1123:                    ETH_RES_OK              - success
1124:                
1125:                    ETH_RES_NO_DESCRIPTORS  - no enough RX descriptors
1126:                
1127:                    ETH_RES_USPACE_ERR      - buffers in user space not supported
1128:                
1129:                
1130:                  Example:
1131:                    <code>
1132:                    ethRes = EthRxBuffersAppend(rxBuffers, rxDcptNo, ETH_BUFF_FLAG_RX_STICKY);
1133:                    if ( ethRes != ETH_RES_OK )
1134:                    {
1135:                        // Handle error
1136:                    }
1137:                    </code>
1138:                
1139:                  Remarks:
1140:                    Not multithreaded safe. Don't call from from both ISR -non ISR code or
1141:                    multiple ISR's!
1142:                
1143:                    This function enables the Ethernet receiving.
1144:                
1145:                    When a packet is split into multiple buffers, all buffers have the same
1146:                    size, set by the EthRxSetBufferSize().
1147:                
1148:                    The append process continues until a NULL buffer pointer is retrieved or
1149:                    nBuffs buffers are appended.
1150:                
1151:                    Only RX eEthBuffFlags are relevant for this function
1152:                 *****************************************************************************/
1153:                
1154:                eEthRes EthRxBuffersAppend ( void *ppBuff[], int nBuffs, eEthBuffFlags rxFlags );
1155:                
1156:                /*******************************************************************************
1157:                  Function:
1158:                    eEthRes EthRxSetBufferSize ( int rxBuffSize )
1159:                
1160:                  Summary:
1161:                    Sets the required buffer size for the receive operation.
1162:                
1163:                  Description:
1164:                    This function sets the required buffer size for the receive operation.  In
1165:                    this implementation, all receive descriptors use the same buffer size
1166:                    (unlike the transmission flow where each descriptor can have a different
1167:                    buffer size).
1168:                
1169:                  Precondition:
1170:                    0 < rxBuffSize <= 2032
1171:                
1172:                    rxBuffSize multiple of 16
1173:                
1174:                  Parameters:
1175:                    rxBuffSize      - size of the RX buffers
1176:                
1177:                  Returns:
1178:                    ETH_RES_OK              - success
1179:                
1180:                    ETH_RES_RX_SIZE_ERR     - the requested size is invalid
1181:                
1182:                  Example:
1183:                    <code>
1184:                    EthRxSetBufferSize(rxBuffSize);
1185:                    </code>
1186:                
1187:                  Remarks:
1188:                    This function should be part of the initialization process and shoult NOT
1189:                    be called when the RX process is active!
1190:                
1191:                    The receive buffer size is always TRUNCATED to a multiple of 16 bytes.
1192:                 *****************************************************************************/
1193:                
1194:                eEthRes EthRxSetBufferSize ( int rxBuffSize );
1195:                
1196:                
1197:                // Section:  TX/RX Functions
1198:                
1199:                
1200:                // *****************************************************************************
1201:                /*  Packet Descriptor
1202:                
1203:                  Summary:
1204:                    Descriptor of a packet accepted by the TX/RX Ethernet engine.
1205:                
1206:                  Description:
1207:                    A packet handled by the Ethernet TX/RX engine is a list of buffer
1208:                    descriptors.  A packet consists of multiple buffers and each buffer needs a
1209:                    descriptor.  Although the number of buffers per packet is not limited, note
1210:                    that the hardware overhead is higher when many buffers have to be handled
1211:                    for one packet.  The list ends when the next field is NULL or when the pBuff
1212:                    is NULL.
1213:                */
1214:                
1215:                typedef struct _tag_sEthPktDcpt
1216:                {
1217:                    // Next descriptor in chain. NULL to end
1218:                    struct _tag_sEthPktDcpt  *next;
1219:                
1220:                    // Buffer to be transmitted
1221:                    void                   *pBuff;
1222:                
1223:                    // Number of bytes in the buffer 0-2047 allowed
1224:                    unsigned short int      nBytes;
1225:                
1226:                } /*DOM-IGNORE-BEGIN*/ __attribute__ ((__packed__)) /*DOM-IGNORE-END*/ sEthPktDcpt;
1227:                
1228:                
1229:                // *****************************************************************************
1230:                /*  Transmitted Packet Status
1231:                
1232:                  Summary:
1233:                    Status of a transmitted packet.
1234:                
1235:                  Description:
1236:                    This structure contains the status of a transmitted packet.
1237:                
1238:                  Notes:
1239:                    Status is always two "words" (64-bits) long.
1240:                */
1241:                
1242:                typedef union
1243:                {
1244:                    struct
1245:                    {
1246:                        // Total bytes transmitted
1247:                        unsigned short  totTxBytes;
1248:                
1249:                        // Control frame transmitted
1250:                        unsigned        txCtrl      : 1;
1251:                
1252:                        // Pause control frame transmitted
1253:                        unsigned        txPause     : 1;
1254:                
1255:                        // Transmit backpressure applied
1256:                        unsigned        txBPres     : 1;
1257:                
1258:                        // Transmit VLAN tagged frame
1259:                        unsigned        txVLAN      : 1;
1260:                
1261:                        unsigned                    : 12;
1262:                
1263:                        // Transmit bytes count
1264:                        unsigned short  bCount;
1265:                
1266:                        // Transmit collision count
1267:                        unsigned        collCount   : 4;
1268:                
1269:                        // Transmit CRC error
1270:                        unsigned        crcError    : 1;
1271:                
1272:                        // Tansmit length check error
1273:                        unsigned        lenError    : 1;
1274:                
1275:                        // Tansmit length out of range
1276:                        unsigned        lenRange    : 1;
1277:                
1278:                        // Transmit done
1279:                        unsigned        txDone      : 1;
1280:                
1281:                        // Transmit multicast
1282:                        unsigned        mcast       : 1;
1283:                
1284:                        // Transmit broadcast
1285:                        unsigned        bcast       : 1;
1286:                
1287:                        // Transmit packet defer
1288:                        unsigned        defer       : 1;
1289:                
1290:                        // Transmit excessive packet defer
1291:                        unsigned        excDefer    : 1;
1292:                
1293:                        // Transmit maximum collision
1294:                        unsigned        maxColl     : 1;
1295:                
1296:                        // Transmit late collision
1297:                        unsigned        lateColl    : 1;
1298:                
1299:                        // Transmit giant frame (set when pktSz>MaxFrameSz && HugeFrameEn==0)
1300:                        unsigned        giant       : 1;
1301:                
1302:                        // Transmit underrun
1303:                        unsigned        underrun    : 1;
1304:                
1305:                    }__attribute__ ((__packed__));
1306:                
1307:                    // Status is 2 words always
1308:                    unsigned long long  w;
1309:                
1310:                } sEthTxPktStat;
1311:                
1312:                
1313:                // *****************************************************************************
1314:                /*  Received Packet Status
1315:                
1316:                  Summary:
1317:                    Status of a received packet.
1318:                
1319:                  Description:
1320:                    This structure contains the status of a received packet.
1321:                
1322:                  Notes:
1323:                    Status is always two "words" (64-bits) long.
1324:                */
1325:                
1326:                typedef union
1327:                {
1328:                    struct
1329:                    {
1330:                        // Packet payload checksum
1331:                        unsigned        pktChecksum     :16;
1332:                
1333:                        unsigned                        : 8;
1334:                
1335:                        // Runt packet received
1336:                        unsigned        runtPkt         : 1;
1337:                
1338:                        // Unicast, not me packet,
1339:                        unsigned        notMeUcast      : 1;
1340:                
1341:                        // Hash table match
1342:                        unsigned        htMatch         : 1;
1343:                
1344:                        // Magic packet match
1345:                        unsigned        magicMatch      : 1;
1346:                
1347:                        // Pattern match match
1348:                        unsigned        pmMatch         : 1;
1349:                
1350:                        // Unicast match
1351:                        unsigned        uMatch          : 1;
1352:                
1353:                        // Broadcast match
1354:                        unsigned        bMatch          : 1;
1355:                
1356:                        // Multicast match
1357:                        unsigned        mMatch          : 1;
1358:                
1359:                        // Received bytes
1360:                        unsigned        rxBytes         :16;
1361:                
1362:                        // Packet previously ignored
1363:                        unsigned        prevIgnore      : 1;
1364:                
1365:                        // RX data valid event previously seen
1366:                        unsigned        prevDV          : 1;
1367:                
1368:                        // Carrier event previously seen
1369:                        unsigned        prevCarrier     : 1;
1370:                
1371:                        // RX code violation
1372:                        unsigned        rxCodeViol      : 1;
1373:                
1374:                        // CRC error in packet
1375:                        unsigned        crcError        : 1;
1376:                
1377:                        // Receive length check error
1378:                        unsigned        lenError        : 1;
1379:                
1380:                        // Receive length out of range
1381:                        unsigned        lenRange        : 1;
1382:                
1383:                        // Receive OK
1384:                        unsigned        rxOk            : 1;
1385:                
1386:                        // Multicast packet
1387:                        unsigned        mcast           : 1;
1388:                
1389:                        // Broadcast packet
1390:                        unsigned        bcast           : 1;
1391:                
1392:                        // Dribble nibble
1393:                        unsigned        dribble         : 1;
1394:                
1395:                        // Control frame received
1396:                        unsigned        rxCtrl          : 1;
1397:                
1398:                        // Pause control frame received
1399:                        unsigned        rxPause         : 1;
1400:                
1401:                        // Received unsupported code
1402:                        unsigned        rxCodeErr       : 1;
1403:                
1404:                        // Received VLAN tagged frame
1405:                        unsigned        rxVLAN          : 1;
1406:                
1407:                        unsigned                        : 1;
1408:                
1409:                    }__attribute__ ((__packed__));
1410:                
1411:                    // Status is 2 words always
1412:                    unsigned long long  w;
1413:                
1414:                } sEthRxPktStat;
1415:                
1416:                
1417:                
1418:                // *****************************************************************************
1419:                /* Ethernet Buffer Acknowledge Callback Function
1420:                
1421:                  Function:
1422:                    void <Function Name> ( void *pPktBuff, int buffIx, void* param )
1423:                
1424:                  Summary:
1425:                    Pointer to an function called to acknowledge a buffer/packet.
1426:                
1427:                  Description:
1428:                    Pointer to a function called to acknowledge the completion of a buffer/packet.
1429:                
1430:                  Precondition:
1431:                    A TX or RX packet must have been queued.
1432:                
1433:                  Parameters:
1434:                    pPktBuff    - Pointer to the currently acknowledged transmitted or received
1435:                                  buffer.
1436:                
1437:                    buffIx      - The 0-based buffer index for a packet that spans multiple
1438:                                  buffers.
1439:                
1440:                    param       - extra parameter that will be used by the function call
1441:                
1442:                
1443:                  Returns:
1444:                    None.
1445:                
1446:                  Remarks:
1447:                    This function is meant to be used for both RX and TX packets acknowledge.
1448:                    It allows the caller to pass an extra parameter that will be used in the
1449:                    function call.
1450:                
1451:                */
1452:                
1453:                typedef void ( *pEthBuffAck ) ( void *pPktBuff, int buffIx, void* param );
1454:                
1455:                
1456:                /*******************************************************************************
1457:                  Function:
1458:                    eEthRes EthTxSendBuffer ( const void *pBuff, unsigned short int nBytes )
1459:                
1460:                  Summary:
1461:                    Schedules the supplied buffer for transmission
1462:                
1463:                  Description:
1464:                    This function schedules the supplied buffer for transmission.  To transmit
1465:                    this buffer an associated transmit descriptor is needed.  Therefore, a
1466:                    transmit descriptor should be available for this function to succeed.  Once
1467:                    a transmission is scheduled and done, EthTxGetBufferStatus can be called to
1468:                    check the transmission result.
1469:                
1470:                  Precondition:
1471:                    EthMACOpen, EthDescriptorsPoolAdd should have been called.
1472:                    Valid buffer pointer required.
1473:                    Buffers specified should be > 0 and < 2048 bytes in size.
1474:                
1475:                  Parameters:
1476:                    pBuff       - Adress of buffer to be sent
1477:                
1478:                    nBytes      - Size of the buffer in bytes
1479:                
1480:                  Returns:
1481:                    ETH_RES_OK              - success
1482:                
1483:                    ETH_RES_NO_DESCRIPTORS  - no descriptors available
1484:                
1485:                    ETH_RES_USPACE_ERR      - user space buffers not supported
1486:                
1487:                  Example:
1488:                    <code>
1489:                    EthTxSendBuffer(txBuffer, pktSize);
1490:                    </code>
1491:                
1492:                  Remarks:
1493:                    Not multithreaded safe.  Don't call from from both ISR and non ISR code
1494:                    or multiple ISR's!
1495:                
1496:                    This function enables the Ethernet transmission.
1497:                
1498:                    This function is for transmission of packets completely assembled in one
1499:                    buffer.
1500:                 *****************************************************************************/
1501:                
1502:                eEthRes EthTxSendBuffer ( const void *pBuff, unsigned short int nBytes );
1503:                
1504:                
1505:                /*******************************************************************************
1506:                  Function:
1507:                    eEthRes EthTxSendPacket ( const sEthPktDcpt *pPkt )
1508:                
1509:                  Summary:
1510:                    Schedules the supplied packet for transmission.
1511:                
1512:                  Description:
1513:                    This function schedules the supplied packet for transmission.  Each packet
1514:                    can consist of multiple buffers, each having a different size, as specified
1515:                    in the packet descriptor.  Each buffer will need an associated transmit
1516:                    descriptor. Therefore, the number of needed transmit descriptors should be
1517:                    available for this function to succeed.  Once a transmission is scheduled
1518:                    and done, EthTxGetPacketStatus can be called to check the transmission
1519:                    result.
1520:                
1521:                  Precondition:
1522:                    EthMACOpen, EthDescriptorsPoolAdd should have been called.
1523:                    Valid packet descriptor pointer required.
1524:                    Buffers specified should be >0 and < 2048 bytes in size.
1525:                
1526:                  Parameters:
1527:                    pPkt        - Packet descriptor consisting of a list of buffer descriptors,
1528:                                  terminated by a NULL pointer.
1529:                
1530:                  Returns:
1531:                    ETH_RES_OK              - success
1532:                
1533:                    ETH_RES_NO_DESCRIPTORS  - no descriptors available
1534:                
1535:                    ETH_RES_USPACE_ERR      - user space buffers not supported
1536:                
1537:                  Example:
1538:                    <code>
1539:                    ethRes = EthTxSendPacket(&txDcpt);
1540:                    if ( ethRes != ETH_RES_OK )
1541:                    {
1542:                        // Transmission failed
1543:                    }
1544:                    </code>
1545:                
1546:                  Remarks:
1547:                    Not multithreaded safe. Don't call from from both ISR and non-ISR code or
1548:                    multiple ISR's!
1549:                
1550:                    This function enables the Ethernet transmission.
1551:                
1552:                    The packet construction from buffers stops when a descriptor with NULL buffer
1553:                    or 0 size is retrieved or the list ends.
1554:                 *****************************************************************************/
1555:                
1556:                eEthRes EthTxSendPacket ( const sEthPktDcpt *pPkt );
1557:                
1558:                
1559:                /*******************************************************************************
1560:                  Function:
1561:                    eEthRes EthTxGetBufferStatus ( const void *pBuff, const sEthTxPktStat **pTxStat )
1562:                
1563:                  Summary:
1564:                    Provides the status of a transmitted buffer/packet.
1565:                
1566:                  Description:
1567:                    This function provides the status of a transmitted buffer/packet.  The
1568:                    transmission of this packet has to have been completed otherwise the call
1569:                    will fail.
1570:                
1571:                  Precondition:
1572:                    EthTxSendBuffer/EthTxSendPacket should have been called and the pBuff pointer must be valid.
1573:                
1574:                  Parameters:
1575:                    pBuff       - Buffer part of the packet whose status is being queried.
1576:                
1577:                    pTxStat     - Address to store the pointer to the packet status or NULL if
1578:                                  status not needed
1579:                
1580:                  Returns:
1581:                    ETH_RES_OK              - the packet was transmitted OK,
1582:                
1583:                    ETH_RES_PACKET_QUEUED   - the packet is not done yet
1584:                
1585:                    ETH_RES_NO_PACKET       - no such packet exists
1586:                
1587:                  Example:
1588:                    <code>
1589:                    ethRes = EthTxGetBufferStatus(pTxBuff, NULL);
1590:                    if ( ethRes != ETH_RES_OK )
1591:                    {
1592:                        // Handle packet not transmitted
1593:                    }
1594:                    </code>
1595:                
1596:                  Remarks:
1597:                    The returned pointer to the packet status is invalid after the
1598:                    EthTxAcknowledgeBuffer/EthTxAcknowledgePacket is called.
1599:                
1600:                    pBuff must be the pointer to the first buffer
1601:                    in the packet, if the packet spans multiple buffers.
1602:                 *****************************************************************************/
1603:                
1604:                eEthRes EthTxGetBufferStatus ( const void *pBuff, const sEthTxPktStat **pTxStat );
1605:                
1606:                /*******************************************************************************
1607:                  Function:
1608:                    eEthRes EthTxGetPacketStatus(const sEthPktDcpt* pPkt, const sEthTxPktStat** pTxStat)
1609:                
1610:                  Summary:
1611:                    Provides the status of a transmitted packet.
1612:                
1613:                  Description:
1614:                    This function provides the status of a transmitted packet.  The
1615:                    transmission of this packet has to have been completed otherwise the call
1616:                    will fail.
1617:                
1618:                  Precondition:
1619:                    EthTxSendPacket should have been called and the pPkt pointer must be valid.
1620:                
1621:                  Parameters:
1622:                    pPkt        - Packet whose status is being queried.
1623:                
1624:                    pTxStat     - Address to store the pointer to the packet status or NULL if
1625:                                  status not needed
1626:                
1627:                  Returns:
1628:                    ETH_RES_OK              - the packet was transmitted OK,
1629:                
1630:                    ETH_RES_PACKET_QUEUED   - the packet is not done yet
1631:                
1632:                    ETH_RES_NO_PACKET       - no such packet exists
1633:                
1634:                  Example:
1635:                    <code>
1636:                    ethRes = EthTxGetPacketStatus(pTxPacket, NULL);
1637:                    if ( ethRes != ETH_RES_OK )
1638:                    {
1639:                        // Handle packet not transmitted
1640:                    }
1641:                    </code>
1642:                
1643:                  Remarks:
1644:                    The returned pointer to the packet status is invalid after the
1645:                    EthTxAcknowledgeBuffer/EthTxAcknowledgePacket is called.
1646:                
1647:                 *****************************************************************************/
1648:                
1649:                eEthRes EthTxGetPacketStatus(const sEthPktDcpt* pPkt, const sEthTxPktStat** pTxStat);
1650:                
1651:                // DOM-IGNORE-BEGIN
1652:                extern __inline__ eEthRes __attribute__((always_inline)) EthTxGetPacketStatus(const sEthPktDcpt* pPkt, const sEthTxPktStat** pTxStat)
1653:                {
1654:                    return  EthTxGetBufferStatus(pPkt?pPkt->pBuff:0, pTxStat);
1655:                }
1656:                // DOM-IGNORE-END
1657:                
1658:                
1659:                /*******************************************************************************
1660:                  Function:
1661:                    eEthRes EthTxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam )
1662:                
1663:                  Summary:
1664:                    Acknowledges a transmitted buffer/packet
1665:                
1666:                  Description:
1667:                    This function acknowledges a transmitted buffer/packet.  The transmission
1668:                    of this packet has to have been completed otherwise the call will fail.
1669:                    When pBuff==NULL, all currently transmitted packets will be acknowledged.
1670:                    The ackFnc, if !NULL, will be called for each buffer within the packet in
1671:                    turn.
1672:                
1673:                  Precondition:
1674:                    EthTxSendBuffer/EthTxSendPacket should have been called.
1675:                
1676:                  Parameters:
1677:                    pBuff           - Buffer of the packet to be acknowledged or NULL.
1678:                
1679:                    ackFnc          - Function to be called for the acknowledged buffers or
1680:                                      NULL
1681:                
1682:                    fParam          - Parameter to be used in the ackFnc callback
1683:                
1684:                  Returns:
1685:                    ETH_RES_OK              - Success
1686:                
1687:                    ETH_RES_PACKET_QUEUED   - The packet is scheduled for transmission/
1688:                                              There are packets scheduled to be transmitted
1689:                
1690:                    ETH_RES_NO_PACKET       - No such packet exists in the transmit queue/
1691:                                              No packets scheduled for transmit
1692:                
1693:                  Example:
1694:                    <code>
1695:                    ethRes=EthTxAcknowledgeBuffer(pTxBuff, myAckFnc, &myInstanceData);
1696:                
1697:                    void myAckFnc(void* pBuff, int buffIx, void* param)
1698:                    {
1699:                        myInstanceType* pType=(myInstanceType*)param;
1700:                        // Handle each buffer acknowledgement
1701:                    }
1702:                    </code>
1703:                
1704:                  Remarks:
1705:                    Any transmitted packet has to be acknowledged, otherwise the Ethernet library will
1706:                    run out of transmission descriptors.
1707:                
1708:                    pBuff must be the pointer to the first buffer in the packet, if the packet
1709:                    spans multiple buffers.
1710:                
1711:                    ackFnc is just a helper that allows the application to acknowledge the
1712:                    transmitted buffers without the need to maintain a list of buffers
1713:                    scheduled for transmission (this list is maintained by the Ethernet library
1714:                    anyway).
1715:                
1716:                    Useful especially when the transmission result is not really needed and
1717:                    the function is called with pBuff=0.
1718:                 *****************************************************************************/
1719:                
1720:                eEthRes EthTxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam );
1721:                
1722:                
1723:                /*******************************************************************************
1724:                  Function:
1725:                    eEthRes EthTxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
1726:                
1727:                  Summary:
1728:                    Acknowledges a transmitted packet
1729:                
1730:                  Description:
1731:                    This function acknowledges a transmitted packet.  The transmission
1732:                    of this packet has to have been completed otherwise the call will fail.
1733:                    When pPkt==NULL, all currently transmitted packets will be acknowledged.
1734:                    The ackFnc, if !NULL, will be called for each buffer within the packet in
1735:                    turn.
1736:                
1737:                  Precondition:
1738:                    EthTxSendPacket should have been called.
1739:                
1740:                  Parameters:
1741:                    pPkt            - Packet to be acknowledged or NULL.
1742:                
1743:                    ackFnc          - Function to be called to acknowledge each buffer
1744:                                      within the packet or NULL
1745:                
1746:                    fParam          - Parameter to be used in the ackFnc callback
1747:                
1748:                
1749:                  Returns:
1750:                    ETH_RES_OK              - Success
1751:                
1752:                    ETH_RES_PACKET_QUEUED   - The packet is queued for transmission/
1753:                                              There are packets scheduled to be transmitted
1754:                
1755:                    ETH_RES_NO_PACKET       - No such packet exist sin th etransmit queue/
1756:                                              No packets scheduled for transmit
1757:                
1758:                  Example:
1759:                    <code>
1760:                    ethRes=EthTxAcknowledgePacket(pTxPkt, 0, 0);
1761:                    </code>
1762:                
1763:                  Remarks:
1764:                    Any transmitted packet has to be acknowledged, otherwise the Ethernet library will
1765:                    run out of transmission descriptors.
1766:                
1767:                    ackFnc is just a helper that allows the application to acknowledge the
1768:                    transmitted buffers without the need to maintain a list of buffers
1769:                    scheduled for transmission (this list is maintained by the Ethernet library
1770:                    anyway).
1771:                
1772:                    Useful especially when the transmission result is not really needed and
1773:                    the function is called with pPkt=0.
1774:                 *****************************************************************************/
1775:                
1776:                eEthRes EthTxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam );
1777:                
1778:                // DOM-IGNORE-BEGIN
1779:                extern __inline__ eEthRes __attribute__((always_inline)) EthTxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
1780:                {
1781:                    return  EthTxAcknowledgeBuffer(pPkt?pPkt->pBuff:0, ackFnc, fParam);
1782:                }
1783:                // DOM-IGNORE-END
1784:                
1785:                
1786:                /*******************************************************************************
1787:                  Function:
1788:                    eEthRes EthRxGetBuffer ( void **ppBuff, const sEthRxPktStat **pRxStat )
1789:                
1790:                  Summary:
1791:                     Returns a pointer to the data and the status of the next available
1792:                     received packet.
1793:                
1794:                  Description:
1795:                    This function returns a pointer to the data and the status of the next
1796:                    available received packet.  If there's no available fully received packet
1797:                    the call will fail (ETH_RES_PACKET_QUEUED/ETH_RES_NO_PACKET).  If the
1798:                    received packet spans multiple buffers/descriptors (i.e. when the size of
1799:                    the buffer, EthRxSetBufferSize() is less than the packet size)
1800:                    ETH_RES_RX_PKT_SPLIT_ERR will be returned.  However, if the ppBuff is NULL,
1801:                    then the caller can use the returned pRxStat to check the total size of the
1802:                    packet. Then using the size of the set buffers, the number of buffers used
1803:                    in the packet will result.
1804:                
1805:                  Precondition:
1806:                    EthRxSetBufferSize, EthRxBuffersAppend should have been called.
1807:                
1808:                  Parameters:
1809:                    ppBuff          - Address of a pointer to packet buffer data or NULL
1810:                
1811:                    pRxStat         - Address to store the pointer to the packet status or
1812:                                      NULL
1813:                
1814:                  Returns:
1815:                    ETH_RES_OK                  - For success
1816:                
1817:                    ETH_RES_PACKET_QUEUED       - The packet is in the reception queus/
1818:                                                  There are packets queued for receive but not
1819:                                                  completed yet
1820:                
1821:                    ETH_RES_NO_PACKET           - No such packet is in the receiving queue/
1822:                                                  No packets available in the receiving queue
1823:                
1824:                    ETH_RES_RX_PKT_SPLIT_ERR    - Packet spans accross multiple buffers
1825:                
1826:                  Example:
1827:                    <code>
1828:                    // Wait to receive a packet
1829:                    do
1830:                    {
1831:                        ethRes = EthRxGetBuffer(&pBuff, &pRxPktStat);
1832:                    } while ( ethRes == ETH_RES_PACKET_QUEUED );
1833:                    </code>
1834:                
1835:                  Remarks:
1836:                    The returned status pointer is invalid once the EthRxAcknowledgeBuffer/EthRxAcknowledgePacket
1837:                    is called.
1838:                
1839:                    Also the associated packet buffer if it was appended with a
1840:                    ETH_BUFF_FLAG_RX_STICKY flag.
1841:                
1842:                    The returned buffer, if existent, will be marked as reported only when the
1843:                    result returned is ETH_RES_OK.
1844:                
1845:                    In this case a new call to the function will not return the same buffer.
1846:                
1847:                    If the call failed for some reason (result!=ETH_RES_OK) the returned
1848:                    buffer is not marked as reported.
1849:                
1850:                    A new call to this function will return the same buffer.
1851:                 *****************************************************************************/
1852:                
1853:                eEthRes EthRxGetBuffer ( void **ppBuff, const sEthRxPktStat **pRxStat );
1854:                
1855:                
1856:                /*******************************************************************************
1857:                  Function:
1858:                    eEthRes EthRxGetPacket ( sEthPktDcpt *pPkt, int *pnBuffs,
1859:                                             const sEthRxPktStat **pRxStat )
1860:                
1861:                  Summary:
1862:                    Provides the layout and the status of the next available received packet.
1863:                
1864:                  Description:
1865:                    This function returns the layout and the status of the next available
1866:                    received packet.  If there's no available fully received packet the call
1867:                    will fail (ETH_RES_PACKET_QUEUED/ETH_RES_NO_PACKET).  The supplied pPkt has
1868:                    to be large enough to accommodate the packet layout in the case of packets
1869:                    split across multiple buffers/descriptors (i.e. when the size of the buffer,
1870:                    EthRxSetBufferSize() is less than the packet size) otherwise
1871:                    ETH_RES_RX_PKT_SPLIT_ERR will be returned.  However, if the pPkt is NULL,
1872:                    then the caller can use the returned pRxStat to check the total size of the
1873:                    packet. Then using the size of the set buffers, the number of buffers in
1874:                    pPkt will result.  pnBuffs can be used for the same purpose. If pnBuffs is
1875:                    supplied, the numbers of buffers in the packet will be returned.
1876:                
1877:                  Precondition:
1878:                    EthRxSetBufferSize, EthRxBuffersAppend should have been called.
1879:                
1880:                  Parameters:
1881:                    pPkt            - Pointer to a packet descriptor: a list of buffer
1882:                                      descriptors large enough to receive the packet layout or
1883:                                      NULL.
1884:                
1885:                    pnBuffs         - Pointer to store the number of buffers in the packet or
1886:                                      NULL.
1887:                
1888:                    pRxStat         - Address to store the pointer to the packet status or
1889:                                      NULL.
1890:                
1891:                  Returns:
1892:                    ETH_RES_OK                  - For success.
1893:                
1894:                    ETH_RES_PACKET_QUEUED       - The packet is queued for reception/
1895:                                                  There are packets queued for receive but not
1896:                                                  completed yet.
1897:                
1898:                    ETH_RES_NO_PACKET           - No such packet in the receiving queue/
1899:                                                  No packets available in the receiving queue.
1900:                
1901:                    ETH_RES_RX_PKT_SPLIT_ERR    - Packet descriptor not large enough to store
1902:                                                  the whole packet.
1903:                
1904:                  Example:
1905:                    <code>
1906:                    // Wait to receive a packet
1907:                    do
1908:                    {
1909:                        ethRes = EthRxGetPacket(&rxPktDcpt, &buffsPerRxPkt, &pRxPktStat);
1910:                
1911:                    } while ( ethRes== ETH_RES_PACKET_QUEUED );
1912:                    </code>
1913:                
1914:                  Remarks:
1915:                    The packet list, when supplied, is terminated with a NULL buffer
1916:                
1917:                    The returned status pointer is invalid after the EthRxAcknowledgePacket() is
1918:                    called.  Also any buffers that were appended with a ETH_BUFF_FLAG_RX_STICKY
1919:                    flag associated to the packet buffers.
1920:                
1921:                    The returned packet, if existent, will be marked as reported only when the
1922:                    result returned is ETH_RES_OK.  In this case a new call to the function
1923:                    will not return the same packet.
1924:                
1925:                    If the call failed for some reason (result!=ETH_RES_OK) the returned
1926:                    packet is not marked as reported.
1927:                
1928:                    A new call to this function will return the same packet.
1929:                 *****************************************************************************/
1930:                
1931:                eEthRes EthRxGetPacket ( sEthPktDcpt *pPkt, int *pnBuffs, const sEthRxPktStat **pRxStat );
1932:                
1933:                
1934:                /*******************************************************************************
1935:                  Function:
1936:                    eEthRes EthRxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam )
1937:                
1938:                  Summary:
1939:                    Acknowledges a received buffer/packet.
1940:                
1941:                  Description:
1942:                    This function acknowledges a received buffer/packet.  The supplied packet
1943:                    has to have been previously received otherwise the call will fail.
1944:                    When pBuff==NULL, all currently received packets will be acknowledged.
1945:                    The ackFnc, if !NULL, will be called for each buffer within the packet in turn.
1946:                
1947:                  Precondition:
1948:                    EthRxSetBufferSize, EthRxBuffersAppend, EthRxGetPacket should have been
1949:                    called.
1950:                
1951:                  Parameters:
1952:                    pBuff       - Buffer/packet to be acknowledged or NULL
1953:                
1954:                    ackFnc      - Function to be called for the acknowledged buffers or NULL
1955:                
1956:                    fParam      - Parameter to be used in the ackFnc callback
1957:                
1958:                  Returns:
1959:                    ETH_RES_OK              - Success
1960:                
1961:                    ETH_RES_PACKET_QUEUED   - The packet is in the receiving queue/
1962:                                              There are packets in the receiving queue
1963:                
1964:                    ETH_RES_NO_PACKET       - No such packet in the receiving queue/
1965:                                              No packets available in the receiving queue
1966:                
1967:                  Example:
1968:                    <code>
1969:                    ethRes = EthRxAcknowledgeBuffer(pRxBuff, myAckFnc, &myInstanceData);
1970:                    if ( ethRes != ETH_RES_OK )
1971:                    {
1972:                        // Handle buffer not acknowledged
1973:                    }
1974:                
1975:                    void myAckFnc(void* pBuff, int buffIx, void* param)
1976:                    {
1977:                        myInstanceType* pType=(myInstanceType*)param;
1978:                        // Handle each buffer acknowledgement
1979:                    }
1980:                    </code>
1981:                
1982:                  Remarks:
1983:                    Any received packet has to be acknowledged, otherwise the Ethernet library will run
1984:                    out of descriptors.
1985:                
1986:                    pBuff must be the pointer to the first buffer in the packet, if the packet
1987:                    spans multiple buffers.
1988:                
1989:                    ackFnc is just a helper that allows the application to call an acknowledge
1990:                    function for each received buffer in turn.
1991:                 *****************************************************************************/
1992:                
1993:                eEthRes EthRxAcknowledgeBuffer ( const void *pBuff, pEthBuffAck ackFnc, void* fParam );
1994:                
1995:                
1996:                /*******************************************************************************
1997:                  Function:
1998:                    eEthRes EthRxAcknowledgePacket ( const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
1999:                
2000:                  Summary:
2001:                    Acknowledges a received packet.
2002:                
2003:                  Description:
2004:                    This function acknowledges a received packet.  The supplied packet
2005:                    has to have been previously received otherwise the call will fail.
2006:                    When pPkt==NULL, all currently received packets will be acknowledged.
2007:                    The ackFnc, if !NULL, will be called for each buffer within the packet in turn.
2008:                
2009:                  Precondition:
2010:                    EthRxSetBufferSize, EthRxBuffersAppend, EthRxGetPacket should have been
2011:                    called.
2012:                
2013:                  Parameters:
2014:                    pPkt        - Packet to be acknowledged or NULL
2015:                
2016:                    ackFnc      - Function to be called for the each buffer within the packet or NULL
2017:                
2018:                    fParam      - Parameter to be used in the ackFnc callback
2019:                
2020:                  Returns:
2021:                    ETH_RES_OK              - Success
2022:                
2023:                    ETH_RES_PACKET_QUEUED   - The packet is in the receiving queue/
2024:                                              There are packets in the receiving queue
2025:                
2026:                    ETH_RES_NO_PACKET       - No such packet in the receiving queue/
2027:                                              No packets available in the receiving queue
2028:                
2029:                  Example:
2030:                    <code>
2031:                    ethRes = EthRxAcknowledgePacket(pRxPkt, NULL, 0);
2032:                    if ( ethRes != ETH_RES_OK )
2033:                    {
2034:                        // Handle packet not acknowledged
2035:                    }
2036:                    </code>
2037:                
2038:                  Remarks:
2039:                    Any received packet has to be acknowledged, otherwise the Ethernet library will run
2040:                    out of descriptors.
2041:                
2042:                    ackFnc is just a helper that allows the application to call an acknowledge
2043:                    function for each received buffer in turn.
2044:                 *****************************************************************************/
2045:                
2046:                eEthRes EthRxAcknowledgePacket ( const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam );
2047:                
2048:                // DOM-IGNORE-BEGIN
2049:                extern __inline__ eEthRes __attribute__((always_inline)) EthRxAcknowledgePacket(const sEthPktDcpt* pPkt, pEthBuffAck ackFnc, void* fParam )
2050:                {
2051:                    return EthRxAcknowledgeBuffer(pPkt?pPkt->pBuff:0, ackFnc, fParam);
2052:                }
2053:                // DOM-IGNORE-END
2054:                
2055:                
2056:                // Section: Status Functions
2057:                
2058:                /*******************************************************************************
2059:                  Function:
2060:                    eEthStat EthStatusGet ( void )
2061:                
2062:                  Summary:
2063:                    Returns the current controller status.
2064:                
2065:                  Description:
2066:                    This function returns the current controller status.
2067:                
2068:                  Precondition:
2069:                    None.
2070:                
2071:                  Parameters:
2072:                    None.
2073:                
2074:                  Returns:
2075:                    Current Ethernet controller status.
2076:                
2077:                  Example:
2078:                    <code>
2079:                    ethStat = EthStatusGet();
2080:                    </code>
2081:                
2082:                  Remarks:
2083:                    None.
2084:                 *****************************************************************************/
2085:                
2086:                eEthStat EthStatusGet ( void );
2087:                
2088:                
2089:                // Section:  Flow Control Functions
2090:                
2091:                // *****************************************************************************
2092:                /* Ethernet Flow Control
2093:                
2094:                  Summary:
2095:                    Defines the possible Ethernet flow control types.
2096:                
2097:                  Description:
2098:                    This enumeration defines the Ethernet flow control types.
2099:                */
2100:                
2101:                typedef enum
2102:                {
2103:                    // Auto flow control
2104:                    ETH_FC_AUTO = 0,
2105:                
2106:                    // Software flow control
2107:                    ETH_FC_SOFTWARE
2108:                
2109:                } eEthFc;
2110:                
2111:                
2112:                /*******************************************************************************
2113:                  Function:
2114:                    void EthFCSetPauseValue ( unsigned int pauseBytes )
2115:                
2116:                  Summary:
2117:                    Sets the pause value to be used with manual or auto flow control.
2118:                
2119:                  Description:
2120:                    This function sets the pause value to be used with manual or auto flow
2121:                    control.  The pause time is calculated as being the time needed to transmit
2122:                    pauseBytes bytes.
2123:                
2124:                  Precondition:
2125:                    EthInit should have been called.
2126:                
2127:                    64 < pauseBytes < 4194304
2128:                
2129:                  Parameters:
2130:                    pauseBytes      - The number of bytes to pause
2131:                
2132:                  Returns:
2133:                    None.
2134:                
2135:                  Example:
2136:                    <code>
2137:                    EthFCSetPauseValue(128);
2138:                    </code>
2139:                
2140:                  Remarks:
2141:                    The pauseBytes value is relevant for full duplex mode only.
2142:                
2143:                    In half duplex, back pressure is applied.
2144:                
2145:                    Should be called only when receive is not enabled (i.e. before
2146:                    EthRxBuffersAppend() is called, for example).
2147:                 *****************************************************************************/
2148:                
2149:                void EthFCSetPauseValue ( unsigned int pauseBytes );
2150:                
2151:                
2152:                /*******************************************************************************
2153:                  Function:
2154:                    void EthFCEnable ( eEthFc fcType, int enable )
2155:                
2156:                  Summary:
2157:                    Enables or disables selected flow control.
2158:                
2159:                  Description:
2160:                    When enabling software flow control:
2161:                    *   In full duplex mode, this function immediately enables the manual flow
2162:                        control and sends a pause frame with the desired pause time.
2163:                    *   Further on, a pause frame is resent, every interval corresponding to
2164:                        pause time/2.
2165:                    *   In half duplex mode, back pressure is applied.
2166:                
2167:                    When disabling software flow control:
2168:                    *   In full duplex, this function immediately disables the manual flow
2169:                        control and sends a pause frame with the pause time set to 0.
2170:                    *   In half duplex, the back pressure is removed.
2171:                
2172:                    When enabling the auto flow control:
2173:                    *   As soon as the number of the unacknowledged received descriptors
2174:                        ( BUFCNT = EthDescriptorsGetRxUnack() ) becomes >= fullWM:
2175:                        *   In full duplex mode a pause frame is sent with the specified pause
2176:                            time (EthFCSetPauseValue).
2177:                        *   Further on, a pause frame is resent, every interval corresponding
2178:                            to pause time/2.
2179:                        *   In half duplex mode, back pressure is applied.
2180:                        *   As soon as the BUFCNT becomes = emptyWM:
2181:                            *   In full duplex mode a pause frame is sent with the pause
2182:                                value set to 0.
2183:                            *   In half duplex mode, the back pressure is removed.
2184:                
2185:                    *   When disabling auto flow control:
2186:                        *   In full duplex, this function immediately disables the flow control
2187:                            and sends a pause frame with the pause time set to 0.
2188:                        *   In half duplex, the back pressure is removed.
2189:                
2190:                  Precondition:
2191:                    EthInit, EthFCSetPauseValue should have been called.
2192:                
2193:                  Parameters:
2194:                    fcType      - Type of the flow control desired: auto or software (manual)
2195:                
2196:                    enable      - Boolean to enable/disable the flow control
2197:                
2198:                  Returns:
2199:                    None.
2200:                
2201:                  Example:
2202:                    <code>
2203:                    EthFCEnable(ETH_FC_AUTO, 1);
2204:                    </code>
2205:                
2206:                  Remarks:
2207:                    BUFCNT is decremented by a call to EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
2208:                 *****************************************************************************/
2209:                
2210:                void EthFCEnable ( eEthFc fcType, int enable );
2211:                
2212:                
2213:                /*******************************************************************************
2214:                  Function:
2215:                    void EthFCSetRxWMark ( int fullWM, int emptyWM )
2216:                
2217:                  Summary:
2218:                    Sets the automatic flow control watermarks.
2219:                
2220:                  Description:
2221:                    This function sets the values for the watermarks used in the automatic flow
2222:                    control.
2223:                
2224:                  Precondition:
2225:                    EthInit, should have been called.
2226:                
2227:                    0 <= emptyWM < fullWM < 256
2228:                
2229:                  Parameters:
2230:                    fullWM          - The full watermark value
2231:                
2232:                    emptyWM         - The empty watermark value
2233:                
2234:                  Returns:
2235:                    None.
2236:                
2237:                  Example:
2238:                    <code>
2239:                    EthFCSetRxWMark(4, 64);
2240:                    </code>
2241:                
2242:                  Remarks:
2243:                    See the description of the automatic flow control in the EthFCEnable
2244:                    description.  To take into account the delays inherent to the traffic
2245:                    stop, the value for fullWM should be set in such a way that the automatic
2246:                    flow control kicks in when there's less than 3 frames (3*1536 bytes)
2247:                    available in the receive descriptors.
2248:                 *****************************************************************************/
2249:                
2250:                void EthFCSetRxWMark ( int fullWM, int emptyWM );
2251:                
2252:                
2253:                // Section: RX Filtering Functions
2254:                
2255:                
2256:                // *****************************************************************************
2257:                /* Ethernet Receive Filter Flags
2258:                
2259:                  Summary:
2260:                    Defines the receive filter flags
2261:                
2262:                  Description:
2263:                    This enumeration defines the receive filter flags.
2264:                
2265:                  Remarks:
2266:                    Multiple values can be OR-ed together.
2267:                
2268:                    The values in this enumeration are displayed in the order of priority
2269:                    that the receive filter state machine works, with the highest priority first.
2270:                    Once a filter accepts or rejects a packet, further filters are not tried.
2271:                    If a packet isn't rejected/accepted after all filters are tried, it will be rejected by
2272:                    default!
2273:                */
2274:                
2275:                typedef enum
2276:                {
2277:                    // Frames with wrong CRC are accepted
2278:                    ETH_FILT_CRC_ERR_ACCEPT
2279:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_CRCERREN_MASK /*DOM-IGNORE-END*/,
2280:                
2281:                    // Runt frames accepted
2282:                    ETH_FILT_RUNT_ACCEPT
2283:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_RUNTERREN_MASK /*DOM-IGNORE-END*/,
2284:                
2285:                    // Frames with wrong CRC are rejected
2286:                    ETH_FILT_CRC_ERR_REJECT
2287:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_CRCOKEN_MASK /*DOM-IGNORE-END*/,
2288:                
2289:                    // Runt frames rejected
2290:                    ETH_FILT_RUNT_REJECT
2291:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_RUNTEN_MASK /*DOM-IGNORE-END*/,
2292:                
2293:                    // Me unicast accepted
2294:                    ETH_FILT_ME_UCAST_ACCEPT
2295:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_UCEN_MASK /*DOM-IGNORE-END*/,
2296:                
2297:                    // Not me unicast accepted
2298:                    ETH_FILT_NOTME_UCAST_ACCEPT
2299:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_NOTMEEN_MASK /*DOM-IGNORE-END*/,
2300:                
2301:                    // Multicast accepted
2302:                    ETH_FILT_MCAST_ACCEPT
2303:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_MCEN_MASK /*DOM-IGNORE-END*/,
2304:                
2305:                    // Broadcast accepted
2306:                    ETH_FILT_BCAST_ACCEPT
2307:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_BCEN_MASK /*DOM-IGNORE-END*/,
2308:                
2309:                    // Hash table matches destination address accepted
2310:                    ETH_FILT_HTBL_ACCEPT
2311:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_HTEN_MASK /*DOM-IGNORE-END*/,
2312:                
2313:                    // Magic packet accepted
2314:                    ETH_FILT_MAGICP_ACCEPT
2315:                        /*DOM-IGNORE-BEGIN*/ = _ETHRXFC_MPEN_MASK /*DOM-IGNORE-END*/,
2316:                
2317:                
2318:                    // All Filters
2319:                    ETH_FILT_ALL_FILTERS     = ETH_FILT_CRC_ERR_ACCEPT  | ETH_FILT_RUNT_ACCEPT        |
2320:                                               ETH_FILT_CRC_ERR_REJECT  | ETH_FILT_RUNT_REJECT        |
2321:                                               ETH_FILT_ME_UCAST_ACCEPT | ETH_FILT_NOTME_UCAST_ACCEPT |
2322:                                               ETH_FILT_MCAST_ACCEPT    | ETH_FILT_BCAST_ACCEPT       |
2323:                                               ETH_FILT_HTBL_ACCEPT     | ETH_FILT_MAGICP_ACCEPT
2324:                
2325:                } eEthRxFilters;
2326:                
2327:                
2328:                // *****************************************************************************
2329:                /* Ethernet Pattern Match Modes
2330:                
2331:                  Summary:
2332:                    Defines pattern match modes
2333:                
2334:                  Description:
2335:                    This enumeration defines the Ethernet pattern match modes.
2336:                
2337:                  Remarks:
2338:                    These are mutually exclusive modes, not flags.  However,
2339:                    ETH_FILT_PMATCH_INVERT act as a flag and can be applied to any value.
2340:                */
2341:                
2342:                typedef enum
2343:                {
2344:                    // Simple Pattern Match accepted
2345:                    ETH_FILT_PMATCH_ACCEPT = 1,
2346:                
2347:                    // Pattern Match AND destination==me
2348:                    ETH_FILT_PMATCH_ME_UCAST_ACCEPT,
2349:                
2350:                    // Pattern Match AND destination!=me
2351:                    ETH_FILT_PMATCH_NOTME_UCAST_ACCEPT,
2352:                
2353:                    // Pattern Match AND destination!=unicast
2354:                    ETH_FILT_PMATCH_MCAST_ACCEPT,
2355:                
2356:                    // Pattern Match AND destination==unicast
2357:                    ETH_FILT_PMATCH_NOT_MCAST_ACCEPT,
2358:                
2359:                    // Pattern Match AND destination==broadcast
2360:                    ETH_FILT_PMATCH_BCAST_ACCEPT,
2361:                
2362:                    // Pattern Match AND destination!=broadcast
2363:                    ETH_FILT_PMATCH_NOT_BCAST_ACCEPT,
2364:                
2365:                    // Pattern Match AND hash table filter match (irrespective of the
2366:                    // ETH_FILT_HTBL_ACCEPT setting)
2367:                    ETH_FILT_PMATCH_HTBL_ACCEPT,
2368:                
2369:                    // Pattern Match AND packet ==magic packet
2370:                    ETH_FILT_PMATCH_MAGICP_ACCEPT,
2371:                
2372:                    // If set, the pattern must NOT match for a successful Pattern Match to
2373:                    // occur!
2374:                    ETH_FILT_PMATCH_INVERT = 0x80000000
2375:                
2376:                } eEthPMatchMode;
2377:                
2378:                
2379:                /*******************************************************************************
2380:                  Function:
2381:                    void EthRxFiltersSet ( eEthRxFilters rxFilters )
2382:                
2383:                  Summary:
2384:                    Sets the acceptance/rejection filters for the Ethernet receive.
2385:                
2386:                  Description:
2387:                    This function sets the acceptance/rejection filters for the Ethernet receive
2388:                    mechanism.  Multiple filters can be OR-ed together.  All filter specified
2389:                    in rxFilters will be set.
2390:                
2391:                  Precondition:
2392:                    This function should not be called when Ethernet RX operation is enabled.
2393:                
2394:                  Parameters:
2395:                    rxFilters       - RX filters that are to be set
2396:                
2397:                  Returns:
2398:                    None.
2399:                
2400:                  Example:
2401:                    <code>
2402:                    EthRxFiltersSet(ETH_FILT_CRC_ERR_REJECT | ETH_FILT_RUNT_REJECT  |
2403:                                    ETH_FILT_ME_UCAST_ACCEPT| ETH_FILT_MCAST_ACCEPT |
2404:                                    ETH_FILT_BCAST_ACCEPT   | ETH_FILT_NOTME_UCAST_ACCEPT);
2405:                    </code>
2406:                
2407:                  Remarks:
2408:                    All filters except Pattern Match can be set. Use EthRxFiltersPMSet().
2409:                
2410:                    Before enabling the Hash Table filter, the hash table values should be set
2411:                    using EthRxFiltersHTSet().
2412:                
2413:                    See the definition of the eEthRxFilters for the priority of the
2414:                    RX filters.
2415:                 *****************************************************************************/
2416:                
2417:                void EthRxFiltersSet ( eEthRxFilters rxFilters );
2418:                
2419:                
2420:                /*******************************************************************************
2421:                  Function:
2422:                    void EthRxFiltersClr ( eEthRxFilters rxFilters )
2423:                
2424:                  Summary:
2425:                    Clears the acceptance/rejection filters for the Ethernet receive.
2426:                
2427:                  Description:
2428:                    This function clears the acceptance/rejection filters for the Ethernet receive
2429:                    mechanism.  Multiple filters can be OR-ed together.  All filters specified
2430:                    in rxFilters will be cleared.
2431:                
2432:                  Precondition:
2433:                    This function should not be called when Ethernet RX operation is enabled.
2434:                
2435:                  Parameters:
2436:                    rxFilters       - RX filters that are to be cleared
2437:                
2438:                  Returns:
2439:                    None.
2440:                
2441:                  Example:
2442:                    <code>
2443:                    EthRxFiltersClr(ETH_FILT_ALL_FILTERS);
2444:                    </code>
2445:                
2446:                  Remarks:
2447:                    All filters except Pattern Match can be cleared. Use EthRxFiltersPMClr();
2448:                 *****************************************************************************/
2449:                
2450:                void EthRxFiltersClr ( eEthRxFilters rxFilters );
2451:                
2452:                
2453:                /*******************************************************************************
2454:                  Function:
2455:                    void EthRxFiltersWrite ( eEthRxFilters rxFilters )
2456:                
2457:                  Summary:
2458:                    Updates the acceptance/rejection filters for the Ethernet receive.
2459:                
2460:                  Description:
2461:                    This function updates the acceptance/rejection filters for the Ethernet receive
2462:                    mechanism to the required value.
2463:                
2464:                  Precondition:
2465:                    This function should not be called when Ethernet RX operation is enabled.
2466:                
2467:                  Parameters:
2468:                    rxFilters       - RX filters that are to be written
2469:                
2470:                  Returns:
2471:                    None.
2472:                
2473:                  Example:
2474:                    <code>
2475:                    EthRxFiltersWrite(ETH_FILT_ALL_FILTERS);
2476:                    </code>
2477:                
2478:                  Remarks:
2479:                    All filters except Pattern Match can be updated.
2480:                
2481:                    The Pattern Match filter will be disabled by this call.  Use
2482:                    EthRxFiltersPMSet();
2483:                
2484:                    Before enabling the Hash Table filter, the hash table values should be set
2485:                    using EthRxFiltersHTSet().
2486:                
2487:                    See the definition of the eEthRxFilters for the priority of the
2488:                    RX filters.
2489:                 *****************************************************************************/
2490:                
2491:                void EthRxFiltersWrite ( eEthRxFilters rxFilters );
2492:                
2493:                
2494:                /*******************************************************************************
2495:                  Function:
2496:                    void  EthRxFiltersHTSet ( unsigned long long htable )
2497:                
2498:                  Summary:
2499:                    Sets the hash table for the hash table RX filter.
2500:                
2501:                  Description:
2502:                    This function sets the hash table for the hash table RX filter.
2503:                
2504:                  Precondition:
2505:                    This function should not be called when Ethernet RX operation is enabled and the
2506:                    hash filter is active.
2507:                
2508:                  Parameters:
2509:                    htable      - The hash table itself
2510:                
2511:                  Returns:
2512:                    None.
2513:                
2514:                  Example:
2515:                    <code>
2516:                    </code>
2517:                
2518:                  Remarks:
2519:                    Properly set the hash table with this function before enabling the Hash
2520:                    Table filter.
2521:                 *****************************************************************************/
2522:                
2523:                void  EthRxFiltersHTSet ( unsigned long long htable );
2524:                
2525:                
2526:                /*******************************************************************************
2527:                  Function:
2528:                    void EthRxFiltersPMSet ( eEthPMatchMode mode, unsigned long long matchMask,
2529:                                             unsigned int matchOffs, unsigned int matchChecksum )
2530:                
2531:                  Summary:
2532:                    Enables the Pattern Match filter with the specified settings.
2533:                
2534:                  Description:
2535:                    This function enables the Pattern Match filter with the specified settings
2536:                    for the offset and window mask. The calculated checksum of the 64 bytes
2537:                    window starting at matchOffs and using the matchMask bytes in the window,
2538:                    is compared against matchChecksum.  If ETH_FILT_PMATCH_INVERT is used in
2539:                    the mode, then the calculated checksum must not match the passed
2540:                    matchChecksum in order for the Pattern Match to succeed.
2541:                
2542:                  Precondition:
2543:                    This function should not be called when Ethernet RX operation is enabled.
2544:                
2545:                  Parameters:
2546:                    mode            - The required Pattern Match Mode
2547:                
2548:                    matchMask       - Mask in the 64 byte window
2549:                
2550:                    matchOffs       - The offset applied to the incoming data (0 to 8128)
2551:                
2552:                    matchChecksum   - The 16 bit checksum used for comparison
2553:                
2554:                  Returns:
2555:                
2556:                  Example:
2557:                    <code>
2558:                    EthRxFiltersPMSet(ETH_FILT_PMATCH_ACCEPT, MY_PATTERN, 0, MY_CHECKSUM);
2559:                    </code>
2560:                
2561:                  Remarks:
2562:                    None.
2563:                 *****************************************************************************/
2564:                
2565:                void EthRxFiltersPMSet ( eEthPMatchMode mode, unsigned long long matchMask,
2566:                                         unsigned int matchOffs, unsigned int matchChecksum );
2567:                
2568:                
2569:                /*******************************************************************************
2570:                  Function:
2571:                    void EthRxFiltersPMClr ( void )
2572:                
2573:                  Summary:
2574:                    Disables the Pattern Match receive filter.
2575:                
2576:                  Description:
2577:                    This function disables the Pattern Match receive filter.
2578:                
2579:                  Precondition:
2580:                    This function should not be called when Ethernet RX operation is enabled.
2581:                
2582:                  Parameters:
2583:                    None.
2584:                
2585:                  Returns:
2586:                    None.
2587:                
2588:                  Example:
2589:                    <code>
2590:                    EthRxFiltersPMClr();
2591:                    </code>
2592:                
2593:                  Remarks:
2594:                    None.
2595:                 *****************************************************************************/
2596:                
2597:                void EthRxFiltersPMClr ( void );
2598:                
2599:                
2600:                // Section: Ethernet Event Functions
2601:                
2602:                // *****************************************************************************
2603:                /* Ethernet Event Flags
2604:                
2605:                  Summary:
2606:                    Ethernet event flags
2607:                
2608:                  Description:
2609:                    This enumeration defines flags for the possible Ethernet events that can
2610:                    cause interrupts.
2611:                */
2612:                
2613:                typedef enum
2614:                {
2615:                    // RX FIFO overflow
2616:                    ETH_EV_RXOVFLOW
2617:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXOVFLW_MASK /*DOM-IGNORE-END*/,
2618:                
2619:                    // RX buffer not available (descriptor overrun)
2620:                    ETH_EV_RXBUFNA
2621:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXBUFNA_MASK /*DOM-IGNORE-END*/,
2622:                
2623:                    // TX abort condition
2624:                    ETH_EV_TXABORT
2625:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_TXABORT_MASK /*DOM-IGNORE-END*/,
2626:                
2627:                    // TX done
2628:                    ETH_EV_TXDONE
2629:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_TXDONE_MASK  /*DOM-IGNORE-END*/,
2630:                
2631:                    // RX activity
2632:                    ETH_EV_RXACT
2633:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXACT_MASK   /*DOM-IGNORE-END*/,
2634:                
2635:                    // RX packet pending
2636:                    ETH_EV_PKTPEND
2637:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_PKTPEND_MASK /*DOM-IGNORE-END*/,
2638:                
2639:                    // RX packet successfully received
2640:                    ETH_EV_RXDONE
2641:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXDONE_MASK  /*DOM-IGNORE-END*/,
2642:                
2643:                    // Full watermark reached
2644:                    ETH_EV_FWMARK
2645:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_FWMARK_MASK  /*DOM-IGNORE-END*/,
2646:                
2647:                    // Empty watermark reached
2648:                    ETH_EV_EWMARK
2649:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_EWMARK_MASK  /*DOM-IGNORE-END*/,
2650:                
2651:                    // RX bus error
2652:                    ETH_EV_RXBUSERR
2653:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_RXBUSE_MASK  /*DOM-IGNORE-END*/,
2654:                
2655:                    // TX bus error
2656:                    ETH_EV_TXBUSERR
2657:                        /*DOM-IGNORE-BEGIN*/ = _ETHIRQ_TXBUSE_MASK  /*DOM-IGNORE-END*/,
2658:                
2659:                    // All events
2660:                    ETH_EV_ALL     = (ETH_EV_RXOVFLOW | ETH_EV_RXBUFNA | ETH_EV_TXABORT |
2661:                                      ETH_EV_TXDONE   | ETH_EV_RXACT   | ETH_EV_PKTPEND |
2662:                                      ETH_EV_RXDONE   | ETH_EV_FWMARK  | ETH_EV_EWMARK  |
2663:                                      ETH_EV_RXBUSERR | ETH_EV_TXBUSERR)
2664:                } eEthEvents;
2665:                
2666:                
2667:                /*******************************************************************************
2668:                  Function:
2669:                    void EthEventsEnableSet ( eEthEvents eEvents )
2670:                
2671:                  Summary:
2672:                    Enables the events that will generate interrupts for the Ethernet controller.
2673:                
2674:                  Description:
2675:                    The function enables the events that will generate interrupts for the Ethernet
2676:                    controller.  Multiple events can be OR-ed together.  Any event that is set
2677:                    in the eEvents will be enabled , the other events won't be touched.
2678:                
2679:                  Precondition:
2680:                    None.
2681:                
2682:                  Parameters:
2683:                    eEvents         - Events with the significance described in the eEthEvents
2684:                                      definition.
2685:                
2686:                  Returns:
2687:                    None.
2688:                
2689:                  Example:
2690:                    <code>
2691:                    EthEventsEnableSet(ETH_EV_ALL);
2692:                    </code>
2693:                
2694:                  Remarks:
2695:                    None.
2696:                 *****************************************************************************/
2697:                
2698:                void EthEventsEnableSet ( eEthEvents eEvents );
2699:                
2700:                
2701:                /*******************************************************************************
2702:                  Function:
2703:                    void EthEventsEnableClr ( eEthEvents eEvents )
2704:                
2705:                  Summary:
2706:                    Disables the events that will generate interrupts.
2707:                
2708:                  Description:
2709:                    The function disables the events that will generate interrupts for the Ethernet
2710:                    controller.  Multiple events can be OR-ed together.  Any event that is set
2711:                    in the eEvents will be disabled , the other events won't be touched.
2712:                
2713:                  Precondition:
2714:                    None.
2715:                
2716:                  Parameters:
2717:                    eEvents         - Events with the significance described in the eEthEvents
2718:                                      definition.
2719:                
2720:                  Returns:
2721:                    None.
2722:                
2723:                  Example:
2724:                    <code>
2725:                    EthEventsEnableClr(ETH_EV_ALL);
2726:                    </code>
2727:                
2728:                  Remarks:
2729:                    None.
2730:                 *****************************************************************************/
2731:                
2732:                void EthEventsEnableClr ( eEthEvents eEvents );
2733:                
2734:                
2735:                /*******************************************************************************
2736:                  Function:
2737:                    void EthEventsEnableWrite ( eEthEvents eEvents )
2738:                
2739:                  Summary:
2740:                    Enables the events that will generate interrupts for the Ethernet controller.
2741:                
2742:                  Description:
2743:                    This function enables the events that will generate interrupts for the Ethernet
2744:                    controller.  The enabled events are forced to the eEvents value.
2745:                
2746:                  Precondition:
2747:                    None.
2748:                
2749:                  Parameters:
2750:                    eEvents     - Events with the significance described in the eEthEvents
2751:                                  definition.
2752:                
2753:                  Returns:
2754:                    None.
2755:                
2756:                  Example:
2757:                    <code>
2758:                    EthEventsEnableWrite( ETH_EV_RXOVFLOW | ETH_EV_RXBUFNA | ETH_EV_TXABORT  |
2759:                                          ETH_EV_RXACT    | ETH_EV_PKTPEND | ETH_EV_RXBUSERR |
2760:                                          ETH_EV_TXBUSERR );
2761:                    </code>
2762:                
2763:                  Remarks:
2764:                    None.
2765:                 *****************************************************************************/
2766:                
2767:                void EthEventsEnableWrite ( eEthEvents eEvents );
2768:                
2769:                
2770:                /*******************************************************************************
2771:                  Function:
2772:                    eEthEvents EthEventsEnableGet ( void )
2773:                
2774:                  Summary:
2775:                    Returns the enabled events for the Ethernet controller.
2776:                
2777:                  Description:
2778:                    This function returns the enabled events for the Ethernet controller.
2779:                
2780:                  Precondition:
2781:                    None.
2782:                
2783:                  Parameters:
2784:                    None.
2785:                
2786:                  Returns:
2787:                    eEvents - events with the significance described in the eEthEvents
2788:                    definition.
2789:                
2790:                  Example:
2791:                    <code>
2792:                    ethEnabledEvents = EthEventsEnableGet();
2793:                    </code>
2794:                
2795:                  Remarks:
2796:                    None.
2797:                 *****************************************************************************/
2798:                
2799:                eEthEvents EthEventsEnableGet ( void );
2800:                
2801:                
2802:                /*******************************************************************************
2803:                  Function:
2804:                    void EthEventsClr ( eEthEvents eEvents )
2805:                
2806:                  Summary:
2807:                    Clears the selected events for the Ethernet controller.
2808:                
2809:                  Description:
2810:                    The function clears the selected events for the Ethernet controller.  Multiple
2811:                    events can be OR-ed together. Any event that is set in the eEvents will be
2812:                    cleared, the other events won't be touched.
2813:                
2814:                  Precondition:
2815:                    None.
2816:                
2817:                  Parameters:
2818:                    eEvents         - Events with the significance described in the eEthEvents
2819:                                      definition.
2820:                
2821:                  Returns:
2822:                    None.
2823:                
2824:                  Example:
2825:                    <code>
2826:                    EthEventsClr(ETH_EV_TXDONE);
2827:                    </code>
2828:                
2829:                  Remarks:
2830:                    The ETH_EV_FWMARK cannot be cleared directly. It is cleared indirectly by
2831:                    EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
2832:                
2833:                    The ETH_EV_EWMARK cannot be cleared directly. It is cleared by hardware when
2834:                    receiving a new packet.
2835:                
2836:                    The ETH_EV_PKTPEND cannot be cleared directly. It is cleared indirectly by
2837:                    EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
2838:                 *****************************************************************************/
2839:                
2840:                void EthEventsClr ( eEthEvents eEvents );
2841:                
2842:                // DOM-IGNORE-BEGIN
2843:                extern __inline__ void __attribute__((always_inline)) EthEventsClr(eEthEvents eEvents)
2844:                {
2845:                    ETHIRQCLR=eEvents;
2846:                }
2847:                // DOM-IGNORE-END
2848:                
2849:                
2850:                /*******************************************************************************
2851:                  Function:
2852:                    eEthEvents EthEventsGet ( void )
2853:                
2854:                  Summary:
2855:                    Returns the active events for the Ethernet controller.
2856:                
2857:                  Description:
2858:                    This function returns the active events for the Ethernet controller.
2859:                
2860:                  Precondition:
2861:                    None.
2862:                
2863:                  Parameters:
2864:                    None.
2865:                
2866:                  Returns:
2867:                    Events with the significance described in the eEthEvents definition.
2868:                
2869:                  Example:
2870:                    <code>
2871:                    ethEvents = EthEventsGet();
2872:                    </code>
2873:                
2874:                  Remarks:
2875:                    None.
2876:                 *****************************************************************************/
2877:                
2878:                eEthEvents EthEventsGet ( void );
2879:                
2880:                // DOM-IGNORE-BEGIN
2881:                extern __inline__ eEthEvents __attribute__((always_inline)) EthEventsGet(void)
2882:                {
2883:                    return (eEthEvents)ETHIRQ;
2884:                }
2885:                // DOM-IGNORE-END
2886:                
2887:                
2888:                // Section: Ethernet Statistics Functions
2889:                
2890:                /*******************************************************************************
2891:                  Function:
2892:                    int EthStatRxOvflCnt ( void )
2893:                
2894:                  Summary:
2895:                    Returns the current number of dropped receive frames.
2896:                
2897:                  Description:
2898:                    This function returns the current number of dropped receive frames by the
2899:                    Ethernet controller.  These are frames accepted by the RX filter but dropped due
2900:                    to internal receive error (RX FIFO overrun).
2901:                
2902:                  Precondition:
2903:                    None.
2904:                
2905:                  Parameters:
2906:                    None.
2907:                
2908:                  Returns:
2909:                    The number of dropped receive frames
2910:                
2911:                  Example:
2912:                    <code>
2913:                    droppedFrames = EthStatRxOvflCnt();
2914:                    </code>
2915:                
2916:                  Remarks:
2917:                    This statistics register is cleared by the read operation.
2918:                
2919:                    An RX overflow event is signalled by the ETH_EV_RXOVFLOW event (see
2920:                    eEthEvents definition).
2921:                 *****************************************************************************/
2922:                
2923:                int EthStatRxOvflCnt ( void );
2924:                
2925:                // DOM-IGNORE-BEGIN
2926:                #define EthStatRxOvflCnt()  (ETHRXOVFLOW)
2927:                // DOM-IGNORE-END
2928:                
2929:                
2930:                /*******************************************************************************
2931:                  Function:
2932:                    int EthStatRxOkCnt ( void )
2933:                
2934:                  Summary:
2935:                    Returns the current number of successfully received frames.
2936:                
2937:                  Description:
2938:                    This function returns the current number of successfully received frames by
2939:                    the Ethernet controller.  These are frames accepted by the RX filter (some of
2940:                    them may still be dropped because of an RX FIFO overrun).
2941:                
2942:                  Precondition:
2943:                    None.
2944:                
2945:                  Parameters:
2946:                    None.
2947:                
2948:                  Returns:
2949:                    The number of frames received OK
2950:                
2951:                  Example:
2952:                    <code>
2953:                    numReceived = EthStatRxOkCnt();
2954:                    </code>
2955:                
2956:                  Remarks:
2957:                    This statistics register is cleared by the read operation.
2958:                
2959:                    Frames with FCS or alignment errors will not increment this count.
2960:                 *****************************************************************************/
2961:                
2962:                int EthStatRxOkCnt ( void );
2963:                
2964:                // DOM-IGNORE-BEGIN
2965:                #define     EthStatRxOkCnt()    (ETHFRMRXOK)
2966:                // DOM-IGNORE-END
2967:                
2968:                
2969:                /*******************************************************************************
2970:                  Function:
2971:                    int EthStatRxFcsErrCnt ( void )
2972:                
2973:                  Summary:
2974:                    Returns the current number of frames with FCS received errors.
2975:                
2976:                  Description:
2977:                    The function returns the current number of frames with FCS errors received
2978:                    by the Ethernet controller.  These are received frames that have an integral
2979:                    number of bytes.
2980:                
2981:                  Precondition:
2982:                    None.
2983:                
2984:                  Parameters:
2985:                    None.
2986:                
2987:                  Returns:
2988:                    The number of received frames having FCS errors
2989:                
2990:                  Example:
2991:                    <code>
2992:                    numRxFcsErrors = EthStatRxFcsErrCnt();
2993:                    </code>
2994:                
2995:                  Remarks:
2996:                    This statistics register is cleared by the read operation.
2997:                
2998:                    Frames with alignment error do not increment this count.
2999:                 *****************************************************************************/
3000:                
3001:                int EthStatRxFcsErrCnt ( void );
3002:                
3003:                // DOM-IGNORE-BEGIN
3004:                #define     EthStatRxFcsErrCnt()    (ETHFCSERR)
3005:                // DOM-IGNORE-END
3006:                
3007:                
3008:                /*******************************************************************************
3009:                  Function:
3010:                    int EthStatRxAlgnErrCnt ( void )
3011:                
3012:                  Summary:
3013:                    Returns the current number of frames with alignment received errors
3014:                
3015:                  Description:
3016:                    The function returns the current number of frames with alignment errors
3017:                    received by the Ethernet controller.  These are received frames that have FCS
3018:                    error and they do not contain an integral number of bytes (aka
3019:                    dribble-nibble).
3020:                
3021:                  Precondition:
3022:                    None.
3023:                
3024:                  Parameters:
3025:                    None.
3026:                
3027:                  Returns:
3028:                    The number of received frames having alignment errors
3029:                
3030:                  Example:
3031:                    <code>
3032:                    numAlignErrors = EthStatRxAlgnErrCnt();
3033:                    </code>
3034:                
3035:                  Remarks:
3036:                    This statistics register is cleared by the read operation.
3037:                 *****************************************************************************/
3038:                
3039:                int EthStatRxAlgnErrCnt ( void );
3040:                
3041:                // DOM-IGNORE-BEGIN
3042:                #define     EthStatRxAlgnErrCnt()   (ETHALGNERR)
3043:                // DOM-IGNORE-END
3044:                
3045:                
3046:                /*******************************************************************************
3047:                  Function:
3048:                    int EthStatTxOkCnt ( void )
3049:                
3050:                  Summary:
3051:                    Returns the current number of frames transmitted successfully
3052:                
3053:                  Description:
3054:                    The function returns the current number of frames transmitted successfully by
3055:                    the Ethernet controller.
3056:                
3057:                  Precondition:
3058:                    None.
3059:                
3060:                  Parameters:
3061:                    None.
3062:                
3063:                  Returns:
3064:                    The number of frames transmitted OK
3065:                
3066:                  Example:
3067:                    <code>
3068:                    numFramesTx = EthStatTxOkCnt();
3069:                    </code>
3070:                
3071:                  Remarks:
3072:                    This statistics register is cleared by the read operation.
3073:                 *****************************************************************************/
3074:                
3075:                int EthStatTxOkCnt ( void );
3076:                
3077:                // DOM-IGNORE-BEGIN
3078:                #define     EthStatTxOkCnt()    (ETHFRMTXOK)
3079:                // DOM-IGNORE-END
3080:                
3081:                
3082:                /*******************************************************************************
3083:                  Function:
3084:                    int EthStatTxSColCnt ( void )
3085:                
3086:                  Summary:
3087:                    Returns the current number of successfully transmitted frames on the second try
3088:                
3089:                  Description:
3090:                    This function returns the current number of transmitted frames that had
3091:                    a collision but were successfully transmitted by the Ethernet controller
3092:                    on the second try.
3093:                
3094:                  Precondition:
3095:                    None.
3096:                
3097:                  Parameters:
3098:                    None.
3099:                
3100:                  Returns:
3101:                    The number of single collision frames
3102:                
3103:                  Example:
3104:                    <code>
3105:                    numSingleCollisions = EthStatTxSColCnt();
3106:                    </code>
3107:                
3108:                  Remarks:
3109:                    This statistics register is cleared by the read operation.
3110:                 *****************************************************************************/
3111:                
3112:                int EthStatTxSColCnt ( void );
3113:                
3114:                // DOM-IGNORE-BEGIN
3115:                #define     EthStatTxSColCnt()  (ETHSCOLFRM)
3116:                // DOM-IGNORE-END
3117:                
3118:                
3119:                /*******************************************************************************
3120:                  Function:
3121:                    int EthStatTxMColCnt( void )
3122:                
3123:                  Summary:
3124:                    Returns the number of current frames transmitted after more than one
3125:                    collision occurred.
3126:                
3127:                  Description:
3128:                    The function returns the current number of frames successfully transmitted
3129:                    by the Ethernet controller after there was more than one collision.
3130:                
3131:                  Precondition:
3132:                    None.
3133:                
3134:                  Parameters:
3135:                    None.
3136:                
3137:                  Returns:
3138:                    The number of multiple collision frames
3139:                
3140:                  Example:
3141:                    <code>
3142:                    numMultiCollisions = EthStatTxMColCnt();
3143:                    </code>
3144:                
3145:                  Remarks:
3146:                    This statistics register is cleared by the read operation.
3147:                 *****************************************************************************/
3148:                
3149:                int EthStatTxMColCnt( void );
3150:                
3151:                // DOM-IGNORE-BEGIN
3152:                #define     EthStatTxMColCnt()  (ETHMCOLFRM)
3153:                // DOM-IGNORE-END
3154:                
3155:                
3156:                // Section: MIIM Access Functions
3157:                
3158:                /*******************************************************************************
3159:                  Function:
3160:                    void EthMIIMConfig ( unsigned int hostClock, unsigned int miimClock )
3161:                
3162:                  Summary:
3163:                    Configures and initializes the MIIM interface clock
3164:                
3165:                  Description:
3166:                    This function initializes and configures the MIIM interface for access of a PHY.
3167:                
3168:                  Precondition:
3169:                    None.
3170:                
3171:                  Parameters:
3172:                    hostClock       - The value of the host clock, Hz
3173:                
3174:                    miimClock       - The maximum clock frequency that the PHY can use for the
3175:                                      MIIM transactions, Hz
3176:                
3177:                  Returns:
3178:                    None.
3179:                
3180:                  Example:
3181:                    <code>
3182:                    EthMIIMConfig(MY_HOST_CLOCK_HZ, MY_MIIM_CLOCK_HZ);
3183:                    </code>
3184:                
3185:                  Remarks:
3186:                    Any previous MIIM operation will be aborted!
3187:                 *****************************************************************************/
3188:                
3189:                void EthMIIMConfig ( unsigned int hostClock, unsigned int miimClock );
3190:                
3191:                
3192:                /*******************************************************************************
3193:                  Function:
3194:                    void EthMIIMReadStart ( unsigned int rIx, unsigned int phyAdd )
3195:                
3196:                  Summary:
3197:                    Initiates a read operation from a PHY register
3198:                
3199:                  Description:
3200:                    This function initiates a read operation from a PHY register using the MIIM
3201:                    interface.  It returns immediately without waiting for the transactions to
3202:                    be performed.
3203:                
3204:                  Precondition:
3205:                    EthMIIMConfig() called
3206:                
3207:                    rIx a valid PHY register, 0-31
3208:                
3209:                    phyAdd a valid PHY address, 0-31
3210:                
3211:                  Parameters:
3212:                    rIx         - PHY register to be accessed
3213:                
3214:                    phyAdd      - PHY address
3215:                
3216:                  Returns:
3217:                    None.
3218:                
3219:                  Example:
3220:                    <code>
3221:                    while(EthMIIMBusy());   // wait device not busy
3222:                    EthMIIMReadStart(12, 1);
3223:                    </code>
3224:                
3225:                  Remarks:
3226:                    It assumes that no scan operation is in progress!
3227:                
3228:                    Before initiating the read operation it waits for the MIIM interface not busy.
3229:                    Call EthMIIMBusy() before if no polling needed!
3230:                 *****************************************************************************/
3231:                
3232:                void EthMIIMReadStart ( unsigned int rIx, unsigned int phyAdd );
3233:                
3234:                
3235:                /*******************************************************************************
3236:                  Function:
3237:                    unsigned short EthMIIMReadResult ( void )
3238:                
3239:                  Summary:
3240:                    Returns the result of a previously started read operation
3241:                
3242:                  Description:
3243:                    This function returns the result of a previously started read operation
3244:                    (using EthMIIMReadStart()).
3245:                
3246:                  Precondition:
3247:                    EthMIIMConfig() called
3248:                
3249:                    EthMIIMReadStart() called
3250:                
3251:                  Parameters:
3252:                    None.
3253:                
3254:                  Returns:
3255:                    PHY register value
3256:                
3257:                  Example:
3258:                    <code>
3259:                    while(EthMIIMBusy());   // wait read operation complete
3260:                    regValue = EthMIIMReadResult();
3261:                    </code>
3262:                
3263:                  Remarks:
3264:                    It assumes that no scan operation is in progress!
3265:                
3266:                    It waits for the read operation to be complete.
3267:                    Call EthMIIMBusy() before if no polling needed!
3268:                 *****************************************************************************/
3269:                
3270:                unsigned short EthMIIMReadResult ( void );
3271:                
3272:                
3273:                /*******************************************************************************
3274:                  Function:
3275:                    void EthMIIMWriteStart ( unsigned int rIx, unsigned int phyAdd,
3276:                                           unsigned short wData )
3277:                
3278:                  Summary:
3279:                    Performs a write operation to a PHY register
3280:                
3281:                  Description:
3282:                    This function performs a write operation to a PHY register using the MIIM
3283:                    interface.  It doesn't wait for the write to take effect.
3284:                
3285:                  Precondition:
3286:                    EthMIIMConfig() called
3287:                
3288:                    rIx a valid PHY register, 0-31
3289:                
3290:                    phyAdd a valid PHY address, 0-31
3291:                
3292:                  Parameters:
3293:                    rIx         - PHY register to be accessed
3294:                
3295:                    phyAdd      - PHY address
3296:                
3297:                    wData       - Data to be written
3298:                
3299:                  Returns:
3300:                    None.
3301:                
3302:                  Example:
3303:                    <code>
3304:                    EthMIIMWriteStart(12, 1, 0x001F);
3305:                    </code>
3306:                
3307:                  Remarks:
3308:                    It assumes that no scan operation is in progress!
3309:                
3310:                    Before initiating the write operation it waits for the MIIM interface not busy.
3311:                    Call EthMIIMBusy() before if no polling needed!
3312:                
3313:                    After write started call EthMIIMBusy() to check if the operation
3314:                    has been completed.
3315:                 *****************************************************************************/
3316:                
3317:                void EthMIIMWriteStart ( unsigned int rIx, unsigned int phyAdd, unsigned short wData );
3318:                
3319:                
3320:                
3321:                /*******************************************************************************
3322:                  Function:
3323:                    void EthMIIMScanStart ( unsigned int rIx, unsigned int phyAdd )
3324:                
3325:                  Summary:
3326:                    Initiates a scan operation to a PHY register
3327:                
3328:                  Description:
3329:                    This function initiates a scan operation to a PHY register using the MIIM
3330:                    interface.
3331:                
3332:                  Precondition:
3333:                    EthMIIMConfig() called
3334:                
3335:                    rIx a valid PHY register, 0-31
3336:                
3337:                    phyAdd a valid PHY address, 0-31
3338:                
3339:                  Parameters:
3340:                    rIx         - PHY register to be accessed
3341:                
3342:                    phyAdd      - PHY address
3343:                
3344:                  Returns:
3345:                    None.
3346:                
3347:                  Example:
3348:                    <code>
3349:                    while(EthMIIMBusy());   // wait device not busy
3350:                    EthMIIMScanStart(12, 1);
3351:                    </code>
3352:                
3353:                  Remarks:
3354:                    It assumes that no scan operation is in progress!
3355:                
3356:                    Before initiating the scan operation it waits for the MIIM interface not busy.
3357:                    Call EthMIIMBusy() before if no polling needed!
3358:                 *****************************************************************************/
3359:                
3360:                void EthMIIMScanStart ( unsigned int rIx, unsigned int phyAdd );
3361:                
3362:                
3363:                /*******************************************************************************
3364:                  Function:
3365:                    unsigned short  EthMIIMScanResult ( void )
3366:                
3367:                  Summary:
3368:                    Reads the result of a previously initiated scan operation
3369:                
3370:                  Description:
3371:                    This function reads the result of a previously initiated scan operation
3372:                    from a PHY register using the MIIM interface.
3373:                
3374:                  Precondition:
3375:                    EthMIIMConfig() called
3376:                
3377:                    EthMIIMScanStart() called
3378:                
3379:                  Parameters:
3380:                    None.
3381:                
3382:                  Returns:
3383:                    Result of previous scan operation
3384:                
3385:                  Example:
3386:                    <code>
3387:                    if ( EthMIIMScanValid() )
3388:                    {
3389:                        value = EthMIIMScanResult();
3390:                    }
3391:                    </code>
3392:                
3393:                  Remarks:
3394:                    It assumes that a scan operation is in progress!
3395:                
3396:                    Before returning it waits for the scan result to be valid.
3397:                    Call EthMIIMScanValid() before if no polling needed!
3398:                 *****************************************************************************/
3399:                
3400:                unsigned short EthMIIMScanResult ( void );
3401:                
3402:                
3403:                /*******************************************************************************
3404:                  Function:
3405:                    void EthMIIMScanStop ( void )
3406:                
3407:                  Summary:
3408:                    Stops a previously initiated scan operation
3409:                
3410:                  Description:
3411:                    This function stops a previously initiated scan operation from a PHY
3412:                    register using the MIIM interface.  It doesn't wait for the scan operation
3413:                    to finish.
3414:                
3415:                  Precondition:
3416:                    EthMIIMConfig() called
3417:                
3418:                    EthMIIMScanStart() called
3419:                
3420:                  Parameters:
3421:                    None.
3422:                
3423:                  Returns:
3424:                    None.
3425:                
3426:                  Example:
3427:                    <code>
3428:                    EthMIIMScanStop();
3429:                    while(EthMIIMBusy());   // wait scan stop is in effect
3430:                    </code>
3431:                
3432:                  Remarks:
3433:                    It assumes that a scan operation is in progress!
3434:                
3435:                    After call use EthMIIMBusy() to check if the scan
3436:                    has been effectively stopped.
3437:                 *****************************************************************************/
3438:                
3439:                void EthMIIMScanStop ( void );
3440:                
3441:                // DOM-IGNORE-BEGIN
3442:                extern __inline__ void __attribute__((always_inline)) EthMIIMScanStop(void)
3443:                {
3444:                    EMACxMCMD=0;            // cancel scan
3445:                }
3446:                // DOM-IGNORE-END
3447:                
3448:                
3449:                /*******************************************************************************
3450:                  Function:
3451:                    int EthMIIMScanValid ( void )
3452:                
3453:                  Summary:
3454:                    Returns the current state of the MIIM scan operation
3455:                
3456:                  Description:
3457:                    This function returns the current validity state of the MIIM scan operation.
3458:                
3459:                  Precondition:
3460:                    EthMIIMConfig() called
3461:                
3462:                    EthMIIMScanStart() called
3463:                
3464:                  Parameters:
3465:                    None.
3466:                
3467:                  Returns:
3468:                    TRUE        - If the result of a MIIM scan result is valid
3469:                
3470:                    FALSE       - Otherwise
3471:                
3472:                  Example:
3473:                    <code>
3474:                    if ( !EthMIIMScanValid()) )
3475:                    {
3476:                        // Handle invalid scan
3477:                    }
3478:                    </code>
3479:                
3480:                  Remarks:
3481:                    None.
3482:                 *****************************************************************************/
3483:                
3484:                int EthMIIMScanValid ( void );
3485:                
3486:                // DOM-IGNORE-BEGIN
3487:                extern __inline__ int __attribute__((always_inline)) EthMIIMScanValid(void)
3488:                {
3489:                    return EMACxMINDbits.NOTVALID==0;
3490:                }
3491:                // DOM-IGNORE-END
3492:                
3493:                
3494:                /*******************************************************************************
3495:                  Function:
3496:                    int EthMIIMBusy ( void )
3497:                
3498:                  Summary:
3499:                    Returns the current busy state of the MIIM interface
3500:                
3501:                  Description:
3502:                    This function returns the current busy state of the MIIM interface.
3503:                
3504:                  Precondition:
3505:                    EthMIIMConfig() called
3506:                
3507:                  Parameters:
3508:                    None.
3509:                
3510:                  Returns:
3511:                    TRUE        - If the MIIM is busy with some transaction
3512:                
3513:                    FALSE       - Otherwise
3514:                
3515:                  Example:
3516:                    <code>
3517:                    do
3518:                    {
3519:                        ; // Nothing
3520:                
3521:                    } while ( EthMIIMBusy() );
3522:                    </code>
3523:                
3524:                  Remarks:
3525:                    Use EthMIIMBusy() to check:
3526:                        - if a read/write/scan operation can be started
3527:                        - if a read/write operation has been completed
3528:                        - if a scan operation has been stopped
3529:                 *****************************************************************************/
3530:                
3531:                int EthMIIMBusy ( void );
3532:                
3533:                // DOM-IGNORE-BEGIN
3534:                extern __inline__ int __attribute__((always_inline)) EthMIIMBusy(void)
3535:                {
3536:                    return EMACxMINDbits.MIIMBUSY!=0;
3537:                }
3538:                // DOM-IGNORE-END
3539:                
3540:                
3541:                // Section:  Ethernet Controller Low Level Access Functions
3542:                
3543:                // *****************************************************************************
3544:                /* Ethernet Configuration Flags
3545:                
3546:                  Summary:
3547:                    Defines the Ethernet configuration flags
3548:                
3549:                  Description:
3550:                    This enumeration defines the Ethernet configuration flags.
3551:                */
3552:                
3553:                typedef enum
3554:                {
3555:                    // Configure manual flow control
3556:                    ETH_CONFIG_MANFC
3557:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_MANFC_MASK   /*DOM-IGNORE-END*/,
3558:                
3559:                    // Configure auto flow control
3560:                    ETH_CONFIG_AUTOFC
3561:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_AUTOFC_MASK  /*DOM-IGNORE-END*/,
3562:                
3563:                    // RX enabled
3564:                    ETH_CONFIG_RXEN
3565:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_RXEN_MASK    /*DOM-IGNORE-END*/,
3566:                
3567:                    // Activate the TX logic and send packets
3568:                    ETH_CONFIG_TXRTS
3569:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_TXRTS_MASK   /*DOM-IGNORE-END*/,
3570:                
3571:                    // Stop in idle
3572:                    ETH_CONFIG_SIDL
3573:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_SIDL_MASK    /*DOM-IGNORE-END*/,
3574:                
3575:                    // Turn on/off the Ethernet controller
3576:                    ETH_CONFIG_ON
3577:                        /*DOM-IGNORE-BEGIN*/ = _ETHCON1_ON_MASK      /*DOM-IGNORE-END*/
3578:                
3579:                } eEthConfigFlags;
3580:                
3581:                
3582:                
3583:                /*******************************************************************************
3584:                  Function:
3585:                    void EthEnable ( int enable )
3586:                
3587:                  Summary:
3588:                    Gives access to low level Ethernet controller configuration.
3589:                
3590:                  Description:
3591:                    The function gives access to low level Ethernet controller configuration.  It can
3592:                    turn on/off the controller.
3593:                
3594:                  Precondition:
3595:                    None.
3596:                
3597:                  Parameters:
3598:                    enable      - Boolean to enable/disable the Ethernet Controller.
3599:                
3600:                  Returns:
3601:                    None.
3602:                
3603:                  Example:
3604:                    <code>
3605:                    EthEnable(FALSE);
3606:                    </code>
3607:                
3608:                  Remarks:
3609:                    The Ethernet controller should be disabled before being configured.
3610:                 *****************************************************************************/
3611:                
3612:                void EthEnable ( int enable );
3613:                
3614:                
3615:                /*******************************************************************************
3616:                  Function:
3617:                    void EthConfig ( eEthConfigFlags cFlags )
3618:                
3619:                  Summary:
3620:                    Configures the Ethernet Controller.
3621:                
3622:                  Description:
3623:                    The function gives access to low level Ethernet controller configuration.  It
3624:                    configures the Ethernet Controller.
3625:                
3626:                  Precondition:
3627:                    The Ethernet controller must be disabled.
3628:                
3629:                  Parameters:
3630:                    cFlags      - Configuration flags
3631:                
3632:                  Returns:
3633:                    None.
3634:                
3635:                  Example:
3636:                    <code>
3637:                    EthEnable(FALSE);
3638:                    EthConfig(ETH_CONFIG_MANFC|ETH_CONFIG_RXEN|ETH_CONFIG_SIDL);
3639:                    EthEnable(TRUE);
3640:                    </code>
3641:                
3642:                  Remarks:
3643:                    The Ethernet controller should be configured when disabled.
3644:                 *****************************************************************************/
3645:                
3646:                void EthConfig ( eEthConfigFlags cFlags );
3647:                
3648:                
3649:                /*******************************************************************************
3650:                  Function:
3651:                    void EthConfigSetFlags ( eEthConfigFlags cFlags )
3652:                
3653:                  Summary:
3654:                    Sets Ethernet controller configuration flags.
3655:                
3656:                  Description:
3657:                    The function gives access to low level Ethernet controller configuration.  Any
3658:                    flag set in the cFlags will be set, the other flags won't be touched.
3659:                
3660:                  Precondition:
3661:                    The Ethernet controller must be disabled.
3662:                
3663:                  Parameters:
3664:                    cFlags      - Configuration flags to be set
3665:                
3666:                  Returns:
3667:                    None.
3668:                
3669:                  Example:
3670:                    <code>
3671:                    EthEnable(FALSE);
3672:                    EthConfigSetFlags(ETH_CONFIG_MANFC|ETH_CONFIG_RXEN|ETH_CONFIG_SIDL);
3673:                    EthEnable(TRUE);
3674:                    </code>
3675:                
3676:                  Remarks:
3677:                    The Ethernet controller should be configured when disabled.
3678:                 *****************************************************************************/
3679:                
3680:                void EthConfigSetFlags ( eEthConfigFlags cFlags );
3681:                
3682:                
3683:                /*******************************************************************************
3684:                  Function:
3685:                    void EthConfigClrFlags ( eEthConfigFlags cFlags )
3686:                
3687:                  Summary:
3688:                    Clears Ethernet controller configuration flags.
3689:                
3690:                  Description:
3691:                    The function gives access to low level Ethernet controller configuration.  Any
3692:                    flag set in the cFlags will be cleared, the other flags won't be touched.
3693:                
3694:                  Precondition:
3695:                    The Ethernet controller must be disabled.
3696:                
3697:                  Parameters:
3698:                    cFlags      - Configuration flags to be cleared
3699:                
3700:                  Returns:
3701:                    None.
3702:                
3703:                  Example:
3704:                    <code>
3705:                    EthEnable(FALSE);
3706:                    EthConfigClrFlags(ETH_CONFIG_MANFC|ETH_CONFIG_RXEN|ETH_CONFIG_SIDL);
3707:                    EthEnable(TRUE);
3708:                    </code>
3709:                
3710:                  Remarks:
3711:                    The Ethernet controller should be configured when disabled.
3712:                 *****************************************************************************/
3713:                
3714:                void EthConfigClrFlags ( eEthConfigFlags cFlags );
3715:                
3716:                
3717:                /*******************************************************************************
3718:                  Function:
3719:                    void EthConfigTxStAddress ( void *address )
3720:                
3721:                  Summary:
3722:                    Sets the address of the TX descriptors.
3723:                
3724:                  Description:
3725:                    The function gives access to low level Ethernet controller configuration.  It
3726:                    sets the address of the TX descriptors in memory.
3727:                
3728:                  Precondition:
3729:                    There must not be a transmit or DMA engine operation in progress.
3730:                
3731:                  Parameters:
3732:                    address     - Starting physical address of the first TX descriptor
3733:                
3734:                  Returns:
3735:                    None.
3736:                
3737:                  Example:
3738:                    <code>
3739:                    EthConfigTxStAddress(VirtToPhys(myTxDcpt));
3740:                    </code>
3741:                
3742:                  Remarks:
3743:                    The address must be 4-byte aligned.
3744:                
3745:                    The address must be a physical address.
3746:                
3747:                    The address must not be written while any transmit or DMA engine operations are
3748:                    in progress.
3749:                 *****************************************************************************/
3750:                
3751:                void EthConfigTxStAddress ( void *address );
3752:                
3753:                
3754:                /*******************************************************************************
3755:                  Function:
3756:                    void EthConfigRxStAddress ( void *address )
3757:                
3758:                  Summary:
3759:                    Sets the address of the RX descriptors in memory.
3760:                
3761:                  Description:
3762:                    The function gives access to low level Ethernet controller configuration.  It
3763:                    sets the address of the RX descriptors in memory.
3764:                
3765:                  Precondition:
3766:                    There must not be a receive or DMA engine operation in progress.
3767:                
3768:                  Parameters:
3769:                    address     - Starting physical address of the first RX descriptor
3770:                
3771:                  Returns:
3772:                    None.
3773:                
3774:                  Example:
3775:                    <code>
3776:                    EthConfigRxStAddress(VirtToPhys(myRxDcpt));
3777:                    </code>
3778:                
3779:                  Remarks:
3780:                    The address must be 4-byte aligned.
3781:                
3782:                    The address must be a physical address.
3783:                
3784:                    The address must not be written while any receive or DMA engine operations are in
3785:                    progress.
3786:                 *****************************************************************************/
3787:                
3788:                void EthConfigRxStAddress ( void *address );
3789:                
3790:                
3791:                /*******************************************************************************
3792:                  Function:
3793:                    void EthAckRxDcpt ( void )
3794:                
3795:                  Summary:
3796:                    Acknowledges a RX descriptor.
3797:                
3798:                  Description:
3799:                    The function gives access to low level Ethernet controller functionality.
3800:                    It acknowledges a receiver descriptor.  When called, the number
3801:                    of un-acknowledged RX descriptors(BUFCNT=EthDescriptorsGetRxUnack()) will
3802:                    be decremented by one.
3803:                
3804:                  Precondition:
3805:                    The RX packet associated with the corresponding descriptor must have already been processed
3806:                    and the RX descriptor should be available for the hardware DMA RX engine re-use.
3807:                
3808:                  Parameters:
3809:                    None.
3810:                
3811:                  Returns:
3812:                    None.
3813:                
3814:                  Example:
3815:                    <code>
3816:                    EthAckRxDcpt();
3817:                    </code>
3818:                
3819:                  Remarks:
3820:                    The function should be called after a RX packet is processed and the RX
3821:                    descriptor is available for the hardware re-use.
3822:                
3823:                    BUFCNT is also decremented by a call to EthRxAcknowledgePacket/EthRxAcknowledgeBuffer.
3824:                
3825:                    BUFCNT value also directs the auto flow control behavior.
3826:                 *****************************************************************************/
3827:                
3828:                void EthAckRxDcpt ( void );
3829:                
3830:                // DOM-IGNORE-BEGIN
3831:                extern __inline__ void __attribute__((always_inline))   EthAckRxDcpt(void)
3832:                {
3833:                    ETHCON1SET=_ETHCON1_BUFCDEC_MASK;
3834:                }
3835:                // DOM-IGNORE-END
3836:                
3837:                
3838:                // Section:  Ethernet MAC Low Level Access Functions
3839:                
3840:                // *****************************************************************************
3841:                /* Ethernet MAC Configuration 1 Flags
3842:                
3843:                  Summary:
3844:                    Ethernet MAC configuration flags (set 1)
3845:                
3846:                  Description:
3847:                    This enumeration defines set 1 of the Ethernet MAC configuration flags.
3848:                
3849:                  Remarks:
3850:                    These flags can be OR-ed together to create configuration mask values.
3851:                */
3852:                
3853:                typedef enum
3854:                {
3855:                    // Enable RX
3856:                    ETH_MAC_CONFIG1_RXEN
3857:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RXENABLE_MASK  /*DOM-IGNORE-END*/,
3858:                
3859:                    // Pass all RX frames (normal and control)
3860:                    ETH_MAC_CONFIG1_PASS_ALL
3861:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_PASSALL_MASK   /*DOM-IGNORE-END*/,
3862:                
3863:                    // Enable acting on RX-ed PAUSE control frames
3864:                    ETH_MAC_CONFIG1_RX_PAUSE
3865:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RXPAUSE_MASK   /*DOM-IGNORE-END*/,
3866:                
3867:                    // Enable TX of PAUSE control frames
3868:                    ETH_MAC_CONFIG1_TX_PAUSE
3869:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_TXPAUSE_MASK   /*DOM-IGNORE-END*/,
3870:                
3871:                    // Enable the loopback mode
3872:                    ETH_MAC_CONFIG1_LOOPBACK
3873:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_LOOPBACK_MASK  /*DOM-IGNORE-END*/,
3874:                
3875:                    // Put the TX logic in reset
3876:                    ETH_MAC_CONFIG1_RESET_TFUN
3877:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETTFUN_MASK /*DOM-IGNORE-END*/,
3878:                
3879:                    // Put the MAC Control SUblayer/TX domain logic in reset
3880:                    ETH_MAC_CONFIG1_RESET_TMCS
3881:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETTMCS_MASK /*DOM-IGNORE-END*/,
3882:                
3883:                    // Put the RX logic in reset
3884:                    ETH_MAC_CONFIG1_RESET_RFUN
3885:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETRFUN_MASK /*DOM-IGNORE-END*/,
3886:                
3887:                    // Put the MAC Control SUblayer/RX domain logic in reset
3888:                    ETH_MAC_CONFIG1_RESET_RMCS
3889:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_RESETRMCS_MASK /*DOM-IGNORE-END*/,
3890:                
3891:                    // Reset the random generator within the TX function
3892:                    ETH_MAC_CONFIG1_RESET_SIM
3893:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_SIMRESET_MASK  /*DOM-IGNORE-END*/,
3894:                
3895:                    // Put the MAC in reset
3896:                    ETH_MAC_CONFIG1_RESET_MAC
3897:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG1_SOFTRESET_MASK /*DOM-IGNORE-END*/
3898:                
3899:                } eEthMACConfig1Flags;
3900:                
3901:                
3902:                // *****************************************************************************
3903:                /* Ethernet MAC Configuration 2 Flags
3904:                
3905:                  Summary:
3906:                    Ethernet MAC configuration flags (set 2)
3907:                
3908:                  Description:
3909:                    This enumeration defines set 2 of the Ethernet MAC configuration flags.
3910:                
3911:                  Remarks:
3912:                    These flags can be OR-ed together to create configuration mask values.
3913:                
3914:                    If disabled the MAC will abort when the excessive deferral limit is reached
3915:                    and provide feedback to the host system.
3916:                */
3917:                
3918:                typedef enum
3919:                {
3920:                    // Enable full duplex functionality
3921:                    ETH_MAC_CONFIG2_FDUPLEX
3922:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_FULLDPLX_MASK  /*DOM-IGNORE-END*/,
3923:                
3924:                    // Enable length frame check
3925:                    ETH_MAC_CONFIG2_LEN_CHECK
3926:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_LENGTHCK_MASK  /*DOM-IGNORE-END*/,
3927:                
3928:                    // Enable huge frames RX/TX
3929:                    ETH_MAC_CONFIG2_HUGE_FRAME
3930:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_HUGEFRM_MASK   /*DOM-IGNORE-END*/,
3931:                
3932:                    // Enable 4 bytes of proprietary header (ignored by the CRC)
3933:                    ETH_MAC_CONFIG2_DELAY_CRC
3934:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_DELAYCRC_MASK  /*DOM-IGNORE-END*/,
3935:                
3936:                    // Enable CRC append to each TX frame
3937:                    ETH_MAC_CONFIG2_CRC_ENABLE
3938:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_CRCENABLE_MASK /*DOM-IGNORE-END*/,
3939:                
3940:                    // PAD/CRC enable used together with ETH_MAC_CONFIG2_VLAN_PAD and
3941:                    // ETH_MAC_CONFIG2_AUTO_PAD
3942:                    ETH_MAC_CONFIG2_PAD_ENABLE
3943:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_PADENABLE_MASK /*DOM-IGNORE-END*/,
3944:                
3945:                    // Enable padding of al frames to 64 bytes and append valid CRC
3946:                    ETH_MAC_CONFIG2_VLAN_PAD
3947:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_VLANPAD_MASK   /*DOM-IGNORE-END*/,
3948:                
3949:                    // Enable automatic detection by the MAC of the type of frame and pad
3950:                    // accordingly
3951:                    ETH_MAC_CONFIG2_AUTO_PAD
3952:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_AUTOPAD_MASK   /*DOM-IGNORE-END*/,
3953:                
3954:                    // Enable preamble verification and discard packets with preamble errors
3955:                    ETH_MAC_CONFIG2_PURE_PRE
3956:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_PUREPRE_MASK   /*DOM-IGNORE-END*/,
3957:                
3958:                    // Allow only packets having preamble fields less than 12 bytes in length
3959:                    ETH_MAC_CONFIG2_LONG_PRE
3960:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_LONGPRE_MASK   /*DOM-IGNORE-END*/,
3961:                
3962:                    // Do not use Binary Exponential Backoff algorithm following a collision,
3963:                    // transmit immediately
3964:                    ETH_MAC_CONFIG2_NO_BACKOFF
3965:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_NOBKOFF_MASK   /*DOM-IGNORE-END*/,
3966:                
3967:                    // After incidentally causing a collision during backpressure the MAC will
3968:                    // immediately retransmit without backoff
3969:                    ETH_MAC_CONFIG2_BP_NO_BACKOFF
3970:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_BPNOBKOFF_MASK /*DOM-IGNORE-END*/,
3971:                
3972:                    // If enabled the MAC will defer to carrier indefinitely as per the standard.
3973:                    ETH_MAC_CONFIG2_EXCESS_DEFER
3974:                        /*DOM-IGNORE-BEGIN*/ = _EMACxCFG2_EXCESSDFR_MASK /*DOM-IGNORE-END*/,
3975:                
3976:                } eEthMACConfig2Flags;
3977:                
3978:                
3979:                // *****************************************************************************
3980:                /* Ethernet MAC Configuration Supplemental Flags
3981:                
3982:                  Summary:
3983:                    Ethernet MAC configuration supplemental flags
3984:                
3985:                  Description:
3986:                    This enumeration defines the supplemental Ethernet MAC configuration flags.
3987:                
3988:                  Remarks:
3989:                    These flags can be OR-ed together to create configuration mask values.
3990:                */
3991:                
3992:                typedef enum
3993:                {
3994:                    // Reset RMII module
3995:                    ETH_MAC_CONFIG_SUPP_RMII_RESET
3996:                        /*DOM-IGNORE-BEGIN*/ = _EMACxSUPP_RESETRMII_MASK /*DOM-IGNORE-END*/,
3997:                
3998:                    // 100 Mbps RMII operation
3999:                    ETH_MAC_CONFIG_SUPP_RMII_SPEED
4000:                        /*DOM-IGNORE-BEGIN*/ = _EMACxSUPP_SPEEDRMII_MASK /*DOM-IGNORE-END*/
4001:                
4002:                } eEthMACConfigSuppFlags;
4003:                
4004:                
4005:                /*******************************************************************************
4006:                  Function:
4007:                    void EthMACConfig ( eEthMACConfig1Flags    c1Flags,
4008:                                        eEthMACConfig2Flags    c2Flags,
4009:                                        eEthMACConfigSuppFlags sFlags )
4010:                
4011:                  Summary:
4012:                    Configures the MAC
4013:                
4014:                  Description:
4015:                    This function gives access to low level Ethernet MAC configuration.  It
4016:                    configures the MAC.
4017:                
4018:                  Precondition:
4019:                    None.
4020:                
4021:                  Parameters:
4022:                    c1Flags         - Configuration flags from set 1
4023:                
4024:                    c2Flags         - Configuration flags from set 2
4025:                
4026:                    sFlags          - Suplemental configuration flags
4027:                
4028:                  Returns:
4029:                    None.
4030:                
4031:                  Example:
4032:                    <code>
4033:                    EthMACConfig( ETH_MAC_CONFIG1_RXEN|ETH_MAC_CONFIG1_RX_PAUSE|ETH_MAC_CONFIG1_TX_PAUSE,
4034:                                  ETH_MAC_CONFIG2_FDUPLEX|ETH_MAC_CONFIG2_HUGE_FRAME,
4035:                                  ETH_MAC_CONFIG_SUPP_RMII_SPEED );
4036:                    </code>
4037:                
4038:                  Remarks:
4039:                    When connected to an external PHY the MAC and PHY configurations have to be consistent.
4040:                 *****************************************************************************/
4041:                
4042:                void EthMACConfig ( eEthMACConfig1Flags c1Flags, eEthMACConfig2Flags c2Flags,
4043:                                    eEthMACConfigSuppFlags sFlags );
4044:                
4045:                
4046:                /*******************************************************************************
4047:                  Function:
4048:                    void EthMACConfigSetFlags ( eEthMACConfig1Flags    c1Flags,
4049:                                                eEthMACConfig2Flags    c2Flags,
4050:                                                eEthMACConfigSuppFlags sFlags );
4051:                
4052:                  Summary:
4053:                    Sets Ethernet MAC configuration flags
4054:                
4055:                  Description:
4056:                    The function gives access to low level Ethernet MAC configuration.  Any flag set
4057:                    in the c1Flags, c2Flags, sFlags will be set, the other flags won't be
4058:                    touched.
4059:                
4060:                  Precondition:
4061:                    None.
4062:                
4063:                  Parameters:
4064:                    c1Flags         - Configuration flags from set 1 to be set
4065:                
4066:                    c2Flags         - Configuration flags from set 2 to be set
4067:                
4068:                    sFlags          - Suplemental configuration flags to be set
4069:                
4070:                  Returns:
4071:                    None.
4072:                
4073:                  Example:
4074:                    <code>
4075:                    EthMACConfigSetFlags( ETH_MAC_CONFIG1_RXEN|ETH_MAC_CONFIG1_RX_PAUSE|ETH_MAC_CONFIG1_TX_PAUSE,
4076:                                          ETH_MAC_CONFIG2_FDUPLEX|ETH_MAC_CONFIG2_HUGE_FRAME,
4077:                                          ETH_MAC_CONFIG_SUPP_RMII_RESET);
4078:                    </code>
4079:                
4080:                  Remarks:
4081:                    When connected to an external PHY the MAC and PHY configurations have to be consistent.
4082:                 *****************************************************************************/
4083:                
4084:                void EthMACConfigSetFlags ( eEthMACConfig1Flags c1Flags, eEthMACConfig2Flags c2Flags,
4085:                                            eEthMACConfigSuppFlags sFlags );
4086:                
4087:                
4088:                /*******************************************************************************
4089:                  Function:
4090:                    void EthMACConfigClrFlags ( eEthMACConfig1Flags    c1Flags,
4091:                                                eEthMACConfig2Flags    c2Flags,
4092:                                                eEthMACConfigSuppFlags sFlags );
4093:                
4094:                  Summary:
4095:                    Clears Ethernet MAC configuration flags
4096:                
4097:                  Description:
4098:                    The function gives access to low level Ethernet MAC configuration.  Any flag set
4099:                    in the c1Flags, c2Flags, sFlags will be cleared, the other flags won't be
4100:                    touched.
4101:                
4102:                  Precondition:
4103:                    None.
4104:                
4105:                  Parameters:
4106:                    c1Flags         - Configuration flags from set 1 to be cleared
4107:                
4108:                    c2Flags         - Configuration flags from set 2 to be cleared
4109:                
4110:                    sFlags          - Suplemental configuration flags to be cleared
4111:                
4112:                  Returns:
4113:                    None.
4114:                
4115:                  Example:
4116:                    <code>
4117:                    EthMACConfigClrFlags( ETH_MAC_CONFIG1_RXEN|ETH_MAC_CONFIG1_RX_PAUSE|ETH_MAC_CONFIG1_TX_PAUSE,
4118:                                          ETH_MAC_CONFIG2_FDUPLEX|ETH_MAC_CONFIG2_HUGE_FRAME,
4119:                                          ETH_MAC_CONFIG_SUPP_RMII_RESET );
4120:                    </code>
4121:                
4122:                  Remarks:
4123:                    When connected to an external PHY the MAC and PHY configurations have to be consistent.
4124:                 *****************************************************************************/
4125:                
4126:                void EthMACConfigClrFlags ( eEthMACConfig1Flags c1Flags, eEthMACConfig2Flags c2Flags,
4127:                                            eEthMACConfigSuppFlags sFlags );
4128:                
4129:                
4130:                /*******************************************************************************
4131:                  Function:
4132:                    void EthMACConfigB2BIpGap ( unsigned int ipGap )
4133:                
4134:                  Summary:
4135:                    Sets the back to back inter packet gap
4136:                
4137:                  Description:
4138:                    The function sets the back to back inter packet gap value (the nibble time
4139:                    offset of the minimum possible period between the end of any transmitted
4140:                    packet to the beginning of the next).
4141:                
4142:                  Precondition:
4143:                    0 < ipGap < 128
4144:                
4145:                  Parameters:
4146:                    ipGap       - The back to back inter packet gap
4147:                
4148:                  Returns:
4149:                    None.
4150:                
4151:                  Example:
4152:                    <code>
4153:                    EthMACConfigB2BIpGap(0x15);
4154:                    </code>
4155:                
4156:                  Remarks:
4157:                    In full duplex the recommended value is 0x15.
4158:                
4159:                    In half duplex the recommended value is 0x12.
4160:                 *****************************************************************************/
4161:                
4162:                void EthMACConfigB2BIpGap ( unsigned int ipGap );
4163:                
4164:                
4165:                /*******************************************************************************
4166:                  Function:
4167:                    void EthMACConfigNB2BIpGap ( unsigned int ipgr1, unsigned int ipgr2 )
4168:                
4169:                  Summary:
4170:                    Sets the non-back-to-back inter-packet gap value.
4171:                
4172:                  Description:
4173:                    The function sets the non back to back inter packet gap value part 1 and 2.
4174:                
4175:                    The ipgr1 represents the optional carrierSense window referenced in IEEE
4176:                    802.3/4.2.3.2.1 Carrier Deference.  If carrier is detected during the
4177:                    timing of IPGR1, the MAC defers to carrier. If, however, carrier becomes
4178:                    active after IPGR1, the MAC continues timing IPGR2 and transmits,
4179:                    knowingly causing a collision, thus ensuring fair access to medium.
4180:                    The ipgr2 represents the non back to back inter packet gap.
4181:                
4182:                  Precondition:
4183:                    0 < carrDefer < 128
4184:                
4185:                    0 < nB2BIpGap < 128
4186:                
4187:                  Parameters:
4188:                    carrDefer       - The carrier deference
4189:                
4190:                    nB2BIpGap       - Non back to back inter packet gap
4191:                
4192:                  Returns:
4193:                    None.
4194:                
4195:                  Example:
4196:                    <code>
4197:                    EthMACConfigNB2BIpGap(0xc, 0x12);
4198:                    </code>
4199:                
4200:                  Remarks:
4201:                    The ipgr1 recommended value is 0xc. Its range of values is 0x0 to ipgr2.
4202:                
4203:                    The ipgr2 recommended value is 0x12.
4204:                 *****************************************************************************/
4205:                
4206:                void EthMACConfigNB2BIpGap ( unsigned int ipgr1, unsigned int ipgr2 );
4207:                
4208:                
4209:                /*******************************************************************************
4210:                  Function:
4211:                    void EthMACConfigCollWinRetry ( unsigned int collWin, unsigned int retMax )
4212:                
4213:                  Summary:
4214:                    Sets the collision window and the retransmission maximum.
4215:                
4216:                  Description:
4217:                    The function sets the collision window and the retransmission maximum.
4218:                
4219:                    The collision window is a programmable field representing the slot time or
4220:                    collision window during which collisions occur in properly configured
4221:                    networks.  Since the collision window starts at the beginning of
4222:                    transmission, the preamble and SFD is included. The retransmission maximum
4223:                    is a programmable field specifying the number of retransmission attempts
4224:                    following a collision before aborting the packet due to excessive
4225:                    collisions.
4226:                
4227:                  Precondition:
4228:                    0 < collWin < 64
4229:                
4230:                    0 < retMax < 16
4231:                
4232:                  Parameters:
4233:                    collWin         - The collision window
4234:                
4235:                    retMax          - Retransmission maximum
4236:                
4237:                  Returns:
4238:                    None.
4239:                
4240:                  Example:
4241:                    <code>
4242:                    EthMACConfigCollWinRetry(0x37, 0xf);
4243:                    </code>
4244:                
4245:                  Remarks:
4246:                    The collWin recommended value is 0x37 which corresponds to the count of
4247:                    frame bytes at the end of the window.
4248:                
4249:                    The retMax recommended value is 0xf.
4250:                 *****************************************************************************/
4251:                
4252:                void EthMACConfigCollWinRetry ( unsigned int collWin, unsigned int retMax );
4253:                
4254:                
4255:                
4256:                /********************************************************************
4257:                 * Include legacy Ethernet functions
4258:                 * New projects should not use them!
4259:                 * The functions in the eth.h should be used instead.
4260:                 ********************************************************************/
4261:                #ifndef _PLIB_DISABLE_LEGACY
4262:                    #include <peripheral/legacy/eth_legacy.h>
4263:                #endif
4264:                
4265:                
4266:                #endif  // _ETH
4267:                
4268:                
4269:                #endif  // _ETH_H_
4270:                
---  /Volumes/home/c11067/xc32/build/xc32-XC32_v1_34_branch/src45x/gcc/gcc/libgcc2.c  -------------------
9D015B60  00C01021   ADDU V0, A2, ZERO
9D015FBC  00C04821   ADDU T1, A2, ZERO
9D015B64  00804021   ADDU T0, A0, ZERO
9D015FC0  00804021   ADDU T0, A0, ZERO
9D015B68  14E0003F   BNE A3, ZERO, 0x9D015C68
9D015B6C  00A01821   ADDU V1, A1, ZERO
9D015FC4  14E0003B   BNE A3, ZERO, 0x9D0160B4
9D015FC8  00A01821   ADDU V1, A1, ZERO
9D015B70  00A6302B   SLTU A2, A1, A2
9D015B74  10C0004C   BEQ A2, ZERO, 0x9D015CA8
9D015B78  00000000   NOP
9D015FCC  00A6102B   SLTU V0, A1, A2
9D015FD0  10400048   BEQ V0, ZERO, 0x9D0160F4
9D015FD4  70C21020   CLZ V0, A2
9D015B7C  70442020   CLZ A0, V0
9D015B80  50800008   BEQL A0, ZERO, 0x9D015BA4
9D015B84  00022402   SRL A0, V0, 16
9D015FD8  10400008   BEQ V0, ZERO, 0x9D015FFC
9D015FDC  00093C02   SRL A3, T1, 16
9D015B94  00821004   SLLV V0, V0, A0
9D015FEC  00464804   SLLV T1, A2, V0
9D015B88  00042823   SUBU A1, ZERO, A0
9D015B8C  00A82806   SRLV A1, T0, A1
9D015B90  00831804   SLLV V1, V1, A0
9D015B98  00A31825   OR V1, A1, V1
9D015FE0  00022023   SUBU A0, ZERO, V0
9D015FE4  00882006   SRLV A0, T0, A0
9D015FE8  00451804   SLLV V1, A1, V0
9D015FF0  00831825   OR V1, A0, V1
9D015B9C  00884004   SLLV T0, T0, A0
9D015FF4  00484004   SLLV T0, T0, V0
9D015BA0  00022402   SRL A0, V0, 16
9D015BA4  0064001B   DIVU V1, A0
9D015BA8  008001F4   TEQ A0, ZERO
9D015BAC  3049FFFF   ANDI T1, V0, -1
9D015BB0  00085C02   SRL T3, T0, 16
9D015BB4  00003812   MFLO A3, 0
9D015BB8  00005010   MFHI T2, 0
9D015BBC  70E93002   MUL A2, A3, T1
9D015BC0  000A2C00   SLL A1, T2, 16
9D015BC4  00AB2825   OR A1, A1, T3
9D015BC8  00A6502B   SLTU T2, A1, A2
9D015BCC  0064001B   DIVU V1, A0
9D015BD0  008001F4   TEQ A0, ZERO
9D015BD4  1140000B   BEQ T2, ZERO, 0x9D015C04
9D015BD8  00A61823   SUBU V1, A1, A2
9D015BDC  00A22821   ADDU A1, A1, V0
9D015BE0  00A2182B   SLTU V1, A1, V0
9D015BE4  14600006   BNE V1, ZERO, 0x9D015C00
9D015BE8  24E7FFFF   ADDIU A3, A3, -1
9D015BEC  00A6182B   SLTU V1, A1, A2
9D015BF0  10600004   BEQ V1, ZERO, 0x9D015C04
9D015BF4  00A61823   SUBU V1, A1, A2
9D015BF8  24E7FFFF   ADDIU A3, A3, -1
9D015BFC  00A22821   ADDU A1, A1, V0
9D015C00  00A61823   SUBU V1, A1, A2
9D015C04  0064001B   DIVU V1, A0
9D015C08  008001F4   TEQ A0, ZERO
9D015C0C  3108FFFF   ANDI T0, T0, -1
9D015C10  00002812   MFLO A1, 0
9D015C14  00003010   MFHI A2, 0
9D015C18  70A94802   MUL T1, A1, T1
9D015C1C  00063400   SLL A2, A2, 16
9D015C20  00C84025   OR T0, A2, T0
9D015C24  0109302B   SLTU A2, T0, T1
9D015C28  0064001B   DIVU V1, A0
9D015C2C  008001F4   TEQ A0, ZERO
9D015C30  10C00007   BEQ A2, ZERO, 0x9D015C50
9D015C34  01024021   ADDU T0, T0, V0
9D015C38  0102102B   SLTU V0, T0, V0
9D015C3C  14400004   BNE V0, ZERO, 0x9D015C50
9D015C40  24A5FFFF   ADDIU A1, A1, -1
9D015C44  0109482B   SLTU T1, T0, T1
9D015C48  55200001   BNEL T1, ZERO, 0x9D015C50
9D015C4C  24A5FFFF   ADDIU A1, A1, -1
9D015C50  00073C00   SLL A3, A3, 16
9D015C54  00A72825   OR A1, A1, A3
9D015C58  00002021   ADDU A0, ZERO, ZERO
9D015FF8  00093C02   SRL A3, T1, 16
9D015FFC  0067001B   DIVU V1, A3
9D016000  00E001F4   TEQ A3, ZERO
9D016004  312AFFFF   ANDI T2, T1, -1
9D016008  00082C02   SRL A1, T0, 16
9D01600C  00005812   MFLO T3, 0
9D016010  00002010   MFHI A0, 0
9D016014  716A5802   MUL T3, T3, T2
9D016018  00043400   SLL A2, A0, 16
9D01601C  00C53025   OR A2, A2, A1
9D016020  00CB602B   SLTU T4, A2, T3
9D016024  0067001B   DIVU V1, A3
9D016028  00E001F4   TEQ A3, ZERO
9D01602C  11800009   BEQ T4, ZERO, 0x9D016054
9D016030  00CB1823   SUBU V1, A2, T3
9D016034  00C93021   ADDU A2, A2, T1
9D016038  00C9182B   SLTU V1, A2, T1
9D01603C  14600005   BNE V1, ZERO, 0x9D016054
9D016040  00CB1823   SUBU V1, A2, T3
9D016044  00CB182B   SLTU V1, A2, T3
9D016048  54600001   BNEL V1, ZERO, 0x9D016050
9D01604C  00C93021   ADDU A2, A2, T1
9D016050  00CB1823   SUBU V1, A2, T3
9D016054  0067001B   DIVU V1, A3
9D016058  00E001F4   TEQ A3, ZERO
9D01605C  3108FFFF   ANDI T0, T0, -1
9D016060  00002012   MFLO A0, 0
9D016064  00002810   MFHI A1, 0
9D016068  708A5002   MUL T2, A0, T2
9D01606C  00052C00   SLL A1, A1, 16
9D016070  00A84025   OR T0, A1, T0
9D016074  010A202B   SLTU A0, T0, T2
9D016078  0067001B   DIVU V1, A3
9D01607C  00E001F4   TEQ A3, ZERO
9D016080  50800009   BEQL A0, ZERO, 0x9D0160A8
9D016084  010A4023   SUBU T0, T0, T2
9D015CA8  14400006   BNE V0, ZERO, 0x9D015CC4
9D015CAC  70431820   CLZ V1, V0
9D0160F4  14C00006   BNE A2, ZERO, 0x9D016110
9D0160F8  71221020   CLZ V0, T1
9D015CB0  24030001   ADDIU V1, ZERO, 1
9D015CB4  0062001B   DIVU V1, V0
9D015CB8  004001F4   TEQ V0, ZERO
9D015CBC  00001012   MFLO V0, 0
9D0160FC  24020001   ADDIU V0, ZERO, 1
9D016100  0046001B   DIVU V0, A2
9D016104  00C001F4   TEQ A2, ZERO
9D016108  00004812   MFLO T1, 0
9D015CC0  70431820   CLZ V1, V0
9D01610C  71221020   CLZ V0, T1
9D015CC4  5460007B   BNEL V1, ZERO, 0x9D015EB4
9D015CC8  24080020   ADDIU T0, ZERO, 32
9D016110  5440007D   BNEL V0, ZERO, 0x9D016308
9D016114  24080020   ADDIU T0, ZERO, 32
9D015CCC  00A22823   SUBU A1, A1, V0
9D015CD0  00023402   SRL A2, V0, 16
9D015CD4  3049FFFF   ANDI T1, V0, -1
9D016118  00A93023   SUBU A2, A1, T1
9D01611C  00091C02   SRL V1, T1, 16
9D016120  312AFFFF   ANDI T2, T1, -1
9D015CD8  24040001   ADDIU A0, ZERO, 1
9D015EB8  01034023   SUBU T0, T0, V1
9D016308  01024023   SUBU T0, T0, V0
9D015EB4  00621004   SLLV V0, V0, V1
9D01630C  00494804   SLLV T1, T1, V0
9D015EBC  01053806   SRLV A3, A1, T0
9D016310  01053806   SRLV A3, A1, T0
9D015ECC  01044006   SRLV T0, A0, T0
9D015ED0  00652804   SLLV A1, A1, V1
9D015ED8  01052825   OR A1, T0, A1
9D016324  01046006   SRLV T4, A0, T0
9D016328  00452804   SLLV A1, A1, V0
9D01632C  01856025   OR T4, T4, A1
9D015EDC  00644004   SLLV T0, A0, V1
9D016334  00444004   SLLV T0, A0, V0
9D015EC0  00023402   SRL A2, V0, 16
9D015EC4  00E6001B   DIVU A3, A2
9D015EC8  00C001F4   TEQ A2, ZERO
9D015ED4  3049FFFF   ANDI T1, V0, -1
9D015EE0  00056402   SRL T4, A1, 16
9D015EE4  00005012   MFLO T2, 0
9D015EE8  00005810   MFHI T3, 0
9D015EEC  71492002   MUL A0, T2, T1
9D015EF0  000B5C00   SLL T3, T3, 16
9D015EF4  018B1825   OR V1, T4, T3
9D015EF8  0064582B   SLTU T3, V1, A0
9D015EFC  00E6001B   DIVU A3, A2
9D015F00  00C001F4   TEQ A2, ZERO
9D015F04  5160000B   BEQL T3, ZERO, 0x9D015F34
9D015F08  00641823   SUBU V1, V1, A0
9D015F0C  00621821   ADDU V1, V1, V0
9D015F10  0062382B   SLTU A3, V1, V0
9D015F14  14E00006   BNE A3, ZERO, 0x9D015F30
9D015F18  254AFFFF   ADDIU T2, T2, -1
9D015F1C  0064382B   SLTU A3, V1, A0
9D015F20  50E00004   BEQL A3, ZERO, 0x9D015F34
9D015F24  00641823   SUBU V1, V1, A0
9D015F28  254AFFFF   ADDIU T2, T2, -1
9D015F2C  00621821   ADDU V1, V1, V0
9D015F30  00641823   SUBU V1, V1, A0
9D015F34  0066001B   DIVU V1, A2
9D015F38  00C001F4   TEQ A2, ZERO
9D015F3C  30A5FFFF   ANDI A1, A1, -1
9D015F40  00002012   MFLO A0, 0
9D015F44  00005810   MFHI T3, 0
9D015F48  70893802   MUL A3, A0, T1
9D015F4C  000B5C00   SLL T3, T3, 16
9D015F50  01652825   OR A1, T3, A1
9D015F54  00A7582B   SLTU T3, A1, A3
9D015F58  0066001B   DIVU V1, A2
9D015F5C  00C001F4   TEQ A2, ZERO
9D015F60  5160000B   BEQL T3, ZERO, 0x9D015F90
9D015F64  000A5400   SLL T2, T2, 16
9D015F68  00A22821   ADDU A1, A1, V0
9D015F6C  00A2182B   SLTU V1, A1, V0
9D015F70  14600006   BNE V1, ZERO, 0x9D015F8C
9D015F74  2484FFFF   ADDIU A0, A0, -1
9D015F78  00A7182B   SLTU V1, A1, A3
9D015F7C  50600004   BEQL V1, ZERO, 0x9D015F90
9D015F80  000A5400   SLL T2, T2, 16
9D015F84  2484FFFF   ADDIU A0, A0, -1
9D015F88  00A22821   ADDU A1, A1, V0
9D015F8C  000A5400   SLL T2, T2, 16
9D015F90  00A72823   SUBU A1, A1, A3
9D015F94  0B405737   J 0x9D015CDC
9D015F98  008A2025   OR A0, A0, T2
9D016314  00091C02   SRL V1, T1, 16
9D016318  00E3001B   DIVU A3, V1
9D01631C  006001F4   TEQ V1, ZERO
9D016320  312AFFFF   ANDI T2, T1, -1
9D016330  000C2C02   SRL A1, T4, 16
9D016338  00005812   MFLO T3, 0
9D01633C  00006810   MFHI T5, 0
9D016340  716A5802   MUL T3, T3, T2
9D016344  000D6C00   SLL T5, T5, 16
9D016348  00AD2025   OR A0, A1, T5
9D01634C  008B282B   SLTU A1, A0, T3
9D016350  00E3001B   DIVU A3, V1
9D016354  006001F4   TEQ V1, ZERO
9D016358  50A00009   BEQL A1, ZERO, 0x9D016380
9D01635C  008B2023   SUBU A0, A0, T3
9D016360  00892021   ADDU A0, A0, T1
9D016364  0089282B   SLTU A1, A0, T1
9D016368  54A00005   BNEL A1, ZERO, 0x9D016380
9D01636C  008B2023   SUBU A0, A0, T3
9D016370  008B282B   SLTU A1, A0, T3
9D016374  54A00001   BNEL A1, ZERO, 0x9D01637C
9D016378  00892021   ADDU A0, A0, T1
9D01637C  008B2023   SUBU A0, A0, T3
9D016380  0083001B   DIVU A0, V1
9D016384  006001F4   TEQ V1, ZERO
9D016388  318CFFFF   ANDI T4, T4, -1
9D01638C  00002812   MFLO A1, 0
9D016390  00003810   MFHI A3, 0
9D016394  70AA2802   MUL A1, A1, T2
9D016398  00073400   SLL A2, A3, 16
9D01639C  00CC3025   OR A2, A2, T4
9D0163A0  00C5382B   SLTU A3, A2, A1
9D0163A4  0083001B   DIVU A0, V1
9D0163A8  006001F4   TEQ V1, ZERO
9D0163AC  50E0FF5D   BEQL A3, ZERO, 0x9D016124
9D0163B0  00C53023   SUBU A2, A2, A1
9D0163B4  00C93021   ADDU A2, A2, T1
9D0163B8  00C9202B   SLTU A0, A2, T1
9D0163BC  5480FF59   BNEL A0, ZERO, 0x9D016124
9D0163C0  00C53023   SUBU A2, A2, A1
9D0163C4  00C5202B   SLTU A0, A2, A1
9D0163C8  54800001   BNEL A0, ZERO, 0x9D0163D0
9D0163CC  00C93021   ADDU A2, A2, T1
9D0163D0  0B405849   J 0x9D016124
9D0163D4  00C53023   SUBU A2, A2, A1
9D015CDC  00A6001B   DIVU A1, A2
9D015CE0  00C001F4   TEQ A2, ZERO
9D015CE4  00086402   SRL T4, T0, 16
9D015CE8  00003812   MFLO A3, 0
9D015CEC  00005810   MFHI T3, 0
9D015CF0  70E95002   MUL T2, A3, T1
9D015CF4  000B1C00   SLL V1, T3, 16
9D015CF8  006C1825   OR V1, V1, T4
9D015CFC  006A582B   SLTU T3, V1, T2
9D015D00  00A6001B   DIVU A1, A2
9D015D04  00C001F4   TEQ A2, ZERO
9D015D08  51600009   BEQL T3, ZERO, 0x9D015D30
9D015D0C  006A1823   SUBU V1, V1, T2
9D015D10  00621821   ADDU V1, V1, V0
9D015D14  0062282B   SLTU A1, V1, V0
9D015D18  14A00004   BNE A1, ZERO, 0x9D015D2C
9D015D1C  24E7FFFF   ADDIU A3, A3, -1
9D015D20  006A282B   SLTU A1, V1, T2
9D015D24  54A000A3   BNEL A1, ZERO, 0x9D015FB4
9D015D28  24E7FFFF   ADDIU A3, A3, -1
9D015D2C  006A1823   SUBU V1, V1, T2
9D015D30  0066001B   DIVU V1, A2
9D015D34  00C001F4   TEQ A2, ZERO
9D015D38  3108FFFF   ANDI T0, T0, -1
9D015D3C  00002812   MFLO A1, 0
9D015D40  00005010   MFHI T2, 0
9D015D44  70A94802   MUL T1, A1, T1
9D015D48  000A5400   SLL T2, T2, 16
9D015D4C  01484025   OR T0, T2, T0
9D015D50  0109502B   SLTU T2, T0, T1
9D015D54  0066001B   DIVU V1, A2
9D015D58  00C001F4   TEQ A2, ZERO
9D015D5C  11400007   BEQ T2, ZERO, 0x9D015D7C
9D015D60  01024021   ADDU T0, T0, V0
9D015D64  0102102B   SLTU V0, T0, V0
9D015D68  14400004   BNE V0, ZERO, 0x9D015D7C
9D015D6C  24A5FFFF   ADDIU A1, A1, -1
9D015D70  0109482B   SLTU T1, T0, T1
9D015D74  55200001   BNEL T1, ZERO, 0x9D015D7C
9D015D78  24A5FFFF   ADDIU A1, A1, -1
9D015D7C  00073C00   SLL A3, A3, 16
9D015D80  00A72825   OR A1, A1, A3
9D015FB4  0B40574B   J 0x9D015D2C
9D015FB8  00621821   ADDU V1, V1, V0
9D016088  01094021   ADDU T0, T0, T1
9D01608C  0109182B   SLTU V1, T0, T1
9D016090  54600005   BNEL V1, ZERO, 0x9D0160A8
9D016094  010A4023   SUBU T0, T0, T2
9D016098  010A182B   SLTU V1, T0, T2
9D01609C  54600001   BNEL V1, ZERO, 0x9D0160A4
9D0160A0  01094021   ADDU T0, T0, T1
9D0160A4  010A4023   SUBU T0, T0, T2
9D016124  00C3001B   DIVU A2, V1
9D016128  006001F4   TEQ V1, ZERO
9D01612C  00086402   SRL T4, T0, 16
9D016130  00002012   MFLO A0, 0
9D016134  00005810   MFHI T3, 0
9D016138  708A2002   MUL A0, A0, T2
9D01613C  000B3C00   SLL A3, T3, 16
9D016140  00EC3825   OR A3, A3, T4
9D016144  00E4582B   SLTU T3, A3, A0
9D016148  00C3001B   DIVU A2, V1
9D01614C  006001F4   TEQ V1, ZERO
9D016150  11600009   BEQ T3, ZERO, 0x9D016178
9D016154  00E42823   SUBU A1, A3, A0
9D016158  00E93821   ADDU A3, A3, T1
9D01615C  00E9282B   SLTU A1, A3, T1
9D016160  14A00005   BNE A1, ZERO, 0x9D016178
9D016164  00E42823   SUBU A1, A3, A0
9D016168  00E4282B   SLTU A1, A3, A0
9D01616C  54A00001   BNEL A1, ZERO, 0x9D016174
9D016170  00E93821   ADDU A3, A3, T1
9D016174  00E42823   SUBU A1, A3, A0
9D016178  00A3001B   DIVU A1, V1
9D01617C  006001F4   TEQ V1, ZERO
9D016180  3108FFFF   ANDI T0, T0, -1
9D016184  00002012   MFLO A0, 0
9D016188  00003010   MFHI A2, 0
9D01618C  708A5002   MUL T2, A0, T2
9D016190  00063400   SLL A2, A2, 16
9D016194  00C84025   OR T0, A2, T0
9D016198  010A202B   SLTU A0, T0, T2
9D01619C  00A3001B   DIVU A1, V1
9D0161A0  006001F4   TEQ V1, ZERO
9D0161A4  5080FFC0   BEQL A0, ZERO, 0x9D0160A8
9D0161A8  010A4023   SUBU T0, T0, T2
9D0161AC  01094021   ADDU T0, T0, T1
9D0161B0  0109182B   SLTU V1, T0, T1
9D0161B4  5460FFBC   BNEL V1, ZERO, 0x9D0160A8
9D0161B8  010A4023   SUBU T0, T0, T2
9D0161BC  0B405827   J 0x9D01609C
9D0161C0  010A182B   SLTU V1, T0, T2
9D0160A8  00481006   SRLV V0, T0, V0
9D0160AC  03E00008   JR RA
9D0160B0  00001821   ADDU V1, ZERO, ZERO
9D015C68  00A7102B   SLTU V0, A1, A3
9D015C6C  54400048   BNEL V0, ZERO, 0x9D015D90
9D015C70  00002021   ADDU A0, ZERO, ZERO
9D015D90  00002821   ADDU A1, ZERO, ZERO
9D0160B4  00A7102B   SLTU V0, A1, A3
9D0160B8  14400042   BNE V0, ZERO, 0x9D0161C4
9D0160BC  70EA5020   CLZ T2, A3
9D0161C4  00801021   ADDU V0, A0, ZERO
9D0161C8  03E00008   JR RA
9D0161CC  00A01821   ADDU V1, A1, ZERO
9D015C74  70E31820   CLZ V1, A3
9D015C78  14600049   BNE V1, ZERO, 0x9D015DA0
9D015C7C  240C0020   ADDIU T4, ZERO, 32
9D0160C0  15400043   BNE T2, ZERO, 0x9D0161D0
9D0160C4  240C0020   ADDIU T4, ZERO, 32
9D015C80  00E5282B   SLTU A1, A3, A1
9D015C84  14A00003   BNE A1, ZERO, 0x9D015C94
9D015C88  0086302B   SLTU A2, A0, A2
9D015C8C  14C00086   BNE A2, ZERO, 0x9D015EA8
9D015C90  00002021   ADDU A0, ZERO, ZERO
9D015C94  00002021   ADDU A0, ZERO, ZERO
9D015C98  24050001   ADDIU A1, ZERO, 1
9D0160C8  00E5102B   SLTU V0, A3, A1
9D0160CC  14400005   BNE V0, ZERO, 0x9D0160E4
9D0160D0  00861023   SUBU V0, A0, A2
9D0160D4  0086102B   SLTU V0, A0, A2
9D0160D8  544000C8   BNEL V0, ZERO, 0x9D0163FC
9D0160DC  00801021   ADDU V0, A0, ZERO
9D0160E0  00861023   SUBU V0, A0, A2
9D0160E4  00A72823   SUBU A1, A1, A3
9D0160E8  0082202B   SLTU A0, A0, V0
9D0160EC  03E00008   JR RA
9D0160F0  00A41823   SUBU V1, A1, A0
9D015DA0  01836023   SUBU T4, T4, V1
9D0161D0  018A6023   SUBU T4, T4, T2
9D015DA4  01864006   SRLV T0, A2, T4
9D015DA8  00673804   SLLV A3, A3, V1
9D015DAC  01074025   OR T0, T0, A3
9D0161D4  01473804   SLLV A3, A3, T2
9D0161D8  01865806   SRLV T3, A2, T4
9D0161DC  01675825   OR T3, T3, A3
9D016204  01463004   SLLV A2, A2, T2
9D015DB4  01853806   SRLV A3, A1, T4
9D0161E0  01856806   SRLV T5, A1, T4
9D015DC4  00652804   SLLV A1, A1, V1
9D015DC8  01846006   SRLV T4, A0, T4
9D015DCC  01856025   OR T4, T4, A1
9D0161F4  01841006   SRLV V0, A0, T4
9D0161F8  01452804   SLLV A1, A1, T2
9D0161FC  00452825   OR A1, V0, A1
9D015DB0  00081402   SRL V0, T0, 16
9D015DB8  00E2001B   DIVU A3, V0
9D015DBC  004001F4   TEQ V0, ZERO
9D015DC0  310DFFFF   ANDI T5, T0, -1
9D015DD0  000C4C02   SRL T1, T4, 16
9D015DD4  00005812   MFLO T3, 0
9D015DD8  00007810   MFHI T7, 0
9D015DDC  716D7002   MUL T6, T3, T5
9D015DE0  000F5400   SLL T2, T7, 16
9D015DE4  01495025   OR T2, T2, T1
9D015DE8  014E282B   SLTU A1, T2, T6
9D015DEC  00E2001B   DIVU A3, V0
9D015DF0  004001F4   TEQ V0, ZERO
9D015DF4  10A0000A   BEQ A1, ZERO, 0x9D015E20
9D015DF8  00663004   SLLV A2, A2, V1
9D015DFC  01485021   ADDU T2, T2, T0
9D015E00  0148282B   SLTU A1, T2, T0
9D015E04  14A00006   BNE A1, ZERO, 0x9D015E20
9D015E08  256BFFFF   ADDIU T3, T3, -1
9D015E0C  014E282B   SLTU A1, T2, T6
9D015E10  50A00004   BEQL A1, ZERO, 0x9D015E24
9D015E14  014E5023   SUBU T2, T2, T6
9D015E18  256BFFFF   ADDIU T3, T3, -1
9D015E1C  01485021   ADDU T2, T2, T0
9D015E20  014E5023   SUBU T2, T2, T6
9D015E24  0142001B   DIVU T2, V0
9D015E28  004001F4   TEQ V0, ZERO
9D015E2C  318CFFFF   ANDI T4, T4, -1
9D015E30  00002812   MFLO A1, 0
9D015E34  00007010   MFHI T6, 0
9D015E38  70AD6802   MUL T5, A1, T5
9D015E3C  000E4C00   SLL T1, T6, 16
9D015E40  012C4825   OR T1, T1, T4
9D015E44  012D382B   SLTU A3, T1, T5
9D015E48  0142001B   DIVU T2, V0
9D015E4C  004001F4   TEQ V0, ZERO
9D015E50  50E0000B   BEQL A3, ZERO, 0x9D015E80
9D015E54  000B5C00   SLL T3, T3, 16
9D015E58  01284821   ADDU T1, T1, T0
9D015E5C  0128102B   SLTU V0, T1, T0
9D015E60  14400006   BNE V0, ZERO, 0x9D015E7C
9D015E64  24A5FFFF   ADDIU A1, A1, -1
9D015E68  012D102B   SLTU V0, T1, T5
9D015E6C  50400004   BEQL V0, ZERO, 0x9D015E80
9D015E70  000B5C00   SLL T3, T3, 16
9D015E74  24A5FFFF   ADDIU A1, A1, -1
9D015E78  01284821   ADDU T1, T1, T0
9D015E7C  000B5C00   SLL T3, T3, 16
9D015E80  00AB2825   OR A1, A1, T3
9D015E88  012D4823   SUBU T1, T1, T5
9D0161E4  000B3C02   SRL A3, T3, 16
9D0161E8  01A7001B   DIVU T5, A3
9D0161EC  00E001F4   TEQ A3, ZERO
9D0161F0  316FFFFF   ANDI T7, T3, -1
9D016200  00051402   SRL V0, A1, 16
9D016208  00007012   MFLO T6, 0
9D01620C  00001810   MFHI V1, 0
9D016210  71CFC002   MUL T8, T6, T7
9D016214  00034C00   SLL T1, V1, 16
9D016218  01224825   OR T1, T1, V0
9D01621C  0138102B   SLTU V0, T1, T8
9D016220  01A7001B   DIVU T5, A3
9D016224  00E001F4   TEQ A3, ZERO
9D016228  1040000A   BEQ V0, ZERO, 0x9D016254
9D01622C  01442004   SLLV A0, A0, T2
9D016230  012B4821   ADDU T1, T1, T3
9D016234  012B102B   SLTU V0, T1, T3
9D016238  14400006   BNE V0, ZERO, 0x9D016254
9D01623C  25CEFFFF   ADDIU T6, T6, -1
9D016240  0138102B   SLTU V0, T1, T8
9D016244  50400004   BEQL V0, ZERO, 0x9D016258
9D016248  01384823   SUBU T1, T1, T8
9D01624C  25CEFFFF   ADDIU T6, T6, -1
9D016250  012B4821   ADDU T1, T1, T3
9D016254  01384823   SUBU T1, T1, T8
9D016258  0127001B   DIVU T1, A3
9D01625C  00E001F4   TEQ A3, ZERO
9D016260  30A5FFFF   ANDI A1, A1, -1
9D016264  00006812   MFLO T5, 0
9D016268  00001810   MFHI V1, 0
9D01626C  71AF7802   MUL T7, T5, T7
9D016270  00031400   SLL V0, V1, 16
9D016274  00451025   OR V0, V0, A1
9D016278  004F182B   SLTU V1, V0, T7
9D01627C  0127001B   DIVU T1, A3
9D016280  00E001F4   TEQ A3, ZERO
9D016284  1060000B   BEQ V1, ZERO, 0x9D0162B4
9D016288  000E4400   SLL T0, T6, 16
9D01628C  004B1021   ADDU V0, V0, T3
9D016290  004B182B   SLTU V1, V0, T3
9D016294  14600007   BNE V1, ZERO, 0x9D0162B4
9D016298  25ADFFFF   ADDIU T5, T5, -1
9D01629C  004F182B   SLTU V1, V0, T7
9D0162A0  10600005   BEQ V1, ZERO, 0x9D0162B8
9D0162A4  01A84025   OR T0, T5, T0
9D0162A8  25ADFFFF   ADDIU T5, T5, -1
9D0162AC  004B1021   ADDU V0, V0, T3
9D0162B0  000E4400   SLL T0, T6, 16
9D0162B4  01A84025   OR T0, T5, T0
9D0162BC  004F7823   SUBU T7, V0, T7
9D015E84  00A60019   MULTU 0, A1, A2
9D015E8C  00003810   MFHI A3, 0
9D0162B8  01060019   MULTU 0, T0, A2
9D0162C0  00004810   MFHI T1, 0
9D0162C4  00004012   MFLO T0, 0
9D0162CC  01201821   ADDU V1, T1, ZERO
9D0162D0  01203821   ADDU A3, T1, ZERO
9D015E90  0127402B   SLTU T0, T1, A3
9D015E94  15000044   BNE T0, ZERO, 0x9D015FA8
9D015E98  00003012   MFLO A2, 0
9D015E9C  1127003F   BEQ T1, A3, 0x9D015F9C
9D015EA0  00642004   SLLV A0, A0, V1
9D015F9C  0086302B   SLTU A2, A0, A2
9D015FA0  50C0FFC1   BEQL A2, ZERO, 0x9D015EA8
9D015FA4  00002021   ADDU A0, ZERO, ZERO
9D0162C8  01E9282B   SLTU A1, T7, T1
9D0162D4  14A00040   BNE A1, ZERO, 0x9D0163D8
9D0162D8  00001012   MFLO V0, 0
9D0162DC  51E90043   BEQL T7, T1, 0x9D0163EC
9D0162E0  0082182B   SLTU V1, A0, V0
9D0163EC  5460FFFB   BNEL V1, ZERO, 0x9D0163DC
9D0163F0  00464023   SUBU T0, V0, A2
9D0163F4  0B4058BA   J 0x9D0162E8
9D0163F8  00001821   ADDU V1, ZERO, ZERO
9D0163FC  03E00008   JR RA
9D016400  00000000   NOP
9D015EA4  00002021   ADDU A0, ZERO, ZERO
9D015FA8  24A5FFFF   ADDIU A1, A1, -1
9D015FAC  0B4057AA   J 0x9D015EA8
9D015FB0  00002021   ADDU A0, ZERO, ZERO
9D0162E4  01E31823   SUBU V1, T7, V1
9D0163D8  00464023   SUBU T0, V0, A2
9D0163DC  00EB1823   SUBU V1, A3, T3
9D0163E0  0048102B   SLTU V0, V0, T0
9D0163E4  0B4058B9   J 0x9D0162E4
9D0163E8  00621823   SUBU V1, V1, V0
9D0162E8  00883023   SUBU A2, A0, T0
9D0162EC  0086202B   SLTU A0, A0, A2
9D0162F0  00641823   SUBU V1, V1, A0
9D0162F4  01836004   SLLV T4, V1, T4
9D0162F8  01461006   SRLV V0, A2, T2
9D0162FC  004C1025   OR V0, V0, T4
9D015C5C  00A01021   ADDU V0, A1, ZERO
9D015C9C  00A01021   ADDU V0, A1, ZERO
9D015D84  00A01021   ADDU V0, A1, ZERO
9D015D94  00A01021   ADDU V0, A1, ZERO
9D015EA8  00A01021   ADDU V0, A1, ZERO
9D016300  03E00008   JR RA
9D016304  01431806   SRLV V1, V1, T2
9D015C60  03E00008   JR RA
9D015C64  00801821   ADDU V1, A0, ZERO
9D015CA0  03E00008   JR RA
9D015CA4  00801821   ADDU V1, A0, ZERO
9D015D88  03E00008   JR RA
9D015D8C  00801821   ADDU V1, A0, ZERO
9D015D98  03E00008   JR RA
9D015D9C  00801821   ADDU V1, A0, ZERO
9D015EAC  03E00008   JR RA
9D015EB0  00801821   ADDU V1, A0, ZERO
